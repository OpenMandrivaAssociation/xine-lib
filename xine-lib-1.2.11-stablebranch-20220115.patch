diff -urN xine-lib-1.2.11/ChangeLog xine-lib-1.2/ChangeLog
--- xine-lib-1.2.11/ChangeLog	2020-12-05 23:27:04.000000000 +0100
+++ xine-lib-1.2/ChangeLog	2022-01-15 22:03:19.558547061 +0100
@@ -1,3 +1,16 @@
+xine-lib (1.2.12)
+  * Add string tree library (generic info parser).
+  * Add OpenSL ES audio output plugin.
+  * Add mpeg-dash input plugin.
+  * Better hls support.
+  * Improved DVB/live stream timing.
+  * Fix RSS parser.
+  * Fix output parameter setting (audio amplification, video hue etc.).
+  * Diverse small fixes and optimizations.
+  * Update german translation.
+  * Code cleanup.
+  * Build fixes.
+
 xine-lib (1.2.11) 2020-12-06
   * Add gopher input plugin.
   * Add user settings for IPv6.
diff -urN xine-lib-1.2.11/contrib/a52dec/diff_against_release.patch xine-lib-1.2/contrib/a52dec/diff_against_release.patch
--- xine-lib-1.2.11/contrib/a52dec/diff_against_release.patch	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/contrib/a52dec/diff_against_release.patch	2022-01-15 22:03:19.561547073 +0100
@@ -0,0 +1,76 @@
+--- src/liba52/a52_internal.h	Sun Jul 28 03:52:06 2002
++++ src/liba52/a52_internal.h	Wed Aug 28 19:01:05 2002
+@@ -84,6 +84,7 @@
+     expbap_t lfe_expbap;
+ 
+     sample_t * samples;
++    void * samples_base;
+     int downmixed;
+ };
+ 
+--- src/liba52/imdct.c	Sun Jul 28 03:52:07 2002
++++ src/liba52/imdct.c	Wed Aug 28 18:55:38 2002
+@@ -38,7 +38,7 @@
+ 
+ #include "a52.h"
+ #include "a52_internal.h"
+-#include "mm_accel.h"
++#include "xineutils.h"
+ 
+ typedef struct complex_s {
+     sample_t real;
+@@ -425,7 +425,6 @@
+     } else
+ #endif
+     {
+-	fprintf (stderr, "liba52:No accelerated IMDCT transform found\n");
+ 	ifft128 = ifft128_c;
+ 	ifft64 = ifft64_c;
+     }
+--- src/liba52/parse.c	Sun Jul 28 03:52:07 2002
++++ src/liba52/parse.c	Wed Aug 28 19:02:21 2002
+@@ -31,14 +31,7 @@
+ #include "a52_internal.h"
+ #include "bitstream.h"
+ #include "tables.h"
+-
+-#ifdef HAVE_MEMALIGN
+-/* some systems have memalign() but no declaration for it */
+-void * memalign (size_t align, size_t size);
+-#else
+-/* assume malloc alignment is sufficient */
+-#define memalign(align,size) malloc (size)
+-#endif
++#include "xineutils.h"
+ 
+ typedef struct {
+     sample_t q1[2];
+@@ -60,7 +53,7 @@
+     if (state == NULL)
+ 	return NULL;
+ 
+-    state->samples = memalign (16, 256 * 12 * sizeof (sample_t));
++    state->samples = xine_xmalloc_aligned (16, 256 * 12 * sizeof (sample_t), &state->samples_base);
+     if (state->samples == NULL) {
+ 	free (state);
+ 	return NULL;
+@@ -896,6 +889,6 @@
+ 
+ void a52_free (a52_state_t * state)
+ {
+-    free (state->samples);
++    free (state->samples_base);
+     free (state);
+ }
+--- src/liba52/bitstream.h
++++ src/liba52/bitstream.h
+@@ -21,6 +21,10 @@
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+ 
++#ifdef WIN32
++#include <unistd.h>
++#endif
++
+ /* (stolen from the kernel) */
+ #ifdef WORDS_BIGENDIAN
diff -urN xine-lib-1.2.11/contrib/libfaad/diff_from_faad2-2.6.1.patch xine-lib-1.2/contrib/libfaad/diff_from_faad2-2.6.1.patch
--- xine-lib-1.2.11/contrib/libfaad/diff_from_faad2-2.6.1.patch	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/contrib/libfaad/diff_from_faad2-2.6.1.patch	2022-01-15 22:03:19.553547040 +0100
@@ -0,0 +1,11 @@
+--- faad2/libfaad/common.h	2007-11-01 13:33:30.000000000 +0100
++++ faad2/libfaad/common.h	2007-11-01 18:51:01.480721384 +0100
+@@ -36,7 +36,7 @@
+ #endif
+ 
+ #ifdef HAVE_CONFIG_H
+-#  include "../config.h"
++#  include <config.h>
+ #endif
+ 
+ #if 1
diff -urN xine-lib-1.2.11/contrib/libfaad/diff_from_faad2-2.7.patch xine-lib-1.2/contrib/libfaad/diff_from_faad2-2.7.patch
--- xine-lib-1.2.11/contrib/libfaad/diff_from_faad2-2.7.patch	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/contrib/libfaad/diff_from_faad2-2.7.patch	2022-01-15 22:03:19.560547069 +0100
@@ -0,0 +1,349 @@
+diff -r 5336b582f060 contrib/libfaad/bits.h
+--- a/contrib/libfaad/bits.h	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/bits.h	Fri Feb 10 12:36:28 2017 +0200
+@@ -35,6 +35,8 @@
+ extern "C" {
+ #endif
+ 
++#include "xine/attributes.h"
++
+ #include "analysis.h"
+ #ifdef ANALYSIS
+ #include <stdio.h>
+@@ -108,7 +110,7 @@
+ }
+ 
+ /* reads only n bytes from the stream instead of the standard 4 */
+-static /*INLINE*/ uint32_t getdword_n(void *mem, int n)
++static /*INLINE*/ __attr_unused uint32_t getdword_n(void *mem, int n)
+ {
+     uint32_t tmp = 0;
+ #ifndef ARCH_IS_BIG_ENDIAN
+@@ -266,7 +268,7 @@
+     }
+ }
+ 
+-static /*INLINE*/ uint32_t faad_getbits_rev(bitfile *ld, uint32_t n
++static /*INLINE*/ __attr_unused uint32_t faad_getbits_rev(bitfile *ld, uint32_t n
+                                         DEBUGDEC)
+ {
+     uint32_t ret;
+diff -r 5336b582f060 contrib/libfaad/cfft.c
+--- a/contrib/libfaad/cfft.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/cfft.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -698,7 +698,7 @@
+ {
+     uint16_t i;
+     uint16_t k1, l1, l2;
+-    uint16_t na, nf, ip, iw, ix2, ix3, ix4, ido, idl1;
++    uint16_t na, nf, ip, iw, ix2, ix3, ix4, ido /*, idl1 */;
+ 
+     nf = ifac[1];
+     na = 0;
+@@ -710,7 +710,7 @@
+         ip = ifac[k1];
+         l2 = ip*l1;
+         ido = n / l2;
+-        idl1 = ido*l1;
++     /* idl1 = ido*l1; */
+ 
+         switch (ip)
+         {
+@@ -777,7 +777,7 @@
+ {
+     uint16_t i;
+     uint16_t k1, l1, l2;
+-    uint16_t na, nf, ip, iw, ix2, ix3, ix4, ido, idl1;
++    uint16_t na, nf, ip, iw, ix2, ix3, ix4, ido /*, idl1 */;
+ 
+     nf = ifac[1];
+     na = 0;
+@@ -789,7 +789,7 @@
+         ip = ifac[k1];
+         l2 = ip*l1;
+         ido = n / l2;
+-        idl1 = ido*l1;
++     /* idl1 = ido*l1; */
+ 
+         switch (ip)
+         {
+diff -r 5336b582f060 contrib/libfaad/common.c
+--- a/contrib/libfaad/common.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/common.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -202,9 +202,10 @@
+     1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0
+ };
+ 
++/* TJ. these are now part of NeAACDecHandle
+ static uint32_t  __r1 = 1;
+ static uint32_t  __r2 = 1;
+-
++*/
+ 
+ /*
+  *  This is a simple random number generator with good quality for audio purposes.
+diff -r 5336b582f060 contrib/libfaad/common.h
+--- a/contrib/libfaad/common.h	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/common.h	Fri Feb 10 12:36:28 2017 +0200
+@@ -36,7 +36,7 @@
+ #endif
+ 
+ #ifdef HAVE_CONFIG_H
+-#  include "../config.h"
++#  include "config.h"
+ #endif
+ 
+ #include "neaacdec.h"
+diff -r 5336b582f060 contrib/libfaad/decoder.c
+--- a/contrib/libfaad/decoder.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/decoder.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -64,7 +64,7 @@
+                                   NeAACDecFrameInfo *hInfo);
+ 
+ 
+-char* NEAACDECAPI NeAACDecGetErrorMessage(unsigned char errcode)
++const char* NEAACDECAPI NeAACDecGetErrorMessage(unsigned char errcode)
+ {
+     if (errcode >= NUM_ERROR_MESSAGES)
+         return NULL;
+diff -r 5336b582f060 contrib/libfaad/drc.c
+--- a/contrib/libfaad/drc.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/drc.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -132,7 +132,7 @@
+         if (drc->dyn_rng_sgn[bd])  /* compress */
+             exp = -drc->ctrl1 * (drc->dyn_rng_ctl[bd] - (DRC_REF_LEVEL - drc->prog_ref_level))/REAL_CONST(24.0);
+         else /* boost */
+-            exp = drc->ctrl2 * (drc->dyn_rng_ctl[bd] - (DRC_REF_LEVEL - drc->prog_ref_level))/REAL_CONST(24.0);
++            exp = drc->ctrl2 * (drc->dyn_rng_ctl[bd] + (DRC_REF_LEVEL - drc->prog_ref_level))/REAL_CONST(24.0);
+         factor = (real_t)pow(2.0, exp);
+ 
+         /* Apply gain factor */
+@@ -145,8 +145,8 @@
+             exp = -1 * (drc->dyn_rng_ctl[bd] - (DRC_REF_LEVEL - drc->prog_ref_level))/ 24;
+             frac = -1 * (drc->dyn_rng_ctl[bd] - (DRC_REF_LEVEL - drc->prog_ref_level)) % 24;
+         } else { /* boost */
+-            exp = (drc->dyn_rng_ctl[bd] - (DRC_REF_LEVEL - drc->prog_ref_level))/ 24;
+-            frac = (drc->dyn_rng_ctl[bd] - (DRC_REF_LEVEL - drc->prog_ref_level)) % 24;
++            exp = (drc->dyn_rng_ctl[bd] + (DRC_REF_LEVEL - drc->prog_ref_level))/ 24;
++            frac = (drc->dyn_rng_ctl[bd] + (DRC_REF_LEVEL - drc->prog_ref_level)) % 24;
+         }
+ 
+         /* Apply gain factor */
+diff -r 5336b582f060 contrib/libfaad/error.c
+--- a/contrib/libfaad/error.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/error.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -31,7 +31,7 @@
+ #include "common.h"
+ #include "error.h"
+ 
+-char *err_msg[] = {
++const char *err_msg[] = {
+     "No error",
+     "Gain control not yet implemented",
+     "Pulse coding not allowed in short blocks",
+diff -r 5336b582f060 contrib/libfaad/error.h
+--- a/contrib/libfaad/error.h	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/error.h	Fri Feb 10 12:36:28 2017 +0200
+@@ -36,7 +36,7 @@
+ #endif
+ 
+ #define NUM_ERROR_MESSAGES 34
+-extern char *err_msg[];
++extern const char *err_msg[];
+ 
+ #ifdef __cplusplus
+ }
+diff -r 5336b582f060 contrib/libfaad/hcr.c
+--- a/contrib/libfaad/hcr.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/hcr.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -225,7 +225,9 @@
+ 
+     uint16_t sp_offset[8];
+     uint16_t g, i, sortloop, set, bitsread;
++#ifdef HCR_CWCOUNT
+     uint16_t bitsleft, codewordsleft;
++#endif
+     uint8_t w_idx, sfb, this_CB, last_CB, this_sec_CB; 
+     
+     const uint16_t nshort = hDecoder->frameLength/8;
+@@ -408,7 +410,7 @@
+             rewrev_bits(&segment[i]);
+     }
+ 
+-#if 0 // Seems to give false errors
++#ifdef HCR_CWCOUNT // Seems to give false errors
+     bitsleft = 0;    
+         
+     for (i = 0; i < numberOfSegments && !bitsleft; i++)
+diff -r 5336b582f060 contrib/libfaad/ic_predict.c
+--- a/contrib/libfaad/ic_predict.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/ic_predict.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -41,43 +41,43 @@
+ static void flt_round(float32_t *pf)
+ {
+     int32_t flg;
+-    uint32_t tmp, tmp1, tmp2;
++    union {float32_t f; uint32_t i;} tmp, tmp1, tmp2;
+ 
+-    tmp = *(uint32_t*)pf;
+-    flg = tmp & (uint32_t)0x00008000;
+-    tmp &= (uint32_t)0xffff0000;
+-    tmp1 = tmp;
++    tmp.f = *pf;
++    flg   = tmp.i & (uint32_t)0x00008000;
++    tmp.i &= (uint32_t)0xffff0000;
+     /* round 1/2 lsb toward infinity */
+     if (flg)
+     {
+-        tmp &= (uint32_t)0xff800000;       /* extract exponent and sign */
+-        tmp |= (uint32_t)0x00010000;       /* insert 1 lsb */
+-        tmp2 = tmp;                             /* add 1 lsb and elided one */
+-        tmp &= (uint32_t)0xff800000;       /* extract exponent and sign */
++        tmp1   = tmp;
++        tmp.i &= (uint32_t)0xff800000; /* extract exponent and sign */
++        tmp.i |= (uint32_t)0x00010000; /* insert 1 lsb */
++        tmp2   = tmp;                  /* add 1 lsb and elided one */
++        tmp.i &= (uint32_t)0xff800000; /* extract exponent and sign */
+         
+-        *pf = *(float32_t*)&tmp1 + *(float32_t*)&tmp2 - *(float32_t*)&tmp;
++        *pf = tmp1.f + tmp2.f - tmp.f;
+     } else {
+-        *pf = *(float32_t*)&tmp;
++        *pf = tmp.f;
+     }
+ }
+ 
+ static int16_t quant_pred(float32_t x)
+ {
+     int16_t q;
+-    uint32_t *tmp = (uint32_t*)&x;
++    union {float32_t f; uint32_t i;} tmp;
++    tmp.f = x;
+ 
+-    q = (int16_t)(*tmp>>16);
++    q = (int16_t)(tmp.i>>16);
+ 
+     return q;
+ }
+ 
+ static float32_t inv_quant_pred(int16_t q)
+ {
+-    float32_t x;
+-    uint32_t *tmp = (uint32_t*)&x;
+-    *tmp = ((uint32_t)q)<<16;
++    union {float32_t f; uint32_t i;} tmp;
++    tmp.i = ((uint32_t)q)<<16;
+ 
+-    return x;
++    return tmp.f;
+ }
+ 
+ static void ic_predict(pred_state *state, real_t input, real_t *output, uint8_t pred)
+diff -r 5336b582f060 contrib/libfaad/neaacdec.h
+--- a/contrib/libfaad/neaacdec.h	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/neaacdec.h	Fri Feb 10 12:36:28 2017 +0200
+@@ -198,7 +198,7 @@
+     unsigned char ps;
+ } NeAACDecFrameInfo;
+ 
+-char* NEAACDECAPI NeAACDecGetErrorMessage(unsigned char errcode);
++const char* NEAACDECAPI NeAACDecGetErrorMessage(unsigned char errcode);
+ 
+ unsigned long NEAACDECAPI NeAACDecGetCapabilities(void);
+ 
+diff -r 5336b582f060 contrib/libfaad/ps_dec.c
+--- a/contrib/libfaad/ps_dec.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/ps_dec.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -1034,7 +1034,7 @@
+                            qmf_t X_hybrid_left[32][32], qmf_t X_hybrid_right[32][32])
+ {
+     uint8_t gr, n, m, bk;
+-    uint8_t temp_delay;
++    uint8_t temp_delay = 0;
+     uint8_t sb, maxsb;
+     const complex_t *Phi_Fract_SubQmf;
+     uint8_t temp_delay_ser[NO_ALLPASS_LINKS];
+@@ -1043,6 +1043,8 @@
+     real_t G_TransientRatio[32][34] = {{0}};
+     complex_t inputLeft;
+ 
++    /* calm down gcc */
++    memset (temp_delay_ser, 0, sizeof (temp_delay_ser));
+ 
+     /* chose hybrid filterbank: 20 or 34 band case */
+     if (ps->use34hybrid_bands)
+@@ -1454,9 +1456,10 @@
+     uint8_t sb, maxsb;
+     uint8_t env;
+     uint8_t nr_ipdopd_par;
+-    complex_t h11, h12, h21, h22;
+-    complex_t H11, H12, H21, H22;
+-    complex_t deltaH11, deltaH12, deltaH21, deltaH22;
++    /* calm down gcc */
++    complex_t h11 = {0, 0}, h12 = {0, 0}, h21 = {0, 0}, h22 = {0, 0};
++    complex_t H11 = {0, 0}, H12 = {0, 0}, H21 = {0, 0}, H22 = {0, 0};
++    complex_t deltaH11 = {0, 0}, deltaH12 = {0, 0}, deltaH21 = {0, 0}, deltaH22 = {0, 0};
+     complex_t tempLeft;
+     complex_t tempRight;
+     complex_t phaseLeft;
+@@ -1963,8 +1966,13 @@
+ /* main Parametric Stereo decoding function */
+ uint8_t ps_decode(ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64])
+ {
+-    qmf_t X_hybrid_left[32][32] = {{0}};
+-    qmf_t X_hybrid_right[32][32] = {{0}};
++#ifndef SBR_LOW_POWER
++#  define QMF_ZERO {0,0}
++#else
++#  define QMF_ZERO 0
++#endif
++    qmf_t X_hybrid_left[32][32] = {{QMF_ZERO}};
++    qmf_t X_hybrid_right[32][32] = {{QMF_ZERO}};
+ 
+     /* delta decoding of the bitstream data */
+     ps_data_decode(ps);
+diff -r 5336b582f060 contrib/libfaad/sbr_dec.c
+--- a/contrib/libfaad/sbr_dec.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/sbr_dec.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -602,8 +602,13 @@
+     uint8_t l, k;
+     uint8_t dont_process = 0;
+     uint8_t ret = 0;
+-    ALIGN qmf_t X_left[38][64] = {{0}};
+-    ALIGN qmf_t X_right[38][64] = {{0}}; /* must set this to 0 */
++#ifndef SBR_LOW_POWER
++#  define QMF_ZERO {0,0}
++#else
++#  define QMF_ZERO 0
++#endif
++    ALIGN qmf_t X_left[38][64] = {{QMF_ZERO}};
++    ALIGN qmf_t X_right[38][64] = {{QMF_ZERO}}; /* must set this to 0 */
+ 
+     if (sbr == NULL)
+         return 20;
+diff -r 5336b582f060 contrib/libfaad/sbr_hfadj.c
+--- a/contrib/libfaad/sbr_hfadj.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/sbr_hfadj.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -1186,8 +1186,9 @@
+             real_t den = 0;
+             real_t acc1 = 0;
+             real_t acc2 = 0;
++#if 0
+             uint8_t current_res_band_size = 0;
+-
++#endif
+             uint8_t ml1, ml2;
+ 
+             ml1 = sbr->f_table_lim[sbr->bs_limiter_bands][k];
+diff -r 5336b582f060 contrib/libfaad/specrec.c
+--- a/contrib/libfaad/specrec.c	Fri Feb 10 12:12:52 2017 +0200
++++ b/contrib/libfaad/specrec.c	Fri Feb 10 12:36:28 2017 +0200
+@@ -425,7 +425,7 @@
+     }
+ }
+ 
+-/* iquant() *
++/* iquant() */
+ /* output = sign(input)*abs(input)^(4/3) */
+ /**/
+ static INLINE real_t iquant(int16_t q, const real_t *tab, uint8_t *error)
diff -urN xine-lib-1.2.11/contrib/libfaad/sbr_qmf.c xine-lib-1.2/contrib/libfaad/sbr_qmf.c
--- xine-lib-1.2.11/contrib/libfaad/sbr_qmf.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/contrib/libfaad/sbr_qmf.c	2022-01-15 22:03:19.550547027 +0100
@@ -66,8 +66,8 @@
     }
 }
 
-void sbr_qmf_analysis_32(sbr_info *sbr, qmfa_info *qmfa, const real_t *input,
-                         qmf_t X[MAX_NTSRHFG][64], uint8_t offset, uint8_t kx)
+void sbr_qmf_analysis_32 (sbr_info *sbr, qmfa_info *qmfa, const real_t *input,
+                         qmf_t X[][64], uint8_t offset, uint8_t kx)
 {
     ALIGN real_t u[64];
 #ifndef SBR_LOW_POWER
@@ -249,8 +249,7 @@
 
 #ifdef SBR_LOW_POWER
 
-void sbr_qmf_synthesis_32(sbr_info *sbr, qmfs_info *qmfs, qmf_t X[MAX_NTSRHFG][64],
-                          real_t *output)
+void sbr_qmf_synthesis_32 (sbr_info *sbr, qmfs_info *qmfs, qmf_t X[][64], real_t *output)
 {
     ALIGN real_t x[16];
     ALIGN real_t y[16];
@@ -318,8 +317,7 @@
     }
 }
 
-void sbr_qmf_synthesis_64(sbr_info *sbr, qmfs_info *qmfs, qmf_t X[MAX_NTSRHFG][64],
-                          real_t *output)
+void sbr_qmf_synthesis_64 (sbr_info *sbr, qmfs_info *qmfs, qmf_t X[][64], real_t *output)
 {
     ALIGN real_t x[64];
     ALIGN real_t y[64];
@@ -388,8 +386,7 @@
     }
 }
 #else
-void sbr_qmf_synthesis_32(sbr_info *sbr, qmfs_info *qmfs, qmf_t X[MAX_NTSRHFG][64],
-                          real_t *output)
+void sbr_qmf_synthesis_32 (sbr_info *sbr, qmfs_info *qmfs, qmf_t X[][64], real_t *output)
 {
     ALIGN real_t x1[32], x2[32];
 #ifndef FIXED_POINT
@@ -454,8 +451,7 @@
     }
 }
 
-void sbr_qmf_synthesis_64(sbr_info *sbr, qmfs_info *qmfs, qmf_t X[MAX_NTSRHFG][64],
-                          real_t *output)
+void sbr_qmf_synthesis_64 (sbr_info *sbr, qmfs_info *qmfs, qmf_t X[][64], real_t *output)
 {
 //    ALIGN real_t x1[64], x2[64];
 #ifndef SBR_LOW_POWER
diff -urN xine-lib-1.2.11/contrib/libfaad/sbr_qmf.h xine-lib-1.2/contrib/libfaad/sbr_qmf.h
--- xine-lib-1.2.11/contrib/libfaad/sbr_qmf.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/contrib/libfaad/sbr_qmf.h	2022-01-15 22:03:19.552547035 +0100
@@ -40,12 +40,10 @@
 qmfs_info *qmfs_init(uint8_t channels);
 void qmfs_end(qmfs_info *qmfs);
 
-void sbr_qmf_analysis_32(sbr_info *sbr, qmfa_info *qmfa, const real_t *input,
-                         qmf_t X[MAX_NTSRHFG][64], uint8_t offset, uint8_t kx);
-void sbr_qmf_synthesis_32(sbr_info *sbr, qmfs_info *qmfs, qmf_t X[MAX_NTSRHFG][64],
-                          real_t *output);
-void sbr_qmf_synthesis_64(sbr_info *sbr, qmfs_info *qmfs, qmf_t X[MAX_NTSRHFG][64],
-                          real_t *output);
+void sbr_qmf_analysis_32 (sbr_info *sbr, qmfa_info *qmfa, const real_t *input,
+                          qmf_t X[][64], uint8_t offset, uint8_t kx);
+void sbr_qmf_synthesis_32 (sbr_info *sbr, qmfs_info *qmfs, qmf_t X[][64], real_t *output);
+void sbr_qmf_synthesis_64 (sbr_info *sbr, qmfs_info *qmfs, qmf_t X[][64], real_t *output);
 
 
 #ifdef __cplusplus
diff -urN xine-lib-1.2.11/contrib/nosefart/diff_to_nosefart_cvs.patch xine-lib-1.2/contrib/nosefart/diff_to_nosefart_cvs.patch
--- xine-lib-1.2.11/contrib/nosefart/diff_to_nosefart_cvs.patch	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/contrib/nosefart/diff_to_nosefart_cvs.patch	2022-01-15 22:03:19.566547094 +0100
@@ -0,0 +1,117 @@
+diff -u -p -r1.1.1.1 types.h
+--- types.h	26 Jul 2004 15:27:59 -0000	1.1.1.1
++++ types.h	26 Aug 2004 16:00:07 -0000
+@@ -23,8 +23,8 @@
+ ** $Id: diff_to_nosefart_cvs.patch,v 1.2 2005/05/07 09:11:39 valtri Exp $
+ */
+ 
+-#ifndef _TYPES_H_
+-#define _TYPES_H_
++#ifndef _NOSEFART_TYPES_H_
++#define _NOSEFART_TYPES_H_
+ 
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+@@ -88,7 +88,7 @@ typedef  uint8    boolean;
+ #define  ASSERT_MSG(msg)
+ #endif
+ 
+-#endif /* _TYPES_H_ */
++#endif /* _NOSEFART_TYPES_H_ */
+ 
+ /*
+ ** $Log: diff_to_nosefart_cvs.patch,v $
+ ** Revision 1.2  2005/05/07 09:11:39  valtri
+ ** *BUGFIX*
+ ** gcc4 patches from Dams Nadé (livna.org) and Keenan Pepper.
+ **
+ ** Revision 1.1  2004/08/27 19:33:37  valtri
+ ** MINGW32 port. Engine library and most of plugins compiles now.
+ **
+ ** List of some changes:
+ **  - replaced some _MSC_VER by more common WIN32
+ **  - define INTLDIR, remove -static flag for included intl
+ **  - shared more common CFLAGS with DEBUG_CFLAGS
+ **  - use WIN32_CFLAGS for all building
+ **  - separate some flags into THREAD_CFLAGS_CONFIG,
+ **    THREAD_CFLAGS_CONFIG and ZLIB_LIB_CONFIG for public xine-config,
+ **    automatically use internal libs if necessary
+ **  - don't warn about missing X for mingw and cygwin
+ **  - libw32dll disabled for WIN32 (making native loader would be
+ **    interesting, or porting wine code to Windows? :->)
+ **  - DVB and RTP disabled for WIN32, not ported yet
+ **  - fix build and fix a warning in cdda
+ **  - fix build for nosefart and libfaad
+ **  - implement configure option --disable-freetype
+ **  - sync libxine.pc and xine-config.in
+ **  - add -liberty to goom under WIN32
+ **  - move original build files from included phread and zlib into archives
+ **    and replace them by autotools
+ **
+Index: nes_apu.c
+===================================================================
+RCS file: /home/valtri/CVS/xine-lib/src/libxineadec/nosefart/nes_apu.c,v
+retrieving revision 1.1.1.1
+diff -u -p -r1.1.1.1 nes_apu.c
+--- nes_apu.c	12 Dec 2004 13:57:16 -0000	1.1.1.1
++++ nes_apu.c	7 May 2005 08:23:36 -0000
+@@ -1011,10 +1011,13 @@ void apu_process(void *buffer, int num_s
+          accum = -0x8000;
+ 
+       /* signed 16-bit output, unsigned 8-bit */
+-      if (16 == apu->sample_bits)
+-         *((int16 *) buffer)++ = (int16) accum;
+-      else
+-         *((uint8 *) buffer)++ = (accum >> 8) ^ 0x80;
++      if (16 == apu->sample_bits) {
++         *((int16 *) buffer) = (int16) accum; 
++         buffer = (int16 *) buffer + 1;
++      } else {
++         *((uint8 *) buffer) = (accum >> 8) ^ 0x80; 
++         buffer = (int8 *) buffer + 1;
++      }
+    }
+ 
+    /* resync cycle counter */
+--- a/src/libxineadec/nosefart/nsf.h	Tue Apr 10 13:42:00 2007 +0200
++++ b/src/libxineadec/nosefart/nsf.h	Tue Apr 10 13:48:50 2007 +0200
+@@ -29,6 +29,8 @@
+ #include "osd.h"
+ #include "nes6502.h"
+ #include "nes_apu.h"
++
++#include "config.h"
+ 
+ #define  NSF_MAGIC   "NESM\x1A"
+ 
+@@ -96,7 +98,7 @@ typedef struct nsf_s
+ 
+    /* our main processing routine, calls all external mixing routines */
+    void (*process)(void *buffer, int num_samples);
+-} __PACKED__ nsf_t;
++} XINE_PACKED nsf_t;
+ 
+ /* Function prototypes */
+ extern void nsf_init(void);
+--- a/src/libxineadec/nosefart/osd.h	Tue Apr 10 13:42:00 2007 +0200
++++ b/src/libxineadec/nosefart/osd.h	Tue Apr 10 13:19:34 2007 +0200
+@@ -26,19 +26,15 @@
+ #ifndef _OSD_H_
+ #define _OSD_H_
+ 
+-
+ #if defined(__GNUC__) || defined(__ICC)
+-#define  __PACKED__  __attribute__ ((packed))
+ #define  PATH_SEP    '/'
+ #ifdef __DJGPP__
+ #include <dpmi.h>
+ #include "dos_ints.h"
+ #endif
+ #elif defined(WIN32)
+-#define  __PACKED__
+ #define  PATH_SEP    '\\'
+ #else /* crapintosh? */
+-#define  __PACKED__
+ #define  PATH_SEP    ':'
+ #endif
+ 
diff -urN xine-lib-1.2.11/contrib/nosefart/memguard.c xine-lib-1.2/contrib/nosefart/memguard.c
--- xine-lib-1.2.11/contrib/nosefart/memguard.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/contrib/nosefart/memguard.c	2022-01-15 22:03:19.571547116 +0100
@@ -278,9 +278,6 @@
 /* free a pointer allocated with my_malloc */
 #ifdef NOFRENDO_DEBUG
 void _my_free(void **data, char *file, int line)
-#else
-void _my_free(void **data)
-#endif
 {
    char fail[256];
 
@@ -316,6 +313,16 @@
 
    *data = NULL; /* NULL our source */
 }
+#else
+void _my_free(void *data)
+{
+   if (NULL == data || ((uintptr_t)-1) == (uintptr_t) data) {
+      ASSERT_MSG("free: attempted to free NULL pointer.\n");
+   }
+
+   free(data);
+}
+#endif
 
 /* check for orphaned memory handles */
 void mem_checkleaks(void)
diff -urN xine-lib-1.2.11/contrib/nosefart/memguard.h xine-lib-1.2/contrib/nosefart/memguard.h
--- xine-lib-1.2.11/contrib/nosefart/memguard.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/contrib/nosefart/memguard.h	2022-01-15 22:03:19.586547179 +0100
@@ -38,10 +38,10 @@
 #else /* Non-debugging versions of calls */
 
 #define  malloc(s)   _my_malloc((s))
-#define  free(d)     _my_free((void **) &(d))
+#define  free(d)     do { _my_free(d); (d) = NULL; } while (0)
 
 extern void *_my_malloc(int size);
-extern void _my_free(void **data);
+extern void _my_free(void *data);
 
 #endif /* NOFRENDO_DEBUG */
 
diff -urN xine-lib-1.2.11/contrib/nosefart/nsf.c xine-lib-1.2/contrib/nosefart/nsf.c
--- xine-lib-1.2.11/contrib/nosefart/nsf.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/contrib/nosefart/nsf.c	2022-01-15 22:03:19.551547031 +0100
@@ -574,9 +574,13 @@
   struct nsf_file_loader_t * floader = (struct nsf_file_loader_t *)loader;
   long save, pos;
   save = ftell(floader->fp);
-  fseek(floader->fp, 0, SEEK_END);
+  if (save < 0)
+    return 0;
+  if (fseek(floader->fp, 0, SEEK_END) < 0)
+    return 0;
   pos = ftell(floader->fp);
-  fseek(floader->fp, save, SEEK_SET);
+  if (fseek(floader->fp, save, SEEK_SET) < 0)
+    return 0;
   return pos;
 }
 
diff -urN xine-lib-1.2.11/include/xine/attributes.h xine-lib-1.2/include/xine/attributes.h
--- xine-lib-1.2.11/include/xine/attributes.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/include/xine/attributes.h	2022-01-15 22:03:19.558547061 +0100
@@ -1,7 +1,7 @@
 /*
  * attributes.h
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
- * Copyright (C) 2001-2008 xine developers
+ * Copyright (C) 2001-2021 xine developers
  *
  * This file was originally part of mpeg2dec, a free MPEG-2 video stream
  * decoder.
@@ -28,7 +28,7 @@
 
 #ifdef XINE_COMPILE
 # if defined(HAVE_CONFIG_H) && !defined(__XINE_LIB_CONFIG_H__)
-#  error config.h not included in source file !
+#  warning Define XINE_COMPILE _only_ when tweaking xine-lib itself, and then include xine config.h early in your source file!
 # endif
 #else
 # if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95 )
diff -urN xine-lib-1.2.11/include/xine/buffer.h xine-lib-1.2/include/xine/buffer.h
--- xine-lib-1.2.11/include/xine/buffer.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/include/xine/buffer.h	2022-01-15 22:03:19.563547082 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -578,6 +578,16 @@
   unsigned char r, g, b;
 } ;
 
+/* NOTE well: unfortunately, early libxine design made all these details public.
+ * Please
+ * a) use _x_[dummy_]fifo_buffer_new (), and dont assume anything about
+ *    the non function members, or
+ * b) provide a full own implementation, which is tricky because fifo_buffer_t
+ *    has been enlarged with libxine version bumps, or
+ * ?) at least never pass your own to engine or unaware plugins.
+ * vdr-xineliboutput builds its own fifo_buffer_t structs from a partly copy
+ * of a libxine one (including some functions) as pools.
+ * We are trying hard to keep that vdr compatibility, with no guarantee. */
 typedef struct fifo_buffer_s fifo_buffer_t;
 struct fifo_buffer_s
 {
@@ -694,7 +704,7 @@
  * @param buf_size Size of each buffer.
  * @internal Only used by video and audio decoder loops.
  */
-fifo_buffer_t *_x_dummy_fifo_buffer_new (int num_buffers, uint32_t buf_size);
+fifo_buffer_t *_x_dummy_fifo_buffer_new (int num_buffers, uint32_t buf_size) XINE_PROTECTED;
 
 /**
  * @brief Free chained list of buffer elements.
diff -urN xine-lib-1.2.11/include/xine/configfile.h xine-lib-1.2/include/xine/configfile.h
--- xine-lib-1.2.11/include/xine/configfile.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/include/xine/configfile.h	2022-01-15 22:03:19.563547082 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/include/xine/input_plugin.h xine-lib-1.2/include/xine/input_plugin.h
--- xine-lib-1.2.11/include/xine/input_plugin.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/include/xine/input_plugin.h	2022-01-15 22:03:19.568547103 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -381,8 +381,26 @@
 #define INPUT_OPTIONAL_DATA_DURATION  13
 /* buffer is a const char * holding the new mrl to try.
  * fragment streams can avoid input_plugin->dispose () followed by input_class->get_instance (),
- * or _x_free_input_plugin () followed by _x_find_input_plugin () on a lot of * similar mrls. */
+ * or _x_free_input_plugin () followed by _x_find_input_plugin () on a lot of * similar mrls.
+ * an empty mrl (buffer[0] == 0) means close connection now, and wait for a real new mrl later. */
 #define INPUT_OPTIONAL_DATA_NEW_MRL   14
+/* buffer is a xine_mfrag_list_t ** where input plugin will store a pointer to its media fragment
+ * list, if any (see <xine/mfrag.h>). demux may update it if fragment index is part of the
+ * container, like with some .mp4. */
+#define INPUT_OPTIONAL_DATA_FRAGLIST  15
+/* after a successful open () of a main input, this may supply possible side stream inputs.
+ * on call, buffer is an int * telling the side stream index 1..3.
+ * on return, buffer is a struct input_plugin_s ** where a pointer to a ready side input
+ * bound to xine_get_side_stream (main_stream, stream_index) will be stored if available.
+ * NOTE: this shall be an alternative get_instance (), not the result of an _x_find_input_plugin ().
+ * release by _x_free_input_plugin () or xine_dispose () of the side stream. */
+#define INPUT_OPTIONAL_DATA_SIDE      16
+/* returns a pts value (1/90000s) to add to all demux media pts, or INPUT_OPTIONAL_UNSUPPORTED == 0.
+ * some fragment streams need this to provide a/v sync over multiple side streams. */
+#define INPUT_OPTIONAL_DATA_PTSOFFS   17
+/* data is an int * telling how many seconds to go back into a live stream.
+ * yes this _does_ work sometimes, up to 24h ;-) */
+#define INPUT_OPTIONAL_DATA_REWIND    18
 
 #define MAX_MRL_ENTRIES 255
 #define MAX_PREVIEW_SIZE 4096
@@ -390,6 +408,8 @@
 /* network buffering control */
 typedef struct xine_nbc_st xine_nbc_t;
 xine_nbc_t *xine_nbc_init (xine_stream_t *stream) XINE_PROTECTED;
+/* returns a combinwd demux pts position, starting with 0 at stream start. */
+int64_t xine_nbc_get_pos_pts (xine_nbc_t *nbc) XINE_PROTECTED;
 void xine_nbc_close (xine_nbc_t *nbc) XINE_PROTECTED;
 
 
diff -urN xine-lib-1.2.11/include/xine/io_helper.h xine-lib-1.2/include/xine/io_helper.h
--- xine-lib-1.2.11/include/xine/io_helper.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/include/xine/io_helper.h	2022-01-15 22:03:19.581547158 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project,
+ * Copyright (C) 2000-2021 the xine project,
  *
  * This file is part of xine, a free video player.
  *
@@ -45,12 +45,11 @@
  *
  * params :
  *   stream        needed for aborting and reporting errors but may be NULL
- *   fd            file/socket descriptor
- *   state         XIO_READ_READY, XIO_WRITE_READY
- *   timeout_sec   timeout in seconds
+ *   fd            file/socket descriptor or -1 (just wait)
+ *   state         XIO_READ_READY, XIO_WRITE_READY or 0 (just wait)
+ *   timeout_msec  timeout in milliseconds
  *
- * An other thread can abort this function if stream != NULL by setting
- * stream->demux_action_pending.
+ * Engine seek/stop can abort this function if stream != NULL.
  *
  * return value :
  *   XIO_READY     the file descriptor is ready for cmd
diff -urN xine-lib-1.2.11/include/xine/mfrag.h xine-lib-1.2/include/xine/mfrag.h
--- xine-lib-1.2.11/include/xine/mfrag.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/include/xine/mfrag.h	2022-01-15 22:03:19.569547107 +0100
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2021 the xine project
+ * Copyright (C) 2021 Torsten Jager <t.jager@gmx.de>
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Xine media fragment list utility.
+ */
+
+#ifndef HAVE_XINE_MFRAG_H
+#define HAVE_XINE_MFRAG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <xine/attributes.h>
+#include <xine/compat.h>
+
+/** -1: error.
+ *  0: the stream head.
+ *    dur = timebase.
+ *    len = byte offset of first media fragment or 0.
+ *  1..n: a media fragment.
+ *    dur = duration in timebase units or -1 (no change).
+ *    len = length in bytes or -1 (unknown/no change).
+ *  n + 1: append this one (set) or the stream total (get/find). */
+typedef int32_t xine_mfrag_index_t;
+
+typedef struct xine_mfrag_list_s xine_mfrag_list_t;
+
+/** *plist may be NULL. */
+void xine_mfrag_list_open (xine_mfrag_list_t **plist) XINE_PROTECTED;
+
+/** returns the "n" above. */
+int32_t xine_mfrag_get_frag_count (xine_mfrag_list_t *list) XINE_PROTECTED;
+
+/** find the media fragment that contains the specified timepos or offs. */
+xine_mfrag_index_t xine_mfrag_find_time (xine_mfrag_list_t *list, int64_t timepos) XINE_PROTECTED;
+xine_mfrag_index_t xine_mfrag_find_pos (xine_mfrag_list_t *list, off_t offs) XINE_PROTECTED;
+
+/** index 0: dur = timebase or -1 (no change).
+ *           len = head size in bytes or -1 (no change).
+ *  1..n:    dur = fragment duration in timebase units or 0 (unknown), -1 (no change).
+ *           len = fragment size or 0 (unknown), -1 (no change).
+ *  n + 1:   dur = set: new fragment duration in timebase units or 0/-1 (unknown).
+ *                 get: 0.
+ *           len = set: new fragment size or 0/-1 (unknown).
+ *                 get: 0. */
+int xine_mfrag_set_index_frag (xine_mfrag_list_t *list, xine_mfrag_index_t index, int64_t dur, off_t len) XINE_PROTECTED;
+int xine_mfrag_get_index_frag (xine_mfrag_list_t *list, xine_mfrag_index_t index, int64_t *dur, off_t *len) XINE_PROTECTED;
+
+/** index 0: timepos = 0.
+ *           offs    = 0.
+ *  these values will be estimated if some previous fragment has an "unknown" setting:
+ *  1..n:    timepos = fragment start time in timebase units.
+ *           offs    = fragment start offs in bytes.
+ *  n + 1:   timepos = total time in timebase units.
+ *           offs    = total size in bytes. */
+int xine_mfrag_get_index_start (xine_mfrag_list_t *list, xine_mfrag_index_t index, int64_t *timepos, off_t *offs) XINE_PROTECTED;
+
+void xine_mfrag_list_close (xine_mfrag_list_t **plist) XINE_PROTECTED;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -urN xine-lib-1.2.11/include/xine/stree.h xine-lib-1.2/include/xine/stree.h
--- xine-lib-1.2.11/include/xine/stree.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/include/xine/stree.h	2022-01-15 22:03:19.576547137 +0100
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2021 the xine project
+ * Copyright (C) 2021 Torsten Jager <t.jager@gmx.de>
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Xine string tree library.
+ */
+
+#ifndef HAVE_XINE_STREE_H
+#define HAVE_XINE_STREE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <xine/attributes.h>
+#include <xine/compat.h>
+
+typedef enum {
+  XINE_STREE_AUTO = 0,
+  XINE_STREE_XML,  /** << eXtensible Markup Language */
+  XINE_STREE_JSON, /** << Java script Serial Object Notation */
+  XINE_STREE_URL,  /** << Uniform Resource Location encoding */
+  XINE_STREE_LAST
+} xine_stree_mode_t;
+
+typedef struct {
+  uint32_t next, prev;                      /** << xine_stree_t index */
+  uint32_t first_child, last_child, parent; /** << xine_stree_t index */
+  uint32_t num_children, level, index;      /** << int */
+  uint32_t key, value;                      /** << offset into buf */
+} xine_stree_t;
+
+/** buf will be reused (modified) to hold the strings referenced by xine_stree_t.
+ *  XINE_STREE_AUTO will update mode. */
+xine_stree_t *xine_stree_load (char *buf, xine_stree_mode_t *mode) XINE_PROTECTED;
+
+/** base is an index into the tree, where to start. */
+void xine_stree_dump (const xine_stree_t *tree, const char *buf, uint32_t base) XINE_PROTECTED;
+
+/** path is a dot separated list of parts.
+ *  part is a key, a zero based index number in square brackets, or both.
+ *  the special key "[]" refers to xml tag content text.
+ *  "foo.[][0]" will also be available as "foo". */
+uint32_t xine_stree_find (const xine_stree_t *tree, const char *buf, const char *path, uint32_t base, int case_sens) XINE_PROTECTED;
+
+void xine_stree_delete (xine_stree_t **tree) XINE_PROTECTED;
+
+/** "&amp;"    -> "&"
+ *  "&lt;"     -> "<"
+ *  "&gt;"     -> ">"
+ *  "&quot;"   -> "\""
+ *  "&#xd575;" -> "핵"
+ * return new strlen (). */
+size_t xine_string_unampersand (char *s) XINE_PROTECTED;
+
+/** "%3a" -> ":" etc. return new strlen (). */
+size_t xine_string_unpercent (char *s) XINE_PROTECTED;
+
+/** "\n"     -> <newline>
+ *  "\070"   -> "8"
+ *  "\x37"   -> "7"
+ *  "\ud575" -> "핵"
+ *  "\cG"    -> <bell> (^G)
+ * return new strlen (). */
+size_t xine_string_unbackslash (char *s) XINE_PROTECTED;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -urN xine-lib-1.2.11/include/xine/video_out.h xine-lib-1.2/include/xine/video_out.h
--- xine-lib-1.2.11/include/xine/video_out.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/include/xine/video_out.h	2022-01-15 22:03:19.568547103 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -237,7 +237,8 @@
 
 };
 
-/* constants for the get/set property functions */
+/* constants for the get/set property functions.
+ * MAINTAINERS: please keep in sync with xine.h/XINE_PARAM_VO_*. */
 #define VO_PROP_INTERLACED            0
 #define VO_PROP_ASPECT_RATIO          1
 #define VO_PROP_HUE                   2
@@ -272,7 +273,9 @@
 #define VO_PROP_BUFS_FREE             27 /* read-only */
 #define VO_PROP_MAX_VIDEO_WIDTH       28 /* read-only */
 #define VO_PROP_MAX_VIDEO_HEIGHT      29 /* read-only */
-#define VO_NUM_PROPERTIES             30
+#define VO_PROP_CAPS2                 30 /* read-only. second capability flags, see below. */
+#define VO_PROP_TRANSFORM             31 /* XINE_VO_TRANSFORM_* */
+#define VO_NUM_PROPERTIES             32
 
 /* number of colors in the overlay palette. Currently limited to 256
    at most, because some alphablend functions use an 8-bit index into
@@ -332,7 +335,9 @@
 #define VO_CAP_GAMMA                  0x08000000
 #define VO_CAP_SHARPNESS              0x10000000
 #define VO_CAP_NOISE_REDUCTION        0x20000000
-
+/* retrieved via VO_PROP_CAPS2 if != -1 */
+#define VO_CAP2_NV12                  0x00000001 /* driver can handle YUV 4:2:0 pictures as 2 planes (Y plus interleaved UV) */
+#define VO_CAP2_TRANSFORM             0x00000002 /* driver can flip image */
 
 /*
  * vo_driver_s contains the functions every display driver
diff -urN xine-lib-1.2.11/include/xine/xine_internal.h xine-lib-1.2/include/xine/xine_internal.h
--- xine-lib-1.2.11/include/xine/xine_internal.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/include/xine/xine_internal.h	2022-01-15 22:03:19.568547103 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -260,6 +260,7 @@
 void _x_demux_control_start        (xine_stream_t *stream) XINE_PROTECTED;
 void _x_demux_control_end          (xine_stream_t *stream, uint32_t flags) XINE_PROTECTED;
 int _x_demux_start_thread          (xine_stream_t *stream) XINE_PROTECTED;
+int _x_demux_called_from           (xine_stream_t *stream) XINE_PROTECTED;
 int _x_demux_stop_thread           (xine_stream_t *stream) XINE_PROTECTED;
 int _x_demux_read_header           (input_plugin_t *input, void *buffer, off_t size) XINE_PROTECTED;
 int _x_demux_check_extension       (const char *mrl, const char *extensions);
@@ -391,4 +392,3 @@
 #endif
 
 #endif
-
diff -urN xine-lib-1.2.11/include/xine/xineutils.h xine-lib-1.2/include/xine/xineutils.h
--- xine-lib-1.2.11/include/xine/xineutils.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/include/xine/xineutils.h	2022-01-15 22:03:19.572547120 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/include/xine.h xine-lib-1.2/include/xine.h
--- xine-lib-1.2.11/include/xine.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/include/xine.h	2022-01-15 22:03:19.558547061 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -328,7 +328,7 @@
 #define XINE_PARAM_AUDIO_VOLUME            6 /* 0..100                      */
 #define XINE_PARAM_AUDIO_MUTE              7 /* 1=>mute, 0=>unmute          */
 #define XINE_PARAM_AUDIO_COMPR_LEVEL       8 /* <100=>off, % compress otherw*/
-#define XINE_PARAM_AUDIO_AMP_LEVEL         9 /* 0..200, 100=>100% (default) */
+#define XINE_PARAM_AUDIO_AMP_LEVEL         9 /* 0..200, (val - 100) / 2 dB, 100 = default */
 #define XINE_PARAM_AUDIO_REPORT_LEVEL     10 /* 1=>send events, 0=> don't   */
 #define XINE_PARAM_VERBOSITY              11 /* control console output      */
 #define XINE_PARAM_SPU_OFFSET             12 /* unit: 1/90000 sec           */
@@ -387,12 +387,16 @@
 #define XINE_PARAM_VO_WINDOW_HEIGHT        0x01000010 /* readonly           */
 #define XINE_PARAM_VO_SHARPNESS            0x01000018 /* 0..65535           */
 #define XINE_PARAM_VO_NOISE_REDUCTION      0x01000019 /* 0..65535           */
+#define XINE_PARAM_VO_TRANSFORM            0x0100001f /* see below          */
 #define XINE_PARAM_VO_CROP_LEFT            0x01000020 /* crop frame pixels  */
 #define XINE_PARAM_VO_CROP_RIGHT           0x01000021 /* crop frame pixels  */
 #define XINE_PARAM_VO_CROP_TOP             0x01000022 /* crop frame pixels  */
 #define XINE_PARAM_VO_CROP_BOTTOM          0x01000023 /* crop frame pixels  */
 #define XINE_PARAM_VO_SINGLE_STEP          0x01000024 /* 1 = "advance to next frame, then pause" */
 
+#define XINE_VO_TRANSFORM_FLIP_H           0x00000001
+#define XINE_VO_TRANSFORM_FLIP_V           0x00000002
+
 #define XINE_VO_ZOOM_STEP                  100
 #define XINE_VO_ZOOM_MAX                   400
 #define XINE_VO_ZOOM_MIN                   -85
@@ -492,6 +496,7 @@
 
 /* xine image formats */
 #define XINE_IMGFMT_YV12 (('2'<<24)|('1'<<16)|('V'<<8)|'Y')
+#define XINE_IMGFMT_NV12 (('2'<<24)|('1'<<16)|('V'<<8)|'N')
 #define XINE_IMGFMT_YUY2 (('2'<<24)|('Y'<<16)|('U'<<8)|'Y')
 #define XINE_IMGFMT_XVMC (('C'<<24)|('M'<<16)|('v'<<8)|'X')
 #define XINE_IMGFMT_XXMC (('C'<<24)|('M'<<16)|('x'<<8)|'X')
@@ -2217,6 +2222,7 @@
 #define XINE_MSG_PERMISSION_ERROR       12 /* (file name or mrl) */
 #define XINE_MSG_FILE_EMPTY             13 /* file is empty      */
 #define XINE_MSG_AUTHENTICATION_NEEDED	14 /* (mrl, likely http) */
+#define XINE_MSG_RECORDING_DONE         15 /* just what it says  */
 
 /* opaque xine_event_queue_t */
 typedef struct xine_event_queue_s xine_event_queue_t;
diff -urN xine-lib-1.2.11/lib/os_internal.h xine-lib-1.2/lib/os_internal.h
--- xine-lib-1.2.11/lib/os_internal.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/lib/os_internal.h	2022-01-15 22:03:19.575547132 +0100
@@ -169,6 +169,7 @@
 #ifndef HAVE_SWAB
 #define HAVE_SWAB
 #define swab(A,B,C) xine_private_swab((A),(B),(C))
+#include <sys/types.h> /* ssize_t */
 void xine_private_swab(const void *from, void *to, ssize_t n);
 #endif
 
diff -urN xine-lib-1.2.11/m4/audio_out.m4 xine-lib-1.2/m4/audio_out.m4
--- xine-lib-1.2.11/m4/audio_out.m4	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/m4/audio_out.m4	2022-01-15 22:03:19.560547069 +0100
@@ -14,7 +14,7 @@
     dnl - OSS is most unix variants
     dnl - PulseAudio has been tested on Linux, Solaris, FreeBSD, Windows
     dnl - SunAudio is NetBSD, Solaris (anything else?)
-    dnl - sndio is OpenBSD only
+    dnl - sndio is *BSD, Linux
 
     default_enable_coreaudio=no
     default_enable_irixal=no
@@ -27,6 +27,7 @@
     default_with_fusionsound=no
     default_with_jack=no
     default_with_pulseaudio=no
+    default_with_opensles=no
 
     case "$host_os" in
         cygwin* | mingw*)
@@ -41,6 +42,7 @@
         freebsd*|kfreebsd*)
             default_with_pulseaudio=yes
             default_with_jack=yes
+            default_enable_sndio=yes
             ;;
         gnu*)
             default_with_pulseaudio=yes
@@ -54,14 +56,17 @@
             default_with_alsa=yes
             default_enable_oss=no
             default_enable_esound=no
+            default_with_opensles=yes
             ;;
         linux*)
             default_with_alsa=yes
             default_with_jack=yes
             default_with_pulseaudio=yes
+            default_enable_sndio=yes
             ;;
         netbsd*)
             default_enable_sunaudio=yes
+            default_enable_sndio=yes
             ;;
         openbsd*)
             default_enable_oss=no
@@ -166,19 +171,13 @@
        ;;
    esac
 
-        AC_CHECK_HEADERS([sys/soundcard.h machine/soundcard.h soundcard.h], [break])
+        AC_CHECK_HEADERS([sys/soundcard.h], [break])
         AC_CHECK_DECL([SNDCTL_DSP_SETFRAGMENT], [have_oss=yes], [have_oss=no],
                       [#ifdef __NetBSD__
                        #include <sys/ioctl.h>
                        #endif
                        #ifdef HAVE_SYS_SOUNDCARD_H
                        # include <sys/soundcard.h>
-                       #endif
-                       #ifdef HAVE_MACHINE_SOUNDCARD_H
-                       # include <sys/soundcard.h>
-                       #endif
-                       #ifdef HAVE_SOUNDCARD_H
-                       # include <soundcard.h>
                        #endif])
         if test x"$hard_enable_oss" = x"yes" && test x"$have_oss" != x"yes"; then
             AC_MSG_ERROR([OSS support requested, but OSS not found])
@@ -232,13 +231,23 @@
     dnl sndio support
     XINE_ARG_ENABLE([sndio], [Enable sndio support])
     if test x"$enable_sndio" != "xno"; then
-	AC_CHECK_LIB([sndio], [sio_open], [SNDIO_LIBS=-lsndio; have_sndio=yes],
-		     [have_sndio=no])
-	if test "x$hard_enable_sndio" = "xyes" && test "x$have_sndio" = "xno"; then
-	    AC_MSG_ERROR([sndio support requested, but sndio not found])
-	fi
+        PKG_CHECK_MODULES([SNDIO], [sndio], [have_sndio=yes], [have_sndio=no])
+        if test x"$hard_enable_sndio" = x"yes" && test x"$have_sndio" != x"yes"; then
+            AC_MSG_ERROR([sndio support requested, but sndio not found])
+        fi
     fi
     AM_CONDITIONAL([ENABLE_SNDIO], [test "x$have_sndio" = "xyes"])
-    AC_SUBST([SNDIO_CFLAGS])
-    AC_SUBST([SNDIO_LIBS])
+
+    dnl OpenSL ES
+    XINE_ARG_WITH([opensles], [Build with OpenSL ES audio output support])
+    if test x"$with_opensles" != x"no"; then
+        AC_CHECK_HEADERS([SLES/OpenSLES.h], [have_opensles=yes], [have_opensles=no])
+        AC_CHECK_HEADERS([SLES/OpenSLES_Android.h])
+        if test "x$hard_with_opensles" = "xyes" && test "x$have_opensles" = "xno"; then
+            AC_MSG_ERROR([OpenSL ES support requested, but headers not found])
+        fi
+    fi
+    AM_CONDITIONAL([ENABLE_OPENSLES], [test x"$have_opensles" = x"yes"])
+    AC_SUBST([OPENSLES_CFLAGS])
+
 ])dnl XINE_AUDIO_OUT_PLUGINS
diff -urN xine-lib-1.2.11/m4/input.m4 xine-lib-1.2/m4/input.m4
--- xine-lib-1.2.11/m4/input.m4	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/m4/input.m4	2022-01-15 22:03:19.571547116 +0100
@@ -258,7 +258,7 @@
     XINE_ARG_ENABLE([tls], [Enable TLS support using gnutls (enables secure http (https) and ftp (ftps)])
     if test "x$enable_tls" != "xno"; then
         PKG_CHECK_MODULES([GNUTLS], [gnutls >= 2.8.6], [have_gnutls=yes], [have_gnutls=no])
-        PKG_CHECK_MODULES([OPENSSL], [openssl >= 1.0.2], [have_openssl=yes], [have_openssl=no])
+        PKG_CHECK_MODULES([OPENSSL], [openssl >= 1.0.0], [have_openssl=yes], [have_openssl=no])
         if test x"$have_gnutls" = x"yes" || test x"$have_openssl" = x"yes"; then
             have_tls=yes
         elif test x"$hard_enable_tls" = x"yes"; then
diff -urN xine-lib-1.2.11/m4/libFLAC.m4 xine-lib-1.2/m4/libFLAC.m4
--- xine-lib-1.2.11/m4/libFLAC.m4	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/m4/libFLAC.m4	2022-01-15 22:03:19.564547086 +0100
@@ -0,0 +1,137 @@
+# Configure paths for libFLAC
+# "Inspired" by ogg.m4
+
+dnl AM_PATH_LIBFLAC([ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]])
+dnl Test for libFLAC, and define LIBFLAC_CFLAGS and LIBFLAC_LIBS
+dnl
+AC_DEFUN([AM_PATH_LIBFLAC],
+[dnl
+dnl Get the cflags and libraries
+dnl
+AC_ARG_WITH(libFLAC-prefix, AS_HELP_STRING([--with-libFLAC-prefix=DIR], [prefix where libFLAC is installed (optional)]), libFLAC_prefix="$withval", libFLAC_prefix="")
+AC_ARG_WITH(libFLAC-libraries, AS_HELP_STRING([--with-libFLAC-libraries=DIR], [directory where libFLAC library is installed (optional)]), libFLAC_libraries="$withval", libFLAC_libraries="")
+AC_ARG_WITH(libFLAC-includes, AS_HELP_STRING([--with-libFLAC-includes=DIR], [directory where libFLAC header files are installed (optional)]), libFLAC_includes="$withval", libFLAC_includes="")
+AC_ARG_ENABLE(libFLACtest, AS_HELP_STRING([--disable-libFLACtest], [do not try to compile and run a test libFLAC program]), enable_libFLACtest=$enableval, enable_libFLACtest=yes)
+
+    AC_MSG_CHECKING([libdir name])
+    case $host_or_hostalias in
+    *-*-linux*)
+     # Test if the compiler is 64bit
+     echo 'int i;' > conftest.$ac_ext
+     xine_cv_cc_64bit_output=no
+     if AC_TRY_EVAL(ac_compile); then
+     case `"$MAGIC_CMD" conftest.$ac_objext` in
+     *"ELF 64"*)
+       xine_cv_cc_64bit_output=yes
+       ;;
+     esac
+     fi
+     rm -rf conftest*
+     ;;
+    esac
+
+    case $host_cpu:$xine_cv_cc_64bit_output in
+    powerpc64:yes | s390x:yes | sparc64:yes | x86_64:yes)
+     XINE_LIBNAME="lib64"
+     ;;
+    *:*)
+     XINE_LIBNAME="lib"
+     ;;
+    esac
+    AC_MSG_RESULT([$XINE_LIBNAME])
+
+  if test "x$libFLAC_libraries" != "x" ; then
+    LIBFLAC_LIBS="-L$libFLAC_libraries"
+  elif test "x$libFLAC_prefix" != "x" ; then
+    LIBFLAC_LIBS="-L$libFLAC_prefix/$XINE_LIBNAME"
+  elif test "x$prefix" != "xNONE" ; then
+    LIBFLAC_LIBS="-L$prefix/$XINE_LIBNAME"
+  fi
+
+  LIBFLAC_LIBS="$LIBFLAC_LIBS -lFLAC -lm"
+
+  if test "x$libFLAC_includes" != "x" ; then
+    LIBFLAC_CFLAGS="-I$libFLAC_includes"
+  elif test "x$libFLAC_prefix" != "x" ; then
+    LIBFLAC_CFLAGS="-I$libFLAC_prefix/include"
+  elif test "$prefix" != "xNONE"; then
+    LIBFLAC_CFLAGS="-I$prefix/include"
+  fi
+
+  AC_MSG_CHECKING(for libFLAC)
+  no_libFLAC=""
+
+
+  if test "x$enable_libFLACtest" = "xyes" ; then
+    ac_save_CFLAGS="$CFLAGS"
+    ac_save_CXXFLAGS="$CXXFLAGS"
+    ac_save_LIBS="$LIBS"
+    CFLAGS="$CFLAGS $LIBFLAC_CFLAGS"
+    CXXFLAGS="$CXXFLAGS $LIBFLAC_CFLAGS"
+    LIBS="$LIBS $LIBFLAC_LIBS"
+dnl
+dnl Now check if the installed libFLAC is sufficiently new.
+dnl
+      rm -f conf.libFLACtest
+      AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <FLAC/format.h>
+
+int main ()
+{
+  system("touch conf.libFLACtest");
+  return 0;
+}
+
+]])],[],[no_libFLAC=yes],[no_libFLAC=cc])
+      if test "x$no_libFLAC" = xcc; then
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <stdio.h>
+#include <FLAC/format.h>
+]], [[ return 0; ]])],[no_libFLAC=''],[no_libFLAC=yes])
+      fi
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+  fi
+
+  if test "x$no_libFLAC" = "x" ; then
+     AC_MSG_RESULT(yes)
+     ifelse([$1], , :, [$1])
+  else
+     AC_MSG_RESULT(no)
+     if test -f conf.libFLACtest ; then
+       :
+     else
+       echo "*** Could not run libFLAC test program, checking why..."
+       CFLAGS="$CFLAGS $LIBFLAC_CFLAGS"
+       LIBS="$LIBS $LIBFLAC_LIBS"
+       AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <stdio.h>
+#include <FLAC/format.h>
+]], [[ return 0; ]])],
+     [ echo "*** The test program compiled, but did not run. This usually means"
+       echo "*** that the run-time linker is not finding libFLAC or finding the wrong"
+       echo "*** version of libFLAC. If it is not finding libFLAC, you'll need to set your"
+       echo "*** LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point"
+       echo "*** to the installed location  Also, make sure you have run ldconfig if that"
+       echo "*** is required on your system"
+       echo "***"
+       echo "*** If you have an old version installed, it is best to remove it, although"
+       echo "*** you may also be able to get things to work by modifying LD_LIBRARY_PATH"],
+     [ echo "*** The test program failed to compile or link. See the file config.log for the"
+       echo "*** exact error that occured. This usually means libFLAC was incorrectly installed"
+       echo "*** or that you have moved libFLAC since it was installed. In the latter case, you"
+       echo "*** may want to edit the libFLAC-config script: $LIBFLAC_CONFIG" ])
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+     fi
+     LIBFLAC_CFLAGS=""
+     LIBFLAC_LIBS=""
+     ifelse([$2], , :, [$2])
+  fi
+  AC_SUBST(LIBFLAC_CFLAGS)
+  AC_SUBST(LIBFLAC_LIBS)
+  rm -f conf.libFLACtest
+])
diff -urN xine-lib-1.2.11/m4/summary.m4 xine-lib-1.2/m4/summary.m4
--- xine-lib-1.2.11/m4/summary.m4	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/m4/summary.m4	2022-01-15 22:03:19.576547137 +0100
@@ -219,7 +219,7 @@
         test x"$have_glx" = x"yes" -a x"$no_x" != x"yes"        && echo "       - X11 (GLX) backend"     || disgl="$disgl GLX"
         test x"$have_egl" = x"yes" -a x"$no_x" != x"yes"        && echo "       - X11 (EGL) backend"     || disgl="$disgl EGL-X11"
         test x"$have_egl" = x"yes" -a x"$have_wayland" = x"yes" && echo "       - Wayland (EGL) backend" || disgl="$disgl EGL-Wayland"
-        test x"$disgh" != x"" && echo "       (disabled plugins:$disgl)"
+        test x"$disgl" != x"" && echo "       (disabled plugins:$disgl)"
     else dis="$dis OpenGL2"
     fi
     if test x"$no_x" != x"yes"; then
@@ -274,6 +274,8 @@
     test x"$have_macosx_video" = x"yes" && echo "   - Mac OS X OpenGL"                 || dis="$dis macos"
     test x"$have_sdl" = x"yes"          && echo "   - sdl (Simple DirectMedia Layer)"  || dis="$dis sdl"
     test x"$have_mmal" = x"yes"         && echo "   - mmal (Broadcom MultiMedia Abstraction Layer)" || dis="$dis mmal"
+    echo "   - none (dummy output plugin)"
+    echo "   - raw"
 
 
     if test x"$have_dxr3" = x"yes"; then
@@ -325,6 +327,9 @@
     test x"$have_pulseaudio" = x"yes"   && echo "   - pulseaudio (PulseAudio sound server)" || dis="$dis pulse"
     test x"$have_sunaudio" = x"yes"     && echo "   - sun (Sun audio interface)"            || dis="$dis sun"
     test "x$have_sndio" = "xyes"	&& echo "   - sndio"                                || dis="$dis sndio"
+    test "x$have_opensles" = "xyes"     && echo "   - OpenSL ES"                            || dis="$dis opensles"
+    echo "   - none (dummy output plugin)"
+    echo "   - file"
     test x"$dis" != x"" && echo "   (disabled plugins:$dis)"
     echo "---"
 
diff -urN xine-lib-1.2.11/m4/video_out.m4 xine-lib-1.2/m4/video_out.m4
--- xine-lib-1.2.11/m4/video_out.m4	2020-12-05 23:27:04.000000000 +0100
+++ xine-lib-1.2/m4/video_out.m4	2022-01-15 22:03:19.575547132 +0100
@@ -103,6 +103,7 @@
     if test x"$have_caca$have_cucul" = x"yesyes"; then
         HAVE_CUCUL=1
         AC_SUBST([HAVE_CUCUL])
+        AC_DEFINE([HAVE_CUCUL], [], [Define this if you have the legacy libcaca with separate libcucul.])
     fi
 
 
diff -urN xine-lib-1.2.11/Makefile.am xine-lib-1.2/Makefile.am
--- xine-lib-1.2.11/Makefile.am	2020-11-19 11:30:36.000000000 +0100
+++ xine-lib-1.2/Makefile.am	2022-01-15 22:03:19.550547027 +0100
@@ -128,6 +128,7 @@
 	include/xine/io_helper.h	\
 	include/xine/list.h		\
 	include/xine/metronom.h		\
+	include/xine/mfrag.h		\
 	include/xine/os_types.h		\
 	include/xine/osd.h		\
 	include/xine/plugin_catalog.h	\
@@ -140,6 +141,7 @@
 	include/xine/sorted_array.h	\
 	include/xine/spu.h		\
 	include/xine/spu_decoder.h	\
+	include/xine/stree.h		\
 	include/xine/tickets.h		\
 	include/xine/vdr.h		\
 	include/xine/version.h		\
diff -urN xine-lib-1.2.11/misc/xine-config xine-lib-1.2/misc/xine-config
--- xine-lib-1.2.11/misc/xine-config	2020-12-06 14:14:00.000000000 +0100
+++ xine-lib-1.2/misc/xine-config	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-#!/bin/sh
-#
-#
-
-unset prefix
-unset exec_prefix
-unset args
-
-usage()
-{
-	cat <<EOF
-Usage: xine-config [OPTIONS] [LIBRARIES]
-       DEPRECATED. Use pkg-config instead.
-Options:
-	[--prefix[=DIR]]
-	[--exec-prefix[=DIR]]
-	[--version]
-        [--libs]
-	[--acflags]
-	[--cflags]
-	[--bindir]
-	[--plugindir]
-	[--datadir]
-	[--scriptdir]
-	[--localedir]
-	[--xine-list]
-	[--objcflags]
-EOF
-	exit $1
-}
-
-if test $# -eq 0; then
-	usage 1 1>&2
-fi
-
-while test $# -gt 0; do
-  case "$1" in
-  -*=*) optarg="${1#--*=}" ;;
-  *) optarg= ;;
-  esac
-
-  case "$1" in
-    --prefix=*)
-      prefix="$optarg"
-      if [ "$exec_prefix" = '' ]; then
-        exec_prefix="$optarg"
-      fi
-      ;;
-    --exec-prefix=*)
-      exec_prefix="$optarg"
-      ;;
-    --version)
-      args="$args${args+ }--modversion"
-      ;;
-    --cflags|--libs)
-      args="$args${args+ }$1"
-      ;;
-    --prefix|--acflags|--bindir|--plugindir|--datadir|--scriptdir|--localedir|--objcflags)
-      args="$args${args+ }--variable=${1#--}"
-      ;;
-    --xine-list)
-      args="$args${args+ }--variable=xine_list"
-      ;;
-    --exec-prefix)
-      args="$args${args+ }--variable=exec_prefix"
-      ;;
-    *)
-      usage 1 1>&2
-      ;;
-  esac
-  shift
-done
-
-echo 'xine-config is DEPRECATED. Use pkg-config instead.' >&2
-
-# Sigh. When installing 32 and 64 bit libxine simultaneously,
-# both will write this script to the same location.
-# Binary package managers like yum only tolerate this when
-# both files are identical. Thus we cannot add a hardcoded
-# (at)XINE_PKGCONFIG_DIR(at) to PKG_CONFIG_PATH here safely.
-# Instead, allow system and/or user to set up correctly,
-# and print some useful error if that fails.
-# That should be good enough for a deprecated feature?
-
-pkg-config --print-errors --exists libxine >&2 || exit
-
-exec pkg-config "${prefix+--define-variable=prefix=}$prefix" \
-		"${exec_prefix+--define-variable=exec_prefix=}$exec_prefix" \
-		$args libxine
diff -urN xine-lib-1.2.11/misc/xine-list.c xine-lib-1.2/misc/xine-list.c
--- xine-lib-1.2.11/misc/xine-list.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/misc/xine-list.c	2022-01-15 22:03:19.583547166 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2008-2019 the xine-project
+ * Copyright (C) 2008-2020 the xine-project
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
diff -urN xine-lib-1.2.11/po/cs.po xine-lib-1.2/po/cs.po
--- xine-lib-1.2.11/po/cs.po	2020-12-05 23:28:08.000000000 +0100
+++ xine-lib-1.2/po/cs.po	2022-01-15 22:03:19.599547234 +0100
@@ -6,7 +6,7 @@
 msgstr ""
 "Project-Id-Version: xine-lib 1.0.1\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2008-11-10 16:33+0200\n"
 "Last-Translator: František Dvořák <valtri@civ.zcu.cz>\n"
 "Language-Team: Czech <cs@li.org>\n"
@@ -233,62 +233,9 @@
 "za běhu aktualizovat svoji grafickou reprezentaci nastavení mixeru."
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
-msgstr "audio_alsa_out : podporované režimy jsou"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
-msgstr " (4kanálový není povolen v konfiguraci xine)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
-msgstr " 4.1kanálový"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
-msgstr " (4.1kanálový není povolen v konfiguraci xine)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
-msgstr " 5kanálový"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
-msgstr " (5kanálový není povolen v konfifuraci xine)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
-msgstr " (5.1kanálový není povolen v konfiguraci xine)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
-msgstr " (a/52 a DTS pass-through nejsou povoleny v konfiguraci xine)"
-
-#: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
-msgstr "snd_cm_open() selhalo:%d:%s\n"
-
-#: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
-msgstr ">>> Zkontrolujte, jestli už jiný program nepoužívá PCM <<<\n"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
-msgstr " 8bitový"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
-msgstr " 16bitový"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
-msgstr " 24bitový"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
-msgstr " 32bitový"
+msgid "snd_lib_error_set_handler() failed: %d"
+msgstr "snd_lib_error_set_handler() selhalo: %d"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "sound card can do mmap"
@@ -305,10 +252,6 @@
 "Můžete to zkusit povolit a zkontrolovat, zda vše funguje. Pokud ano, zlepší "
 "toto nastavení výkon."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
-msgstr " mono"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for mono output"
 msgstr "zařízení použité pro mono výstup"
@@ -321,10 +264,6 @@
 "xine použije toto zařízení ALSA pro výstup zvuku mono.\n"
 "Informace o zařízeních ALSA naleznete v dokumentaci k ALSA."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
-msgstr " stereo"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for stereo output"
 msgstr "zařízení použité pro stereo výstup"
@@ -337,10 +276,6 @@
 "xine použije toto zařízení ALSA pro výstup zvuku stereo.\n"
 "Informace o zařízeních ALSA naleznete v dokumentaci k ALSA."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
-msgstr " 4kanálový"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 4-channel output"
 msgstr "zařízení použité pro čtyřkanálový výstup"
@@ -353,10 +288,6 @@
 "xine použije toto zařízení ALSA pro výstup surround zvuku 4kanálově (4.0).\n"
 "Informace o zařízeních ALSA naleznete v dokumentaci k ALSA."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr " 5.1kanálový"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 5.1-channel output"
 msgstr "zařízení použité pro 5.1-kanálový výstup"
@@ -372,15 +303,6 @@
 "Informace o zařízeních ALSA naleznete v dokumentaci k ALSA."
 
 #: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
-msgstr " a/52 a DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
-#, fuzzy
-msgid "device used for a/52 and DTS pass-through"
-msgstr " a/52 a DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
 msgid ""
 "xine will use this alsa device to output undecoded digital surround sound. "
 "This can be used be external surround decoders.\n"
@@ -392,8 +314,81 @@
 
 #: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
-msgstr "snd_lib_error_set_handler() selhalo: %d"
+msgid "snd_pcm_open() failed:%d:%s\n"
+msgstr "snd_cm_open() selhalo:%d:%s\n"
+
+#: src/audio_out/audio_alsa_out.c
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
+msgstr ">>> Zkontrolujte, jestli už jiný program nepoužívá PCM <<<\n"
+
+#: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr "audio_alsa_out : podporované režimy jsou"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 8bit"
+msgstr " 8bitový"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
+msgstr " 16bitový"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 24bit"
+msgstr " 24bitový"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 32bit"
+msgstr " 32bitový"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " mono"
+msgstr " mono"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
+msgstr " stereo"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
+msgstr " 4kanálový"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (4-channel not enabled in xine config)"
+msgstr " (4kanálový není povolen v konfiguraci xine)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 4.1-channel"
+msgstr " 4.1kanálový"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (4.1-channel not enabled in xine config)"
+msgstr " (4.1kanálový není povolen v konfiguraci xine)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5-channel"
+msgstr " 5kanálový"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
+msgstr " (5kanálový není povolen v konfifuraci xine)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
+msgstr " 5.1kanálový"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
+msgstr " (5.1kanálový není povolen v konfiguraci xine)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " a/52 and DTS pass-through"
+msgstr " a/52 a DTS pass-through"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgstr " (a/52 a DTS pass-through nejsou povoleny v konfiguraci xine)"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "alsa mixer device"
@@ -3002,11 +2997,6 @@
 msgid "tls input plugin"
 msgstr "modul pro vstup ze souboru"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "modul pro vstup ze souboru"
-
 #: src/input/input_nfs.c
 #, fuzzy
 msgid "Network File System (NFS) input plugin"
@@ -6151,16 +6141,6 @@
 "digitální formě."
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr "povolit převzorkovávání"
 
@@ -7172,16 +7152,6 @@
 "příliš vysoké hodnoty zablokují přehrávač, pokud se ztratí spojení."
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
Binary files xine-lib-1.2.11/po/de.gmo and xine-lib-1.2/po/de.gmo differ
diff -urN xine-lib-1.2.11/po/de.po xine-lib-1.2/po/de.po
--- xine-lib-1.2.11/po/de.po	2020-12-05 23:28:08.000000000 +0100
+++ xine-lib-1.2/po/de.po	2022-01-15 22:03:19.599547234 +0100
@@ -6,14 +6,14 @@
 msgstr ""
 "Project-Id-Version: xine-lib 1.2.2\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2021-12-25 15:42+0100\n"
 "PO-Revision-Date: 2007-04-18 11:00+0200\n"
 "Last-Translator: Torsten Jager <t.jager@gmx.de>\n"
 "Language-Team: German <de@li.org>\n"
-"Language: de\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
+"Language: de\n"
 "Plural-Forms: nplurals=2; plural=n != 1;\n"
 
 #: lib/hstrerror.c
@@ -1770,8 +1770,8 @@
 #: src/dxr3/dxr3_decode_video.c
 msgid ""
 "Tries to set a synchronization timestamp for every frame. Normally this is "
-"not necessary, because sync is sufficent even when the timestamp is set only "
-"every now and then.\n"
+"not necessary, because sync is sufficient even when the timestamp is set "
+"only every now and then.\n"
 "This is relevant for progressive video only (most PAL films)."
 msgstr ""
 "Zeitmarken zur Synchronisationen für jedes Einzelbild erzeugen. "
@@ -2984,6 +2984,10 @@
 "Wählt das Protokoll über MMS.\n"
 "TCP ist besser, aber hinter einer Firewall kann HTTP benötigt werden."
 
+#: src/input/input_mpegdash.c
+msgid "MPEG Dynamic Adaptive Streaming over Http input plugin"
+msgstr "MPEG Dynamic Adaptive Streaming over Http Eingabe"
+
 #: src/input/input_net.c
 msgid "net input plugin as shipped with xine"
 msgstr "Mit xine ausgeliefertes net Plugin"
@@ -3607,8 +3611,8 @@
 "See the help for the title_format for the meanings of these."
 msgstr ""
 "Das selbe Format wie für Fenstertitel. Ähnlich dem Unix date-Befehl. "
-"Formatangaben starten mit einem Prozentzeichen. Formatfelder sind %A, %C, "
-"%c, %F, %I, %L, %N, %P, %p, %S, %T, %V, %v, und %%.\n"
+"Formatangaben starten mit einem Prozentzeichen. Formatfelder sind %A, %C, %"
+"c, %F, %I, %L, %N, %P, %p, %S, %T, %V, %v, und %%.\n"
 "Siehe Hilfe für title_format bezüglich deren Bedeutung."
 
 #: src/input/vcd/xineplug_inp_vcd.c
@@ -5620,6 +5624,18 @@
 "Rauschminderung und Schärfen nur bei SD.\n"
 
 #: src/video_out/video_out_vdpau.c
+msgid "vdpau: make snapshots like visible on screen"
+msgstr "vdpau: Mache Schnappschüsse wie auf dem Bildschirm gezeigt"
+
+#: src/video_out/video_out_vdpau.c
+msgid ""
+"If set, snapshots will be scaled, cropped, padded and subtitled.\n"
+"Otherwise, you get the pure original video image.\n"
+msgstr ""
+"Ein: vergrößert/verkleinert, beschnitten, aufgefüllt und untertitelt.\n"
+"Aus: nur das reine originale Videobild.\n"
+
+#: src/video_out/video_out_vdpau.c
 msgid "xine video output plugin using VDPAU hardware acceleration"
 msgstr "xine Bildausgabe über VDPAU-Beschleuniger"
 
@@ -6144,11 +6160,11 @@
 
 #: src/xine-engine/audio_decoder.c
 msgid ""
-"The number of audio buffers (each is 8k in size) xine uses in its internal "
+"The number of audio buffers (each is 2k in size) xine uses in its internal "
 "queue. Higher values mean smoother playback for unreliable inputs, but also "
 "increased latency and memory consumption."
 msgstr ""
-"Anzahl der Audiopuffer (jeder 8KiB groß), die xine für seine interne "
+"Anzahl der Audiopuffer (jeder 2KiB groß), die xine für seine interne "
 "Warteschlange benutzt. Höhere Werte bedeuten eine flüssigere Wiedergabe bei "
 "unzuverlässigen Quellen, erhöhen aber auch die Latenzzeit und den "
 "Speicherverbrauch."
@@ -7365,6 +7381,14 @@
 msgid "File is empty:"
 msgstr "Datei ist leer:"
 
+#: src/xine-engine/xine_interface.c
+msgid "Authentication needed"
+msgstr "Zugangsberechtigung erforderlich"
+
+#: src/xine-engine/xine_interface.c
+msgid "Recording done:"
+msgstr "Aufzeichnung beendet:"
+
 #: src/xine-utils/memcpy.c
 #, c-format
 msgid "Benchmarking memcpy methods (smaller is better):\n"
Binary files xine-lib-1.2.11/po/en_US.gmo and xine-lib-1.2/po/en_US.gmo differ
diff -urN xine-lib-1.2.11/po/en_US.po xine-lib-1.2/po/en_US.po
--- xine-lib-1.2.11/po/en_US.po	2020-12-05 23:28:09.000000000 +0100
+++ xine-lib-1.2/po/en_US.po	2022-01-15 22:03:19.602547246 +0100
@@ -6,7 +6,7 @@
 msgstr ""
 "Project-Id-Version: xine-lib.hg\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2009-01-15 19:04+0000\n"
 "Last-Translator: Not translated <null@example.com>\n"
 "Language-Team: en_US <none>\n"
@@ -212,149 +212,145 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
+#, c-format
+msgid "snd_lib_error_set_handler() failed: %d"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid "sound card can do mmap"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
+msgid ""
+"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
+"You can try enabling it and check, if everything works. If it does, this "
+"will increase performance."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
+msgid "device used for mono output"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output mono sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid "device used for stereo output"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output stereo sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgid "device used for 4-channel output"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
+msgid ""
+"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
+msgid "device used for 5.1-channel output"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
+msgid ""
+"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
+"sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
+msgid ""
+"xine will use this alsa device to output undecoded digital surround sound. "
+"This can be used be external surround decoders.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
+#, c-format
+msgid "snd_pcm_open() failed:%d:%s\n"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "sound card can do mmap"
+msgid "audio_alsa_out : supported modes are"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
-"You can try enabling it and check, if everything works. If it does, this "
-"will increase performance."
+msgid " 8bit"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "device used for mono output"
+msgid " 24bit"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output mono sound.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " 32bit"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
+msgid " mono"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for stereo output"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output stereo sound.\n"
-"See the alsa documentation for information on alsa devices."
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
+msgid " (4-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "device used for 4-channel output"
+msgid " 4.1-channel"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " (4.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr ""
-
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for 5.1-channel output"
+msgid " 5-channel"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
-"sound.\n"
-"See the alsa documentation for information on alsa devices."
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for a/52 and DTS pass-through"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output undecoded digital surround sound. "
-"This can be used be external surround decoders.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " a/52 and DTS pass-through"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
@@ -2584,10 +2580,6 @@
 msgid "tls input plugin"
 msgstr ""
 
-#: src/input/input_net.c
-msgid "gopher input plugin"
-msgstr ""
-
 #: src/input/input_nfs.c
 msgid "Network File System (NFS) input plugin"
 msgstr ""
@@ -5273,16 +5265,6 @@
 msgstr ""
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr ""
 
@@ -6183,16 +6165,6 @@
 msgstr ""
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
Binary files xine-lib-1.2.11/po/eo.gmo and xine-lib-1.2/po/eo.gmo differ
diff -urN xine-lib-1.2.11/po/eo.po xine-lib-1.2/po/eo.po
--- xine-lib-1.2.11/po/eo.po	2020-12-05 23:28:09.000000000 +0100
+++ xine-lib-1.2/po/eo.po	2022-01-15 22:03:19.590547196 +0100
@@ -12,7 +12,7 @@
 msgstr ""
 "Project-Id-Version: eo\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2007-05-24 17:57+0200\n"
 "Last-Translator: Antonio C. Codazzi <f_sophia@libero.it>\n"
 "Language-Team:  <it@li.org>\n"
@@ -223,62 +223,9 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
-msgstr "audio_alsa_out : subtenitaj modusoj estas"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
-msgstr " (kvarfonio ne estas ebligita en xine-agordoj)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
-msgstr " 4.1-kanalo"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
-msgstr " (4.1-kanaloj ne estas ebligita en xine-agordoj)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
-msgstr " kvinfonio"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
-msgstr " (kvinfonio ne estas ebligita en xine-agordoj)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
-msgstr " (5.1-kanaloj ne estas ebligita en xine-agordoj)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
-msgstr " (rektotrajro de a/52 kaj DTS ne estas ebligita en xine-agordoj)"
-
-#: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
-msgstr "snd_pcm_open() malsukcesis:%d:%s\n"
-
-#: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
-msgstr ">>> Kontrolu se alia programo estas uzanta PCM <<<\n"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
-msgstr " 8bitoj"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
-msgstr " 16bitoj"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
-msgstr " 24bitoj"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
-msgstr " 32bitoj"
+msgid "snd_lib_error_set_handler() failed: %d"
+msgstr "snd_lib_error_set_handler() malsukcesis: %d"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "sound card can do mmap"
@@ -291,10 +238,6 @@
 "will increase performance."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
-msgstr " unufonio"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for mono output"
 msgstr "aparato uzita por unufonia eligo"
@@ -305,10 +248,6 @@
 "See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
-msgstr " stereofonio"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for stereo output"
 msgstr "aparato uzita por stereofonia eligo"
@@ -319,10 +258,6 @@
 "See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
-msgstr " kvarfonio"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 4-channel output"
 msgstr "aparato uzita por kvarfonia eligo"
@@ -333,10 +268,6 @@
 "See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr " 5.1-kanalo"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 5.1-channel output"
 msgstr "aparato uzita por 5.1-kanala eligo"
@@ -349,15 +280,6 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
-msgstr " rektotrajro de a/52 kaj DTS"
-
-#: src/audio_out/audio_alsa_out.c
-#, fuzzy
-msgid "device used for a/52 and DTS pass-through"
-msgstr " rektotrajro de a/52 kaj DTS"
-
-#: src/audio_out/audio_alsa_out.c
 msgid ""
 "xine will use this alsa device to output undecoded digital surround sound. "
 "This can be used be external surround decoders.\n"
@@ -366,8 +288,81 @@
 
 #: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
-msgstr "snd_lib_error_set_handler() malsukcesis: %d"
+msgid "snd_pcm_open() failed:%d:%s\n"
+msgstr "snd_pcm_open() malsukcesis:%d:%s\n"
+
+#: src/audio_out/audio_alsa_out.c
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
+msgstr ">>> Kontrolu se alia programo estas uzanta PCM <<<\n"
+
+#: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr "audio_alsa_out : subtenitaj modusoj estas"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 8bit"
+msgstr " 8bitoj"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
+msgstr " 16bitoj"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 24bit"
+msgstr " 24bitoj"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 32bit"
+msgstr " 32bitoj"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " mono"
+msgstr " unufonio"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
+msgstr " stereofonio"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
+msgstr " kvarfonio"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (4-channel not enabled in xine config)"
+msgstr " (kvarfonio ne estas ebligita en xine-agordoj)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 4.1-channel"
+msgstr " 4.1-kanalo"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (4.1-channel not enabled in xine config)"
+msgstr " (4.1-kanaloj ne estas ebligita en xine-agordoj)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5-channel"
+msgstr " kvinfonio"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
+msgstr " (kvinfonio ne estas ebligita en xine-agordoj)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
+msgstr " 5.1-kanalo"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
+msgstr " (5.1-kanaloj ne estas ebligita en xine-agordoj)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " a/52 and DTS pass-through"
+msgstr " rektotrajro de a/52 kaj DTS"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgstr " (rektotrajro de a/52 kaj DTS ne estas ebligita en xine-agordoj)"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "alsa mixer device"
@@ -2710,11 +2705,6 @@
 msgid "tls input plugin"
 msgstr "eniga kromaĵo de dosiero"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "eniga kromaĵo de dosiero"
-
 #: src/input/input_nfs.c
 #, fuzzy
 msgid "Network File System (NFS) input plugin"
@@ -5529,16 +5519,6 @@
 msgstr ""
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr "ebligu re-sampladon"
 
@@ -6473,16 +6453,6 @@
 msgstr ""
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
Binary files xine-lib-1.2.11/po/es.gmo and xine-lib-1.2/po/es.gmo differ
diff -urN xine-lib-1.2.11/po/es.po xine-lib-1.2/po/es.po
--- xine-lib-1.2.11/po/es.po	2020-12-05 23:28:09.000000000 +0100
+++ xine-lib-1.2/po/es.po	2022-01-15 22:03:19.598547229 +0100
@@ -10,7 +10,7 @@
 msgstr ""
 "Project-Id-Version: xine-lib.hg\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2008-04-02 01:05+0200\n"
 "Last-Translator: Carlos E. R. M. <carloser@users.sourceforge.net>\n"
 "Language-Team: Spanish <none>\n"
@@ -245,62 +245,9 @@
 "ajustes del mezclador al vuelo."
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
-msgstr "audio_alsa_out : los modos soportados son"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
-msgstr " (4-canales no activado en la configuración de xine)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
-msgstr " 4.1-canales"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
-msgstr " (4.1-canales no activado en la configuración de xine)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
-msgstr " 5-canales"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
-msgstr " (5-canales no activado en la configuración de xine)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
-msgstr " (5.1-canales no activado en la configuración de xine)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
-msgstr " (travesía a/52 and DTS no activada en la configuración de xine)"
-
-#: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
-msgstr "snd_pcm_open() falló:%d:%s\n"
-
-#: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
-msgstr ">>> Comprobar si otro programa está ya usando PCM <<<\n"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
-msgstr " 8bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
-msgstr " 16bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
-msgstr " 24bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
-msgstr " 32bit"
+msgid "snd_lib_error_set_handler() failed: %d"
+msgstr "snd_lib_error_set_handler() falló: %d"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "sound card can do mmap"
@@ -317,10 +264,6 @@
 "Puede probar a activarlo y verficar, si todo funciona. Si lo hace, esto "
 "aumentará el rendimiento."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
-msgstr " mono"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for mono output"
 msgstr "dispositivo usado para salida mono"
@@ -333,10 +276,6 @@
 "xine usará éste dispositivo para generar sonido monofónico.\n"
 "Vea la documentación de alsa para información de dispositivos alsa."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
-msgstr " estéreo"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for stereo output"
 msgstr "dispositivo usado para salida estéreo"
@@ -349,10 +288,6 @@
 "xine usará este dispositivo alsa para la salida de sonido estereo.\n"
 "Vea la documentación de alsa para información de dispositivos alsa."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
-msgstr " 4-canales"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 4-channel output"
 msgstr "dispositivo usado para salida de cuatro canales"
@@ -366,10 +301,6 @@
 "canales (4.0).\n"
 "Vea la documentación de alsa para información de dispositivos alsa."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr " 5.1-canales"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 5.1-channel output"
 msgstr "dispositivo usado para salida de 5.1 canales"
@@ -385,15 +316,6 @@
 "Vea la documentación de alsa para información de dispositivos alsa."
 
 #: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
-msgstr " travesía a/52 y DTS"
-
-#: src/audio_out/audio_alsa_out.c
-#, fuzzy
-msgid "device used for a/52 and DTS pass-through"
-msgstr " travesía a/52 y DTS"
-
-#: src/audio_out/audio_alsa_out.c
 msgid ""
 "xine will use this alsa device to output undecoded digital surround sound. "
 "This can be used be external surround decoders.\n"
@@ -405,8 +327,81 @@
 
 #: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
-msgstr "snd_lib_error_set_handler() falló: %d"
+msgid "snd_pcm_open() failed:%d:%s\n"
+msgstr "snd_pcm_open() falló:%d:%s\n"
+
+#: src/audio_out/audio_alsa_out.c
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
+msgstr ">>> Comprobar si otro programa está ya usando PCM <<<\n"
+
+#: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr "audio_alsa_out : los modos soportados son"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 8bit"
+msgstr " 8bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
+msgstr " 16bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 24bit"
+msgstr " 24bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 32bit"
+msgstr " 32bit"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " mono"
+msgstr " mono"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
+msgstr " estéreo"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
+msgstr " 4-canales"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (4-channel not enabled in xine config)"
+msgstr " (4-canales no activado en la configuración de xine)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 4.1-channel"
+msgstr " 4.1-canales"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (4.1-channel not enabled in xine config)"
+msgstr " (4.1-canales no activado en la configuración de xine)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5-channel"
+msgstr " 5-canales"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
+msgstr " (5-canales no activado en la configuración de xine)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
+msgstr " 5.1-canales"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
+msgstr " (5.1-canales no activado en la configuración de xine)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " a/52 and DTS pass-through"
+msgstr " travesía a/52 y DTS"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgstr " (travesía a/52 and DTS no activada en la configuración de xine)"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "alsa mixer device"
@@ -3129,11 +3124,6 @@
 msgid "tls input plugin"
 msgstr "complemento de fichero entrada"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "complemento de fichero entrada"
-
 #: src/input/input_nfs.c
 #, fuzzy
 msgid "Network File System (NFS) input plugin"
@@ -6420,16 +6410,6 @@
 "audio se pasan a un decodificador externo en forma digital."
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr "activar remuestreo (resampling)"
 
@@ -7470,16 +7450,6 @@
 "congelarán el reproductor si se pierde la conexión."
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
Binary files xine-lib-1.2.11/po/eu.gmo and xine-lib-1.2/po/eu.gmo differ
diff -urN xine-lib-1.2.11/po/eu.po xine-lib-1.2/po/eu.po
--- xine-lib-1.2.11/po/eu.po	2020-12-05 23:28:09.000000000 +0100
+++ xine-lib-1.2/po/eu.po	2022-01-15 22:03:19.583547166 +0100
@@ -8,7 +8,7 @@
 msgstr ""
 "Project-Id-Version: xine-lib-1\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2005-02-17 14:29+0100\n"
 "Last-Translator: Piarres Beobide <pi@beobide.net>\n"
 "Language-Team: lubrezale <librezale@librezale.org>\n"
@@ -220,62 +220,9 @@
 "nahaslearen irudi grafikoa denbora errealean eraldatuko du."
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
-msgstr "audio_alsa_out : Onartutako moduak:"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
-msgstr " (4-kanal ez dago gaiturik xine konfigruaketan)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
-msgstr " 4.1-kanal"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
-msgstr " (4.1-kanal ez dago gaiturik xine konfigruaketan)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
-msgstr " 5-kanal"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
-msgstr " (5-kanal ez dago gaiturik xine konfigruaketan)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
-msgstr " (5.1-kanal ez dago gaiturik xine konfigruaketan)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
-msgstr " (a/52 eta DTS pass-through ez daude gaiturik xine konfiguraketan)"
-
-#: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
-msgstr "snd_pcm_open()-ek huts egin du:%d:%s\n"
-
-#: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
-msgstr ">>> Egiaztatu beste programa batek PCM darabilkien<<<\n"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
-msgstr " 8bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
-msgstr " 16bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
-msgstr " 24bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
-msgstr " 32bit"
+msgid "snd_lib_error_set_handler() failed: %d"
+msgstr "snd_lib_error_set_handler() hutsa: %d"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "sound card can do mmap"
@@ -292,10 +239,6 @@
 "Gaitu eta frogaru dezakezu beldurrik gabe, denak behar bezala funtzionatu "
 "ezkero portamoldea obetuko du."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
-msgstr " mono"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for mono output"
 msgstr "mono irteerarako erabiliko den gailua"
@@ -309,10 +252,6 @@
 "Irakurri alsa dokumentazioa alsa gailuei buruzko informazio gehiago behar "
 "izan ezkero."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
-msgstr " estereo"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for stereo output"
 msgstr "Estereo irteerak erabiltzen duen gailua"
@@ -326,10 +265,6 @@
 "Irakurri alsa dokumentazioa alsa gailuei buruzko informazio gehiago behar "
 "izan ezkero."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
-msgstr " 4-kanal"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 4-channel output"
 msgstr "4 kanaletako irteerak erabiltzen duen gailua"
@@ -343,10 +278,6 @@
 "Irakurri alsa dokumentazioa alsa gailei buruzko informazio gehiago behar "
 "izan ezkero."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr " 5.1-kanal"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 5.1-channel output"
 msgstr "5.1 kanaletako irteerak erabiltzen duen gailua"
@@ -362,15 +293,6 @@
 "izan ezkero."
 
 #: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
-msgstr " a/52 eta DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
-#, fuzzy
-msgid "device used for a/52 and DTS pass-through"
-msgstr " a/52 eta DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
 msgid ""
 "xine will use this alsa device to output undecoded digital surround sound. "
 "This can be used be external surround decoders.\n"
@@ -382,8 +304,81 @@
 
 #: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
-msgstr "snd_lib_error_set_handler() hutsa: %d"
+msgid "snd_pcm_open() failed:%d:%s\n"
+msgstr "snd_pcm_open()-ek huts egin du:%d:%s\n"
+
+#: src/audio_out/audio_alsa_out.c
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
+msgstr ">>> Egiaztatu beste programa batek PCM darabilkien<<<\n"
+
+#: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr "audio_alsa_out : Onartutako moduak:"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 8bit"
+msgstr " 8bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
+msgstr " 16bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 24bit"
+msgstr " 24bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 32bit"
+msgstr " 32bit"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " mono"
+msgstr " mono"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
+msgstr " estereo"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
+msgstr " 4-kanal"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (4-channel not enabled in xine config)"
+msgstr " (4-kanal ez dago gaiturik xine konfigruaketan)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 4.1-channel"
+msgstr " 4.1-kanal"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (4.1-channel not enabled in xine config)"
+msgstr " (4.1-kanal ez dago gaiturik xine konfigruaketan)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5-channel"
+msgstr " 5-kanal"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
+msgstr " (5-kanal ez dago gaiturik xine konfigruaketan)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
+msgstr " 5.1-kanal"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
+msgstr " (5.1-kanal ez dago gaiturik xine konfigruaketan)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " a/52 and DTS pass-through"
+msgstr " a/52 eta DTS pass-through"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgstr " (a/52 eta DTS pass-through ez daude gaiturik xine konfiguraketan)"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "alsa mixer device"
@@ -2879,11 +2874,6 @@
 msgid "tls input plugin"
 msgstr "fitxategi sarrera plugina"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "fitxategi sarrera plugina"
-
 #: src/input/input_nfs.c
 #, fuzzy
 msgid "Network File System (NFS) input plugin"
@@ -5703,16 +5693,6 @@
 msgstr ""
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr ""
 
@@ -6652,16 +6632,6 @@
 msgstr ""
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
Binary files xine-lib-1.2.11/po/fr.gmo and xine-lib-1.2/po/fr.gmo differ
diff -urN xine-lib-1.2.11/po/fr.po xine-lib-1.2/po/fr.po
--- xine-lib-1.2.11/po/fr.po	2020-12-05 23:28:09.000000000 +0100
+++ xine-lib-1.2/po/fr.po	2022-01-15 22:03:19.580547154 +0100
@@ -8,7 +8,7 @@
 msgstr ""
 "Project-Id-Version: xine-lib 1.1.9\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2014-03-11 23:17+0100\n"
 "Last-Translator: Xavier Bachelot <xavier@bachelot.org>\n"
 "Language-Team: french <fr@li.org>\n"
@@ -229,62 +229,9 @@
 "représentation graphique du mixeur."
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
-msgstr "audio_alsa_out : les modes supportés sont"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
-msgstr " (sortie 4 canaux non activée dans la configuration de xine)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
-msgstr " sortie 4.1 canaux"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
-msgstr " (sortie 4.1 canaux non activée dans la configuration de xine)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
-msgstr " Sortie 5 canaux"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
-msgstr " (Sortie 5 canaux non activée dans la configuration de xine)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
-msgstr " (Sortie 5.1 canaux non activée dans la configuration de xine)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
-msgstr " (a/52 et DTS pass-through non activés dans la configuration de xine)"
-
-#: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
-msgstr "snd_pcm_open() a échoué:%d:%s\n"
-
-#: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
-msgstr ">>> Vérifiez si un autre programme utilise déjà PCM <<<\n"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
-msgstr " 8bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
-msgstr " 16bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
-msgstr " 24bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
-msgstr " 32bit"
+msgid "snd_lib_error_set_handler() failed: %d"
+msgstr "snd_lib_error_set_handler() a échoué: %d"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "sound card can do mmap"
@@ -301,10 +248,6 @@
 "Essayez de l'activer et contrôlez que tout fonctionne correctement.Si c'est "
 "le cas,cela augmentera les performances ."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
-msgstr " mono"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for mono output"
 msgstr "périphérique utilisé pour la sortie mono"
@@ -318,10 +261,6 @@
 "Voir la documentation alsa pour toutes informations complémentaires sur les "
 "périphériques alsa."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
-msgstr " stéréo"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for stereo output"
 msgstr "périphérique utilisé pour la sortie stéréo"
@@ -335,10 +274,6 @@
 "Voir la documentation alsa pour toutes informations complémentaires sur les "
 "périphériques alsa"
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
-msgstr " 4-canaux"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 4-channel output"
 msgstr "périphérique utilisé pour la sortie 4 canaux"
@@ -353,10 +288,6 @@
 "Voir la documentation alsa pour toutes informations complémentaires sur les "
 "périphériques alsa."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr " Sortie 5.1 canaux"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 5.1-channel output"
 msgstr "périphérique utilisé pour la sortie 5.1 canaux"
@@ -373,15 +304,6 @@
 "périphériques alsa."
 
 #: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
-msgstr " a/52 et DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
-#, fuzzy
-msgid "device used for a/52 and DTS pass-through"
-msgstr " a/52 et DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
 msgid ""
 "xine will use this alsa device to output undecoded digital surround sound. "
 "This can be used be external surround decoders.\n"
@@ -394,8 +316,81 @@
 
 #: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
-msgstr "snd_lib_error_set_handler() a échoué: %d"
+msgid "snd_pcm_open() failed:%d:%s\n"
+msgstr "snd_pcm_open() a échoué:%d:%s\n"
+
+#: src/audio_out/audio_alsa_out.c
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
+msgstr ">>> Vérifiez si un autre programme utilise déjà PCM <<<\n"
+
+#: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr "audio_alsa_out : les modes supportés sont"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 8bit"
+msgstr " 8bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
+msgstr " 16bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 24bit"
+msgstr " 24bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 32bit"
+msgstr " 32bit"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " mono"
+msgstr " mono"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
+msgstr " stéréo"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
+msgstr " 4-canaux"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (4-channel not enabled in xine config)"
+msgstr " (sortie 4 canaux non activée dans la configuration de xine)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 4.1-channel"
+msgstr " sortie 4.1 canaux"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (4.1-channel not enabled in xine config)"
+msgstr " (sortie 4.1 canaux non activée dans la configuration de xine)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5-channel"
+msgstr " Sortie 5 canaux"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
+msgstr " (Sortie 5 canaux non activée dans la configuration de xine)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
+msgstr " Sortie 5.1 canaux"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
+msgstr " (Sortie 5.1 canaux non activée dans la configuration de xine)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " a/52 and DTS pass-through"
+msgstr " a/52 et DTS pass-through"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgstr " (a/52 et DTS pass-through non activés dans la configuration de xine)"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "alsa mixer device"
@@ -2984,11 +2979,6 @@
 msgid "tls input plugin"
 msgstr "plugin d'entrée fichier"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "plugin d'entrée fichier"
-
 #: src/input/input_nfs.c
 #, fuzzy
 msgid "Network File System (NFS) input plugin"
@@ -5791,16 +5781,6 @@
 msgstr ""
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr "Activation du ré-échantillonage"
 
@@ -6739,16 +6719,6 @@
 msgstr ""
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
Binary files xine-lib-1.2.11/po/it.gmo and xine-lib-1.2/po/it.gmo differ
diff -urN xine-lib-1.2.11/po/it.po xine-lib-1.2/po/it.po
--- xine-lib-1.2.11/po/it.po	2020-12-05 23:28:09.000000000 +0100
+++ xine-lib-1.2/po/it.po	2022-01-15 22:03:19.594547213 +0100
@@ -9,7 +9,7 @@
 msgstr ""
 "Project-Id-Version: it\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2007-12-24 16:09+0100\n"
 "Last-Translator: Diego 'Flameeyes' Pettenò <flameeyes@gentoo.org>\n"
 "Language-Team: Italian\n"
@@ -236,63 +236,9 @@
 "impostazioni del mixer al volo."
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
-msgstr "audio_alsa_out : i modi supportati sono"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
-msgstr " (4-canali non abilitato nella configurazione di xine)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
-msgstr " 4.1-canali"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
-msgstr " (4.1-canali non abilitati nella configurazione di xine)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
-msgstr " 5-canali"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
-msgstr " (5-canali non abilitati nella configurazione di xine)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
-msgstr " (5.1-canali non abilitati nella configurazione di xine)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
-msgstr ""
-" (passaggio diretto a/52 e DTS non abilitato nella configurazione di xine)"
-
-#: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
-msgstr "snd_pcm_open() non riuscito:%d:%s\n"
-
-#: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
-msgstr ">>>Controlla se un altro programma sta già usando PCM <<<\n"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
-msgstr " 8-bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
-msgstr " 16-bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
-msgstr " 24-bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
-msgstr " 32-bit"
+msgid "snd_lib_error_set_handler() failed: %d"
+msgstr "snd_lib_error_set_handler() non riuscita: %d"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "sound card can do mmap"
@@ -309,10 +255,6 @@
 "Si può provare ad abilitarlo e vedere se funziona, in qual caso migliorerà "
 "le prestazioni."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
-msgstr " mono"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for mono output"
 msgstr "dispositivo usato per output mono"
@@ -325,10 +267,6 @@
 "xine utilizzerà questo dispositivo ALSA per riprodurre suono mono.\n"
 "Si veda la documentazione ALSA per informazioni sui dispositivi."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
-msgstr " stereo"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for stereo output"
 msgstr "dispositivo usato per output stereo"
@@ -341,10 +279,6 @@
 "xine utilizzerà questo dispositivo ALSA per riprodurre suono stereo.\n"
 "Si veda la documentazione ALSA per informazioni sui dispositivi."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
-msgstr " 4-canali"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 4-channel output"
 msgstr "dispositivo usato per output a 4 canali"
@@ -358,10 +292,6 @@
 "canali (4.0.\n"
 "Si veda la documentazione ALSA per informazioni sui dispositivi."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr " 5.1-canali"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 5.1-channel output"
 msgstr "dispositivo usato per output a canale 5.1"
@@ -377,15 +307,6 @@
 "Si veda la documentazione ALSA per informazioni sui dispositivi."
 
 #: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
-msgstr " passaggio diretto a/52 e DTS"
-
-#: src/audio_out/audio_alsa_out.c
-#, fuzzy
-msgid "device used for a/52 and DTS pass-through"
-msgstr " passaggio diretto a/52 e DTS"
-
-#: src/audio_out/audio_alsa_out.c
 msgid ""
 "xine will use this alsa device to output undecoded digital surround sound. "
 "This can be used be external surround decoders.\n"
@@ -398,8 +319,82 @@
 
 #: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
-msgstr "snd_lib_error_set_handler() non riuscita: %d"
+msgid "snd_pcm_open() failed:%d:%s\n"
+msgstr "snd_pcm_open() non riuscito:%d:%s\n"
+
+#: src/audio_out/audio_alsa_out.c
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
+msgstr ">>>Controlla se un altro programma sta già usando PCM <<<\n"
+
+#: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr "audio_alsa_out : i modi supportati sono"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 8bit"
+msgstr " 8-bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
+msgstr " 16-bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 24bit"
+msgstr " 24-bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 32bit"
+msgstr " 32-bit"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " mono"
+msgstr " mono"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
+msgstr " stereo"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
+msgstr " 4-canali"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (4-channel not enabled in xine config)"
+msgstr " (4-canali non abilitato nella configurazione di xine)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 4.1-channel"
+msgstr " 4.1-canali"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (4.1-channel not enabled in xine config)"
+msgstr " (4.1-canali non abilitati nella configurazione di xine)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5-channel"
+msgstr " 5-canali"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
+msgstr " (5-canali non abilitati nella configurazione di xine)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
+msgstr " 5.1-canali"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
+msgstr " (5.1-canali non abilitati nella configurazione di xine)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " a/52 and DTS pass-through"
+msgstr " passaggio diretto a/52 e DTS"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgstr ""
+" (passaggio diretto a/52 e DTS non abilitato nella configurazione di xine)"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "alsa mixer device"
@@ -3059,11 +3054,6 @@
 msgid "tls input plugin"
 msgstr "plugin di input del file"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "plugin di input del file"
-
 #: src/input/input_nfs.c
 #, fuzzy
 msgid "Network File System (NFS) input plugin"
@@ -6193,16 +6183,6 @@
 "digitale."
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr "abilita ricampionamento"
 
@@ -7238,16 +7218,6 @@
 "connessione viene persa."
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
Binary files xine-lib-1.2.11/po/ja.gmo and xine-lib-1.2/po/ja.gmo differ
diff -urN xine-lib-1.2.11/po/ja.po xine-lib-1.2/po/ja.po
--- xine-lib-1.2.11/po/ja.po	2020-12-05 23:28:09.000000000 +0100
+++ xine-lib-1.2/po/ja.po	2022-01-15 22:03:19.574547128 +0100
@@ -7,7 +7,7 @@
 msgstr ""
 "Project-Id-Version: xine-lib 1.1.19\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2010-07-31 01:14+0700\n"
 "Last-Translator: Takeshi Hamasaki <hmatrjp@users.sourceforge.jp>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -218,35 +218,71 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
+#, c-format
+msgid "snd_lib_error_set_handler() failed: %d"
+msgstr "snd_lib_error_set_handler() が失敗: %d"
+
+#: src/audio_out/audio_alsa_out.c
+msgid "sound card can do mmap"
+msgstr "サウンドカードは mmap を使用可能"
+
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
+"You can try enabling it and check, if everything works. If it does, this "
+"will increase performance."
 msgstr ""
+"サウンドカードと ALSA ドライバがメモリマップドIO をサポートしている場合には有"
+"効にしてください。\n"
+"一度有効にしてきちんと働くか確認してみてください。大丈夫なら性能が向上しま"
+"す。"
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid "device used for mono output"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
-msgstr " 4.1チャネル"
+msgid ""
+"xine will use this alsa device to output mono sound.\n"
+"See the alsa documentation for information on alsa devices."
+msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
+msgid "device used for stereo output"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
-msgstr " 5チャネル"
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output stereo sound.\n"
+"See the alsa documentation for information on alsa devices."
+msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid "device used for 4-channel output"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgid "device used for 5.1-channel output"
+msgstr ""
+
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
+"sound.\n"
+"See the alsa documentation for information on alsa devices."
+msgstr ""
+
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output undecoded digital surround sound. "
+"This can be used be external surround decoders.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
@@ -260,6 +296,10 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr ""
+
+#: src/audio_out/audio_alsa_out.c
 msgid " 8bit"
 msgstr "8ビット"
 
@@ -275,99 +315,55 @@
 msgid " 32bit"
 msgstr " 24ビット"
 
-#: src/audio_out/audio_alsa_out.c
-msgid "sound card can do mmap"
-msgstr "サウンドカードは mmap を使用可能"
-
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
-"You can try enabling it and check, if everything works. If it does, this "
-"will increase performance."
-msgstr ""
-"サウンドカードと ALSA ドライバがメモリマップドIO をサポートしている場合には有"
-"効にしてください。\n"
-"一度有効にしてきちんと働くか確認してみてください。大丈夫なら性能が向上しま"
-"す。"
-
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
 msgid " mono"
 msgstr "モノラル"
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for mono output"
-msgstr ""
-
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output mono sound.\n"
-"See the alsa documentation for information on alsa devices."
-msgstr ""
-
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
 msgid " stereo"
 msgstr "ステレオ"
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for stereo output"
-msgstr ""
-
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output stereo sound.\n"
-"See the alsa documentation for information on alsa devices."
-msgstr ""
-
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
 msgid " 4-channel"
 msgstr " 4チャネル"
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for 4-channel output"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (4-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " 4.1-channel"
+msgstr " 4.1チャネル"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (4.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr " 5.1チャネル"
+msgid " 5-channel"
+msgstr " 5チャネル"
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for 5.1-channel output"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
-"sound.\n"
-"See the alsa documentation for information on alsa devices."
-msgstr ""
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
+msgstr " 5.1チャネル"
 
-#: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "device used for a/52 and DTS pass-through"
+msgid " a/52 and DTS pass-through"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output undecoded digital surround sound. "
-"This can be used be external surround decoders.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
-msgstr "snd_lib_error_set_handler() が失敗: %d"
-
-#: src/audio_out/audio_alsa_out.c
 msgid "alsa mixer device"
 msgstr ""
 
@@ -2605,11 +2601,6 @@
 msgid "tls input plugin"
 msgstr ""
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "xine: 入力プラグインが見つかりました  : %s\n"
-
 #: src/input/input_nfs.c
 msgid "Network File System (NFS) input plugin"
 msgstr ""
@@ -5299,16 +5290,6 @@
 msgstr ""
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr ""
 
@@ -6209,16 +6190,6 @@
 msgstr ""
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
diff -urN xine-lib-1.2.11/po/libxine2.pot xine-lib-1.2/po/libxine2.pot
--- xine-lib-1.2.11/po/libxine2.pot	2020-12-05 23:28:08.000000000 +0100
+++ xine-lib-1.2/po/libxine2.pot	2022-01-15 22:03:19.584547170 +0100
@@ -6,9 +6,9 @@
 #, fuzzy
 msgid ""
 msgstr ""
-"Project-Id-Version: xine-lib 1.2.11\n"
+"Project-Id-Version: xine-lib 1.2.10\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -214,149 +214,145 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
+#, c-format
+msgid "snd_lib_error_set_handler() failed: %d"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid "sound card can do mmap"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
+msgid ""
+"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
+"You can try enabling it and check, if everything works. If it does, this "
+"will increase performance."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
+msgid "device used for mono output"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output mono sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid "device used for stereo output"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output stereo sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgid "device used for 4-channel output"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
+msgid ""
+"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
+msgid "device used for 5.1-channel output"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
+msgid ""
+"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
+"sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
+msgid ""
+"xine will use this alsa device to output undecoded digital surround sound. "
+"This can be used be external surround decoders.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
+#, c-format
+msgid "snd_pcm_open() failed:%d:%s\n"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "sound card can do mmap"
+msgid "audio_alsa_out : supported modes are"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
-"You can try enabling it and check, if everything works. If it does, this "
-"will increase performance."
+msgid " 8bit"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "device used for mono output"
+msgid " 24bit"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output mono sound.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " 32bit"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
+msgid " mono"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for stereo output"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output stereo sound.\n"
-"See the alsa documentation for information on alsa devices."
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
+msgid " (4-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "device used for 4-channel output"
+msgid " 4.1-channel"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " (4.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr ""
-
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for 5.1-channel output"
+msgid " 5-channel"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
-"sound.\n"
-"See the alsa documentation for information on alsa devices."
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for a/52 and DTS pass-through"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output undecoded digital surround sound. "
-"This can be used be external surround decoders.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " a/52 and DTS pass-through"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
@@ -2586,10 +2582,6 @@
 msgid "tls input plugin"
 msgstr ""
 
-#: src/input/input_net.c
-msgid "gopher input plugin"
-msgstr ""
-
 #: src/input/input_nfs.c
 msgid "Network File System (NFS) input plugin"
 msgstr ""
@@ -5275,16 +5267,6 @@
 msgstr ""
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr ""
 
@@ -6185,16 +6167,6 @@
 msgstr ""
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
diff -urN xine-lib-1.2.11/po/Makevars.template xine-lib-1.2/po/Makevars.template
--- xine-lib-1.2.11/po/Makevars.template	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/po/Makevars.template	2022-01-15 22:03:19.573547124 +0100
@@ -0,0 +1,53 @@
+# Makefile variables for PO directory in any package using GNU gettext.
+
+# Usually the message domain is the same as the package name.
+DOMAIN = $(PACKAGE)
+
+# These two variables depend on the location of this directory.
+subdir = po
+top_builddir = ..
+
+# These options get passed to xgettext.
+XGETTEXT_OPTIONS = --keyword=_ --keyword=N_
+
+# This is the copyright holder that gets inserted into the header of the
+# $(DOMAIN).pot file.  Set this to the copyright holder of the surrounding
+# package.  (Note that the msgstr strings, extracted from the package's
+# sources, belong to the copyright holder of the package.)  Translators are
+# expected to transfer the copyright for their translations to this person
+# or entity, or to disclaim their copyright.  The empty string stands for
+# the public domain; in this case the translators are expected to disclaim
+# their copyright.
+COPYRIGHT_HOLDER = Free Software Foundation, Inc.
+
+# This is the email address or URL to which the translators shall report
+# bugs in the untranslated strings:
+# - Strings which are not entire sentences, see the maintainer guidelines
+#   in the GNU gettext documentation, section 'Preparing Strings'.
+# - Strings which use unclear terms or require additional context to be
+#   understood.
+# - Strings which make invalid assumptions about notation of date, time or
+#   money.
+# - Pluralisation problems.
+# - Incorrect English spelling.
+# - Incorrect formatting.
+# It can be your email address, or a mailing list address where translators
+# can write to without being subscribed, or the URL of a web page through
+# which the translators can contact you.
+MSGID_BUGS_ADDRESS =
+
+# This is the list of locale categories, beyond LC_MESSAGES, for which the
+# message catalogs shall be used.  It is usually empty.
+EXTRA_LOCALE_CATEGORIES =
+
+# This tells whether the $(DOMAIN).pot file contains messages with an 'msgctxt'
+# context.  Possible values are "yes" and "no".  Set this to yes if the
+# package uses functions taking also a message context, like pgettext(), or
+# if in $(XGETTEXT_OPTIONS) you define keywords with a context argument.
+USE_MSGCTXT = no
+
+# These options get passed to msgmerge.
+# Useful options are in particular:
+#   --previous            to keep previous msgids of translated messages,
+#   --quiet               to reduce the verbosity.
+MSGMERGE_OPTIONS =
Binary files xine-lib-1.2.11/po/pl.gmo and xine-lib-1.2/po/pl.gmo differ
diff -urN xine-lib-1.2.11/po/pl.po xine-lib-1.2/po/pl.po
--- xine-lib-1.2.11/po/pl.po	2020-12-05 23:28:10.000000000 +0100
+++ xine-lib-1.2/po/pl.po	2022-01-15 22:03:19.567547099 +0100
@@ -7,7 +7,7 @@
 msgstr ""
 "Project-Id-Version: pl_PL\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2003-05-24 12:36+0200\n"
 "Last-Translator: Bartłomiej Muryn <_4ever_@irc.pl>\n"
 "Language-Team: Polish <pl@li.org>\n"
@@ -221,35 +221,73 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
+#, c-format
+msgid "snd_lib_error_set_handler() failed: %d"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid "sound card can do mmap"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
+msgid ""
+"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
+"You can try enabling it and check, if everything works. If it does, this "
+"will increase performance."
 msgstr ""
 
+# src/audio_out/audio_alsa_out.c:181 src/audio_out/audio_alsa_out.c:728
+# src/audio_out/audio_alsa_out.c:913 src/audio_out/audio_alsa_out.c:957
 #: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
+msgid "device used for mono output"
+msgstr "urządzenie użyte w trybie mono"
+
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output mono sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
+# src/audio_out/audio_alsa_out.c:191 src/audio_out/audio_alsa_out.c:920
+#: src/audio_out/audio_alsa_out.c
+msgid "device used for stereo output"
+msgstr "urządzenie użyte w trybie stereo"
+
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output stereo sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
+# src/audio_out/audio_alsa_out.c:201 src/audio_out/audio_alsa_out.c:927
+#: src/audio_out/audio_alsa_out.c
+msgid "device used for 4-channel output"
+msgstr "urządzenie użyte do wyjścia 4-kanałowego"
+
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
+# src/audio_out/audio_alsa_out.c:221 src/audio_out/audio_alsa_out.c:232
+# src/audio_out/audio_alsa_out.c:941 src/audio_out/audio_alsa_out.c:948
+#: src/audio_out/audio_alsa_out.c
+msgid "device used for 5.1-channel output"
+msgstr "urządzenie użyte do wyjścia 5.1-kanałowego"
+
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
+"sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgid ""
+"xine will use this alsa device to output undecoded digital surround sound. "
+"This can be used be external surround decoders.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
@@ -263,6 +301,10 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr ""
+
+#: src/audio_out/audio_alsa_out.c
 msgid " 8bit"
 msgstr ""
 
@@ -278,100 +320,52 @@
 msgid " 32bit"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid "sound card can do mmap"
-msgstr ""
-
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
-"You can try enabling it and check, if everything works. If it does, this "
-"will increase performance."
-msgstr ""
-
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
 msgid " mono"
 msgstr ""
 
-# src/audio_out/audio_alsa_out.c:181 src/audio_out/audio_alsa_out.c:728
-# src/audio_out/audio_alsa_out.c:913 src/audio_out/audio_alsa_out.c:957
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for mono output"
-msgstr "urządzenie użyte w trybie mono"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
+msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output mono sound.\n"
-"See the alsa documentation for information on alsa devices."
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
+msgid " (4-channel not enabled in xine config)"
 msgstr ""
 
-# src/audio_out/audio_alsa_out.c:191 src/audio_out/audio_alsa_out.c:920
 #: src/audio_out/audio_alsa_out.c
-msgid "device used for stereo output"
-msgstr "urządzenie użyte w trybie stereo"
+msgid " 4.1-channel"
+msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output stereo sound.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " (4.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
+msgid " 5-channel"
 msgstr ""
 
-# src/audio_out/audio_alsa_out.c:201 src/audio_out/audio_alsa_out.c:927
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for 4-channel output"
-msgstr "urządzenie użyte do wyjścia 4-kanałowego"
-
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
-"See the alsa documentation for information on alsa devices."
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
 msgid " 5.1-channel"
 msgstr ""
 
-# src/audio_out/audio_alsa_out.c:221 src/audio_out/audio_alsa_out.c:232
-# src/audio_out/audio_alsa_out.c:941 src/audio_out/audio_alsa_out.c:948
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for 5.1-channel output"
-msgstr "urządzenie użyte do wyjścia 5.1-kanałowego"
-
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
-"sound.\n"
-"See the alsa documentation for information on alsa devices."
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
 msgid " a/52 and DTS pass-through"
 msgstr ""
 
-# src/audio_out/audio_alsa_out.c:191 src/audio_out/audio_alsa_out.c:920
-#: src/audio_out/audio_alsa_out.c
-#, fuzzy
-msgid "device used for a/52 and DTS pass-through"
-msgstr "urządzenie użyte w trybie stereo"
-
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output undecoded digital surround sound. "
-"This can be used be external surround decoders.\n"
-"See the alsa documentation for information on alsa devices."
-msgstr ""
-
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
 msgstr ""
 
 # src/audio_out/audio_alsa_out.c:862 src/audio_out/audio_alsa_out.c:1072
@@ -2727,11 +2721,6 @@
 msgid "tls input plugin"
 msgstr "wtyczka wejścia pliku"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "wtyczka wejścia pliku"
-
 # src/input/input_http.c:640
 #: src/input/input_nfs.c
 #, fuzzy
@@ -5536,16 +5525,6 @@
 msgstr ""
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr ""
 
@@ -6508,16 +6487,6 @@
 msgstr ""
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
diff -urN xine-lib-1.2.11/po/POTFILES.in xine-lib-1.2/po/POTFILES.in
--- xine-lib-1.2.11/po/POTFILES.in	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/po/POTFILES.in	2022-01-15 22:03:19.574547128 +0100
@@ -108,6 +108,7 @@
 src/input/input_hls.c
 src/input/input_http.c
 src/input/input_mms.c
+src/input/input_mpegdash.c
 src/input/input_net.c
 src/input/input_nfs.c
 src/input/input_pnm.c
Binary files xine-lib-1.2.11/po/pt_BR.gmo and xine-lib-1.2/po/pt_BR.gmo differ
diff -urN xine-lib-1.2.11/po/pt_BR.po xine-lib-1.2/po/pt_BR.po
--- xine-lib-1.2.11/po/pt_BR.po	2020-12-05 23:28:10.000000000 +0100
+++ xine-lib-1.2/po/pt_BR.po	2022-01-15 22:03:19.582547162 +0100
@@ -6,7 +6,7 @@
 msgstr ""
 "Project-Id-Version: xine-lib 0.9.13\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2002-01-22 18:31GMT-3\n"
 "Last-Translator: Marcelo Roberto Jimenez <mroberto@cetuc.puc-rio.br>\n"
 "Language-Team: Portuguese (Brazilian) <pt_BR@li.org>\n"
@@ -213,149 +213,145 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
+#, c-format
+msgid "snd_lib_error_set_handler() failed: %d"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid "sound card can do mmap"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
+msgid ""
+"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
+"You can try enabling it and check, if everything works. If it does, this "
+"will increase performance."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
+msgid "device used for mono output"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output mono sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid "device used for stereo output"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
+#: src/audio_out/audio_alsa_out.c
+msgid ""
+"xine will use this alsa device to output stereo sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgid "device used for 4-channel output"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
+msgid ""
+"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
+msgid "device used for 5.1-channel output"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
+msgid ""
+"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
+"sound.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
+msgid ""
+"xine will use this alsa device to output undecoded digital surround sound. "
+"This can be used be external surround decoders.\n"
+"See the alsa documentation for information on alsa devices."
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
+#, c-format
+msgid "snd_pcm_open() failed:%d:%s\n"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "sound card can do mmap"
+msgid "audio_alsa_out : supported modes are"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"Enable this, if your sound card and alsa driver support memory mapped IO.\n"
-"You can try enabling it and check, if everything works. If it does, this "
-"will increase performance."
+msgid " 8bit"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "device used for mono output"
+msgid " 24bit"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output mono sound.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " 32bit"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
+msgid " mono"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for stereo output"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output stereo sound.\n"
-"See the alsa documentation for information on alsa devices."
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
+msgid " (4-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "device used for 4-channel output"
+msgid " 4.1-channel"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 4 channel (4.0) surround sound.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " (4.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr ""
-
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for 5.1-channel output"
+msgid " 5-channel"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output 5 channel plus LFE (5.1) surround "
-"sound.\n"
-"See the alsa documentation for information on alsa devices."
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c
-msgid "device used for a/52 and DTS pass-through"
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid ""
-"xine will use this alsa device to output undecoded digital surround sound. "
-"This can be used be external surround decoders.\n"
-"See the alsa documentation for information on alsa devices."
+msgid " a/52 and DTS pass-through"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
@@ -2598,11 +2594,6 @@
 msgid "tls input plugin"
 msgstr "input_rip: erro de leitura no input plugin\n"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "input_rip: erro de leitura no input plugin\n"
-
 #: src/input/input_nfs.c
 msgid "Network File System (NFS) input plugin"
 msgstr ""
@@ -5293,16 +5284,6 @@
 msgstr ""
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr ""
 
@@ -6211,16 +6192,6 @@
 msgstr ""
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
Binary files xine-lib-1.2.11/po/sk.gmo and xine-lib-1.2/po/sk.gmo differ
diff -urN xine-lib-1.2.11/po/sk.po xine-lib-1.2/po/sk.po
--- xine-lib-1.2.11/po/sk.po	2020-12-05 23:28:10.000000000 +0100
+++ xine-lib-1.2/po/sk.po	2022-01-15 22:03:19.583547166 +0100
@@ -6,7 +6,7 @@
 msgstr ""
 "Project-Id-Version: xine-lib 1.0\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2004-09-15 13:53+0100\n"
 "Last-Translator: \n"
 "Language-Team: Slovak <ski18n@lists.isternet.sk>\n"
@@ -217,62 +217,9 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
-msgstr "audio_alsa_out : podporované módy sú"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
-msgstr " (4-kanály nepovolené v xine konfigu)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
-msgstr " 4.1-kanálov"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
-msgstr " (4.1-kanálov nepovolené v xine konfigu)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
-msgstr " 5-kanálov"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
-msgstr " (5-kanálov nepovolené v xine konfigu)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
-msgstr " (5.1-kanálov nepovolené v xine konfigu)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
-msgstr " (a/52 a DTS pass-through not enabled in xine config)"
-
-#: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
-msgstr "snd_pcm_open() zlyhal:%d:%s\n"
-
-#: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
-msgstr ">>> Skontrolujte či už iný program používa PCM <<<\n"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
-msgstr " 8bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
-msgstr " 16bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
-msgstr " 24bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
-msgstr " 32bit"
+msgid "snd_lib_error_set_handler() failed: %d"
+msgstr "snd_lib_error_set_handler() zlyhal: %d"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "sound card can do mmap"
@@ -285,10 +232,6 @@
 "will increase performance."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
-msgstr " mono"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for mono output"
 msgstr "zariadenie pre mono výstup"
@@ -299,10 +242,6 @@
 "See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
-msgstr " stereo"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for stereo output"
 msgstr "zariadenie pre stereo výstup"
@@ -313,10 +252,6 @@
 "See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
-msgstr " 4-kanály"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 4-channel output"
 msgstr "zariadenie pre 4-kanálový výstup"
@@ -327,10 +262,6 @@
 "See the alsa documentation for information on alsa devices."
 msgstr ""
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr " 5.1-kanálov"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 5.1-channel output"
 msgstr "zariadenie pre 5.1-kanálový výstup"
@@ -343,15 +274,6 @@
 msgstr ""
 
 #: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
-msgstr " a/52 a DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
-#, fuzzy
-msgid "device used for a/52 and DTS pass-through"
-msgstr " a/52 a DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
 msgid ""
 "xine will use this alsa device to output undecoded digital surround sound. "
 "This can be used be external surround decoders.\n"
@@ -360,8 +282,81 @@
 
 #: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
-msgstr "snd_lib_error_set_handler() zlyhal: %d"
+msgid "snd_pcm_open() failed:%d:%s\n"
+msgstr "snd_pcm_open() zlyhal:%d:%s\n"
+
+#: src/audio_out/audio_alsa_out.c
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
+msgstr ">>> Skontrolujte či už iný program používa PCM <<<\n"
+
+#: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr "audio_alsa_out : podporované módy sú"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 8bit"
+msgstr " 8bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
+msgstr " 16bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 24bit"
+msgstr " 24bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 32bit"
+msgstr " 32bit"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " mono"
+msgstr " mono"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
+msgstr " stereo"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
+msgstr " 4-kanály"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (4-channel not enabled in xine config)"
+msgstr " (4-kanály nepovolené v xine konfigu)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 4.1-channel"
+msgstr " 4.1-kanálov"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (4.1-channel not enabled in xine config)"
+msgstr " (4.1-kanálov nepovolené v xine konfigu)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5-channel"
+msgstr " 5-kanálov"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
+msgstr " (5-kanálov nepovolené v xine konfigu)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
+msgstr " 5.1-kanálov"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
+msgstr " (5.1-kanálov nepovolené v xine konfigu)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " a/52 and DTS pass-through"
+msgstr " a/52 a DTS pass-through"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgstr " (a/52 a DTS pass-through not enabled in xine config)"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "alsa mixer device"
@@ -2668,11 +2663,6 @@
 msgid "tls input plugin"
 msgstr "modul vstupu zo súboru"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "modul vstupu zo súboru"
-
 #: src/input/input_nfs.c
 #, fuzzy
 msgid "Network File System (NFS) input plugin"
@@ -5573,16 +5563,6 @@
 msgstr ""
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr ""
 
@@ -6512,16 +6492,6 @@
 msgstr ""
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
diff -urN xine-lib-1.2.11/po/stamp-po xine-lib-1.2/po/stamp-po
--- xine-lib-1.2.11/po/stamp-po	2020-12-06 14:14:10.000000000 +0100
+++ xine-lib-1.2/po/stamp-po	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-timestamp
Binary files xine-lib-1.2.11/po/tr.gmo and xine-lib-1.2/po/tr.gmo differ
diff -urN xine-lib-1.2.11/po/tr.po xine-lib-1.2/po/tr.po
--- xine-lib-1.2.11/po/tr.po	2020-12-05 23:28:10.000000000 +0100
+++ xine-lib-1.2/po/tr.po	2022-01-15 22:03:19.593547208 +0100
@@ -10,7 +10,7 @@
 msgstr ""
 "Project-Id-Version: libxine1\n"
 "Report-Msgid-Bugs-To: xine-devel@lists.sourceforge.net\n"
-"POT-Creation-Date: 2020-12-06 00:28+0200\n"
+"POT-Creation-Date: 2019-12-13 18:25+0200\n"
 "PO-Revision-Date: 2008-01-05 18:22+0200\n"
 "Last-Translator: Server Acim <sacim@kde.org.tr>\n"
 "Language-Team: Türkçe <yerellestirme@kde.org.tr>\n"
@@ -237,63 +237,9 @@
 "görsel yeniden sunumunun güncelleneceği uyarısını alacaktır."
 
 #: src/audio_out/audio_alsa_out.c
-msgid "audio_alsa_out : supported modes are"
-msgstr "audio_alsa_out : desteklenen kipler"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (4-channel not enabled in xine config)"
-msgstr " (4-kanal xine yapılandırmasında etkinleştirilmemiş)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 4.1-channel"
-msgstr " 4.1-kanal"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (4.1-channel not enabled in xine config)"
-msgstr " (4.1-kanal xine yapılandırmasında etkinleştirilmemiş)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5-channel"
-msgstr " 5-kanal"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5-channel not enabled in xine config)"
-msgstr " (5-kanal xine yapılandırmasında etkinleştirilmemiş)"
-
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " (5.1-channel not enabled in xine config)"
-msgstr " (5.1-kanal xine yapılandırmasında etkinleştirilmemiş)"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " (a/52 and DTS pass-through not enabled in xine config)"
-msgstr " (a/52 and DTS pass-through xine yapılandırmasında etkinleştirilmemiş)"
-
-#: src/audio_out/audio_alsa_out.c
-#, c-format
-msgid "snd_pcm_open() failed:%d:%s\n"
-msgstr "snd_pcm_open() başarısız oldu:%d:%s\n"
-
-#: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid ">>> Check if another program already uses PCM <<<\n"
-msgstr ""
-">>>Başka bir uygulamanın PCM'yi kullanıp kullanmadığını kontrol edin<<<\n"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 8bit"
-msgstr " 8bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 16bit"
-msgstr " 16bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 24bit"
-msgstr " 24bit"
-
-#: src/audio_out/audio_alsa_out.c
-msgid " 32bit"
-msgstr " 32bit"
+msgid "snd_lib_error_set_handler() failed: %d"
+msgstr "snd_lib_error_set_handler() başarısız oldu: %d"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "sound card can do mmap"
@@ -310,10 +256,6 @@
 "etkinleştirmeyi ve kontrol etmeyi deneyebilirsiniz. Eğer çalışırsa, bu "
 "başarını arttıracaktır."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " mono"
-msgstr " mono"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for mono output"
 msgstr "mono çıktı için kullanılan aygıt"
@@ -326,10 +268,6 @@
 "xine mono ses çıkışı için bu alsa aygıtını kullanacaktır.\n"
 "Alsa aygıtları hakkında daha fazla bilgi için alsa belgesine bakınız."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " stereo"
-msgstr " stereo"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for stereo output"
 msgstr "stereo çıktı için kullanılan aygıt"
@@ -342,10 +280,6 @@
 "xine stereo ses çıkışı için bu alsa aygıtını kullanacaktır.\n"
 "Alsa aygıtları hakkında daha fazla bilgi için alsa belgesine bakınız."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 4-channel"
-msgstr " 4-kanal"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 4-channel output"
 msgstr "4-kanal çıktı için kullanılan aygıt"
@@ -359,10 +293,6 @@
 "kullanacaktır.\n"
 "Alsa aygıtları hakkında daha fazla bilgi için alsa belgesine bakınız."
 
-#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
-msgid " 5.1-channel"
-msgstr " 5.1-kanal"
-
 #: src/audio_out/audio_alsa_out.c
 msgid "device used for 5.1-channel output"
 msgstr "5.1-kanal çıktı için kullanılan aygıt"
@@ -378,15 +308,6 @@
 "Alsa aygıtları hakkında daha fazla bilgi için alsa belgesine bakınız."
 
 #: src/audio_out/audio_alsa_out.c
-msgid " a/52 and DTS pass-through"
-msgstr " a/52 and DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
-#, fuzzy
-msgid "device used for a/52 and DTS pass-through"
-msgstr " a/52 and DTS pass-through"
-
-#: src/audio_out/audio_alsa_out.c
 msgid ""
 "xine will use this alsa device to output undecoded digital surround sound. "
 "This can be used be external surround decoders.\n"
@@ -398,8 +319,82 @@
 
 #: src/audio_out/audio_alsa_out.c
 #, c-format
-msgid "snd_lib_error_set_handler() failed: %d"
-msgstr "snd_lib_error_set_handler() başarısız oldu: %d"
+msgid "snd_pcm_open() failed:%d:%s\n"
+msgstr "snd_pcm_open() başarısız oldu:%d:%s\n"
+
+#: src/audio_out/audio_alsa_out.c
+#, c-format
+msgid ">>> Check if another program already uses PCM <<<\n"
+msgstr ""
+">>>Başka bir uygulamanın PCM'yi kullanıp kullanmadığını kontrol edin<<<\n"
+
+#: src/audio_out/audio_alsa_out.c
+msgid "audio_alsa_out : supported modes are"
+msgstr "audio_alsa_out : desteklenen kipler"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 8bit"
+msgstr " 8bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 16bit"
+msgstr " 16bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 24bit"
+msgstr " 24bit"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 32bit"
+msgstr " 32bit"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " mono"
+msgstr " mono"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " stereo"
+msgstr " stereo"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 4-channel"
+msgstr " 4-kanal"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (4-channel not enabled in xine config)"
+msgstr " (4-kanal xine yapılandırmasında etkinleştirilmemiş)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " 4.1-channel"
+msgstr " 4.1-kanal"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (4.1-channel not enabled in xine config)"
+msgstr " (4.1-kanal xine yapılandırmasında etkinleştirilmemiş)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5-channel"
+msgstr " 5-kanal"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5-channel not enabled in xine config)"
+msgstr " (5-kanal xine yapılandırmasında etkinleştirilmemiş)"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " 5.1-channel"
+msgstr " 5.1-kanal"
+
+#: src/audio_out/audio_alsa_out.c src/audio_out/audio_oss_out.c
+msgid " (5.1-channel not enabled in xine config)"
+msgstr " (5.1-kanal xine yapılandırmasında etkinleştirilmemiş)"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " a/52 and DTS pass-through"
+msgstr " a/52 and DTS pass-through"
+
+#: src/audio_out/audio_alsa_out.c
+msgid " (a/52 and DTS pass-through not enabled in xine config)"
+msgstr " (a/52 and DTS pass-through xine yapılandırmasında etkinleştirilmemiş)"
 
 #: src/audio_out/audio_alsa_out.c
 msgid "alsa mixer device"
@@ -2981,11 +2976,6 @@
 msgid "tls input plugin"
 msgstr "dosya girdi eklentisi"
 
-#: src/input/input_net.c
-#, fuzzy
-msgid "gopher input plugin"
-msgstr "dosya girdi eklentisi"
-
 #: src/input/input_nfs.c
 #, fuzzy
 msgid "Network File System (NFS) input plugin"
@@ -6154,16 +6144,6 @@
 "sayısal ürünlerde işe yaramaz."
 
 #: src/xine-engine/audio_out.c
-msgid "a/v sync precision"
-msgstr ""
-
-#: src/xine-engine/audio_out.c
-msgid ""
-"Normal: keep current drift within driver gap tolerance.\n"
-"Fine:   keep average drift within 1/8 tolerance."
-msgstr ""
-
-#: src/xine-engine/audio_out.c
 msgid "enable resampling"
 msgstr "yeniden örneklemeyi etkinleştir "
 
@@ -7186,16 +7166,6 @@
 "donmasına neden olabilir."
 
 #: src/xine-engine/xine.c
-msgid "Internet Protocol version(s) to use"
-msgstr ""
-
-#: src/xine-engine/xine.c
-msgid ""
-"\"auto\" just tries what the name query returned.\n"
-"Otherwise, IPv4 may offer more compatibility and privacy."
-msgstr ""
-
-#: src/xine-engine/xine.c
 msgid "Auto join separate audio/video files"
 msgstr ""
 
diff -urN xine-lib-1.2.11/README-VDPAU xine-lib-1.2/README-VDPAU
--- xine-lib-1.2.11/README-VDPAU	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/README-VDPAU	2022-01-15 22:03:19.551547031 +0100
@@ -0,0 +1,40 @@
+FAQ:
+
+Q:
+  Why my file plays fine with mplayer-vdpau and not with xine-vdpau?
+A:
+  We are not using the nvidia's libavcodec patch.
+  We are writing decoders from scratch.
+  So don't expect them to be as mature as ffmpeg ones. Not yet.
+
+Q:
+  Why mpeg2 doesn't use less cpu than software decoder?
+A:
+  Because at that moment it does a lot of memcpy. This will be fixed soon, but that's not
+  a priority. Stability is our focus.
+
+Q:
+  Is deinterlacing working?
+A:
+  Yes. It's already quite good (doing 50i->50p), but could even be better in the future.
+
+Q:
+  How do i get it working with VDR, Kaffeine, whatever.
+A:
+  Ask VDR, Kaffeine, whatever developers.
+    (Note: for kaffeine you are lucky, i'm going to tell you the tip.
+     Build kaffeine like that: ./configure --without-xcb && make && make install)
+
+Q:
+  How can i contact you?
+A:
+  IRC: #xine-vdpau on freenode
+  MAIL: http://lists.kafic.ba/mailman/listinfo/xine-vdpau
+  Eventually, nvnews.
+
+Q:
+  What information do I need if there's a problem?
+A:
+  Run 'xine --verbose /path/to/a/working/sample' (or equivalent for your
+  chosen front end). You will probably be asked for this anyway, so it
+  helps to have it handy.
diff -urN xine-lib-1.2.11/src/audio_dec/xine_a52_decoder.c xine-lib-1.2/src/audio_dec/xine_a52_decoder.c
--- xine-lib-1.2.11/src/audio_dec/xine_a52_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/audio_dec/xine_a52_decoder.c	2022-01-15 22:03:19.589547192 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/src/audio_dec/xine_a52_spdif.c xine-lib-1.2/src/audio_dec/xine_a52_spdif.c
--- xine-lib-1.2.11/src/audio_dec/xine_a52_spdif.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/audio_dec/xine_a52_spdif.c	2022-01-15 22:03:19.574547128 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/src/audio_dec/xine_dts_decoder.c xine-lib-1.2/src/audio_dec/xine_dts_decoder.c
--- xine-lib-1.2.11/src/audio_dec/xine_dts_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/audio_dec/xine_dts_decoder.c	2022-01-15 22:03:19.576547137 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a unix video player.
  *
@@ -72,7 +72,7 @@
   int              sync_state;
   int              ac5_length, ac5_pcm_length, frame_todo;
   uint32_t         syncdword;
-  uint8_t          frame_buffer[MAX_AC5_FRAME];
+  uint8_t          frame_buffer[MAX_AC5_FRAME + 1];
   uint8_t         *frame_ptr;
 
   int              output_open;
@@ -474,6 +474,8 @@
   lprintf("open_plugin\n");
 
   this = calloc(1, sizeof (dts_decoder_t));
+  if (!this)
+    return NULL;
 
   this->audio_decoder.decode_data         = dts_decode_data;
   this->audio_decoder.reset               = dts_reset;
diff -urN xine-lib-1.2.11/src/audio_out/audio_alsa_out.c xine-lib-1.2/src/audio_out/audio_alsa_out.c
--- xine-lib-1.2.11/src/audio_out/audio_alsa_out.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/audio_out/audio_alsa_out.c	2022-01-15 22:03:19.588547187 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -427,7 +427,7 @@
         if (err >= 0)
           break;
         xprintf (this->class->xine, XINE_VERBOSITY_DEBUG,
-          "audio_alsa_out: mmap not available, falling back to compatiblity mode\n");
+          "audio_alsa_out: mmap not available, falling back to compatibility mode\n");
         this->mmap = 0;
       }
       err = snd_pcm_hw_params_set_access (this->audio_fd, this->hw_params, SND_PCM_ACCESS_RW_INTERLEAVED);
diff -urN xine-lib-1.2.11/src/audio_out/audio_jack_out.c xine-lib-1.2/src/audio_out/audio_jack_out.c
--- xine-lib-1.2.11/src/audio_out/audio_jack_out.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/audio_out/audio_jack_out.c	2022-01-15 22:03:19.577547141 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -735,6 +735,8 @@
   }
 
   this = calloc(1, sizeof (jack_driver_t));
+  if (!this)
+    goto err_out;
 
   rate = jack_get_sample_rate (client);
   xprintf (class->xine, XINE_VERBOSITY_DEBUG,
diff -urN xine-lib-1.2.11/src/audio_out/audio_opensles_out.c xine-lib-1.2/src/audio_out/audio_opensles_out.c
--- xine-lib-1.2.11/src/audio_out/audio_opensles_out.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/audio_out/audio_opensles_out.c	2022-01-15 22:03:19.568547103 +0100
@@ -0,0 +1,576 @@
+/*
+ * Copyright (C) 2000-2021 the xine project
+ * Copyright (C) 2021 Petri Hintukainen <phintuka@users.sourceforge.net>
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Audio output plugin for OpenSL ES
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <math.h>
+
+#define LOG_MODULE "audio_opensles_out"
+
+#include <xine/xine_internal.h>
+#include <xine/xineutils.h>
+#include <xine/audio_out.h>
+
+#include <SLES/OpenSLES.h>
+#ifdef HAVE_SLES_OPENSLES_ANDROID_H
+#  include <SLES/OpenSLES_Android.h>
+#endif
+
+#define AO_OUT_OPENSLES_IFACE_VERSION 9
+#define OPENSLES_BUFFERS              250 /* max buffers, 10 ms each -> 2.5 seconds */
+
+
+typedef struct opensles_driver_s {
+
+  ao_driver_t    ao_driver;
+
+  xine_t        *xine;
+
+  int32_t        sample_rate;
+  uint32_t       num_channels;
+  uint32_t       bits_per_sample;
+  uint32_t       bytes_per_frame;
+
+  /* libOpenSLES.so */
+  void          *hlib;
+
+  SLInterfaceID  SL_IID_myBUFFERQUEUE;
+  SLInterfaceID  SL_IID_VOLUME;
+  SLInterfaceID  SL_IID_PLAY;
+
+  /* OpenSL ES objects */
+  SLObjectItf    engine_object;
+  SLObjectItf    output_mix_object;
+  SLObjectItf    player_object;
+
+  /* OpenSL ES interfaces */
+  SLEngineItf    engine_if;
+  SLPlayItf      player_if;
+  SLVolumeItf    volume_if;
+#ifdef HAVE_SLES_OPENSLES_ANDROID_H
+  SLAndroidSimpleBufferQueueItf buffer_if;
+#else
+  SLBufferQueueItf              buffer_if;
+#endif
+
+  /* queue */
+  uint8_t *buf;            /* playback buffer */
+  size_t   buf_elem_size;  /* size of single buffer chunk (10 ms) */
+  size_t   next_buf;       /* next free buffer */
+  size_t   buf_size;       /* bytes filled in next_buf (partial buffer) */
+} opensles_driver_t;
+
+typedef struct {
+  audio_driver_class_t  driver_class;
+  xine_t               *xine;
+} opensles_class_t;
+
+
+#define CHECK_OPENSL_RESULT(errmsg, erraction)                  \
+  do {                                                          \
+    if (result != SL_RESULT_SUCCESS) {                          \
+      xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": "  \
+               errmsg ": %" PRIu32 "\n", result);               \
+      erraction ;                                               \
+    }                                                           \
+  } while (0)
+
+static int _opensles_open(ao_driver_t *this_gen, uint32_t bits, uint32_t rate, int mode)
+{
+  opensles_driver_t *this = (opensles_driver_t *) this_gen;
+  SLresult result;
+
+  xprintf (this->xine, XINE_VERBOSITY_DEBUG, LOG_MODULE ": "
+           "ao_open bits=%d rate=%d, mode=%d\n", bits, rate, mode);
+
+  this->sample_rate            = rate;
+  this->bits_per_sample        = bits;
+
+  switch (mode) {
+    case AO_CAP_MODE_MONO:
+      this->num_channels = 1;
+      break;
+    case AO_CAP_MODE_STEREO:
+      this->num_channels = 2;
+      break;
+    default:
+      xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": "
+               "unsupported mode 0x%X\n", mode);
+      return 0;
+  }
+  if (bits != 16) {
+      xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": "
+               "unsupported bits per sample %d\n", bits);
+      return 0;
+  }
+
+  this->bytes_per_frame = (bits * this->num_channels) / 8;
+
+  /* create audio player */
+
+  {
+#ifdef HAVE_SLES_OPENSLES_ANDROID_H
+    SLDataLocator_AndroidSimpleBufferQueue loc_bufqueue = {
+      SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, OPENSLES_BUFFERS
+    };
+#else
+    SLDataLocator_BufferQueue loc_bufqueue = {
+      SL_DATALOCATOR_BUFFERQUEUE, OPENSLES_BUFFERS
+    };
+#endif
+    SLDataFormat_PCM format = {
+      .formatType       = SL_DATAFORMAT_PCM,
+      .numChannels      = this->num_channels,
+      .samplesPerSec    = rate * 1000,
+      .bitsPerSample    = SL_PCMSAMPLEFORMAT_FIXED_16,
+      .containerSize    = SL_PCMSAMPLEFORMAT_FIXED_16,
+      .channelMask      = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT,
+      .endianness       = SL_BYTEORDER_LITTLEENDIAN,
+    };
+    SLDataSource audio_src = { &loc_bufqueue, &format };
+
+    SLDataLocator_OutputMix loc_outputmix = {
+        SL_DATALOCATOR_OUTPUTMIX, this->output_mix_object
+    };
+    SLDataSink audio_sink = { &loc_outputmix, NULL};
+
+    SLInterfaceID if_ids[] = { this->SL_IID_myBUFFERQUEUE, this->SL_IID_VOLUME };
+    SLboolean     if_req[] = { SL_BOOLEAN_TRUE,            SL_BOOLEAN_TRUE };
+
+    result = (*(this->engine_if))->CreateAudioPlayer(this->engine_if, &this->player_object, &audio_src,
+                                                     &audio_sink, sizeof(if_ids) / sizeof(if_ids[0]),
+                                                     if_ids, if_req);
+    CHECK_OPENSL_RESULT("error creating player", return 0);
+  }
+
+  result = (*(this->player_object))->Realize(this->player_object, SL_BOOLEAN_FALSE);
+  CHECK_OPENSL_RESULT("error realizing player", goto fail);
+
+  result = (*(this->player_object))->GetInterface(this->player_object, this->SL_IID_PLAY, &this->player_if);
+  CHECK_OPENSL_RESULT("error getting player interface", goto fail);
+
+  result = (*(this->player_object))->GetInterface(this->player_object, this->SL_IID_VOLUME, &this->volume_if);
+  CHECK_OPENSL_RESULT("error getting volume interface", goto fail);
+
+  result = (*(this->player_object))->GetInterface(this->player_object, this->SL_IID_myBUFFERQUEUE, &this->buffer_if);
+  CHECK_OPENSL_RESULT("error getting buffer interface", goto fail);
+
+  result = (*(this->player_if))->SetPlayState(this->player_if, SL_PLAYSTATE_PLAYING);
+  CHECK_OPENSL_RESULT("error setting playing state", goto fail);
+
+  /* initialize buffer */
+
+  this->buf_elem_size = this->bytes_per_frame * this->sample_rate / 100;
+  this->buf_size = 0;
+  this->next_buf = 0;
+
+  free(this->buf);
+  this->buf = malloc(this->buf_elem_size * OPENSLES_BUFFERS);
+  if (!this->buf)
+    goto fail;
+
+  return this->sample_rate;
+
+fail:
+  this_gen->close(this_gen);
+  return 0;
+}
+
+
+static int _opensles_num_channels(ao_driver_t *this_gen)
+{
+  opensles_driver_t *this = (opensles_driver_t *)this_gen;
+  return this->num_channels;
+}
+
+static int _opensles_bytes_per_frame(ao_driver_t *this_gen)
+{
+  opensles_driver_t *this = (opensles_driver_t *)this_gen;
+  return this->bytes_per_frame;
+}
+
+static int _opensles_get_gap_tolerance (ao_driver_t *this_gen)
+{
+  (void)this_gen;
+  return AO_MAX_GAP;
+}
+
+static int _opensles_write(ao_driver_t *this_gen, int16_t *data, uint32_t num_frames)
+{
+  opensles_driver_t *this = (opensles_driver_t *)this_gen;
+  SLresult result;
+  size_t   need_bufs = (num_frames * this->bytes_per_frame + this->buf_elem_size - 1) / this->buf_elem_size;
+
+  /* wait until we have enough free buffers */
+
+  while (1) {
+#ifdef HAVE_SLES_OPENSLES_ANDROID_H
+    SLAndroidSimpleBufferQueueState st;
+#else
+    SLBufferQueueState              st;
+#endif
+
+    result = (*(this->buffer_if))->GetState(this->buffer_if, &st);
+    CHECK_OPENSL_RESULT("error querying buffer state", return -1);
+
+    if (st.count < OPENSLES_BUFFERS - 1 - need_bufs)
+      break;
+
+    xine_usec_sleep(10000);
+  }
+
+  /* copy to buffers and queue (full) buffers */
+
+  while (num_frames > 0) {
+    uint8_t *buf  = this->buf + this->next_buf * this->buf_elem_size;
+    size_t   room = this->buf_elem_size - this->buf_size;
+    if (room > num_frames * this->bytes_per_frame) {
+      /* partial buffer, save data and return */
+      memcpy(buf + this->buf_size, data, num_frames * this->bytes_per_frame);
+      this->buf_size += num_frames * this->bytes_per_frame;
+      return 1;
+    }
+
+    memcpy(buf + this->buf_size, data, room);
+
+    result = (*(this->buffer_if))->Enqueue(this->buffer_if, buf, this->buf_elem_size);
+    CHECK_OPENSL_RESULT("enque failed", (void)result );
+
+    data += room * sizeof(uint16_t) / this->bytes_per_frame;
+    num_frames -= room / this->bytes_per_frame;
+    this->buf_size = 0;
+    if (++this->next_buf >= OPENSLES_BUFFERS)
+      this->next_buf = 0;
+  }
+
+  return 1;
+}
+
+static int _opensles_delay (ao_driver_t *this_gen)
+{
+  opensles_driver_t *this = (opensles_driver_t *)this_gen;
+#ifdef HAVE_SLES_OPENSLES_ANDROID_H
+  SLAndroidSimpleBufferQueueState st;
+#else
+  SLBufferQueueState              st;
+#endif
+  SLresult result;
+
+  if (!this->buffer_if)
+    return -1;
+
+  result = (*(this->buffer_if))->GetState(this->buffer_if, &st);
+  CHECK_OPENSL_RESULT("error querying buffer state", return -1);
+
+  lprintf("latency %u frames\n", st.count * this->buf_elem_size / this->bytes_per_frame);
+
+  return st.count * this->buf_elem_size / this->bytes_per_frame;
+}
+
+static void _opensles_close(ao_driver_t *this_gen)
+{
+  opensles_driver_t *this = (opensles_driver_t *)this_gen;
+
+  if (this->player_if) {
+    (*(this->player_if))->SetPlayState(this->player_if, SL_PLAYSTATE_STOPPED);
+  }
+  if (this->buffer_if) {
+    (*(this->buffer_if))->Clear(this->buffer_if);
+  }
+  if (this->player_object) {
+    (*(this->player_object))->Destroy(this->player_object);
+  }
+
+  this->player_object = NULL;
+  this->buffer_if = NULL;
+  this->volume_if = NULL;
+  this->player_if = NULL;
+
+  _x_freep(&this->buf);
+}
+
+static uint32_t _opensles_get_capabilities (ao_driver_t *this_gen)
+{
+  (void)this_gen;
+  return AO_CAP_MODE_MONO | AO_CAP_MODE_STEREO | AO_CAP_16BITS | AO_CAP_MIXER_VOL | AO_CAP_MUTE_VOL;
+}
+
+static void _opensles_exit(ao_driver_t *this_gen)
+{
+  opensles_driver_t *this = (opensles_driver_t *)this_gen;
+
+  _opensles_close(this_gen);
+
+  if (this->output_mix_object)
+    (*(this->output_mix_object))->Destroy(this->output_mix_object);
+  if (this->engine_object)
+    (*(this->engine_object))->Destroy(this->engine_object);
+
+  if (this->hlib) {
+    dlclose(this->hlib);
+    this->hlib = NULL;
+  }
+
+  free (this);
+}
+
+static int _opensles_get_property (ao_driver_t *this_gen, int property)
+{
+  opensles_driver_t *this = (opensles_driver_t *)this_gen;
+  SLresult   result;
+  SLboolean  b;
+  SLmillibel millibels;
+
+  if (!this->volume_if)
+    return -1;
+
+  switch (property) {
+    case AO_PROP_PCM_VOL:
+    case AO_PROP_MIXER_VOL:
+      result = (*(this->volume_if))->GetVolumeLevel(this->volume_if, &millibels);
+      CHECK_OPENSL_RESULT("error getting volume level", return -1);
+      return  lroundf(100.0 * expf(millibels * logf(10.0) / 2000.0));
+    break;
+
+    case AO_PROP_MUTE_VOL:
+      result = (*(this->volume_if))->GetMute(this->volume_if, &b);
+      CHECK_OPENSL_RESULT("error getting mute state", return -1);
+      return !!b;
+  }
+
+  return 0;
+}
+
+static int _opensles_set_property (ao_driver_t *this_gen, int property, int value)
+{
+  opensles_driver_t *this = (opensles_driver_t *)this_gen;
+  SLresult   result;
+  SLmillibel millibels;
+
+  if (!this->volume_if)
+    return -1;
+
+  switch (property) {
+    case AO_PROP_PCM_VOL:
+    case AO_PROP_MIXER_VOL:
+
+      millibels = lroundf(2000.0 * log10f( (value < 0 ? 0 : value) / 100.0));
+      if (millibels < SL_MILLIBEL_MIN)
+        millibels = SL_MILLIBEL_MIN;
+      else if (millibels > 0)
+        millibels = 0;
+
+      result = (*(this->volume_if))->SetVolumeLevel(this->volume_if, millibels);
+      CHECK_OPENSL_RESULT("error setting volume level", return -1);
+      return value;
+
+    case AO_PROP_MUTE_VOL:
+      result = (*(this->volume_if))->SetMute(this->volume_if, !!value);
+      CHECK_OPENSL_RESULT("error setting mute state", return -1);
+      return value;
+  }
+
+  return -1;
+}
+
+static int _opensles_ctrl(ao_driver_t *this_gen, int cmd, ...)
+{
+  opensles_driver_t *this = (opensles_driver_t *)this_gen;
+  SLresult result;
+
+  switch (cmd) {
+
+    case AO_CTRL_PLAY_PAUSE:
+      if (this->player_if) {
+        result = (*(this->player_if))->SetPlayState(this->player_if, SL_PLAYSTATE_PAUSED);
+        CHECK_OPENSL_RESULT("failed pausing playback", return -1);
+      }
+      break;
+
+    case AO_CTRL_PLAY_RESUME:
+      if (this->player_if) {
+        result = (*(this->player_if))->SetPlayState(this->player_if, SL_PLAYSTATE_PLAYING);
+        CHECK_OPENSL_RESULT("failed resuming playback", return -1);
+      }
+      break;
+
+    case AO_CTRL_FLUSH_BUFFERS:
+      if (this->player_if) {
+        (*(this->player_if))->SetPlayState(this->player_if, SL_PLAYSTATE_STOPPED);
+        (*(this->buffer_if))->Clear(this->buffer_if);
+        (*(this->player_if))->SetPlayState(this->player_if, SL_PLAYSTATE_PLAYING);
+      }
+      this->buf_size = 0;
+      this->next_buf = 0;
+      break;
+  }
+
+  return 0;
+}
+
+static int _dlsym_iid(opensles_driver_t *this, const char *name, SLInterfaceID *iid)
+{
+  SLInterfaceID *p = dlsym(this->hlib, name);
+  if (!p) {
+    xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": "
+             "dlsym(\'%s\') failed: %s\n", name, dlerror());
+    return -1;
+  }
+  *iid = *p;
+  return 0;
+}
+
+static ao_driver_t *_opensles_open_plugin (audio_driver_class_t *class_gen, const void *data)
+{
+  opensles_class_t  *class = (opensles_class_t *)class_gen;
+  opensles_driver_t *this;
+
+  SLresult           result;
+  SLInterfaceID      SL_IID_ENGINE;
+  SLresult         (*slCreateEngine)(SLObjectItf*, SLuint32, const SLEngineOption*, SLuint32,
+                                     const SLInterfaceID*, const SLboolean*);
+
+  lprintf ("open_plugin called\n");
+
+  (void)data;
+  this = calloc(1, sizeof (opensles_driver_t));
+  if (!this)
+    return NULL;
+
+  this->xine = class->xine;
+
+  /* Load OpenSL ES */
+
+  this->hlib = dlopen("libOpenSLES.so", RTLD_NOW);
+  if (!this) {
+    xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": "
+             "error opening libOpenSLES.so: %s\n", dlerror());
+    goto fail;
+  }
+
+  slCreateEngine = dlsym(this->hlib, "slCreateEngine");
+  if (!slCreateEngine) {
+    xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": "
+             "dlsym(\'slCreateEngine\') failed: %s\n", dlerror());
+    goto fail;
+  }
+
+  if (_dlsym_iid(this, "SL_IID_ENGINE", &SL_IID_ENGINE) < 0)
+    goto fail;
+  if (_dlsym_iid(this, "SL_IID_PLAY", &this->SL_IID_PLAY) < 0)
+    goto fail;
+  if (_dlsym_iid(this, "SL_IID_VOLUME", &this->SL_IID_VOLUME) < 0)
+    goto fail;
+#ifdef HAVE_SLES_OPENSLES_ANDROID_H
+  if (_dlsym_iid(this, "SL_IID_ANDROIDSIMPLEBUFFERQUEUE", &this->SL_IID_myBUFFERQUEUE) < 0)
+    goto fail;
+#else
+  if (_dlsym_iid(this, "SL_IID_BUFFERQUEUE", &this->SL_IID_myBUFFERQUEUE) < 0)
+    goto fail;
+#endif
+
+  /* create engine */
+
+  result = slCreateEngine(&this->engine_object, 0, NULL, 0, NULL, NULL);
+  CHECK_OPENSL_RESULT("error creating engine", goto fail);
+
+  result = (*(this->engine_object))->Realize(this->engine_object, SL_BOOLEAN_FALSE);
+  CHECK_OPENSL_RESULT("error realizing engine", goto fail);
+
+  result = (*(this->engine_object))->GetInterface(this->engine_object, SL_IID_ENGINE, &this->engine_if);
+  CHECK_OPENSL_RESULT("error getting engine interface", goto fail);
+
+  /* init output mix */
+
+  {
+    const SLInterfaceID ids1[] = { this->SL_IID_VOLUME };
+    const SLboolean req1[] = { SL_BOOLEAN_FALSE };
+
+    result = (*(this->engine_if))->CreateOutputMix(this->engine_if, &this->output_mix_object, 1, ids1, req1);
+    CHECK_OPENSL_RESULT("error creating output mix", goto fail);
+  }
+
+  result = (*(this->output_mix_object))->Realize(this->output_mix_object, SL_BOOLEAN_FALSE);
+  CHECK_OPENSL_RESULT("error realizing output mix", goto fail);
+
+  this->ao_driver.get_capabilities    = _opensles_get_capabilities;
+  this->ao_driver.get_property        = _opensles_get_property;
+  this->ao_driver.set_property        = _opensles_set_property;
+  this->ao_driver.open                = _opensles_open;
+  this->ao_driver.num_channels        = _opensles_num_channels;
+  this->ao_driver.bytes_per_frame     = _opensles_bytes_per_frame;
+  this->ao_driver.delay               = _opensles_delay;
+  this->ao_driver.write               = _opensles_write;
+  this->ao_driver.close               = _opensles_close;
+  this->ao_driver.exit                = _opensles_exit;
+  this->ao_driver.get_gap_tolerance   = _opensles_get_gap_tolerance;
+  this->ao_driver.control             = _opensles_ctrl;
+
+  return &this->ao_driver;
+
+fail:
+  _opensles_exit(&this->ao_driver);
+  return NULL;
+}
+
+static void *_opensles_init_class (xine_t *xine, const void *data)
+{
+  opensles_class_t *this;
+
+  (void)data;
+  this = calloc(1, sizeof (opensles_class_t));
+  if (!this)
+    return NULL;
+
+  this->xine = xine;
+
+  this->driver_class.open_plugin     = _opensles_open_plugin;
+  this->driver_class.identifier      = "opensles";
+#ifdef HAVE_SLES_OPENSLES_ANDROID_H
+  this->driver_class.description     = N_("OpenSL ES audio output plugin (Android)");
+#else
+  this->driver_class.description     = N_("OpenSL ES audio output plugin");
+#endif
+  this->driver_class.dispose         = default_audio_driver_class_dispose;
+
+  return this;
+}
+
+/*
+ * exported plugin catalog entry
+ */
+
+static const ao_info_t ao_info_opensles = {
+  .priority = 5,
+};
+
+const plugin_info_t xine_plugin_info[] EXPORTED = {
+  /* type, API, "name", version, special_info, init_function */
+  { PLUGIN_AUDIO_OUT, AO_OUT_OPENSLES_IFACE_VERSION, "opensles", XINE_VERSION_CODE, &ao_info_opensles, _opensles_init_class },
+  { PLUGIN_NONE, 0, NULL, 0, NULL, NULL }
+};
diff -urN xine-lib-1.2.11/src/audio_out/audio_oss_out.c xine-lib-1.2/src/audio_out/audio_oss_out.c
--- xine-lib-1.2.11/src/audio_out/audio_oss_out.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/audio_out/audio_oss_out.c	2022-01-15 22:03:19.588547187 +0100
@@ -51,12 +51,6 @@
 #ifdef HAVE_SYS_SOUNDCARD_H
 # include <sys/soundcard.h>
 #endif
-#ifdef HAVE_MACHINE_SOUNDCARD_H
-# include <sys/soundcard.h>
-#endif
-#ifdef HAVE_SOUNDCARD_H
-# include <soundcard.h>
-#endif
 
 #define LOG_MODULE "audio_oss_out"
 #define LOG_VERBOSE
diff -urN xine-lib-1.2.11/src/audio_out/Makefile.am xine-lib-1.2/src/audio_out/Makefile.am
--- xine-lib-1.2.11/src/audio_out/Makefile.am	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/audio_out/Makefile.am	2022-01-15 22:03:19.577547141 +0100
@@ -64,6 +64,10 @@
 sndio_module = xineplug_ao_out_sndio.la
 endif
 
+if ENABLE_OPENSLES
+opensles_module = xineplug_ao_out_opensles.la
+endif
+
 xineplug_LTLIBRARIES =		\
 	$(ao_builtins)		\
 	$(oss_module)		\
@@ -76,6 +80,7 @@
 	$(directx2_module)	\
 	$(fusionsound_module)	\
 	$(jack_module)		\
+	$(opensles_module)	\
 	$(sndio_module)
 
 xineplug_ao_out_none_la_SOURCES = audio_none_out.c
@@ -130,3 +135,7 @@
 xineplug_ao_out_sndio_la_SOURCES = audio_sndio_out.c
 xineplug_ao_out_sndio_la_LIBADD = $(XINE_LIB) $(SNDIO_LIBS)
 xineplug_ao_out_sndio_la_CFLAGS = $(AM_CFLAGS) $(SNDIO_CFLAGS)
+
+xineplug_ao_out_opensles_la_SOURCES = audio_opensles_out.c
+xineplug_ao_out_opensles_la_LIBADD = $(XINE_LIB) $(DYNAMIC_LD_LIBS) -lm
+xineplug_ao_out_opensles_la_CFLAGS = $(AM_CFLAGS) $(OPENSLES_CFLAGS)
diff -urN xine-lib-1.2.11/src/combined/ffmpeg/demux_avformat.c xine-lib-1.2/src/combined/ffmpeg/demux_avformat.c
--- xine-lib-1.2.11/src/combined/ffmpeg/demux_avformat.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/combined/ffmpeg/demux_avformat.c	2022-01-15 22:03:19.571547116 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2020 the xine project
+ * Copyright (C) 2013-2021 the xine project
  * Copyright (C) 2013-2020 Petri Hintukainen <phintuka@users.sourceforge.net>
  *
  * This file is part of xine, a free video player.
@@ -27,6 +27,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <pthread.h>
+#include <errno.h>
 
 #include <libavformat/avformat.h>
 #include <libavformat/avio.h>
@@ -381,6 +382,9 @@
   this->num_streams = this->fmt_ctx->nb_streams;
   this->xine_buf_type = calloc(this->num_streams, sizeof(uint32_t));
   this->audio_stream_idx = calloc(this->num_streams, sizeof(int));
+  if (!this->xine_buf_type || !this->audio_stream_idx) {
+    return 0;
+  }
 
   /* map video stream to xine buffer type */
 
@@ -543,28 +547,28 @@
 {
   int64_t  stream_pos    = avio_tell(this->fmt_ctx->pb);
   int64_t  stream_length = avio_size(this->fmt_ctx->pb);
-  AVPacket pkt;
+  XFF_PACKET_DECL (pkt);
   uint32_t buffer_type = 0;
   fifo_buffer_t *fifo = NULL;
 
-  av_init_packet(&pkt);
-  pkt.data = NULL;
-  pkt.size = 0;
+  XFF_PACKET_NEW (pkt);
+  pkt->data = NULL;
+  pkt->size = 0;
 
   /* read frame from the file */
-  if (av_read_frame(this->fmt_ctx, &pkt) < 0) {
+  if (av_read_frame(this->fmt_ctx, pkt) < 0) {
     xprintf (this->stream->xine, XINE_VERBOSITY_LOG, LOG_MODULE": av_read_frame() failed\n");
     return -1;
   }
 
   /* map to xine fifo / buffer type */
-  if (pkt.stream_index >= 0 && (unsigned)pkt.stream_index < this->num_streams) {
-    buffer_type = this->xine_buf_type[pkt.stream_index];
+  if (pkt->stream_index >= 0 && (unsigned)pkt->stream_index < this->num_streams) {
+    buffer_type = this->xine_buf_type [pkt->stream_index];
   } else {
     // TODO: new streams found
   }
 
-  if (this->video_stream_idx >= 0 && pkt.stream_index == this->video_stream_idx) {
+  if (this->video_stream_idx >= 0 && pkt->stream_index == this->video_stream_idx) {
     fifo = this->stream->video_fifo;
   } else {
     fifo = this->stream->audio_fifo;
@@ -577,17 +581,17 @@
     int      total_time    = (int)((int64_t)this->fmt_ctx->duration * 1000 / AV_TIME_BASE);
     int      input_time    = input_normpos * total_time / 65535;
 
-    if (pkt.pts != AV_NOPTS_VALUE) {
-      AVStream *stream = this->fmt_ctx->streams[pkt.stream_index];
-      pts = (int64_t)(pkt.pts * stream->time_base.num * 90000 / stream->time_base.den);
+    if (pkt->pts != AV_NOPTS_VALUE) {
+      AVStream *stream = this->fmt_ctx->streams [pkt->stream_index];
+      pts = (int64_t)(pkt->pts * stream->time_base.num * 90000 / stream->time_base.den);
       check_newpts(this, pts);
     }
 
-    _x_demux_send_data(fifo, pkt.data, pkt.size, pts, buffer_type, 0/*decoder_flags*/,
+    _x_demux_send_data (fifo, pkt->data, pkt->size, pts, buffer_type, 0/*decoder_flags*/,
                        input_normpos, input_time, total_time, 0/*frame_number*/);
   }
 
-  XFF_PACKET_UNREF(&pkt);
+  XFF_PACKET_UNREF (pkt);
 
   return 1;
 }
@@ -749,11 +753,23 @@
 
 static int pb_input_read_packet(void *opaque, uint8_t *buf, int buf_size) {
   input_plugin_t *input = (input_plugin_t *)opaque;
-  return input->read(input, buf, buf_size);
+  int r = input->read (input, buf, buf_size);
+  /* avoid eternal misunderstanding :-O */
+  if (r > 0)
+    return r;
+  if (r == 0) {
+#ifdef AVERROR_EOF
+    return AVERROR_EOF;
+#else
+    return 0;
+#endif
+  }
+  return AVERROR (errno);
 }
 
 static int64_t pb_input_seek(void *opaque, int64_t offset, int whence) {
   input_plugin_t *input = (input_plugin_t *)opaque;
+  int64_t r;
 
   if (whence == AVSEEK_SIZE) {
     off_t len = input->get_length(input);
@@ -762,7 +778,10 @@
     return -1;
   }
 
-  return input->seek(input, offset, whence);
+  r = input->seek (input, offset, whence);
+  if (r >= 0)
+    return r;
+  return AVERROR (errno);
 }
 
 static AVIOContext *get_io_context(xine_stream_t *stream, input_plugin_t *input)
@@ -861,6 +880,10 @@
   avformat_demux_plugin_t *this;
 
   this         = calloc(1, sizeof(avformat_demux_plugin_t));
+  if (!this) {
+    avformat_close_input(&fmt_ctx);
+    return NULL;
+  }
   this->stream = stream;
 
   this->demux_plugin.send_headers      = demux_avformat_send_headers;
diff -urN xine-lib-1.2.11/src/combined/ffmpeg/ff_audio_decoder.c xine-lib-1.2/src/combined/ffmpeg/ff_audio_decoder.c
--- xine-lib-1.2.11/src/combined/ffmpeg/ff_audio_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/combined/ffmpeg/ff_audio_decoder.c	2022-01-15 22:03:19.584547170 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2001-2020 the xine project
+ * Copyright (C) 2001-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -74,7 +74,7 @@
   int               size;
 
   AVCodecContext    *context;
-  AVCodec           *codec;
+  const AVCodec     *codec;
 
   char              *decode_buffer;
   int               decoder_ok;
@@ -83,6 +83,9 @@
 #if XFF_AUDIO > 3
   AVFrame          *av_frame;
 #endif
+#if XFF_AUDIO > 2
+  XFF_PACKET_DECL (avpkt);
+#endif
 
   /* AAC ADTS */
   uint32_t          buftype;
@@ -690,11 +693,9 @@
   else parsed = 0;
 
 #if XFF_AUDIO > 2
-  AVPacket avpkt;
-  av_init_packet (&avpkt);
-  avpkt.data = buf;
-  avpkt.size = size;
-  avpkt.flags = AV_PKT_FLAG_KEY;
+  this->avpkt->data = buf;
+  this->avpkt->size = size;
+  this->avpkt->flags = AV_PKT_FLAG_KEY;
 #  if XFF_AUDIO > 3
   int got_frame;
   float gain = this->class->gain;
@@ -702,7 +703,7 @@
     this->av_frame = XFF_ALLOC_FRAME ();
 #   if XFF_AUDIO == 5
   {
-    int err = avcodec_send_packet (this->context, &avpkt);
+    int err = avcodec_send_packet (this->context, this->avpkt);
     /* xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "ff_audio_dec: send (%d) = %d.\n", (int)size, err); */
     /* multiple frames per packet */
     consumed = (err >= 0) ? size : ((err == AVERROR (EAGAIN)) ? 0 : err);
@@ -712,7 +713,7 @@
     got_frame = (err == 0);
   }
 #   else
-  consumed = avcodec_decode_audio4 (this->context, this->av_frame, &got_frame, &avpkt);
+  consumed = avcodec_decode_audio4 (this->context, this->av_frame, &got_frame, this->avpkt);
 #   endif
   if ((consumed >= 0) && got_frame) {
     /* setup may have altered while decoding */
@@ -970,7 +971,7 @@
     }
   } else *decode_buffer_size = 0;
 #  else
-  consumed = avcodec_decode_audio3 (this->context, decode_buffer, decode_buffer_size, &avpkt);
+  consumed = avcodec_decode_audio3 (this->context, decode_buffer, decode_buffer_size, this->avpkt);
   ff_map_channels (this);
 #  endif
 #else
@@ -1286,6 +1287,8 @@
   this->context->extradata_size = 0;
   XFF_FREE_CONTEXT (this->context);
 
+  XFF_PACKET_UNREF (this->avpkt);
+
   free (this_gen);
 }
 
@@ -1313,6 +1316,10 @@
 # endif
 #endif
 
+# if XFF_AUDIO > 2
+  XFF_PACKET_NEW (this->avpkt);
+#endif
+
   this->class  = (ff_audio_class_t *)class_gen;
   this->stream = stream;
 
diff -urN xine-lib-1.2.11/src/combined/ffmpeg/ffmpeg_compat.h xine-lib-1.2/src/combined/ffmpeg/ffmpeg_compat.h
--- xine-lib-1.2.11/src/combined/ffmpeg/ffmpeg_compat.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/combined/ffmpeg/ffmpeg_compat.h	2022-01-15 22:03:19.591547200 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a unix video player.
  *
@@ -130,6 +130,12 @@
 #  define XFF_PALETTE 3
 #endif
 
+#if LIBAVCODEC_VERSION_INT < XFF_INT_VERSION(59,0,100) /** << revise this */
+#  define XFF_VAAPI 1 /** << libavcodec/vaapi.h */
+#else
+#  define XFF_VAAPI 2 /** << libavutil/hwcontext.h, libavutil/hwcontext_vaapi.h */
+#endif
+
 #if LIBAVUTIL_VERSION_INT >= XFF_INT_VERSION(52,0,0)
 #  define PIX_FMT_NONE      AV_PIX_FMT_NONE
 #  define PIX_FMT_YUV420P   AV_PIX_FMT_YUV420P
@@ -138,7 +144,6 @@
 #  define PIX_FMT_YUVJ444P  AV_PIX_FMT_YUVJ444P
 #  define PIX_FMT_YUV410P   AV_PIX_FMT_YUV410P
 #  define PIX_FMT_YUV411P   AV_PIX_FMT_YUV411P
-#  define PIX_FMT_VAAPI_VLD AV_PIX_FMT_VAAPI_VLD
 #  define PIX_FMT_ARGB      AV_PIX_FMT_ARGB
 #  define PIX_FMT_BGRA      AV_PIX_FMT_BGRA
 #  define PIX_FMT_RGB24     AV_PIX_FMT_RGB24
@@ -150,8 +155,17 @@
 #  define PIX_FMT_PAL8      AV_PIX_FMT_PAL8
 #  define PixelFormat       AVPixelFormat
 /* video_out/video_out_vaapi */
-#  define PIX_FMT_VAAPI_IDCT AV_PIX_FMT_VAAPI_IDCT
-#  define PIX_FMT_VAAPI_MOCO AV_PIX_FMT_VAAPI_MOCO
+#  if LIBAVCODEC_VERSION_INT < XFF_INT_VERSION(59,0,100) /** << revise this */
+#    define PIX_FMT_VAAPI_VLD AV_PIX_FMT_VAAPI_VLD
+#    define PIX_FMT_VAAPI_IDCT AV_PIX_FMT_VAAPI_IDCT
+#    define PIX_FMT_VAAPI_MOCO AV_PIX_FMT_VAAPI_MOCO
+#  else
+#    define PIX_FMT_VAAPI_VLD AV_PIX_FMT_VAAPI
+#    define PIX_FMT_VAAPI_IDCT AV_PIX_FMT_VAAPI
+#    define PIX_FMT_VAAPI_MOCO AV_PIX_FMT_VAAPI
+#  endif
+
+#  define CODEC_FLAG_BITEXACT AV_CODEC_FLAG_BITEXACT
 #endif
 
 #if LIBAVCODEC_VERSION_INT >= XFF_INT_VERSION(54,25,0)
@@ -188,6 +202,18 @@
 #  define XFF_AV_BUFFER 1
 #endif
 
+/* 0 (no), 1 (yes), 2 (deprecated but still needed to make direct rendering work) */
+#if LIBAVCODEC_VERSION_INT < XFF_INT_VERSION(55,0,100)
+#  define XFF_THREAD_SAFE_CB 0
+#elif LIBAVCODEC_VERSION_INT < XFF_INT_VERSION(59,0,100)
+#  define XFF_THREAD_SAFE_CB 1
+#elif LIBAVCODEC_VERSION_INT < XFF_INT_VERSION(60,0,0)
+#  define XFF_THREAD_SAFE_CB 2
+#else
+/* now callbacks shall always be thread safe. */
+#  define XFF_THREAD_SAFE_CB 0
+#endif
+
 /* function aliases */
 
 #if LIBAVCODEC_VERSION_INT < XFF_INT_VERSION(52,66,0)
@@ -235,9 +261,17 @@
 #endif
 
 #if LIBAVCODEC_VERSION_INT < XFF_INT_VERSION(57,12,100)
-#define XFF_PACKET_UNREF av_free_packet
-#else
-#define XFF_PACKET_UNREF av_packet_unref
+#  define XFF_PACKET_DECL(_p) AVPacket _p##_stat, *_p
+#  define XFF_PACKET_NEW(_p) _p = &_p##_stat, av_init_packet (_p)
+#  define XFF_PACKET_UNREF(_p) av_free_packet (_p)
+#elif LIBAVCODEC_VERSION_INT < XFF_INT_VERSION(59,0,100) /** << revise this */
+#  define XFF_PACKET_DECL(_p) AVPacket _p##_stat, *_p
+#  define XFF_PACKET_NEW(_p) _p = &_p##_stat, av_init_packet (_p)
+#  define XFF_PACKET_UNREF(_p) av_packet_unref (_p)
+#else
+#  define XFF_PACKET_DECL(_p) AVPacket *_p
+#  define XFF_PACKET_NEW(_p) _p = av_packet_alloc ()
+#  define XFF_PACKET_UNREF(_p) av_packet_free (&(_p))
 #endif
 
 #ifndef AV_INPUT_BUFFER_PADDING_SIZE
@@ -257,3 +291,4 @@
 #endif
 
 #endif /* XINE_AVCODEC_COMPAT_H */
+
diff -urN xine-lib-1.2.11/src/combined/ffmpeg/ff_video_decoder.c xine-lib-1.2/src/combined/ffmpeg/ff_video_decoder.c
--- xine-lib-1.2.11/src/combined/ffmpeg/ff_video_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/combined/ffmpeg/ff_video_decoder.c	2022-01-15 22:03:19.595547217 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2001-2020 the xine project
+ * Copyright (C) 2001-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -51,23 +51,32 @@
 #include "ffmpeg_decoder.h"
 #include "ff_mpeg_parser.h"
 
-#ifdef HAVE_POSTPROC
-#ifdef HAVE_FFMPEG_AVUTIL_H
-# include <postprocess.h>
-#else
-# include <libpostproc/postprocess.h>
-# include <libavutil/mem.h>
+#include "ffmpeg_compat.h"
+
+#if LIBAVCODEC_VERSION_INT >= XFF_INT_VERSION(59,0,100)
+# undef HAVE_POSTPROC
 #endif
+#ifdef HAVE_POSTPROC
+# ifdef HAVE_FFMPEG_AVUTIL_H
+#  include <postprocess.h>
+# else
+#  include <libpostproc/postprocess.h>
+#  include <libavutil/mem.h>
+# endif
 #endif
 
-#ifdef HAVE_VA_VA_X11_H
-# include <libavcodec/vaapi.h>
+#ifdef HAVE_VA_VA_H
+# if XFF_VAAPI == 1
+#  include <libavcodec/vaapi.h>
+# elif XFF_VAAPI == 2
+#  warning rumms
+#  include <libavutil/hwcontext.h>
+#  include <libavutil/hwcontext_vaapi.h>
+# endif
 # include "accel_vaapi.h"
 # define ENABLE_VAAPI 1
 #endif
 
-#include "ffmpeg_compat.h"
-
 #if defined(ARCH_X86) && defined(HAVE_MMX)
 # include "xine_mmx.h"
 # define ENABLE_EMMS
@@ -140,7 +149,7 @@
   AVFrame          *av_frame;
   AVFrame          *av_frame2;
   AVCodecContext   *context;
-  AVCodec          *codec;
+  const AVCodec    *codec;
 
 #ifdef HAVE_POSTPROC
   int               pp_quality;
@@ -187,7 +196,15 @@
 #ifdef ENABLE_VAAPI
   int                   vaapi_width, vaapi_height;
   int                   vaapi_profile;
+# if XFF_VAAPI == 1
   struct vaapi_context  vaapi_context;
+# elif XFF_VAAPI == 2
+  /* these are _here_ for debugging mostly. */
+  AVBufferRef          *vaapi_av_ctx_ref;
+  AVHWDeviceContext    *vaapi_av_ctx;
+  AVVAAPIDeviceContext *vaapi_hw_ctx;
+  AVVAAPIHWConfig      *vaapi_hw_cfg;
+# endif
   const struct vaapi_accel_funcs_s *accel;
   vo_frame_t            *accel_img;
 #endif
@@ -210,12 +227,79 @@
   /* see get_buffer () */
   int               use_emms;
 #endif
+
+#if XFF_VIDEO > 1
+  XFF_PACKET_DECL (avpkt);
+#endif
 };
 
 /* import color matrix names */
 #define CM_HAVE_YCGCO_SUPPORT 1
 #include "../../video_out/color_matrix.c"
 
+#ifdef ENABLE_VAAPI
+# if XFF_VAAPI == 2
+
+static void ff_vaapi_stop (ff_video_decoder_t *this) {
+  if (this->vaapi_av_ctx) {
+    av_buffer_unref (&this->vaapi_av_ctx_ref);
+    this->vaapi_av_ctx = NULL;
+    this->vaapi_av_ctx_ref = NULL;
+  }
+}
+
+static void ff_vaapi_free_ctx (AVHWDeviceContext *ctx) {
+  ff_video_decoder_t *this;
+
+  if (!ctx)
+    return;
+  this = (ff_video_decoder_t *)ctx->user_opaque;
+  if (!this)
+    return;
+
+  av_free (this->vaapi_hw_cfg);
+  this->vaapi_hw_cfg = NULL;
+}
+
+static int ff_vaapi_start (ff_video_decoder_t *this, VADisplay display, VAConfigID config_id) {
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "ffmpeg_video_dec: ff_vaapi_start (display = %p, config_id = %d).\n",
+    (void *)display, (int)config_id);
+
+  this->vaapi_av_ctx_ref = av_hwdevice_ctx_alloc (AV_HWDEVICE_TYPE_VAAPI);
+  if (!this->vaapi_av_ctx_ref)
+    return 0;
+  this->vaapi_av_ctx = (AVHWDeviceContext *)this->vaapi_av_ctx_ref->data;
+  if (!this->vaapi_av_ctx) {
+    ff_vaapi_stop (this);
+    return 0;
+  }
+
+  this->vaapi_hw_ctx = (AVVAAPIDeviceContext *)this->vaapi_av_ctx->hwctx;
+  if (!this->vaapi_hw_ctx) {
+    ff_vaapi_stop (this);
+    return 0;
+  }
+  this->vaapi_av_ctx->user_opaque = this;
+  this->vaapi_av_ctx->free = ff_vaapi_free_ctx;
+  this->vaapi_hw_ctx->display = display;
+
+  this->vaapi_hw_cfg = (AVVAAPIHWConfig *)av_hwdevice_hwconfig_alloc (this->vaapi_av_ctx_ref);
+  if (!this->vaapi_hw_cfg) {
+    ff_vaapi_stop (this);
+    return 0;
+  }
+  this->vaapi_hw_cfg->config_id = config_id;
+
+  if (av_hwdevice_ctx_init (this->vaapi_av_ctx_ref)) {
+    ff_vaapi_stop (this);
+    return 0;
+  }
+  return 1;
+}
+
+# endif
+#endif
 
 static void ff_check_colorspace (ff_video_decoder_t *this) {
   int i, cm, caps;
@@ -481,9 +565,20 @@
       ff_vaapi_context_t *va_context = this->accel->get_context (this->accel_img);
 
       if (va_context) {
+#  if XFF_VAAPI == 2
+        /* avcodec.h saye custom frame allocators shall use AVCodecContext.hw_frames_ctx instead.
+         * however, avcodec_default_get_buffer2 () seems the only 1 using it as such. */
+        if (ff_vaapi_start (this, va_context->va_display, va_context->va_config_id)) {
+          AVBufferRef *old_vaapi_av_ctx_ref = context->hw_device_ctx;
+
+          context->hw_device_ctx = this->vaapi_av_ctx_ref;
+          av_buffer_unref (&old_vaapi_av_ctx_ref);
+        }
+#  else
         this->vaapi_context.config_id  = va_context->va_config_id;
         this->vaapi_context.context_id = va_context->va_context_id;
         this->vaapi_context.display    = va_context->va_display;
+#  endif
       }
     }
   }
@@ -867,11 +962,22 @@
         context->draw_horiz_band = NULL;
         context->slice_flags = SLICE_FLAG_CODED_ORDER | SLICE_FLAG_ALLOW_FIELD;
 
+# if XFF_VAAPI == 2
+        /* avcodec.h saye custom frame allocators shall use AVCodecContext.hw_frames_ctx instead.
+         * however, avcodec_default_get_buffer2 () seems the only 1 using it as such. */
+        if (ff_vaapi_start (this, va_context->va_display, va_context->va_config_id)) {
+          AVBufferRef *old_vaapi_av_ctx_ref = context->hw_device_ctx;
+
+          context->hw_device_ctx = this->vaapi_av_ctx_ref;
+          av_buffer_unref (&old_vaapi_av_ctx_ref);
+        }
+# else
         this->vaapi_context.config_id    = va_context->va_config_id;
         this->vaapi_context.context_id   = va_context->va_context_id;
         this->vaapi_context.display      = va_context->va_display;
 
         context->hwaccel_context     = &this->vaapi_context;
+# endif
         this->pts = 0;
 
         return fmt[i];
@@ -955,7 +1061,12 @@
   if( this->codec->capabilities & AV_CODEC_CAP_DR1 && this->class->enable_dri ) {
 # ifdef XFF_AV_BUFFER
     this->context->get_buffer2 = get_buffer;
+#  if XFF_THREAD_SAFE_CB == 2
+#   warning h.264 still needs this set, or falls back to indirect rendering. please ignore the next warning.
+#  endif
+#  if XFF_THREAD_SAFE_CB != 0
     this->context->thread_safe_callbacks = 1;
+#  endif
 #  if XFF_VIDEO != 3
     this->context->refcounted_frames = 1;
 #  endif
@@ -1162,9 +1273,9 @@
 
 static void init_postprocess (ff_video_decoder_t *this) {
 #ifdef HAVE_POSTPROC
-#if defined(ARCH_X86)
+# if defined(ARCH_X86)
   uint32_t cpu_caps;
-#endif
+# endif
 
   /* Allow post processing on mpeg-4 (based) codecs */
   switch(this->codec->id) {
@@ -1183,7 +1294,7 @@
 
   this->pp_flags = PP_FORMAT_420;
 
-#if defined(ARCH_X86)
+# if defined(ARCH_X86)
   /* Detect what cpu accel we have */
   cpu_caps = xine_mm_accel();
 
@@ -1195,10 +1306,12 @@
 
   if(cpu_caps & MM_ACCEL_X86_3DNOW)
     this->pp_flags |= PP_CPU_CAPS_3DNOW;
-#endif
+# endif
 
   /* Set level */
   pp_change_quality(this);
+#else
+  (void)this;
 #endif /* HAVE_POSTPROC */
 }
 
@@ -1848,15 +1961,13 @@
 #endif /* ENABLE_VAAPI */
 
 #if XFF_VIDEO > 1
-  AVPacket avpkt;
-  av_init_packet(&avpkt);
-  avpkt.data = buf;
-  avpkt.size = buf_size;
-  avpkt.flags = AV_PKT_FLAG_KEY;
+  this->avpkt->data = buf;
+  this->avpkt->size = buf_size;
+  this->avpkt->flags = AV_PKT_FLAG_KEY;
 
 # if XFF_PALETTE == 2 || XFF_PALETTE == 3
   if (buf && this->palette_changed) {
-    uint8_t *sd = av_packet_new_side_data (&avpkt, AV_PKT_DATA_PALETTE, 256 * 4);
+    uint8_t *sd = av_packet_new_side_data (this->avpkt, AV_PKT_DATA_PALETTE, 256 * 4);
     if (sd)
       memcpy (sd, this->palette, 256 * 4);
   }
@@ -1868,7 +1979,7 @@
   {
     int e = AVERROR (EAGAIN);
     if (buf || !this->flush_packet_sent) {
-      e = avcodec_send_packet (this->context, &avpkt);
+      e = avcodec_send_packet (this->context, this->avpkt);
       this->flush_packet_sent = (buf == NULL);
     }
     len = (e == AVERROR (EAGAIN)) ? 0 : buf_size;
@@ -1878,7 +1989,7 @@
 # else
   {
     int got_picture = 0;
-    len = avcodec_decode_video2 (this->context, av_frame, &got_picture, &avpkt);
+    len = avcodec_decode_video2 (this->context, av_frame, &got_picture, this->avpkt);
     if ((len < 0) || (len > (int)buf_size)) {
       *err = got_picture ? 0 : len;
       len = buf_size;
@@ -1891,16 +2002,16 @@
 # if XFF_PALETTE == 2 || XFF_PALETTE == 3
   if (buf && this->palette_changed) {
     /* Prevent freeing our data buffer */
-    avpkt.data = NULL;
-    avpkt.size = 0;
+    this->avpkt->data = NULL;
+    this->avpkt->size = 0;
 #  if XFF_PALETTE == 2
     /* TJ. Oh dear and sigh.
        AVPacket side data handling is broken even in ffmpeg 1.1.1 - see avcodec/avpacket.c
        The suggested av_free_packet () would leave a memory leak here, and
        ff_packet_free_side_data () is private. */
-    av_destruct_packet (&avpkt);
+    av_destruct_packet (this->avpkt);
 #  else /* XFF_PALETTE == 3 */
-    XFF_PACKET_UNREF (&avpkt);
+    /* XFF_PACKET_UNREF (this->avpkt); */ ;
 #  endif
     this->palette_changed = 0;
   }
@@ -1929,6 +2040,8 @@
   return len;
 }
 
+static void ff_reset (video_decoder_t *this_gen);
+
 static void ff_handle_mpeg12_buffer (ff_video_decoder_t *this, buf_element_t *buf) {
 
   vo_frame_t *img;
@@ -2012,8 +2125,20 @@
     flush = next_flush;
 
     if ((err < 0) && (err != AVERROR (EAGAIN))) {
-      xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-        "ffmpeg_video_dec: error decompressing frame (%d).\n", err);
+#ifdef AVERROR_EOF
+      if (err == AVERROR_EOF) {
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+          "ffmpeg_video_dec: lost track, reinitializing.\n");
+        ff_reset (&this->video_decoder);
+      } else
+#endif
+      {
+        char b[20];
+
+        _x_tag32_me2str (b, -err);
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+          "ffmpeg_video_dec: error decompressing frame [%s] (%d).\n", b, err);
+      }
     }
     size -= len;
     offset += len;
@@ -2266,8 +2391,20 @@
             this->size -= len;
             continue;
           }
-          xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-            "ffmpeg_video_dec: error decompressing frame (%d).\n", err);
+#ifdef AVERROR_EOF
+          if (err == AVERROR_EOF) {
+            xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+              "ffmpeg_video_dec: lost track, reinitializing.\n");
+            ff_reset (&this->video_decoder);
+          } else
+#endif
+          {
+            char b[20];
+
+            _x_tag32_me2str (b, -err);
+            xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+              "ffmpeg_video_dec: error decompressing frame [%s] (%d).\n", b, err);
+          }
           this->size = 0;
 
         } else {
@@ -2763,6 +2900,10 @@
     XFF_FREE_CONTEXT (this->context);
   }
 
+#if XFF_VIDEO > 1
+  XFF_PACKET_UNREF (this->avpkt);
+#endif
+
   if( this->av_frame )
     XFF_FREE_FRAME( this->av_frame );
   if (this->av_frame2)
@@ -2805,7 +2946,7 @@
 static video_decoder_t *ff_video_open_plugin (video_decoder_class_t *class_gen, xine_stream_t *stream) {
 
   ff_video_decoder_t  *this ;
-  AVCodec             *codec = NULL;
+  const AVCodec       *codec = NULL;
   uint32_t             video_type;
   size_t               i;
 
@@ -2915,6 +3056,10 @@
   this->debug_fmt = -1;
 #endif
 
+#if XFF_VIDEO > 1
+  XFF_PACKET_NEW (this->avpkt);
+#endif
+
 #ifdef ENABLE_VAAPI
   if (this->class->enable_vaapi && (stream->video_out->get_capabilities(stream->video_out) & VO_CAP_VAAPI)) {
     xprintf(this->class->xine, XINE_VERBOSITY_LOG, _("ffmpeg_video_dec: vaapi_mpeg_softdec %d\n"),
diff -urN xine-lib-1.2.11/src/combined/wavpack_demuxer.c xine-lib-1.2/src/combined/wavpack_demuxer.c
--- xine-lib-1.2.11/src/combined/wavpack_demuxer.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/combined/wavpack_demuxer.c	2022-01-15 22:03:19.570547111 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006-2020 the xine project
+ * Copyright (C) 2006-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -98,7 +98,7 @@
 static int32_t xine_input_write_bytes(__attr_unused void *const id,
 				      __attr_unused void *const data,
 				      __attr_unused const int32_t bcount) {
-  lprintf("xine_input_write_bytes: acces is read-only.\n");
+  lprintf("xine_input_write_bytes: access is read-only.\n");
   return 0;
 }
 
@@ -331,6 +331,10 @@
 				    xine_stream_t *const stream,
 				    input_plugin_t *const input) {
   demux_wv_t *const this = calloc(1, sizeof (demux_wv_t));
+
+  if (!this)
+    return NULL;
+
   this->stream = stream;
   this->input = input;
 
diff -urN xine-lib-1.2.11/src/combined/xine_ogg_demuxer.c xine-lib-1.2/src/combined/xine_ogg_demuxer.c
--- xine-lib-1.2.11/src/combined/xine_ogg_demuxer.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/combined/xine_ogg_demuxer.c	2022-01-15 22:03:19.592547204 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -2146,6 +2146,9 @@
    */
 
   this         = calloc(1, sizeof(demux_ogg_t));
+  if (!this)
+    return NULL;
+
   this->stream = stream;
   this->input  = input;
 
@@ -2193,6 +2196,8 @@
    */
 
   this         = calloc(1, sizeof(demux_ogg_t));
+  if (!this)
+    return NULL;
   this->stream = stream;
   this->input  = input;
 
diff -urN xine-lib-1.2.11/src/demuxers/demux_iff.c xine-lib-1.2/src/demuxers/demux_iff.c
--- xine-lib-1.2.11/src/demuxers/demux_iff.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/demuxers/demux_iff.c	2022-01-15 22:03:19.596547221 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2004-2018 the xine project
+ * Copyright (C) 2004-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -167,7 +167,7 @@
   unsigned char signature[IFF_SIGNATURE_SIZE];
   unsigned char buffer[512];
   unsigned int  keep_on_reading = 1;
-  uint32_t      junk_size;
+  uint32_t      junk_size, junk_type;
 
   while ( keep_on_reading == 1 ) {
     if (this->input->read(this->input, signature, IFF_JUNK_SIZE) == IFF_JUNK_SIZE) {
@@ -182,8 +182,9 @@
         if (this->input->read(this->input, &signature[7], 1) != 1)
           return 0;
       }
+      junk_type = _X_BE_32(&signature[0]);
       junk_size = _X_BE_32(&signature[4]);
-      switch( _X_BE_32(&signature[0]) ) {
+      switch (junk_type) {
         case IFF_CMAP_CHUNK:
         case IFF_BODY_CHUNK:
         case IFF_DLTA_CHUNK:
@@ -201,7 +202,7 @@
           break;
       }
 
-      switch( _X_BE_32(&signature[0]) ) {
+      switch (junk_type) {
         case IFF_FORM_CHUNK:
           if (this->input->read(this->input, buffer, 4) != 4)
             return 0;
diff -urN xine-lib-1.2.11/src/demuxers/demux_ipmovie.c xine-lib-1.2/src/demuxers/demux_ipmovie.c
--- xine-lib-1.2.11/src/demuxers/demux_ipmovie.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/demuxers/demux_ipmovie.c	2022-01-15 22:03:19.589547192 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -430,8 +430,9 @@
           this->frame_pts_inc);
 
         /* load the decode map into the staging area */
-        if (this->input->read(this->input, this->decode_map,
-          this->decode_map_size) != this->decode_map_size)
+        if (!this->decode_map ||
+            this->input->read(this->input, this->decode_map,
+                              this->decode_map_size) != this->decode_map_size)
           this->status = DEMUX_FINISHED;
         break;
 
@@ -457,7 +458,7 @@
 
         /* send the decode map first */
         decode_map_index = 0;
-        decode_map_size_countdown = this->decode_map_size;
+        decode_map_size_countdown = this->decode_map ? this->decode_map_size : 0;
         while (decode_map_size_countdown) {
           buf = this->video_fifo->buffer_pool_alloc (this->video_fifo);
           buf->type = BUF_VIDEO_INTERPLAY;
diff -urN xine-lib-1.2.11/src/demuxers/demux_matroska.c xine-lib-1.2/src/demuxers/demux_matroska.c
--- xine-lib-1.2.11/src/demuxers/demux_matroska.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/demuxers/demux_matroska.c	2022-01-15 22:03:19.606547263 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -1166,6 +1166,7 @@
 
     *out_data = NULL;
 
+    memset(&zstream, 0, sizeof(zstream));
     zstream.zalloc = (alloc_func) 0;
     zstream.zfree = (free_func) 0;
     zstream.opaque = (voidpf) 0;
diff -urN xine-lib-1.2.11/src/demuxers/demux_qt.c xine-lib-1.2/src/demuxers/demux_qt.c
--- xine-lib-1.2.11/src/demuxers/demux_qt.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/demuxers/demux_qt.c	2022-01-15 22:03:19.606547263 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2001-2020 the xine project
+ * Copyright (C) 2001-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -53,6 +53,7 @@
 #include <xine/xineutils.h>
 #include <xine/demux.h>
 #include <xine/buffer.h>
+#include <xine/mfrag.h>
 #include "bswap.h"
 
 #include "qtpalette.h"
@@ -70,9 +71,7 @@
 #define WIDE_ATOM QT_ATOM('w', 'i', 'd', 'e')
 #define PICT_ATOM QT_ATOM('P', 'I', 'C', 'T')
 #define FTYP_ATOM QT_ATOM('f', 't', 'y', 'p')
-/*
 #define SIDX_ATOM QT_ATOM('s', 'i', 'd', 'x')
-*/
 
 #define CMOV_ATOM QT_ATOM('c', 'm', 'o', 'v')
 
@@ -234,18 +233,6 @@
 
 } media_type;
 
-#ifdef SIDX_ATOM
-typedef struct {
-  int64_t offset;
-  int64_t pts;
-} fragment_info_t;
-
-typedef struct {
-  int num_fragments;
-  fragment_info_t fragments[1];
-} fragment_index_t;
-#endif
-
 /* TJ. Cinematic movies reach > 200000 frames easily, so we better save space here.
  * offset / file size should well fit into 48 bits :-) */
 typedef struct {
@@ -427,6 +414,7 @@
   int          seek_flag;  /* this is set to indicate that a seek has just occurred */
 
   /* fragment mode */
+  xine_mfrag_list_t *fraglist;
   int          fragment_count;
   size_t       fragbuf_size;
   uint8_t     *fragment_buf;
@@ -464,6 +452,7 @@
   fifo_buffer_t       *audio_fifo;
 
   input_plugin_t      *input;
+  int                  ptsoffs;
 
   int                  status;
 
@@ -2080,9 +2069,8 @@
 * Fragment stuff                                                        *
 ************************************************************************/
 
-#ifdef SIDX_ATOM
-static fragment_index_t *load_fragment_index (input_plugin_t *input, const uint8_t *head, uint32_t hsize, uint32_t timescale) {
-  uint32_t inum;
+static int demux_qt_load_fragment_index (demux_qt_t *this, const uint8_t *head, uint32_t hsize) {
+  uint32_t inum, timebase;
 
   {
     uint8_t fullhead[32];
@@ -2091,63 +2079,66 @@
     if (hsize)
       memcpy (fullhead, head, hsize);
     if (n > 0) {
-      if (input->read (input, fullhead + hsize, n) != n)
-        return NULL;
+      if (this->input->read (this->input, fullhead + hsize, n) != n)
+        return 0;
     }
     isize = _X_BE_32 (fullhead);
     if (isize < 32)
-      return NULL;
+      return 0;
     inum  = _X_BE_32 (fullhead + 28);
     if (inum > (isize - 32) / 12)
       inum = (isize - 32) / 12;
+    timebase = _X_BE_32 (fullhead + 16);
+    if (!timebase)
+      timebase = this->qt.timescale;
   }
 
   {
-    int64_t pos, pts;
-    fragment_index_t *idx;
-    fragment_info_t  *inf;
-    uint8_t *tab = malloc (sizeof (*idx) + inum * sizeof (idx->fragments[0]));
-    if (!tab)
-      return NULL;
-    idx = (fragment_index_t *)tab;
-    tab += sizeof (*idx) + inum * sizeof (idx->fragments[0]) - inum * 12;
-    if (input->read (input, tab, inum * 12) != (int32_t)inum * 12) {
-      free (idx);
-      return NULL;
+    xine_mfrag_list_t *fraglist = NULL;
+    if (this->input->get_optional_data (this->input, &fraglist, INPUT_OPTIONAL_DATA_FRAGLIST) == INPUT_OPTIONAL_SUCCESS)
+      this->qt.fraglist = fraglist;
+  }
+
+  xine_mfrag_set_index_frag (this->qt.fraglist, 0, timebase, -1);
+
+  {
+    uint32_t idx = 1;
+    inum += 1;
+    while (idx < inum) {
+      uint8_t buf[256 * 12], *p;
+      uint32_t stop = idx + sizeof (buf) / 12;
+      if (stop > inum)
+        stop = inum;
+      if (this->input->read (this->input, buf, (stop - idx) * 12) != (int32_t)((stop - idx) * 12))
+        break;
+      p = buf;
+      while (idx < stop) {
+        xine_mfrag_set_index_frag (this->qt.fraglist, idx, _X_BE_32 (p + 4), _X_BE_32 (p));
+        p += 12;
+        idx += 1;
+
+      }
     }
-    idx->num_fragments = inum;
-    pos = input->get_current_pos (input);
-    pts = 0;
-    inf = &idx->fragments[0];
-    while (inum--) {
-      inf->offset = pos;
-      pos += _X_BE_32 (tab);
-      inf->pts = pts * 90000 / timescale;
-      pts += _X_BE_32 (tab + 8);
-      inf++;
-      tab += 12;
-    }
-    inf->offset = pos;
-    inf->pts    = pts * 90000 / timescale;
-    return idx;
   }
-}
 
-static void report_fragment_index (xine_t *xine, fragment_index_t *idx) {
-  if (idx) {
+  if (this->qt.fraglist) {
+    int64_t d, l;
     unsigned int v, s, m;
-    v = idx->fragments[idx->num_fragments].pts / 90000;
+    inum = xine_mfrag_get_frag_count (this->qt.fraglist);
+    xine_mfrag_get_index_start (this->qt.fraglist, inum + 1, &d, &l);
+    v = d / timebase;
     s = v % 60;
     v /= 60;
     m = v % 60;
     v /= 60;
-    xprintf (xine, XINE_VERBOSITY_DEBUG,
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
       "demux_qt: found index of %u fragments, %"PRId64" bytes, %0u:%02u:%02u.\n",
-      (unsigned int)idx->num_fragments, idx->fragments[idx->num_fragments].offset,
-      v, m, s);
+      (unsigned int)inum, l, v, m, s);
+    return 1;
   }
+
+  return 0;
 }
-#endif
 
 static qt_trak *find_trak_by_id (demux_qt_t *this, int id) {
   unsigned int i;
@@ -2794,6 +2785,8 @@
         }
         if (parse_moof_atom (this, this->qt.fragment_buf, atomsize, pos))
           frags++;
+      } else if (atomtype == SIDX_ATOM) {
+        demux_qt_load_fragment_index (this, hbuf, 16);
       }
     }
     this->qt.fragment_next = pos;
@@ -2808,6 +2801,7 @@
     if (pos == 0)
       pos = this->input->get_current_pos (this->input);
     while (1) {
+      uint32_t atomtype, hsize;
       if (pos <= 0)
         return 0;
       if (this->input->seek (this->input, pos, SEEK_SET) != pos)
@@ -2815,8 +2809,10 @@
       if (this->input->read (this->input, hbuf, 8) != 8)
         return 0;
       atomsize = _X_BE_32 (hbuf);
-      if (_X_BE_32 (hbuf + 4) == MOOF_ATOM)
+      atomtype = _X_BE_32 (hbuf + 4);
+      if (atomtype == MOOF_ATOM)
         break;
+      hsize = 8;
       if (atomsize < 8) {
         if (atomsize != 1)
           return 0;
@@ -2825,7 +2821,10 @@
         atomsize = _X_BE_64 (hbuf + 8);
         if (atomsize < 16)
           return 0;
+        hsize = 16;
       }
+      if (atomtype == SIDX_ATOM)
+        demux_qt_load_fragment_index (this, hbuf, hsize);
       pos += atomsize;
     }
     /* add it */
@@ -3327,6 +3326,7 @@
       z_stream z_state;
       int      z_ret_code1, z_ret_code2;
       this->qt.last_error  = QT_ZLIB_ERROR;
+      memset(&z_state, 0, sizeof(z_state));
       z_state.next_in   = moov_atom + 0x28;
       z_state.avail_in  = moov_atom_size - 0x28;
       z_state.next_out  = unzip_buffer;
@@ -3535,7 +3535,7 @@
       buf->type = trak->properties->codec_buftype;
       buf->extra_info->input_time = qt_pts_2_msecs (trak->frames[i].pts);
       buf->extra_info->input_normpos = qt_msec_2_normpos (this, buf->extra_info->input_time);
-      buf->pts = trak->frames[i].pts + (int64_t)trak->frames[i].ptsoffs;
+      buf->pts = trak->frames[i].pts + (int64_t)trak->frames[i].ptsoffs + this->ptsoffs;
 
       buf->decoder_flags |= BUF_FLAG_FRAMERATE;
       buf->decoder_info[0] = frame_duration;
@@ -3605,14 +3605,14 @@
       if ((buf->type == BUF_AUDIO_LPCM_BE) ||
           (buf->type == BUF_AUDIO_LPCM_LE)) {
         if (first_buf) {
-          buf->pts = trak->frames[i].pts;
+          buf->pts = trak->frames[i].pts + this->ptsoffs;
           first_buf = 0;
         } else {
           buf->extra_info->input_time = 0;
           buf->pts = 0;
         }
       } else {
-        buf->pts = trak->frames[i].pts;
+        buf->pts = trak->frames[i].pts + this->ptsoffs;
       }
 
       /* 24-bit audio doesn't fit evenly into the default 8192-byte buffers */
@@ -4199,6 +4199,11 @@
 
   this->stream = stream;
   this->input  = input;
+  this->ptsoffs = this->input->get_optional_data (this->input, NULL, INPUT_OPTIONAL_DATA_PTSOFFS);
+  if (this->ptsoffs) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+        "demux_qt: using input offset %d pts.\n", this->ptsoffs);
+  }
 
   /* fetch bandwidth config */
   this->bandwidth = 0x7FFFFFFFFFFFFFFFLL;  /* assume infinite bandwidth */
diff -urN xine-lib-1.2.11/src/demuxers/demux_shn.c xine-lib-1.2/src/demuxers/demux_shn.c
--- xine-lib-1.2.11/src/demuxers/demux_shn.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/demuxers/demux_shn.c	2022-01-15 22:03:19.577547141 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2018 the xine project
+ * Copyright (C) 2005-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/src/demuxers/demux_snd.c xine-lib-1.2/src/demuxers/demux_snd.c
--- xine-lib-1.2.11/src/demuxers/demux_snd.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/demuxers/demux_snd.c	2022-01-15 22:03:19.583547166 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2001-2018 the xine project
+ * Copyright (C) 2001-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -183,7 +183,7 @@
   }
 
   while (remaining_sample_bytes) {
-    buf = this->audio_fifo->buffer_pool_alloc (this->audio_fifo);
+    buf = this->audio_fifo->buffer_pool_size_alloc (this->audio_fifo, 8 << 10);
     buf->type = this->audio_type;
     if( this->data_size )
       buf->extra_info->input_normpos = (int)( (double) current_file_pos * 65535 / this->data_size);
diff -urN xine-lib-1.2.11/src/demuxers/demux_ts.c xine-lib-1.2/src/demuxers/demux_ts.c
--- xine-lib-1.2.11/src/demuxers/demux_ts.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/demuxers/demux_ts.c	2022-01-15 22:03:19.613547293 +0100
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2022 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -818,6 +818,9 @@
   this->audio_tracks_count = tracks;
   /* should really have no effect */
   this->spu_langs_count = spus;
+
+  _x_stream_info_set (this->stream, XINE_STREAM_INFO_HAS_VIDEO, this->videoPid == INVALID_PID ? 0 : 1);
+  _x_stream_info_set (this->stream, XINE_STREAM_INFO_HAS_AUDIO, this->audio_tracks_count > 0 ? 1 : 0);
 }
 
 static void demux_ts_dynamic_pmt_clear (demux_ts_t *this) {
@@ -2859,6 +2862,123 @@
   }
 }
 
+/* 0 (go on), 1 (recheck), 2 (stop) */
+static int demux_ts_parse_pat_pmt_packet (demux_ts_t*this) {
+
+  const uint8_t *originalPkt;
+  uint32_t       tsp_head;
+  uint32_t       pid;
+  unsigned int   data_offset;
+  unsigned int   data_len;
+  uint32_t       index;
+
+  /* get next synchronised packet, or NULL */
+#if TS_PACKET_READER == 2
+  originalPkt = sync_next (this);
+#elif TS_PACKET_READER == 1
+  originalPkt = demux_synchronise(this);
+#endif
+  if (originalPkt == NULL)
+    return 2;
+
+  tsp_head = _X_BE_32 (originalPkt);
+  pid      = (tsp_head & TSP_pid) >> 8;
+
+  /*
+   * Discard packets that are obviously bad.
+   */
+  if ((tsp_head >> 24) != SYNC_BYTE)
+    return 2;
+  if (tsp_head & TSP_transport_error)
+    return 0;
+  if (tsp_head & TSP_scrambling_control)
+    return 0;
+
+  data_offset = 4;
+
+  if (tsp_head & TSP_adaptation_field_1) {
+    uint32_t adaptation_field_length = originalPkt[4];
+    if (adaptation_field_length > PKT_SIZE - 5)
+      return 0;
+
+    if (adaptation_field_length > 0) {
+      int64_t pcr = demux_ts_adaptation_field_parse (originalPkt+5, adaptation_field_length);
+      if (pid == this->pcr_pid)
+        demux_ts_tbre_update (this, TBRE_MODE_PCR, pcr);
+      else if (pid == this->tbre_pid)
+        demux_ts_tbre_update (this, TBRE_MODE_AUDIO_PCR, pcr);
+    }
+    /*
+     * Skip adaptation header.
+     */
+    data_offset += adaptation_field_length + 1;
+    if (data_offset >= PKT_SIZE) {
+      /* no payload or invalid header */
+      return 0;
+    }
+  }
+
+  if (!(tsp_head & TSP_adaptation_field_0)) {
+    return 0;
+  }
+
+  data_len = PKT_SIZE - data_offset;
+  index = this->pid_index[pid];
+
+  if (!(index & 0x80))
+    return 0;
+
+  if (index != 0xff) {
+    /* PMT */
+    index &= 0x7f;
+    demux_ts_parse_pmt (this, originalPkt + data_offset, tsp_head & TSP_payload_unit_start, data_len, index, pid);
+    return 1;
+  }
+
+  /* PAT */
+  if (pid == 0) {
+    demux_ts_parse_pat (this, originalPkt + data_offset, tsp_head & TSP_payload_unit_start, data_len);
+    return 1;
+  }
+
+  return 0;
+}
+
+static void demux_ts_scan_pat_pmt (demux_ts_t *this) {
+  unsigned int max;
+
+  if ((this->videoPid != INVALID_PID) || (this->audio_tracks_count > 0))
+    return;
+
+  /* we naed first pat/pmt before outputting anything anyway.
+   * do the scan even if the rewind below fails. */
+  for (max = (2 << 20) / 188; max; max--) {
+    int r = demux_ts_parse_pat_pmt_packet (this);
+
+    if (r == 2)
+      break;
+    if (r == 1) {
+      if ((this->videoPid != INVALID_PID) || (this->audio_tracks_count > 0))
+        break;
+    }
+  }
+
+  if ((this->videoPid != INVALID_PID) || (this->audio_tracks_count > 0)) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+      LOG_MODULE ": found pat/pmt after %u packets.\n", (2 << 20) / 188 + 1 - max);
+  }
+
+  if (this->input->seek (this->input, 0, SEEK_SET) == 0) {
+    /* in dvb, pat/pmt repeat every half second regardless of key frames.
+     * rewind did work, lets try to play the very beginning as well :-) */
+#if TS_PACKET_READER == 2
+    this->buf_pos  = 0;
+    this->buf_size = 0;
+#endif
+  }
+}
+
+
 /*
  * check for pids change events
  */
@@ -2979,9 +3099,10 @@
   this->spu_langs_count = 0;
   this->current_spu_channel = -1;
 
-  /* FIXME ? */
-  _x_stream_info_set(this->stream, XINE_STREAM_INFO_HAS_VIDEO, 1);
-  _x_stream_info_set(this->stream, XINE_STREAM_INFO_HAS_AUDIO, 1);
+  _x_stream_info_set (this->stream, XINE_STREAM_INFO_HAS_VIDEO, 1);
+  _x_stream_info_set (this->stream, XINE_STREAM_INFO_HAS_AUDIO, 1);
+
+  demux_ts_scan_pat_pmt (this);
 }
 
 static int demux_ts_seek (demux_plugin_t *this_gen,
@@ -3000,7 +3121,7 @@
     /* Append sequence end code to video stream. */
     /* Keep ffmpeg h.264 video decoder from piling up too many DR1 frames, */
     /* and thus freezing video out. */
-    if (this->videoPid != INVALID_PID && this->video_fifo)
+    if (this->videoPid != INVALID_PID)
       post_sequence_end (this->video_fifo, this->media[this->videoMedia].type);
   }
 
@@ -3241,18 +3362,18 @@
 static int detect_ts (const uint32_t *buf, size_t len) {
   uint32_t stats_ts[188 / 4], stats_hdmv[192 / 4];
   /* Fold 188 or 192 counter slots over the buffer.
-   * Count bytes that "fail" to be 0x47.
-   * Consider a slot failed when >= 20% (1/5) of its bytes fail.
+   * Count bytes that are 0x47.
+   * Consider a slot passed when >= 80% (4/5) of its bytes match.
    * NOTE: this works with buffer size <= 188 * 127, or 23876.
    * we just need 2048. */
   {
     uint32_t i, v;
-    v = 128 - len / (5 * 188);
+    v = 128 - len * 4 / (5 * 188);
     v += v << 8;
     v += v << 16;
     for (i = 0; i < 188 / 4; i++)
       stats_ts[i] = v;
-    v = 128 - len / (5 * 192);
+    v = 128 - len * 4 / (5 * 192);
     v += v << 8;
     v += v << 16;
     for (i = 0; i < 192 / 4; i++)
@@ -3266,12 +3387,8 @@
     while (b < e) {
       /* misuse plain int as a vector register.
        * endian does not matter here. */
-      uint32_t a = *b++;
-      a ^= 0x47474747;
-      a |= a >> 4;
-      a |= a >> 2;
-      a |= a >> 1;
-      a &= 0x01010101;
+      uint32_t a = *b++ ^ ~0x47474747;
+      a = ((a & 0x80808080) & ((a & 0x7f7f7f7f) + 0x01010101)) >> 7;
       stats_ts[i] += a;
       stats_hdmv[j] += a;
       if (--i < 0)
@@ -3289,7 +3406,6 @@
     s += s >> 16;
     s += s >> 8;
     s &= 0x000000ff;
-    s = 188 - s;
     /* 0x47 may appear again in packet head. */
     if ((s > 0) && (s < 5))
       return 0;
@@ -3299,7 +3415,6 @@
     s += s >> 16;
     s += s >> 8;
     s &= 0x000000ff;
-    s = 192 - s;
     /* 0x47 may appear again in packet head, and in timestamp field.
      * FIXME: main read resync code is not really prepared for the latter. */
     if ((s > 0) && (s < 7))
@@ -3475,4 +3590,3 @@
 
   return (void *)&demux_ts_class;
 }
-
diff -urN xine-lib-1.2.11/src/demuxers/demux_tta.c xine-lib-1.2/src/demuxers/demux_tta.c
--- xine-lib-1.2.11/src/demuxers/demux_tta.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/demuxers/demux_tta.c	2022-01-15 22:03:19.582547162 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006-2018 the xine project
+ * Copyright (C) 2006-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -46,7 +46,6 @@
   demux_plugin_t       demux_plugin;
 
   xine_stream_t       *stream;
-  fifo_buffer_t       *video_fifo;
   fifo_buffer_t       *audio_fifo;
   input_plugin_t      *input;
 
diff -urN xine-lib-1.2.11/src/demuxers/demux_vmd.c xine-lib-1.2/src/demuxers/demux_vmd.c
--- xine-lib-1.2.11/src/demuxers/demux_vmd.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/demuxers/demux_vmd.c	2022-01-15 22:03:19.608547272 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2004-2018 the xine project
+ * Copyright (C) 2004-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -160,6 +160,8 @@
 
   raw_frame_table_size = this->frame_count * BYTES_PER_FRAME_RECORD;
   raw_frame_table = malloc(raw_frame_table_size);
+  if (!raw_frame_table)
+    return 0;
   if (this->input->read(this->input, raw_frame_table, raw_frame_table_size) !=
     raw_frame_table_size) {
     free(raw_frame_table);
@@ -167,6 +169,10 @@
   }
 
   this->frame_table = calloc(this->frame_count, sizeof(vmd_frame_t));
+  if (!this->frame_table) {
+    free(raw_frame_table);
+    return 0;
+  }
 
   current_offset = this->data_start = _X_LE_32(&vmd_header[20]);
   this->data_size = toc_offset - this->data_start;
diff -urN xine-lib-1.2.11/src/dxr3/dxr3_decode_video.c xine-lib-1.2/src/dxr3/dxr3_decode_video.c
--- xine-lib-1.2.11/src/dxr3/dxr3_decode_video.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/dxr3/dxr3_decode_video.c	2022-01-15 22:03:19.589547192 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -239,7 +239,7 @@
   this->sync_every_frame      = cfg->register_bool(cfg,
     "dxr3.playback.sync_every_frame", 0, _("try to sync video every frame"),
     _("Tries to set a synchronization timestamp for every frame. "
-      "Normally this is not necessary, because sync is sufficent "
+      "Normally this is not necessary, because sync is sufficient "
       "even when the timestamp is set only every now and then.\n"
       "This is relevant for progressive video only (most PAL films)."),
     20, dxr3_update_sync_mode, this);
diff -urN xine-lib-1.2.11/src/dxr3/dxr3_scr.c xine-lib-1.2/src/dxr3/dxr3_scr.c
--- xine-lib-1.2.11/src/dxr3/dxr3_scr.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/dxr3/dxr3_scr.c	2022-01-15 22:03:19.609547276 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -76,6 +76,8 @@
   char tmpstr[128];
 
   this = calloc(1, sizeof(dxr3_scr_t));
+  if (!this)
+    return NULL;
 
   devnum = xine->config->register_num(xine->config,
     CONF_KEY, 0, CONF_NAME, CONF_HELP, 10, NULL, NULL);
diff -urN xine-lib-1.2.11/src/dxr3/ffmpeg_encoder.c xine-lib-1.2/src/dxr3/ffmpeg_encoder.c
--- xine-lib-1.2.11/src/dxr3/ffmpeg_encoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/dxr3/ffmpeg_encoder.c	2022-01-15 22:03:19.609547276 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a unix video player.
  *
@@ -75,6 +75,9 @@
   AVFrame            *picture;         /* picture to be encoded */
   uint8_t            *out[3];          /* aligned buffer for YV12 data */
   uint8_t            *buf;     /* base address of YV12 buffer */
+#if XFF_ENCVIDEO > 1
+  XFF_PACKET_DECL (pkt);
+#endif
 } lavc_data_t;
 
 
@@ -98,6 +101,9 @@
   XFF_AVCODEC_INIT();
 
   XFF_AVCODEC_REGISTER_ALL();
+#if XFF_ENCVIDEO > 1
+  XFF_PACKET_NEW (this->pkt);
+#endif
 
   this->encoder_data.type             = ENC_LAVC;
   this->encoder_data.on_update_format = lavc_on_update_format;
@@ -255,13 +261,13 @@
 
 static int lavc_on_display_frame(dxr3_driver_t *drv, dxr3_frame_t *frame)
 {
+  lavc_data_t* this = (lavc_data_t *)drv->enc;
 #if XFF_ENCVIDEO == 1
   int size;
 #else /* 2, 3 */
-  AVPacket pkt = {.data = NULL};
   int ret, got_output;
+  this->pkt->data = NULL;
 #endif
-  lavc_data_t* this = (lavc_data_t *)drv->enc;
   ssize_t written;
 
   if (frame->vo_frame.bad_frame) return 1;
@@ -279,12 +285,12 @@
 #if XFF_ENCVIDEO == 1
   size = avcodec_encode_video(this->context, this->ffmpeg_buffer, DEFAULT_BUFFER_SIZE, this->picture);
 #elif XFF_ENCVIDEO == 2
-  ret = avcodec_encode_video2(this->context, &pkt, this->picture, &got_output);
+  ret = avcodec_encode_video2(this->context, this->pkt, this->picture, &got_output);
 #else /* 3 */
   got_output = 0;
   ret = avcodec_send_frame (this->context, this->picture);
   if ((ret >= 0) || (ret == AVERROR (EAGAIN))) {
-    ret = avcodec_receive_packet (this->context, &pkt);
+    ret = avcodec_receive_packet (this->context, this->pkt);
     got_output = (ret == 0);
     ret = (ret == AVERROR (EAGAIN)) ? 0 : ret;
   }
@@ -310,13 +316,10 @@
 #if XFF_ENCVIDEO == 1
   written = write(drv->fd_video, this->ffmpeg_buffer, size);
 #else /* 2, 3 */
-  written = write(drv->fd_video, pkt.data, pkt.size);
+  written = write(drv->fd_video, this->pkt->data, this->pkt->size);
 #endif
 
   if (written < 0) {
-#if XFF_ENCVIDEO >= 2
-      av_packet_unref(&pkt);
-#endif
       xprintf(drv->class->xine, XINE_VERBOSITY_LOG,
         "dxr3_mpeg_encoder: video device write failed (%s)\n", strerror(errno));
       return 0;
@@ -326,10 +329,9 @@
       xprintf(drv->class->xine, XINE_VERBOSITY_LOG,
         "dxr3_mpeg_encoder: Could only write %zd of %d mpeg bytes.\n", written, size);
 #else /* 2, 3 */
-  if (written != pkt.size)
+  if (written != this->pkt->size)
       xprintf(drv->class->xine, XINE_VERBOSITY_LOG,
-        "dxr3_mpeg_encoder: Could only write %zd of %d mpeg bytes.\n", written, pkt.size);
-  av_packet_unref(&pkt);
+        "dxr3_mpeg_encoder: Could only write %zd of %d mpeg bytes.\n", written, this->pkt->size);
 #endif
   return 1;
 }
@@ -339,6 +341,9 @@
   lavc_data_t *this = (lavc_data_t *)drv->enc;
   lprintf("flushing buffers\n");
   if (this->context) {
+#if XFF_ENCVIDEO > 1
+    XFF_PACKET_UNREF (this->pkt);
+#endif
     avcodec_close(this->context);
     XFF_FREE_CONTEXT (this->context);
     free(this->picture);
@@ -398,3 +403,4 @@
   this->picture->linesize[2] = this->context->width / 2;
   return 1;
 }
+
diff -urN xine-lib-1.2.11/src/input/group_network.c xine-lib-1.2/src/input/group_network.c
--- xine-lib-1.2.11/src/input/group_network.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/group_network.c	2022-01-15 22:03:19.580547154 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017-2020 the xine project
+ * Copyright (C) 2017-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -48,6 +48,7 @@
   { PLUGIN_INPUT,                       18, "ftp",  XINE_VERSION_CODE, NULL, input_ftp_init_class },
   { PLUGIN_INPUT,                       18, "ftpes", XINE_VERSION_CODE, NULL, input_ftpes_init_class },
   { PLUGIN_INPUT | PLUGIN_MUST_PRELOAD, 18, "hls",  XINE_VERSION_CODE, &input_hls_info, input_hls_init_class },
+  { PLUGIN_INPUT,                       18, "mpegdash", XINE_VERSION_CODE, &input_hls_info, input_mpegdash_init_class },
   { PLUGIN_NONE, 0, NULL, 0, NULL, NULL }
 };
 
diff -urN xine-lib-1.2.11/src/input/group_network.h xine-lib-1.2/src/input/group_network.h
--- xine-lib-1.2.11/src/input/group_network.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/group_network.h	2022-01-15 22:03:19.590547196 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017-2020 the xine project
+ * Copyright (C) 2017-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -31,3 +31,4 @@
 void *input_ftp_init_class  (xine_t *xine, const void *data);
 void *input_ftpes_init_class(xine_t *xine, const void *data);
 void *input_hls_init_class  (xine_t *xine, const void *data);
+void *input_mpegdash_init_class (xine_t *xine, const void *data);
diff -urN xine-lib-1.2.11/src/input/input_cdda.c xine-lib-1.2/src/input/input_cdda.c
--- xine-lib-1.2.11/src/input/input_cdda.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_cdda.c	2022-01-15 22:03:19.586547179 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -2328,7 +2328,7 @@
 
   buf_element_t *buf;
 
-  buf = fifo->buffer_pool_alloc(fifo);
+  buf = fifo->buffer_pool_size_alloc (fifo, 8 << 10);
   buf->content = buf->mem;
   buf->type = BUF_DEMUX_BLOCK;
 
diff -urN xine-lib-1.2.11/src/input/input_dvb.c xine-lib-1.2/src/input/input_dvb.c
--- xine-lib-1.2.11/src/input/input_dvb.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_dvb.c	2022-01-15 22:03:19.605547259 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -36,7 +36,7 @@
  *               no data is in cache.
  *             - Tried to stabilize the EPG updater thread.
  *             - Fixed a tuning problem I had with Linux 2.6.11-rc2.
- *             - Now tuning to an erroneus channel shouldn't hang but stop
+ *             - Now tuning to an erroneous channel shouldn't hang but stop
  *               the playback and output a log describing the error.
  *             - Style cleanups here and there.
  *
@@ -2506,7 +2506,7 @@
 	  pthread_mutex_unlock( &this->channel_change_mutex );
           xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
 		  "input_dvb: Channel \"%s\" could not be tuned in. "
-		  "Possibly erroneus settings in channels.conf "
+		  "Possibly erroneous settings in channels.conf "
 		  "(frequency changed?).\n",
 		  this->channels[this->channel].name);
 	  return 0;
diff -urN xine-lib-1.2.11/src/input/input_file.c xine-lib-1.2/src/input/input_file.c
--- xine-lib-1.2.11/src/input/input_file.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_file.c	2022-01-15 22:03:19.573547124 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -32,6 +32,7 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <string.h>
+#include <time.h>
 #include <errno.h>
 
 #ifdef HAVE_MMAP
@@ -78,6 +79,12 @@
   xine_stream_t    *stream;
 
   int               fh;
+  enum {
+    FILE_STATIC = 0,
+    FILE_PROGRESSIVE,
+    FILE_DONE
+  }                 state;
+  off_t             size;
 #ifdef HAVE_MMAP
   int               mmap_on;
   uint8_t          *mmap_base;
@@ -88,6 +95,18 @@
 
 } file_input_plugin_t;
 
+static void file_input_size (file_input_plugin_t *this, const struct stat *sbuf) {
+  if ((sbuf->st_size != this->size) &&
+#ifdef HAVE_MMAP
+    !this->mmap_on &&
+#endif
+    (this->state != FILE_PROGRESSIVE) && S_ISREG (sbuf->st_mode)) {
+    this->state = FILE_PROGRESSIVE;
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+      LOG_MODULE ": \"%s\" changed size, will wait for possible updates.\n", this->mrl);
+  }
+  this->size = sbuf->st_size;
+}
 
 static uint32_t file_input_get_capabilities (input_plugin_t *this_gen) {
 
@@ -102,12 +121,17 @@
 	return INPUT_CAP_CLONE | INPUT_CAP_SEEKABLE;
 #else
   if (fstat (this->fh, &buf) == 0) {
+    file_input_size (this, &buf);
     if (S_ISREG(buf.st_mode))
       return INPUT_CAP_CLONE | INPUT_CAP_SEEKABLE;
     else
       return 0;
-  } else
-    perror ("system call fstat");
+  } else {
+    int e = errno;
+
+    xprintf (this->stream->xine, XINE_VERBOSITY_LOG,
+        LOG_MODULE ": fstat (): %s.\n", strerror (e));
+  }
   return 0;
 #endif /* _MSC_VER */
 }
@@ -138,12 +162,17 @@
     return 0;
   }
 
+  file_input_size (this, &sbuf);
+
   return 1;
 }
 #endif
 
 static off_t file_input_read (input_plugin_t *this_gen, void *buf, off_t len) {
   file_input_plugin_t *this = (file_input_plugin_t *) this_gen;
+  uint8_t *b;
+  ssize_t r, left;
+  int try;
 
   if (len < 0)
     return -1;
@@ -161,7 +190,51 @@
   }
 #endif
 
-  return read (this->fh, buf, len);
+  b = (uint8_t *)buf;
+  left = len;
+  r = 0;
+  while (left > 0) {
+    r = read (this->fh, b, left);
+    if (r <= 0)
+      break;
+    b += r;
+    left -= r;
+  }
+  if (r < 0)
+    return r;
+  r = b - (uint8_t *)buf;
+  if (r == len)
+    return len;
+
+  /* poll for updates only when playing, dont delay plain xine_open (). */
+  if (this->state != FILE_PROGRESSIVE)
+    return r;
+  if (!_x_demux_called_from (this->stream))
+    return r;
+
+  try = 2 - 1;
+  while (left > 0) {
+    /* _x_io_select (, this->fh, ) tends to return XIO_READY immediately. */
+    if (_x_io_select (this->stream, -1, XIO_READ_READY, 1000) == XIO_ABORTED)
+      break;
+    r = read (this->fh, b, left);
+    if (r > 0) {
+      try = 2 - 1;
+      b += r;
+      left -= r;
+    } else if (r < 0) {
+      return r;
+    } else if (--try < 0) {
+      break;
+    }
+  }
+  r = b - (uint8_t *)buf;
+  if (r != len) {
+    this->state = FILE_DONE;
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+      LOG_MODULE ": \"%s\": no update, assuming real EOF.\n", this->mrl);
+  }
+  return r;
 }
 
 static buf_element_t *file_input_read_block (input_plugin_t *this_gen, fifo_buffer_t *fifo, off_t todo) {
@@ -258,6 +331,7 @@
 #endif
 
   if (fstat (this->fh, &buf) == 0) {
+    file_input_size (this, &buf);
     return buf.st_size;
   } else
     perror ("system call fstat");
@@ -313,6 +387,7 @@
   file_input_plugin_t *this = (file_input_plugin_t *) this_gen;
   char                *filename;
   struct stat          sbuf;
+  int                  sres;
 
   lprintf("file_input_open\n");
 
@@ -330,8 +405,8 @@
   if (!filename)
     return -1;
 
-  this->fh = xine_open_cloexec(filename, O_RDONLY|O_BINARY);
-
+  this->fh = xine_open_cloexec (filename, O_RDONLY | O_BINARY);
+  _x_freep (&filename);
   if (this->fh == -1) {
     if (errno == EACCES) {
       _x_message(this->stream, XINE_MSG_PERMISSION_ERROR, this->mrl, NULL);
@@ -342,12 +417,23 @@
       xine_log (this->stream->xine, XINE_LOG_MSG,
                 _("input_file: File not found: >%s<\n"), this->mrl);
     }
-
-    free(filename);
     return -1;
   }
 
-  _x_freep(&filename);
+  sres = fstat (this->fh, &sbuf);
+
+  if (!sres) {
+    this->size = sbuf.st_size;
+    if (S_ISREG (sbuf.st_mode)) {
+      time_t now = time (NULL);
+
+      if ((sbuf.st_mtime <= now) && (sbuf.st_mtime + 10 >= now)) {
+        this->state = FILE_PROGRESSIVE;
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+          LOG_MODULE ": \"%s\" is quite recent, will wait for possible updates.\n", this->mrl);
+      }
+    }
+  }
 
 #ifdef HAVE_MMAP
   this->mmap_on = 0;
@@ -357,23 +443,32 @@
 #endif
 
   /* don't check length of fifo or character device node */
-  if (fstat (this->fh, &sbuf) == 0) {
-    if (!S_ISREG(sbuf.st_mode))
-      return 1;
-  }
+  if (!sres && !S_ISREG (sbuf.st_mode))
+    return 1;
 
 #ifdef HAVE_MMAP
-  {
-    size_t tmp_size = sbuf.st_size; /* may cause truncation - if it does, DON'T mmap! */
-    if ((tmp_size == sbuf.st_size) &&
-	( (this->mmap_base = mmap(NULL, tmp_size, PROT_READ, MAP_SHARED, this->fh, 0)) != (void*)-1 )) {
-      this->mmap_on = 1;
-      this->mmap_curr = this->mmap_base;
-      this->mmap_len = sbuf.st_size;
-    } else {
-      this->mmap_base = NULL;
+  this->mmap_base = NULL;
+  do {
+    uint8_t mmap_base;
+    size_t tmp_size;
+    /* may cause truncation - if it does, DON'T mmap! */
+    tmp_size = (size_t)sbuf.st_size;
+    if ((off_t)tmp_size != sbuf.st_size)
+      break;
+    mmap_base = mmap (NULL, tmp_size, PROT_READ, MAP_SHARED, this->fh, 0);
+    if (mmap_base == (void*)-1)
+      break;
+    /* paranoia */
+    sres = fstat (this->fh, &sbuf);
+    if (sres || (off_t)tmp_size != sbuf.st_size) {
+      munmap (mmap_base, tmp_size);
+      break;
     }
-  }
+    this->mmap_on = 1;
+    this->mmap_base =
+    this->mmap_curr = mmap_base;
+    this->mmap_len = sbuf.st_size;
+  } while (0);
 #endif
 
   if (file_input_get_length (this_gen) == 0) {
@@ -409,6 +504,8 @@
   this->stream = stream;
   this->mrl    = strdup(mrl);
   this->fh     = -1;
+  this->state  = FILE_STATIC;
+  this->size   = 0;
 
   this->input_plugin.open               = file_input_open;
   this->input_plugin.get_capabilities   = file_input_get_capabilities;
@@ -999,4 +1096,3 @@
   { PLUGIN_NONE, 0, NULL, 0, NULL, NULL }
 };
 #endif
-
diff -urN xine-lib-1.2.11/src/input/input_ftp.c xine-lib-1.2/src/input/input_ftp.c
--- xine-lib-1.2.11/src/input/input_ftp.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_ftp.c	2022-01-15 22:03:19.580547154 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  * Copyright (C) 2018 Petri Hintukainen <phintuka@users.sourceforge.net>
  *
  * This file is part of xine, a free video player.
@@ -479,7 +479,7 @@
 
   if (rc / 100 != 1) {
     xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": "
-            "Failed to retrive file %s: %s\n", uri, this->buf);
+            "Failed to retrieve file %s: %s\n", uri, this->buf);
     return -1;
   }
 
diff -urN xine-lib-1.2.11/src/input/input_hls.c xine-lib-1.2/src/input/input_hls.c
--- xine-lib-1.2.11/src/input/input_hls.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_hls.c	2022-01-15 22:03:19.588547187 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2020 the xine project
+ * Copyright (C) 2020-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -39,6 +39,7 @@
 #include <xine/xineutils.h>
 #include <xine/compat.h>
 #include <xine/input_plugin.h>
+#include <xine/mfrag.h>
 
 #include "http_helper.h"
 #include "input_helper.h"
@@ -51,31 +52,25 @@
   multirate_pref_t  pref;
 } hls_input_class_t;
 
-  typedef struct {
-  uint32_t mrl_offs;
-  uint32_t start_msec;
-  off_t    byte_size;
-  off_t    start_offs;
-} hls_frag_info_t;
-
 typedef struct {
   input_plugin_t    input_plugin;
   xine_stream_t    *stream;
+  xine_nbc_t       *nbc;
   input_plugin_t   *in1;
-  off_t             size1;
   uint32_t          caps1;
-  hls_frag_info_t  *frags, *current_frag;
+  struct {
+    xine_mfrag_list_t *list;
+    uint64_t          *input_offs; /** << bytes + 1, or 0 if unset */
+    uint32_t          *mrl_offs; /** << offs into list_buf */
+    off_t              pos;
+    off_t              size;
+    int64_t            pts;
+    uint32_t           num;
+    uint32_t           current; /** << 1..n or 0 (none) */
+  }                 frag;
+  off_t             pos;
   char             *list_buf;
   uint32_t          list_bsize;
-  uint32_t          frag_have;
-  uint32_t          frag_max;
-  off_t             est_size;
-  off_t             seen_size;
-  off_t             live_pos;
-  uint32_t          seen_num;
-  uint32_t          seen_avg;
-  uint32_t          duration;
-  uint32_t          pos_in_frag;
   enum {
     LIST_VOD,
     LIST_LIVE_BUMP,
@@ -83,6 +78,11 @@
   }                 list_type;
   uint32_t          list_seq;
   uint32_t          items_num;
+  uint32_t          prev_size1; /** << the actual preview bytes, for INPUT_OPTIONAL_DATA_[SIZED]_PREVIEW. */
+  uint32_t          prev_size2; /** << for read (), 0 after leaving that range. */
+  struct timespec   frag_dur;   /** << != 0 if fixed duration live frags */
+  struct timespec   next_stop;  /** << live timeline emulation */
+  int               rewind;     /** << seconds */
   const char       *items_mrl[20];
   multirate_pref_t  items[20];
   const char       *list_strtype;
@@ -90,6 +90,7 @@
 #define HLS_MAX_MRL 4096
   char              list_mrl[HLS_MAX_MRL];
   char              item_mrl[HLS_MAX_MRL];
+  char              prev_item_mrl[HLS_MAX_MRL];
   size_t            bump_pos;
   size_t            bump_size;
   uint32_t          bump_seq;
@@ -97,8 +98,74 @@
   char              bump1[HLS_MAX_MRL];
   char              pad2[4];
   char              bump2[HLS_MAX_MRL];
+  char              preview[32 << 10];
 } hls_input_plugin_t;
 
+#ifdef HAVE_POSIX_TIMERS
+#  define xine_gettime(t) clock_gettime (CLOCK_REALTIME, t)
+#else
+static inline int xine_gettime (struct timespec *ts) {
+  struct timeval tv;
+  int r;
+  r = gettimeofday (&tv, NULL);
+  if (!r) {
+    ts->tv_sec  = tv.tv_sec;
+    ts->tv_nsec = tv.tv_usec * 1000;
+  }
+  return r;
+}
+#endif
+
+
+static int hls_get_duration (hls_input_plugin_t *this) {
+  int64_t d = 0;
+  if (!xine_mfrag_get_index_start (this->frag.list, this->frag.num + 1, &d, NULL))
+    return 0;
+  return d / 1000;
+}
+
+static off_t hls_get_size (hls_input_plugin_t *this) {
+  int64_t s = 0;
+  xine_mfrag_get_index_start (this->frag.list, this->frag.num + 1, NULL, &s);
+  if (this->pos > s)
+    s = this->pos;
+  return s;
+}
+
+static uint32_t hls_frag_start (hls_input_plugin_t *this) {
+  int64_t s1, s2;
+  this->frag.pos = this->pos;
+  /* known size */
+  xine_mfrag_get_index_frag (this->frag.list, this->frag.current, NULL, &s1);
+  /* seen size */
+  s2 = this->in1->get_length (this->in1);
+  /* subfragment? */
+  if (this->frag.input_offs[this->frag.current - 1]) {
+    this->frag.size = s1;
+    if (s1 > 0)
+      return s1;
+    s2 -= this->frag.input_offs[this->frag.current - 1] - 1;
+  }
+  /* update size */
+  this->frag.size = s2;
+  if (s2 > 0) {
+    if ((s1 > 0) && (s1 != s2)) {
+      xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+        "input_hls: WTF: fragment #%u changed size from %" PRId64 " to %" PRId64 " bytes!!\n",
+        (unsigned int)this->frag.current, s1, s2);
+    }
+    xine_mfrag_set_index_frag (this->frag.list, this->frag.current, -1, s2);
+    return s2;
+  }
+  return s2;
+}
+
+static void hls_frag_end (hls_input_plugin_t *this) {
+  int64_t s;
+  s = this->pos - this->frag.pos;
+  xine_mfrag_set_index_frag (this->frag.list, this->frag.current, -1, s);
+}
+
 static int hls_bump_find (hls_input_plugin_t *this, const char *item1, const char *seq) {
   size_t len1, len2;
   uint8_t *p1, *ps, s;
@@ -216,6 +283,7 @@
 }
 
 static int hls_input_switch_mrl (hls_input_plugin_t *this) {
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "input_hls: %s.\n", this->item_mrl);
   if (this->in1) {
     if (this->in1->get_capabilities (this->in1) & INPUT_CAP_NEW_MRL) {
       if (this->in1->get_optional_data (this->in1, this->item_mrl,
@@ -236,57 +304,55 @@
 
 static int hls_input_open_bump (hls_input_plugin_t *this) {
   /* bump mode */
-    _x_merge_mrl (this->item_mrl, HLS_MAX_MRL, this->list_mrl, this->bump1);
-    return hls_input_switch_mrl (this);
+  _x_merge_mrl (this->item_mrl, HLS_MAX_MRL, this->list_mrl, this->bump1);
+  if (!hls_input_switch_mrl (this))
+    return 0;
+  this->caps1 = this->in1->get_capabilities (this->in1);
+  hls_frag_start (this);
+  return 1;
 }
 
 static int hls_input_open_item (hls_input_plugin_t *this, uint32_t n) {
-  hls_frag_info_t *frag;
   /* valid index ? */
-  if (n >= this->frag_have)
+  if ((n < 1) || (n > this->frag.num))
     return 0;
+  strcpy (this->prev_item_mrl, this->item_mrl);
   /* get fragment mrl */
-  _x_merge_mrl (this->item_mrl, HLS_MAX_MRL, this->list_mrl, this->list_buf + this->frags[n].mrl_offs);
+  _x_merge_mrl (this->item_mrl, HLS_MAX_MRL, this->list_mrl, this->list_buf + this->frag.mrl_offs[n - 1]);
   /* get input */
-  this->caps1 = 0;
-  if (!hls_input_switch_mrl (this))
-    return 0;
-  this->caps1 = this->in1->get_capabilities (this->in1);
-  /* query fragment */
-  this->size1 = this->in1->get_length (this->in1);
-  if (this->size1 <= 0)
-    return 0;
-  /* update size info */
-  this->pos_in_frag = 0;
-  frag = this->frags + n;
-  this->current_frag = frag;
-  if (frag->byte_size == 0) {
-    this->seen_num += 1;
-    this->seen_size += this->size1;
-  } else if (frag->byte_size != this->size1) {
-    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-      "input_hls: WTF: fragment #%u changed size from %" PRId64 " to %" PRId64 " bytes!!\n",
-      (unsigned int)n, (int64_t)frag->byte_size, (int64_t)this->size1);
-    this->seen_size += this->size1 - frag->byte_size;
+  if (strcmp (this->prev_item_mrl, this->item_mrl)) {
+    this->caps1 = 0;
+    if (!hls_input_switch_mrl (this))
+      return 0;
   } else {
-    n = ~0u;
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+      "input_hls: reuse %s for fragment #%u.\n", (const char *)this->item_mrl, (unsigned int)n);
   }
-  if (n != ~0u) {
-    uint32_t u;
-    off_t pos;
-    frag->byte_size = this->size1;
-    this->seen_avg = this->seen_size / this->seen_num;
-    pos = frag->start_offs;
-    /* dont shift current pos as this would confuse demuxers too much. */
-    for (u = this->frag_have - n; u; u--) {
-      frag->start_offs = pos;
-      pos += frag->byte_size == 0 ? this->seen_avg : frag->byte_size;
-      frag++;
+  this->caps1 = this->in1->get_capabilities (this->in1);
+  /* input offset */
+  do {
+    int64_t old_pos = this->in1->get_current_pos (this->in1), new_pos;
+    if (old_pos < 0)
+      break;
+    if (!this->frag.input_offs[n - 1])
+      break;
+    new_pos = this->frag.input_offs[n - 1] - 1;
+    if (old_pos == new_pos)
+      break;
+    if (this->caps1 & (INPUT_CAP_SEEKABLE | INPUT_CAP_SLOW_SEEKABLE)) {
+      xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+        "input_hls: seek into fragment @ %" PRId64 ".\n", new_pos);
+      old_pos = this->in1->seek (this->in1, new_pos, SEEK_SET);
+      if (old_pos == new_pos)
+        break;
     }
-    frag->start_offs = pos;
-    this->est_size = pos;
-  }
-  this->bump_seq = this->list_seq + n;
+    xprintf (this->stream->xine, XINE_VERBOSITY_LOG,
+      "input_hls: sub input seek failed.\n");
+  } while (0);
+  this->frag.current = n;
+  /* update size info */
+  hls_frag_start (this);
+  this->bump_seq = this->list_seq + n - 1;
   return 1;
 }
 
@@ -312,6 +378,35 @@
   return 0;
 }
 
+static const uint8_t hls_tab_char[256] = {
+  ['\t'] = 1,
+  [' ']  = 1,
+  ['\r'] = 2,
+  ['\n'] = 2,
+  [0]    = 128
+};
+
+static void hls_skip_spc (char **s) {
+  uint8_t *p = (uint8_t *)*s;
+  while (hls_tab_char[*p] & 1)
+    p++;
+  *s = (char *)p;
+}
+
+static void hls_skip_newline_spc (char **s) {
+  uint8_t *p = (uint8_t *)*s;
+  while (hls_tab_char[*p] & (1 | 2))
+    p++;
+  *s = (char *)p;
+}
+
+static void hls_skip_line (char **s) {
+  uint8_t *p = (uint8_t *)*s;
+  while (!(hls_tab_char[*p] & (2 | 128)))
+    p++;
+  *s = (char *)p;
+}
+
 static uint32_t str2uint32 (char **s) {
   uint8_t *p = (uint8_t *)*s;
   uint32_t v = 0;
@@ -324,7 +419,19 @@
   return v;
 }
 
-static uint32_t str2msec (char **s) {
+static uint64_t str2uint64 (char **s) {
+  uint8_t *p = (uint8_t *)*s;
+  uint64_t v = 0;
+  uint8_t z;
+  while ((z = *p ^ '0') < 10) {
+    v = (v << 3) + (v << 1) + z;
+    p++;
+  }
+  *s = (char *)p;
+  return v;
+}
+
+static uint32_t str2usec (char **s) {
   uint8_t *p = (uint8_t *)*s;
   uint32_t v = 0;
   uint8_t z;
@@ -332,22 +439,36 @@
     v = v * 10u + z;
     p++;
   }
-  v *= 1000u;
-  if (z == ('.' ^ '0')) {
+  v *= 1000000;
+  do {
+    if (z != ('.' ^ '0'))
+      break;
     p++;
-    if ((z = *p ^ '0') < 10) {
-      v += 100u * z;
-      p++;
-      if ((z = *p ^ '0') < 10) {
-        v += 10u * z;
-        p++;
-        if ((z = *p ^ '0') < 10) {
-          v += z;
-          p++;
-        }
-      }
-    }
-  }
+    if ((z = *p ^ '0') >= 10)
+      break;
+    v += 100000u * z;
+    p++;
+    if ((z = *p ^ '0') >= 10)
+      break;
+    v += 10000u * z;
+    p++;
+    if ((z = *p ^ '0') >= 10)
+      break;
+    v += 1000u * z;
+    p++;
+    if ((z = *p ^ '0') >= 10)
+      break;
+    v += 100u * z;
+    p++;
+    if ((z = *p ^ '0') >= 10)
+      break;
+    v += 10u * z;
+    p++;
+    if ((z = *p ^ '0') >= 10)
+      break;
+    v += z;
+    p++;
+  } while (0);
   *s = (char *)p;
   return v;
 }
@@ -355,15 +476,12 @@
 static int hls_input_load_list (hls_input_plugin_t *this) {
   ssize_t size;
   char *line, *lend;
-  uint32_t frag_start, frag_duration;
+  uint32_t frag_duration, fixed_duration;
 
-  _x_freep (&this->frags);
-  this->frag_have = 0;
-  this->frag_max  = 0;
-  this->est_size  = 0;
-  this->seen_size = 0;
-  this->seen_num  = 0;
-  this->seen_avg  = 0;
+  this->frag.mrl_offs = NULL;
+  _x_freep (&this->frag.input_offs);
+  xine_mfrag_list_close (&this->frag.list);
+  this->frag.num = 0;
   this->items_num = 0;
 
   {
@@ -416,78 +534,98 @@
   memset (this->list_buf, 0, 4);
   memset (this->list_buf + 4 + size, 0, 4);
 
-  this->frags = malloc (256 * sizeof (this->frags[0]));
-  if (!this->frags) {
-    this->list_bsize = 0;
-    _x_freep (&this->list_buf);
-    return 0;
-  }
-  this->frag_max = 256;
-
   this->list_seq = 1;
   this->list_strseq = "";
   this->list_strtype = "";
 
-  frag_start    = 0;
+  fixed_duration = 0;
   frag_duration = 0;
   lend = this->list_buf + 4;
 
   if (strstr (lend, "#EXTINF:")) {
+    uint32_t fragsize = ~0u;
     /* fragment list */
+    {
+      uint8_t *mem;
+      uint32_t n = 0;
+      while (1) {
+        hls_skip_newline_spc (&lend);
+        if (lend[0] == 0)
+          break;
+        if (lend[0] != '#')
+          n++;
+        hls_skip_line (&lend);
+      }
+      if (n == 0)
+        return 0;
+      mem = malloc ((n + 2) * (sizeof (*this->frag.input_offs) + sizeof (this->frag.mrl_offs)));
+      if (!mem)
+        return 0;
+      this->frag.input_offs = (uint64_t *)mem;
+      mem += (n + 2) * sizeof (*this->frag.input_offs);
+      this->frag.mrl_offs = (uint32_t *)mem;
+    }
+    this->frag.mrl_offs[0] = 0;
+    this->frag.input_offs[0]= 0;
+    xine_mfrag_list_open (&this->frag.list);
+    xine_mfrag_set_index_frag (this->frag.list, 0, 1000000, 0);
+    lend = this->list_buf + 4;
     while (1) {
       size_t llen;
       /* find next line */
-      while (((lend[0] & 0xe0) == 0) && (lend[0] != 0))
-        lend++;
+      hls_skip_newline_spc (&lend);
       if (lend[0] == 0)
         break;
       line = lend;
-      while ((lend[0] & 0xe0) != 0)
-        lend++;
+      hls_skip_line (&lend);
       llen = lend - line;
-      *lend++ = 0;
+      if (lend[0] != 0)
+        *lend++ = 0;
       if ((llen >=4) && !strncasecmp (line, "#EXT", 4)) {
         /* control tag */
         if ((llen > 8) && !strncasecmp (line + 4, "INF:", 4)) {
           line += 8;
-          frag_duration = str2msec (&line);
+          frag_duration = str2usec (&line);
+          if (fixed_duration == 0)
+            fixed_duration = frag_duration;
+          else if (fixed_duration != frag_duration)
+            fixed_duration = ~0u;
+        } else if ((llen > 17) && !strncasecmp (line + 4, "-X-BYTERANGE:", 13)) {
+          line += 17;
+          hls_skip_spc (&line);
+          fragsize = str2uint32 (&line);
+          hls_skip_spc (&line);
+          if (*line == '@') {
+            line++;
+            hls_skip_spc (&line);
+            this->frag.input_offs[this->frag.num] = str2uint64 (&line) + 1;
+          } else {
+            this->frag.input_offs[this->frag.num] = 1;
+          }
         } else if ((llen > 22) && !strncasecmp (line + 4, "-X-MEDIA-SEQUENCE:", 18)) {
-          for (line += 22; *line == ' '; line++) ;
+          line += 22;
+          hls_skip_spc (&line);
           this->list_strseq = line;
           if (line[0])
             this->list_seq = str2uint32 (&line);
         } else if ((llen > 21) && !strncasecmp (line + 4, "-X-PLAYLIST-TYPE:", 17)) {
-          for (line += 21; *line == ' '; line++) ;
+          line += 21;
+          hls_skip_spc (&line);
           this->list_strtype = line;
         }
       } else if ((llen >= 1) && (line[0] != '#')) {
-        hls_frag_info_t *frag;
         /* mrl */
-        if (this->frag_have + 1 >= this->frag_max) {
-          uint32_t nsize = this->frag_max + 256;
-          frag = realloc (this->frags, nsize * sizeof (this->frags[0]));
-          if (!frag)
-            break;
-          this->frags = frag;
-          this->frag_max = nsize;
-        }
-        frag = this->frags + this->frag_have;
-        frag->mrl_offs = line - this->list_buf;
-        frag->start_msec = frag_start;
-        frag_start += frag_duration;
-        frag->byte_size = 0;
-        frag->start_offs = 0;
-        this->frag_have++;
+        this->frag.mrl_offs[this->frag.num] = line - this->list_buf;
+        this->frag.num += 1;
+        this->frag.mrl_offs[this->frag.num] = 0;
+        this->frag.input_offs[this->frag.num] = 0;
+        xine_mfrag_set_index_frag (this->frag.list, this->frag.num, frag_duration, fragsize != ~0u ? (int64_t)fragsize : -1);
       }
     }
-    {
-      hls_frag_info_t *frag = this->frags + this->frag_have;
-      frag->start_msec = frag_start;
-      frag->mrl_offs = 0;
-      frag->byte_size = 0;
-      frag->start_offs = 0;
+    if ((fixed_duration != 0) && (fixed_duration != ~0u)) {
+      this->frag_dur.tv_sec = fixed_duration / 1000000;
+      this->frag_dur.tv_nsec = (fixed_duration % 1000000) * 1000;
     }
-    this->duration = frag_start;
     return 1;
   }
 
@@ -557,107 +695,180 @@
 
 static uint32_t hls_input_get_capabilities (input_plugin_t *this_gen) {
   hls_input_plugin_t *this = (hls_input_plugin_t *)this_gen;
-  uint32_t flags = this->caps1
-    & (INPUT_CAP_SEEKABLE | INPUT_CAP_SLOW_SEEKABLE | INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW);
+  uint32_t flags;
+  if (!this)
+    return 0;
   if (this->list_type == LIST_VOD) {
-    flags |= INPUT_CAP_TIME_SEEKABLE;
+    if (this->in1)
+      this->caps1 = this->in1->get_capabilities (this->in1);
+    flags = (this->caps1 & INPUT_CAP_SEEKABLE)
+          | INPUT_CAP_TIME_SEEKABLE | INPUT_CAP_SLOW_SEEKABLE | INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW;
   } else {
-    flags &= ~(INPUT_CAP_SEEKABLE | INPUT_CAP_SLOW_SEEKABLE);
-    flags |= INPUT_CAP_LIVE;
+    flags = INPUT_CAP_LIVE | INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW;
   }
   return flags;
 }
 
+static void hls_live_start (hls_input_plugin_t *this) {
+  if (!this->in1 || (this->list_type == LIST_VOD))
+    return;
+  xine_gettime (&this->next_stop);
+  this->frag.pts = xine_nbc_get_pos_pts (this->nbc);
+}
+
+static int hls_live_wait (hls_input_plugin_t *this) {
+  struct timespec now = {0, 0};
+  int64_t pts;
+  int d;
+
+  if (!this->in1 || (this->frag_dur.tv_sec == 0))
+    return 1;
+
+  pts = xine_nbc_get_pos_pts (this->nbc);
+
+  if (this->next_stop.tv_sec == 0) {
+    /* paranoia */
+    xine_gettime (&this->next_stop);
+    this->next_stop.tv_sec -= 2;
+    this->frag.pts = pts;
+  }
+
+  d = pts - this->frag.pts;
+  if ((d > 0) && (d < 100 * 900000)) {
+    this->frag_dur.tv_sec = d / 90000;
+    this->frag_dur.tv_nsec = (d % 90000) * (1000000000 / 90000);
+  }
+  this->frag.pts = pts;
+
+  this->next_stop.tv_sec += this->frag_dur.tv_sec;
+  this->next_stop.tv_nsec += this->frag_dur.tv_nsec;
+  if (this->next_stop.tv_nsec >= 1000000000) {
+    this->next_stop.tv_nsec -= 1000000000;
+    this->next_stop.tv_sec += 1;
+  }
+  xine_gettime (&now);
+  d = (this->next_stop.tv_sec - now.tv_sec) * 1000;
+  d += ((int)this->next_stop.tv_nsec - (int)now.tv_nsec) / 1000000;
+  if ((d <= 0) || (d >= 100000))
+    return 1;
+  this->caps1 = this->in1->get_capabilities (this->in1);
+  if (this->caps1 & INPUT_CAP_NEW_MRL) {
+    this->item_mrl[0] = 0;
+    this->in1->get_optional_data (this->in1, this->item_mrl, INPUT_OPTIONAL_DATA_NEW_MRL);
+  }
+  if (_x_io_select (this->stream, -1, 0, d) != XIO_TIMEOUT)
+    return 0;
+  return 1;
+}
+
 static off_t hls_input_read (input_plugin_t *this_gen, void *buf, off_t len) {
   hls_input_plugin_t *this = (hls_input_plugin_t *)this_gen;
   uint8_t *b = (uint8_t *)buf;
   size_t left;
-  hls_frag_info_t *frag = this->current_frag;
 
-  if (!b)
+  if (!this || !b)
     return 0;
   if (len < 0)
     return 0;
   left = len;
 
+  if (this->pos <= (off_t)this->prev_size2) {
+    size_t l = this->prev_size2 - this->pos;
+    if (l > 0) {
+      if (l > left)
+        l = left;
+      memcpy (b, this->preview + this->pos, l);
+      b += l;
+      this->pos += l;
+      left -= l;
+    }
+    if (left > 0)
+      this->prev_size2 = 0;
+  }
+
   while (left > 0) {
     int reget = 0;
-    if (this->list_type != LIST_LIVE_BUMP) {
-      if (!frag)
-        break;
-      {
-        ssize_t r;
-        size_t fragleft = frag->byte_size - this->pos_in_frag;
-        if (left < fragleft) {
-          r = this->in1->read (this->in1, (void *)b, left);
-          if (r > 0) {
-            this->pos_in_frag += r;
-            b += r;
-          }
-          break;
+    /* read, safe with unknown size. */
+    if (this->frag.current == 0)
+      break;
+    {
+      ssize_t r = 0;
+      size_t fragleft = left;
+      if (this->frag.size > 0) {
+        int64_t fl2 = this->frag.pos + this->frag.size - this->pos;
+        if (fl2 <= 0) {
+          fragleft = 0;
+        } else if ((int64_t)fragleft > fl2) {
+          fragleft = fl2;
         }
+      }
+      left -= fragleft;
+      while (fragleft > 0) {
         r = this->in1->read (this->in1, (void *)b, fragleft);
-        if (r > 0) {
-          this->pos_in_frag += r;
-          left -= r;
-          b += r;
-        }
-        if (r < (ssize_t)fragleft)
+        if (r <= 0)
           break;
-      }  
-      {
-        uint32_t n = frag - this->frags + 1;
-        if (n >= this->frag_have) {
-          if (this->list_type != LIST_LIVE_REGET)
-            break;
-          reget = 1;
+        this->pos += r;
+        b += r;
+        fragleft -= r;
+      }
+      if (fragleft <= 0)
+        r = 0;
+      left += fragleft;
+      if (r <= 0) {
+        if (r == 0) {
+          /* EOF */
+          hls_frag_end (this);
         } else {
-          if (!hls_input_open_item (this, n))
-            break;
-          frag = this->current_frag;
+          return -1;
         }
       }
+    }
+    if (left == 0)
+      break;
+    /* bump */
+    if (this->list_type != LIST_LIVE_BUMP) {
+      uint32_t n = this->frag.current + 1;
+      if (n > this->frag.num + 1) {
+        if (this->list_type != LIST_LIVE_REGET)
+          break;
+        reget = 1;
+      } else {
+        if (!hls_input_open_item (this, n))
+          break;
+      }
     } else {
-      ssize_t r = this->in1->read (this->in1, (void *)b, left);
-      if (r < 0)
+      hls_bump_inc (this);
+      this->frag.current += 1;
+      if (!hls_live_wait (this))
         break;
-      left -= r;
-      b += r;
-      if (left > 0) {
-        hls_bump_inc (this);
-        if (!hls_input_open_bump (this)) {
-          this->list_type = LIST_LIVE_REGET;
-          xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-            "input_hls: LIVE bump error, falling back to reget mode.\n");
-          reget = 1;
-        }
+      if (!hls_input_open_bump (this)) {
+        this->list_type = LIST_LIVE_REGET;
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+          "input_hls: LIVE bump error, falling back to reget mode.\n");
+        reget = 1;
       }
     }
     if (reget) {
-      uint32_t n;
+      int32_t n;
       strcpy (this->item_mrl, this->list_mrl);
       if (!hls_input_switch_mrl (this))
         break;
       if (hls_input_load_list (this) != 1)
         break;
       this->bump_seq += 1;
-      if ((this->bump_seq >= this->list_seq) && (this->bump_seq < this->list_seq + this->frag_have)) {
-        n = this->bump_seq - this->list_seq;
-      } else {
+      n = this->bump_seq - this->list_seq;
+      if ((n < 0) || (n >= (int32_t)this->frag.num)) {
         xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
           "input_hls: LIVE seq discontinuity %u -> %u.\n", (unsigned int)this->bump_seq, (unsigned int)this->list_seq);
         this->bump_seq = this->list_seq;
         n = 0;
       }
-      if (!hls_input_open_item (this, n))
+      if (!hls_input_open_item (this, n + 1))
         break;
-      frag = this->current_frag;
     }
   }
 
-  left = b - (uint8_t *)buf;
-  this->live_pos += left;
-  return left;
+  return b - (uint8_t *)buf;
 }
 
 static buf_element_t *hls_input_read_block (input_plugin_t *this_gen, fifo_buffer_t *fifo, off_t todo) {
@@ -667,172 +878,201 @@
   return NULL;
 }
 
-static void hls_input_frag_seek (hls_input_plugin_t *this, uint32_t new_pos_in_frag) {
-  if (this->caps1 & (INPUT_CAP_SEEKABLE | INPUT_CAP_SLOW_SEEKABLE)) {
-    int32_t newpos = this->in1->seek (this->in1, new_pos_in_frag, SEEK_SET);
-    if (newpos < 0)
-      newpos = this->in1->get_current_pos (this->in1);
-    if (newpos >= 0)
-      this->pos_in_frag = newpos;
-  }
-}
-
 static off_t hls_input_time_seek (input_plugin_t *this_gen, int time_offs, int origin) {
   hls_input_plugin_t *this = (hls_input_plugin_t *)this_gen;
-  uint32_t new_time;
-  hls_frag_info_t *frag;
+  uint32_t new_time, d;
+  int idx;
 
-  if (this->list_type != LIST_VOD)
-    return this->live_pos;
-
-  frag = this->current_frag;
-  if (!frag)
+  if (!this)
     return 0;
+  if (this->list_type != LIST_VOD)
+    return this->pos;
+  if (!this->frag.list)
+    return this->pos;
 
+  d = hls_get_duration (this);
   switch (origin) {
     case SEEK_SET:
       new_time = 0;
       break;
     case SEEK_CUR:
-      new_time = frag->start_msec + (frag[1].start_msec - frag[0].start_msec) * this->pos_in_frag / frag->byte_size;
+      {
+        int64_t t1, t2, p1, p2;
+        xine_mfrag_get_index_start (this->frag.list, this->frag.current, &t1, &p1);
+        xine_mfrag_get_index_start (this->frag.list, this->frag.current + 1, &t2, &p2);
+        t1 /= 1000;
+        t2 /= 1000;
+        new_time = p2 - p1;
+        new_time = new_time
+                 ? (uint32_t)t1 + (uint64_t)(t2 - t1) * (uint32_t)(this->pos - this->frag.pos) / new_time
+                 : (uint32_t)t1;
+      }
       break;
     case SEEK_END:
-      new_time = this->duration;
+      new_time = d;
       break;
     default:
       errno = EINVAL;
       return (off_t)-1;
   }
   new_time += time_offs;
-  if (new_time > this->duration) {
+  if (new_time > d) {
     errno = EINVAL;
     return (off_t)-1;
   }
 
+  idx = xine_mfrag_find_time (this->frag.list, new_time * (uint64_t)1000);
+  if (idx < 1)
+    return (off_t)-1;
   {
-    /* find nearest fragment at or before requested time. */
-    int32_t b = 0, e = this->frag_have, m;
-    do {
-      uint32_t t;
-      m = (b + e) >> 1;
-      t = this->frags[m].start_msec;
-      if (new_time < t)
-        e = m--;
-      else
-        b = m + 1;
-    } while (b != e);
-    if (m < 0)
-      m = 0;
-    if (this->frags + m == frag) {
-      hls_input_frag_seek (this, 0);
+    int64_t p;
+    xine_mfrag_get_index_start (this->frag.list, idx, NULL, &p);
+    if ((idx == 1) && (this->frag.current == 1) && (this->pos <= (off_t)this->prev_size2) && (p <= (int64_t)this->prev_size2)) {
+      this->pos = p;
     } else {
-      if (!hls_input_open_item (this, m))
+      this->frag.current = idx;
+      this->pos = p;
+      this->prev_size2 = 0;
+      if (!hls_input_open_item (this, idx))
         return (off_t)-1;
-      frag = this->current_frag;
     }
   }
 
-  return frag->start_offs + this->pos_in_frag;
+  return this->pos;
 }
 
 static off_t hls_input_seek (input_plugin_t *this_gen, off_t offset, int origin) {
   hls_input_plugin_t *this = (hls_input_plugin_t *)this_gen;
-  off_t new_offs;
-  uint32_t new_pos_in_frag;
-  hls_frag_info_t *frag;
+  off_t new_offs, l;
+  int idx;
 
-  if (this->list_type != LIST_VOD)
-    return this->live_pos;
-
-  frag = this->current_frag;
-  if (!frag)
+  if (!this)
     return 0;
 
+  l = hls_get_size (this);
   switch (origin) {
     case SEEK_SET:
       new_offs = 0;
       break;
     case SEEK_CUR:
-      new_offs = frag->start_offs + this->pos_in_frag;
+      new_offs = this->pos;
       break;
     case SEEK_END:
-      new_offs = this->est_size;
+      new_offs = l;
       break;
     default:
       errno = EINVAL;
       return (off_t)-1;
   }
   new_offs += offset;
-  if ((new_offs < 0) || (new_offs > this->est_size)) {
+  if (new_offs < 0) {
+    errno = EINVAL;
+    return (off_t)-1;
+  }
+
+  /* always seek within preview. */
+  if ((new_offs <= (off_t)this->prev_size2) && (this->pos <= (off_t)this->prev_size2)) {
+    this->pos = new_offs;
+    return this->pos;
+  }
+  this->prev_size2 = 0;
+
+  if (this->list_type != LIST_VOD)
+    return this->pos;
+
+  if (new_offs > l) {
+    errno = EINVAL;
+    return (off_t)-1;
+  }
+
+  idx = xine_mfrag_find_pos (this->frag.list, new_offs);
+  if (idx < 1) {
     errno = EINVAL;
     return (off_t)-1;
   }
 
-  if ((new_offs < frag->start_offs) || (new_offs >= frag->start_offs + frag->byte_size)) {
-    /* find nearest fragment at or before requested offs. */
-    int32_t b = 0, e = this->frag_have, m;
-    do {
-      off_t t;
-      m = (b + e) >> 1;
-      t = this->frags[m].start_offs;
-      if (new_offs < t)
-        e = m--;
-      else
-        b = m + 1;
-    } while (b != e);
-    if (m < 0)
-      m = 0;
+  if (((uint32_t)idx != this->frag.current) || (new_offs < this->pos)) {
+    int64_t p1, p2;
     /* HACK: offsets around this fragment may be guessed ones,
      * and the fragment itself may turn out to be smaller than expected.
      * however, demux expects a seek to land at the exact byte offs.
      * lets try to meet that, even if it is still wrong. */
-    do {
-      if (!hls_input_open_item (this, m))
+    xine_mfrag_get_index_start (this->frag.list, idx, NULL, &p1);
+    this->pos = p1;
+    if (!hls_input_open_item (this, idx))
+      return (off_t)-1;
+    xine_mfrag_get_index_start (this->frag.list, idx + 1, NULL, &p2);
+    while (new_offs >= p2) {
+      p1 = p2;
+      this->pos = p1;
+      idx += 1;
+      if (!hls_input_open_item (this, idx))
         return (off_t)-1;
-      m++;
-      frag = this->current_frag;
-      new_pos_in_frag = new_offs - frag->start_offs;
-    } while (new_pos_in_frag >= (uint32_t)frag->byte_size);
-  } else {
-    new_pos_in_frag = new_offs - frag->start_offs;
+      xine_mfrag_get_index_start (this->frag.list, idx + 1, NULL, &p2);
+    }
   }
 
-  hls_input_frag_seek (this, new_pos_in_frag);
+  new_offs -= this->frag.pos;
+  if (new_offs > 0) {
+    off_t subpos = new_offs;
+    if (this->frag.input_offs[this->frag.current - 1])
+      subpos += this->frag.input_offs[this->frag.current - 1] - 1;
+    if (this->in1->seek (this->in1, subpos, SEEK_SET) != subpos) {
+      this->in1->seek (this->in1, 0, SEEK_SET);
+    } else {
+      this->pos += new_offs;
+    }
+  }
 
-  return frag->start_offs + this->pos_in_frag;
+  return this->pos;
 }
 
 static off_t hls_input_get_current_pos (input_plugin_t *this_gen) {
   hls_input_plugin_t *this = (hls_input_plugin_t *)this_gen;
-  if (this->list_type != LIST_VOD)
-    return this->live_pos;
-  if (!this->current_frag)
+  if (!this)
     return 0;
-  return this->current_frag->start_offs + this->pos_in_frag;
+  return this->pos;
 }
 
 static off_t hls_input_get_length (input_plugin_t *this_gen) {
   hls_input_plugin_t *this = (hls_input_plugin_t *)this_gen;
-  return this->est_size;
+  if (!this)
+    return 0;
+  return hls_get_size (this);
 }
 
 static const char *hls_input_get_mrl (input_plugin_t *this_gen) {
   hls_input_plugin_t *this = (hls_input_plugin_t *)this_gen;
+  if (!this)
+    return NULL;
   return this->list_mrl;
 }
 
 static void hls_input_dispose (input_plugin_t *this_gen) {
   hls_input_plugin_t *this = (hls_input_plugin_t *)this_gen;
+  if (!this)
+    return;
   if (this->in1) {
     _x_free_input_plugin (this->stream, this->in1);
     this->in1 = NULL;
   }
+  if (this->nbc) {
+    xine_nbc_close (this->nbc);
+    this->nbc = NULL;
+  }
+  xine_mfrag_list_close (&this->frag.list);
   _x_freep (&this->list_buf);
-  _x_freep (&this->frags);
+  this->frag.mrl_offs = NULL;
+  _x_freep (&this->frag.input_offs);
   free (this);
 }
 
 static int hls_input_open (input_plugin_t *this_gen) {
+  static const char * const type_names[3] = {
+    [LIST_VOD] = "seekable VOD",
+    [LIST_LIVE_BUMP] = "non seekable LIVE bump",
+    [LIST_LIVE_REGET] = "non seekable LIVE reget"
+  };
   hls_input_plugin_t *this = (hls_input_plugin_t *)this_gen;
   hls_input_class_t  *cls  = (hls_input_class_t *)this->input_plugin.input_class;
   int try;
@@ -867,37 +1107,45 @@
     return 0;
   }
 
-  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-    "input_hls: got %u fragments for %u.%03u seconds.\n", (unsigned int)this->frag_have,
-    (unsigned int)(this->frags[this->frag_have].start_msec / 1000u),
-    (unsigned int)(this->frags[this->frag_have].start_msec % 1000u));
+  {
+    unsigned int d = hls_get_duration (this);
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+      "input_hls: got %u fragments for %u.%03u seconds.\n", (unsigned int)this->frag.num, d / 1000u, d % 1000u);
+  }
 
-  if (!strncasecmp (this->list_strtype, "VOD", 3) || ((this->frag_have >= 8) && (this->list_seq == 1))) {
+  if (!strncasecmp (this->list_strtype, "VOD", 3) || ((this->frag.num >= 8) && (this->list_seq == 1))) {
     this->list_type = LIST_VOD;
-    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-      "input_hls: seekable VOD mode @ seq %s.\n", this->list_strseq);
   } else {
-    if ((this->frag_have > 1)
-      && hls_bump_guess (this, this->list_buf + this->frags[0].mrl_offs, this->list_buf + this->frags[1].mrl_offs)) {
+    if ((this->frag.num > 1)
+      && hls_bump_guess (this, this->list_buf + this->frag.mrl_offs[0], this->list_buf + this->frag.mrl_offs[1])) {
       this->list_type = LIST_LIVE_BUMP;
-      xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-        "input_hls: non seekable LIVE bump mode @ seq %s.\n", this->list_strseq);
-    } else if ((this->frag_have > 0)
-      && hls_bump_find (this, this->list_buf + this->frags[0].mrl_offs, this->list_strseq)) {
+    } else if ((this->frag.num > 0)
+      && hls_bump_find (this, this->list_buf + this->frag.mrl_offs[0], this->list_strseq)) {
       this->list_type = LIST_LIVE_BUMP;
-      xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-        "input_hls: non seekable LIVE bump mode @ seq %s.\n", this->list_strseq);
     } else {
       this->list_type = LIST_LIVE_REGET;
-      xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-        "input_hls: non seekable LIVE reget mode @ seq %s.\n", this->list_strseq);
     }
   }
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "input_hls: %s mode @ seq %s.\n", type_names[this->list_type], this->list_strseq);
+
+  if (this->list_type == LIST_LIVE_BUMP) {
+    this->frag.current = 1;
+    if (!hls_input_open_bump (this))
+      return 0;
+  } else {
+    if (!hls_input_open_item (this, 1))
+      return 0;
+  }
 
-  if (this->list_type == LIST_LIVE_BUMP)
-    return hls_input_open_bump (this);
+  hls_live_start (this);
+  try = hls_input_read (&this->input_plugin, this->preview, sizeof (this->preview));
+  if (try > 0) {
+    this->prev_size1 = this->prev_size2 = try;
+    hls_input_seek (&this->input_plugin, 0, SEEK_SET);
+  }
 
-  return hls_input_open_item (this, 0);
+  return 1;
 }
 
 static int hls_input_get_optional_data (input_plugin_t *this_gen, void *data, int data_type) {
@@ -907,16 +1155,62 @@
     return INPUT_OPTIONAL_UNSUPPORTED;
 
   switch (data_type) {
+
     case INPUT_OPTIONAL_DATA_PREVIEW:
+      if (!data)
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      {
+        uint32_t s = this->prev_size1;
+        if (s > MAX_PREVIEW_SIZE)
+          s = MAX_PREVIEW_SIZE;
+        if (!s) {
+          if (this->in1)
+            return this->in1->get_optional_data (this->in1, data, data_type);
+          else
+            return INPUT_OPTIONAL_UNSUPPORTED;
+        }
+        memcpy (data, this->preview, s);
+        return s;
+      }
+
     case INPUT_OPTIONAL_DATA_SIZED_PREVIEW:
-      if (!this->in1)
+      if (!data)
         return INPUT_OPTIONAL_UNSUPPORTED;
-      return this->in1->get_optional_data (this->in1, data, data_type);
+      {
+        int s;
+        memcpy (&s, data, sizeof (s));
+        if (s < 0)
+          return INPUT_OPTIONAL_UNSUPPORTED;
+        if (s > (int)this->prev_size1)
+          s = this->prev_size1;
+        if (!s) {
+          if (this->in1)
+            return this->in1->get_optional_data (this->in1, data, data_type);
+          else
+            return INPUT_OPTIONAL_UNSUPPORTED;
+        }
+        memcpy (data, this->preview, s);
+        return s;
+      }
+
     case INPUT_OPTIONAL_DATA_DURATION:
       if (!data)
         return INPUT_OPTIONAL_UNSUPPORTED;
-      memcpy (data, &this->duration, sizeof (this->duration));
+      {
+        int d = hls_get_duration (this);
+        memcpy (data, &d, sizeof (d));
+        return INPUT_OPTIONAL_SUCCESS;
+      }
+
+    case INPUT_OPTIONAL_DATA_FRAGLIST:
+      if (!data)
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      {
+        xine_mfrag_list_t *n = NULL;
+        memcpy (data, this->list_type == LIST_VOD ? &this->frag.list : &n, sizeof (this->frag.list));
+      }
       return INPUT_OPTIONAL_SUCCESS;
+
     default:
       return INPUT_OPTIONAL_UNSUPPORTED;
   }
@@ -941,7 +1235,7 @@
     } else if (hls_input_is_hls (mrl) == 2)
       in1 = _x_find_input_plugin (stream, mrl);
     if (in1) {
-      if (in1->open (in1)) {
+      if (in1->open (in1) > 0) {
         if (_x_demux_read_header (in1, hbuf, 8) == 8) {
           if (!strncmp (hbuf, "#EXTM3U", 7)) {
             this = calloc (1, sizeof (*this));
@@ -956,24 +1250,33 @@
   } while (0);
 
 #ifndef HAVE_ZERO_SAFE_MEM
-  this->size1        = 0;
   this->caps1        = 0;
-  this->frags        = NULL;
-  this->current_frag = NULL;
+  this->frag.list    = NULL;
+  this->frag.input_offs = NULL;
+  this->frag.size    = 0;
+  this->frag.mrl_offs = NULL;
+  this->frag.num     = 0;
+  this->frag.current = 0;
   this->list_buf     = NULL;
   this->list_bsize   = 0;
-  this->live_pos     = 0;
-  this->est_size     = 0;
-  this->seen_size    = 0;
-  this->seen_num     = 0;
-  this->seen_avg     = 0;
-  this->duration     = 0;
   this->items_num    = 0;
+  this->prev_size1   = 0;
+  this->prev_size2   = 0;
+  this->frag_dur.tv_sec  = 0;
+  this->frag_dur.tv_nsec = 0;
+  this->next_stop.tv_sec  = 0;
+  this->next_stop.tv_nsec = 0;
+  this->rewind       = 0;
+  this->prev_item_mrl[0] = 0;
 #endif
 
   this->stream = stream;
   this->in1    = in1;
 
+  /* TJ. yes input_http already does this, but i want to test offline
+   * with a file based service. */
+  this->nbc    = xine_nbc_init (this->stream);
+
   xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "input_hls: %s.\n", mrl + n);
 
   strlcpy (this->list_mrl, mrl + n, HLS_MAX_MRL);
@@ -1031,4 +1334,3 @@
 
   return this;
 }
-
diff -urN xine-lib-1.2.11/src/input/input_http.c xine-lib-1.2/src/input/input_http.c
--- xine-lib-1.2.11/src/input/input_http.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_http.c	2022-01-15 22:03:19.612547289 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -977,12 +977,13 @@
   uint32_t caps = INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW | INPUT_CAP_NEW_MRL;
 
   /* Nullsoft asked to not allow saving streaming nsv files */
-  if (this->url.uri && strlen(this->url.uri) >= 4 &&
-      !strncmp(this->url.uri + strlen(this->url.uri) - 4, ".nsv", 4))
+  if (this->mode & MODE_NSV)
     caps |= INPUT_CAP_RIP_FORBIDDEN;
 
   if (this->mode & MODE_SEEKABLE) {
     caps |= INPUT_CAP_SLOW_SEEKABLE;
+  } else if (this->shoutcast_interval) {
+    caps |= INPUT_CAP_LIVE;
   }
   return caps;
 }
@@ -1762,29 +1763,37 @@
     case INPUT_OPTIONAL_DATA_NEW_MRL:
       if (!data)
         break;
-      if (!http_can_handle (this->stream, data))
-        break;
-      http_close (this);
-      sbuf_reset (this);
-      this->mrl[0] = 0;
-      this->mime_type[0] = 0;
-      _x_freep (&this->user_agent);
-      _x_freep (&this->shoutcast_songtitle);
-      this->curpos              = 0;
-      this->contentlength       = 0;
-      this->mode                &= ~(MODE_DONE | MODE_SEEKABLE | MODE_NSV | MODE_LASTFM | MODE_SHOUTCAST);
-      this->shoutcast_interval  = 0;
-      this->shoutcast_left      = 0;
-      this->preview_size        = 0;
-      if ((this->num_msgs < 0) || (this->num_msgs > 8))
-        this->num_msgs = 8;
-      if (!strncasecmp ((const char *)data, "peercast://pls/", 15)) {
-        char *w = this->mrl, *e = w + sizeof (this->mrl);
-        w += strlcpy (w, "http://127.0.0.1:7144/stream/", e - w);
-        strlcpy (w, (const char *)data + 15, e - w);
-      } else
-        strlcpy (this->mrl, (const char *)data, sizeof (this->mrl));
-      return INPUT_OPTIONAL_SUCCESS;
+      {
+        const char *new_mrl = (const char *)data;
+        if (new_mrl[0] && !http_can_handle (this->stream, data))
+          break;
+        if (!new_mrl[0])
+          xprintf (this->xine, XINE_VERBOSITY_DEBUG, "input_http: going standby.\n");
+        http_close (this);
+        sbuf_reset (this);
+        this->mrl[0] = 0;
+        this->mime_type[0] = 0;
+        _x_freep (&this->user_agent);
+        _x_freep (&this->shoutcast_songtitle);
+        this->curpos              = 0;
+        this->contentlength       = 0;
+        this->mode                &= ~(MODE_DONE | MODE_SEEKABLE | MODE_NSV | MODE_LASTFM | MODE_SHOUTCAST);
+        this->shoutcast_interval  = 0;
+        this->shoutcast_left      = 0;
+        this->preview_size        = 0;
+        if ((this->num_msgs < 0) || (this->num_msgs > 8))
+          this->num_msgs = 8;
+        if (!new_mrl[0])
+          return INPUT_OPTIONAL_SUCCESS;
+	if (!strncasecmp (new_mrl, "peercast://pls/", 15)) {
+          char *w = this->mrl, *e = w + sizeof (this->mrl);
+          w += strlcpy (w, "http://127.0.0.1:7144/stream/", e - w);
+          strlcpy (w, new_mrl + 15, e - w);
+        } else {
+          strlcpy (this->mrl, new_mrl, sizeof (this->mrl));
+        }
+        return INPUT_OPTIONAL_SUCCESS;
+      }
   }
 
   return INPUT_OPTIONAL_UNSUPPORTED;
diff -urN xine-lib-1.2.11/src/input/input_mpegdash.c xine-lib-1.2/src/input/input_mpegdash.c
--- xine-lib-1.2.11/src/input/input_mpegdash.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/input/input_mpegdash.c	2022-01-15 22:03:19.596547221 +0100
@@ -0,0 +1,1473 @@
+/*
+ * Copyright (C) 2021 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <pthread.h>
+
+#define LOG_MODULE "input_mpegdash"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/xineutils.h>
+#include <xine/compat.h>
+#include <xine/input_plugin.h>
+#include <xine/stree.h>
+#include <xine/mfrag.h>
+
+#include <xine/io_helper.h>
+
+#include "http_helper.h"
+#include "input_helper.h"
+#include "group_network.h"
+#include "multirate_pref.c"
+#include "net_buf_ctrl.h"
+
+typedef struct {
+  input_class_t     input_class;
+  xine_t           *xine;
+  multirate_pref_t  pref;
+} mpd_input_class_t;
+
+typedef struct {
+  uint32_t mime, sfile, init, media, id; /** << offs into stree buf */
+#define MPD_TYPE_AUDIO 1
+#define MPD_TYPE_VIDEO 2
+#define MPD_TYPE_SUBT  4
+  uint32_t type;
+  uint32_t index_p, index_as, index_r;   /** << xine_stree_t units */
+  uint32_t timebase;                     /** << units/second */
+  uint32_t bitrate;                      /** << bits/second */
+  uint32_t samplerate;                   /** << audio_samples/second */
+  uint32_t w, h;                         /** << video pixels */
+  uint32_t frag_start;                   /** << frag number offset */
+  uint32_t frag_duration;                /** << timebase units */
+  uint32_t frag_count;                   /** << 0 in live mode */
+} mpd_stream_info_t;
+
+typedef enum {
+  MPD_LIVE = 0,
+  MPD_SINGLE_LIVE,
+  MPD_INIT_LIVE,
+  MPD_VOD,
+  MPD_SINGLE_VOD,
+  MPD_INIT_VOD,
+  MPD_MODE_LAST
+} mpd_mode_t;
+
+#define MPD_IS_LIVE(this) ((this->mode == MPD_LIVE) || (this->mode == MPD_SINGLE_LIVE) || (this->mode == MPD_INIT_LIVE))
+
+static const char *mpd_mode_names[MPD_MODE_LAST] = {
+  [MPD_LIVE]        = "non seekable live mode",
+  [MPD_SINGLE_LIVE] = "non seekable single file live mode",
+  [MPD_INIT_LIVE]   = "non seekable live mode with init fragment",
+  [MPD_VOD]         = "seekable VOD mode",
+  [MPD_SINGLE_VOD]  = "seekable single file VOD mode",
+  [MPD_INIT_VOD]    = "seekable VOD mode with init fragment"
+};
+
+typedef struct mpd_input_plugin_s {
+  input_plugin_t    input_plugin;
+  xine_stream_t    *stream;
+  xine_nbc_t       *nbc;
+
+  struct mpd_input_plugin_s *main_input;
+
+  input_plugin_t   *in1;
+  uint32_t          caps1;
+
+  uint32_t          side_index; /** << 0..3 */
+  uint32_t          num_sides;
+
+  struct {
+    pthread_mutex_t mutex;
+    time_t          avail_start, play_start; /** << seconds since 1970 */
+    struct timespec play_systime;
+    int             lag;  /** pts */
+    uint32_t        type;
+    int             init;
+    int             refs;
+  }                 sync;  /** set by main input, used by sides */
+
+  int               lag;  /** pts */
+
+  int               rewind; /** seconds */
+
+  xine_stree_t     *tree;
+  char             *list_buf;
+  xine_stree_mode_t tmode;
+
+  uint32_t          base_url, seg_base_url, time_url; /** << offs into stree buf */
+  int64_t           frag_num;      /** << derived from manifest */
+  uint32_t          frag_index;    /** << 0 (init), 1...n (real frags) */
+  uint32_t          frag_mrl_1;    /** << [foo/bar_]12345.mp4 */
+  uint32_t          frag_mrl_2;    /** << foo/bar_[12345].mp4 */
+  uint32_t          frag_mrl_3;    /** << foo/ber_12345[.mp4] */
+
+#define MPD_MAX_SIDES 4
+#define MPD_MAX_REPR 16
+  uint8_t           side_have_streams[MPD_MAX_SIDES][MPD_MAX_REPR];
+
+#define MPD_MAX_STREAMS 32
+  uint32_t          num_streams, used_stream;
+  mpd_stream_info_t info;
+  mpd_stream_info_t streams[MPD_MAX_STREAMS];
+  multirate_pref_t  items[MPD_MAX_STREAMS];
+
+  xine_mfrag_list_t *fraglist;
+  off_t             pos, frag_pos, all_size;
+  uint32_t          frag_size;
+  uint32_t          prev_size1; /** << the actual preview bytes, for INPUT_OPTIONAL_DATA_[SIZED]_PREVIEW. */
+  uint32_t          prev_size2; /** << for read (), 0 after leaving that range. */
+
+  uint32_t          list_bsize;
+  uint32_t          duration;
+  mpd_mode_t        mode;
+#define MPD_MAX_MRL 4096
+  char              manifest_mrl[MPD_MAX_MRL];
+  char              list_mrl[MPD_MAX_MRL];
+  char              item_mrl[MPD_MAX_MRL];
+#define MPD_PREVIEW_SIZE (32 << 10)
+  char              preview[MPD_PREVIEW_SIZE];
+} mpd_input_plugin_t;
+
+#ifdef HAVE_POSIX_TIMERS
+#  define xine_gettime(t) clock_gettime (CLOCK_REALTIME, t)
+#else
+static inline int xine_gettime (struct timespec *ts) {
+  struct timeval tv;
+  int r;
+  r = gettimeofday (&tv, NULL);
+  if (!r) {
+    ts->tv_sec  = tv.tv_sec;
+    ts->tv_nsec = tv.tv_usec * 1000;
+  }
+  return r;
+}
+#endif
+
+static uint32_t str2uint32 (char **s) {
+  uint8_t *p = (uint8_t *)*s;
+  uint32_t v = 0;
+  uint8_t z;
+  while ((z = *p ^ '0') < 10) {
+    v = v * 10u + z;
+    p++;
+  }
+  *s = (char *)p;
+  return v;
+}
+
+static time_t mpd_str2time (char *s) {
+  char buf[256], *tz;
+  struct tm tm;
+  time_t ret;
+  /* Sigh. try to parse something like "1969-12-31T23:59:44Z" or "PT5H30M55S". */
+  if (!s)
+    return (time_t)-1;
+
+  if (((s[0] | 0x20) == 'p') && ((s[1] | 0x20) == 't')) {
+    ret = 0;
+    s += 2;
+    while (1) {
+      uint32_t v = str2uint32 (&s);
+      uint32_t z = (*s | 0x20);
+      if (z == 'h')
+        ret += 3600u * v;
+      else if (z == 'm')
+        ret += 60u * v;
+      else if (z == 's')
+        ret += v;
+      else
+        break;
+      s++;
+    }
+    return ret;
+  }
+
+  tm.tm_year = (int)str2uint32 (&s) - 1900;
+  if (*s++ != '-')
+    return (time_t)-1;
+  tm.tm_mon = (int)str2uint32 (&s) - 1;
+  if (*s++ != '-')
+    return (time_t)-1;
+  tm.tm_mday= str2uint32 (&s);
+  if ((*s++ | 0x20) != 't')
+    return (time_t)-1;
+  tm.tm_hour = str2uint32 (&s);
+  if (*s++ != ':')
+    return (time_t)-1;
+  tm.tm_min = str2uint32 (&s);
+  if (*s++ != ':')
+    return (time_t)-1;
+  tm.tm_sec = str2uint32 (&s);
+  tm.tm_wday = 0;
+  tm.tm_yday = 0;
+  tm.tm_isdst = 0;
+
+  tz = getenv ("TZ");
+  strlcpy (buf, tz ? tz : "", sizeof (buf));
+  setenv ("TZ", "", 1);
+  tzset ();
+  ret = mktime (&tm);
+  if (buf[0])
+    setenv ("TZ", buf, 1);
+  else
+    unsetenv ("TZ");
+  tzset ();
+
+  return ret;
+}
+
+static char *mpd_strcasestr (const char *haystack, const char *needle) {
+  const char *n;
+  size_t ln;
+  char z;
+
+  if (!haystack)
+    return NULL;
+  if (!needle)
+    return (char *)haystack;
+  if (!needle[0])
+    return (char *)haystack;
+
+  n = haystack;
+  needle++;
+  ln = strlen (needle);
+  z = needle[-1] | 0x20;
+  if ((z >= 'a') && (z <= 'z')) {
+    while ((n = strchr (n, z))) {
+      if (!strncasecmp (n + 1, needle, ln))
+        return (char *)n;
+      n++;
+    }
+    z &= 0xdf;
+    n = haystack;
+  } else {
+    z = needle[-1];
+  }
+  while ((n = strchr (n, z))) {
+    if (!strncasecmp (n + 1, needle, ln))
+      return (char *)n;
+    n++;
+  }
+  return NULL;
+}
+
+static int mpd_build_mrl (mpd_input_plugin_t *this, const char *name) {
+  const char *p, *b;
+  char *q, *e;
+
+  _x_merge_mrl (this->item_mrl, MPD_MAX_MRL, this->list_buf + this->base_url, name);
+
+  q = this->list_mrl;
+  e = q + MPD_MAX_MRL;
+  p = this->item_mrl;
+  while ((b = mpd_strcasestr (p, "$RepresentationId$"))) {
+    size_t l = b - p;
+    if (l >= (size_t)(e - q))
+      return 0;
+    if (l) {
+      memcpy (q, p, l);
+      q += l;
+    }
+    p = b + strlen ("$RepresentationId$");
+    q += strlcpy (q, this->list_buf + this->info.id, e - q);
+    if (q >= e)
+      return 0;
+  }
+  q += strlcpy (q, p, e - q);
+  if (q >= e)
+    return 0;
+
+  _x_merge_mrl (this->item_mrl, MPD_MAX_MRL, this->manifest_mrl, this->list_mrl);
+  return 1;
+}
+
+static void mpd_prepare_fragnum (mpd_input_plugin_t *this) {
+  const char *b = mpd_strcasestr (this->item_mrl, "$Number$");
+
+  if (b) {
+    this->frag_mrl_1 = b - (const char *)this->item_mrl;
+    this->frag_mrl_2 = strlen ("$Number$");
+    this->frag_mrl_3 = strlen (b + this->frag_mrl_2);
+  } else {
+    this->frag_mrl_1 = strlen (this->item_mrl);
+    this->frag_mrl_2 = 0;
+    this->frag_mrl_3 = 0;
+  }
+}
+
+static void mpd_apply_fragnum (mpd_input_plugin_t *this) {
+  if (this->frag_mrl_2) {
+    char buf[32];
+    uint32_t l_2 = sprintf (buf, "%" PRId64, this->frag_num);
+
+    if (l_2 != this->frag_mrl_2) {
+      memmove (this->item_mrl + this->frag_mrl_1 + l_2,
+        this->item_mrl + this->frag_mrl_1 + this->frag_mrl_2, this->frag_mrl_3 + 1);
+      this->frag_mrl_2 = l_2;
+    }
+    memcpy (this->item_mrl + this->frag_mrl_1, buf, l_2);
+  }
+}
+
+static int mpd_input_switch_mrl (mpd_input_plugin_t *this) {
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "input_mpegdash.%d: %s.\n", (int)this->side_index, this->item_mrl);
+  if (this->in1) {
+    if (this->in1->get_capabilities (this->in1) & INPUT_CAP_NEW_MRL) {
+      if (this->in1->get_optional_data (this->in1, this->item_mrl,
+        INPUT_OPTIONAL_DATA_NEW_MRL) == INPUT_OPTIONAL_SUCCESS) {
+        if (this->in1->open (this->in1) > 0)
+          return 1;
+      }
+    }
+    _x_free_input_plugin (this->stream, this->in1);
+  }
+  this->in1 = _x_find_input_plugin (this->stream, this->item_mrl);
+  if (!this->in1)
+    return 0;
+  if (this->in1->open (this->in1) <= 0)
+    return 0;
+  return 1;
+}
+
+static int mpd_set_start_time (mpd_input_plugin_t *this) {
+  if (!MPD_IS_LIVE (this)) {
+    if (!mpd_build_mrl (this, this->list_buf + this->info.media))
+      return 0;
+    this->frag_index = 1;
+    this->frag_num = this->info.frag_start;
+    mpd_prepare_fragnum (this);
+    return 2;
+  }
+
+  if (!this->side_index) { /* main */
+    char buf[256];
+    time_t play_start;
+    struct timespec ts;
+    int l;
+
+    if (this->sync.avail_start == (time_t)-1)
+      return 0;
+    if (!this->info.timebase || !this->info.frag_duration)
+      return 0;
+    if (!mpd_build_mrl (this, this->list_buf + this->time_url))
+      return 0;
+    if (!mpd_input_switch_mrl (this))
+      return 0;
+    l = this->in1->read (this->in1, buf, sizeof (buf) - 1);
+    if (l <= 0)
+      return 0;
+    buf[l] = 0;
+    play_start = mpd_str2time (buf);
+    if (play_start == (time_t)-1)
+      return 0;
+    ts.tv_sec = 0;
+    ts.tv_nsec = 0;
+    xine_gettime (&ts);
+    this->frag_index = 1;
+    /* heavy magic ;-) */
+    {
+      int64_t d = play_start - this->sync.avail_start - this->rewind;
+      d *= this->info.timebase;
+      this->frag_num = d / this->info.frag_duration + this->info.frag_start;
+      this->lag = (d % this->info.frag_duration) * 90000 / this->info.timebase;
+    }
+    if (this->sync.init) {
+      pthread_mutex_lock (&this->sync.mutex);
+      this->sync.play_start = play_start;
+      this->sync.play_systime = ts;
+      this->sync.lag = this->lag;
+      this->sync.type = this->info.type;
+      pthread_mutex_unlock (&this->sync.mutex);
+    } else {
+      this->sync.play_start = play_start;
+      this->sync.play_systime = ts;
+      this->sync.lag = this->lag;
+      this->sync.type = this->info.type;
+    }
+  } else {
+    mpd_input_plugin_t *main_input = this->main_input;
+
+    if (!this->info.timebase || !this->info.frag_duration)
+      return 0;
+    if (main_input->sync.init) {
+      pthread_mutex_lock (&this->sync.mutex);
+      this->sync.avail_start = main_input->sync.avail_start;
+      this->sync.play_start = main_input->sync.play_start;
+      this->sync.play_systime = main_input->sync.play_systime;
+      this->sync.lag = main_input->sync.lag;
+      this->sync.type = main_input->sync.type;
+      pthread_mutex_unlock (&this->sync.mutex);
+    } else {
+      this->sync.avail_start = main_input->sync.avail_start;
+      this->sync.play_start = main_input->sync.play_start;
+      this->sync.play_systime = main_input->sync.play_systime;
+      this->sync.lag = main_input->sync.lag;
+      this->sync.type = main_input->sync.type;
+    }
+    if (this->sync.avail_start == (time_t)-1)
+      return 0;
+    this->frag_index = 1;
+    /* heavy magic ;-) */
+    {
+      int64_t d = this->sync.play_start - this->sync.avail_start - this->rewind;
+      d *= this->info.timebase;
+      this->frag_num = d / this->info.frag_duration + this->info.frag_start;
+      this->lag = (d % this->info.frag_duration) * 90000 / this->info.timebase;
+    }
+  }
+    
+  if (!mpd_build_mrl (this, this->list_buf + this->info.media))
+    return 0;
+  mpd_prepare_fragnum (this);
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "input_mpegdash.%d: live start @ fragment #%" PRId64 ", lag %d pts.\n",
+    (int)this->side_index, this->frag_num, this->lag);
+  return 1;
+}
+
+static int mpd_set_frag_index (mpd_input_plugin_t *this, uint32_t index, int wait) {
+  if (!MPD_IS_LIVE (this)) {
+    this->frag_num = this->info.frag_start + index - 1;
+    this->frag_index = index;
+    mpd_apply_fragnum (this);
+  } else {
+    int32_t d = index - this->frag_index;
+    this->frag_num += d;
+    this->frag_index = index;
+    mpd_apply_fragnum (this);
+    if (!wait) 
+      return 2;
+    if (d > 0) {
+      int32_t ms;
+      struct timespec ts = {0, 0};
+      xine_gettime (&ts);
+      ms = (ts.tv_sec - this->sync.play_systime.tv_sec) * 1000;
+      ms += (ts.tv_nsec - this->sync.play_systime.tv_nsec) / 1000000;
+      ms = (int64_t)(index - 1) * 1000 * this->info.frag_duration / this->info.timebase - ms;
+      if ((ms > 0) && (ms < 100000)) {
+        /* save server load and hang up before wait. */
+        if (this->in1) {
+          if (this->in1->get_capabilities (this->in1) & INPUT_CAP_NEW_MRL) {
+            char no_mrl[] = "";
+            this->in1->get_optional_data (this->in1, no_mrl, INPUT_OPTIONAL_DATA_NEW_MRL);
+          }
+        }
+        if (_x_io_select (this->stream, -1, 0, ms) != XIO_TIMEOUT)
+          return 0;
+      }
+    }
+  }
+  return mpd_input_switch_mrl (this);
+}
+
+static void mpd_frag_seen (mpd_input_plugin_t *this) {
+  this->frag_pos = this->pos;
+  if (this->in1) {
+    int64_t l = this->in1->get_length (this->in1);
+    if (l > 0) {
+      this->frag_size = l;
+      xine_mfrag_set_index_frag (this->fraglist, this->frag_index,
+        (this->frag_index && this->info.frag_duration) ? (int64_t)this->info.frag_duration : -1, l);
+    } else if (xine_mfrag_get_index_frag (this->fraglist, this->frag_index, NULL, &l) && (l > 0)) {
+      this->frag_size = l;
+    } else {
+      this->frag_size = 0;
+    }
+  } else {
+    this->frag_size = 0;
+  }
+}
+
+static void mpd_frag_end (mpd_input_plugin_t *this) {
+  int64_t l = this->pos - this->frag_pos;
+  if (l > (int64_t)this->frag_size) {
+    this->frag_size = l;
+    xine_mfrag_set_index_frag (this->fraglist, this->frag_index, -1, l);
+  }
+}
+
+static ssize_t mpd_read_int (mpd_input_plugin_t *this, void *buf, size_t len, int wait) {
+  char *q = (char *)buf;
+
+  if (len == 0)
+    return 0;
+
+  if (this->pos <= (off_t)this->prev_size2) {
+    size_t n = this->prev_size2 - this->pos;
+    if (n > 0) {
+      if (n > len)
+        n = len;
+      memcpy (q, this->preview + this->pos, n);
+      q += n;
+      this->pos += n;
+      len -= n;
+    }
+    if (len > 0)
+      this->prev_size2 = 0;
+  }
+  if (len == 0)
+    return q - (char *)buf;
+
+  if (this->frag_index == 0) {
+    if (this->list_buf[this->info.init]) {
+      int r;
+      if (this->pos == 0) {
+        if (!mpd_build_mrl (this, this->list_buf + this->info.init))
+          return -1;
+        if (!mpd_input_switch_mrl (this))
+          return -1;
+        mpd_frag_seen (this);
+      }
+      r = this->in1->read (this->in1, q, len);
+      if (r < 0)
+        return -1;
+      q += r;
+      this->pos += r;
+      len -= r;
+      if (len == 0)
+        return q - (char *)buf;
+    }
+    mpd_frag_end (this);
+    if (!mpd_set_start_time (this))
+      return q - (char *)buf;
+    mpd_apply_fragnum (this);
+    if (!mpd_input_switch_mrl (this))
+      return q - (char *)buf;
+    mpd_frag_seen (this);
+  }
+
+  while (len > 0) {
+    int r = this->in1->read (this->in1, q, len);
+    if (r < 0)
+      return q > (char *)buf ? q - (char *)buf : -1;
+    q += r;
+    this->pos += r;
+    len -= r;
+    if (len == 0)
+      break;
+    if (r == 0) {
+      if ((this->mode == MPD_SINGLE_LIVE) || (this->mode == MPD_SINGLE_VOD))
+        break;
+      mpd_frag_end (this);
+      if (mpd_set_frag_index (this, this->frag_index + 1, wait) != 1)
+        break;
+      mpd_frag_seen (this);
+    }
+  }
+
+  return q - (char *)buf;
+}
+
+static int mpd_input_get_mrl_ext (const char *mrl, const char **ext) {
+  const char *p1, *p2;
+  for (p2 = mrl; *p2 && (*p2 != '?'); p2++) ;
+  for (p1 = p2; (p1 > mrl) && (p1[-1] != '.'); p1--) ;
+  *ext = p1;
+  return p2 - p1;
+}
+
+static int mpd_input_is_mpd (const char *mrl) {
+  const char *ext;
+  int n = mpd_input_get_mrl_ext (mrl, &ext);
+  if ((n == 3) && !strncasecmp (ext, "mpd", 3))
+    return 1;
+  return 0;
+}
+
+/*
+static uint32_t str2msec (char **s) {
+  uint8_t *p = (uint8_t *)*s;
+  uint32_t v = 0;
+  uint8_t z;
+  while ((z = *p ^ '0') < 10) {
+    v = v * 10u + z;
+    p++;
+  }
+  v *= 1000u;
+  if (z == ('.' ^ '0')) {
+    p++;
+    if ((z = *p ^ '0') < 10) {
+      v += 100u * z;
+      p++;
+      if ((z = *p ^ '0') < 10) {
+        v += 10u * z;
+        p++;
+        if ((z = *p ^ '0') < 10) {
+          v += z;
+          p++;
+        }
+      }
+    }
+  }
+  *s = (char *)p;
+  return v;
+}
+*/
+
+static uint32_t mpd_stree_find (mpd_input_plugin_t *this, const char *path, uint32_t base) {
+  return 4 + this->tree[xine_stree_find (this->tree, this->list_buf + 4, path, base, 0)].value;
+}
+
+static int mpd_input_load_manifest (mpd_input_plugin_t *this) {
+  ssize_t size;
+  uint32_t tree_mpd;
+
+  {
+    off_t s = this->in1->get_length (this->in1);
+    if (s > (32 << 20))
+      return 0;
+    size = s;
+  }
+  if (size > 0) {
+    /* size known, get at once. */
+    if (this->in1->seek (this->in1, 0, SEEK_SET) != 0)
+      return 0;
+    if ((uint32_t)size + 8 > this->list_bsize) {
+      char *nbuf = realloc (this->list_buf, (uint32_t)size * 5 / 4 + 8);
+      if (!nbuf)
+        return 0;
+      this->list_buf = nbuf;
+      this->list_bsize = (uint32_t)size * 5 / 4 + 8;
+    }
+    if (this->in1->read (this->in1, this->list_buf + 4, size) != size)
+      return 0;
+  } else {
+    /* chunked/deflated */
+    uint32_t have;
+    if (!this->list_buf) {
+      this->list_buf = malloc (32 << 10);
+      if (!this->list_buf)
+          return 0;
+      this->list_bsize = 32 << 10;
+    }
+    have = 0;
+    while (1) {
+      int32_t r = this->in1->read (this->in1, this->list_buf + 4 + have, this->list_bsize - have - 8);
+      if (r <= 0)
+        break;
+      have += r;
+      if (have == this->list_bsize - 8) {
+        char *nbuf;
+        if (this->list_bsize >= (32 << 20))
+          break;
+        nbuf = realloc (this->list_buf, this->list_bsize + (32 << 10));
+        if (!nbuf)
+          return 0;
+        this->list_buf = nbuf;
+        this->list_bsize += 32 << 10;
+      }
+    }
+    size = have;
+  }
+  memset (this->list_buf, 0, 4);
+  memset (this->list_buf + 4 + size, 0, 4);
+
+
+  this->tmode = XINE_STREE_AUTO;
+  this->tree = xine_stree_load (this->list_buf + 4, &this->tmode);
+  if (!this->tree) {
+    this->list_bsize = 0;
+    _x_freep (&this->list_buf);
+    return 0;
+  }
+
+  tree_mpd = xine_stree_find (this->tree, this->list_buf + 4, "mpd", 0, 0);
+  if (!tree_mpd) {
+    tree_mpd = xine_stree_find (this->tree, this->list_buf + 4, "?xml.mpd", 0, 0);
+    if (!tree_mpd) {
+      xine_stree_delete (&this->tree);
+      this->list_bsize = 0;
+      _x_freep (&this->list_buf);
+      return 0;
+    }
+  }
+
+  this->base_url = mpd_stree_find (this, "BaseURL", tree_mpd);
+  this->seg_base_url = mpd_stree_find (this, "SegmentBase", tree_mpd);
+  if (!this->list_buf[this->seg_base_url])
+    this->seg_base_url = this->base_url;
+  this->time_url = mpd_stree_find (this, "UTCTiming.value", tree_mpd);
+  {
+    char *s = this->list_buf + mpd_stree_find (this, "availabilityStartTime", tree_mpd);
+    this->sync.avail_start = mpd_str2time (s);
+  }
+
+  {
+    char path_p[] = "Period[  ]";
+    uint32_t period, index_p;
+
+    this->num_streams = 0;
+    for (period = 0; this->num_streams < MPD_MAX_STREAMS; period++) {
+      char path_as[] = "AdaptationSet[  ]";
+      uint32_t adaptationset, index_as, max_as;
+
+      path_p[7] = period < 10 ? ' ' : '0' + period / 10u;
+      path_p[8] = '0' + period % 10u;
+      index_p = xine_stree_find (this->tree, this->list_buf + 4, path_p, tree_mpd, 0);
+      if (!index_p)
+        break;
+
+      max_as = MPD_MAX_STREAMS - this->num_streams;
+      if (max_as > MPD_MAX_SIDES)
+        max_as = MPD_MAX_SIDES;
+      for (adaptationset = 0; adaptationset < max_as; adaptationset++) {
+        char path_r[] = "Representation[  ]";
+        uint32_t representation, max_r;
+        mpd_stream_info_t *info;
+        char *s;
+
+        path_as[14] = adaptationset < 10 ? ' ' : '0' + adaptationset / 10;
+        path_as[15] = '0' + adaptationset % 10;
+        index_as = xine_stree_find (this->tree, this->list_buf + 4, path_as, index_p, 0);
+        if (!index_as)
+          break;
+        info = this->streams + this->num_streams;
+        s = this->list_buf + mpd_stree_find (this, "contentType", index_as);
+        info->type = 0;
+        if (mpd_strcasestr (s, "audio"))
+          info->type |= MPD_TYPE_AUDIO;
+        if (mpd_strcasestr (s, "video"))
+          info->type |= MPD_TYPE_VIDEO;
+        if (mpd_strcasestr (s, "subtitle"))
+          info->type |= MPD_TYPE_SUBT;
+        info->mime = mpd_stree_find (this, "mimeType", index_as);
+        info->index_p = index_p;
+        info->index_as = index_as;
+        info->index_r = 0;
+        s = this->list_buf + mpd_stree_find (this, "SegmentTemplate.timescale", index_as);
+        info->timebase = str2uint32 (&s);
+        s = this->list_buf + mpd_stree_find (this, "audioSamplingRate", index_as);
+        info->samplerate = str2uint32 (&s);
+        info->init = mpd_stree_find (this, "SegmentTemplate.initialization", index_as);
+        info->media = mpd_stree_find (this, "SegmentTemplate.media", index_as);
+        s = this->list_buf + mpd_stree_find (this, "width", index_as);
+        info->w = str2uint32 (&s);
+        s = this->list_buf + mpd_stree_find (this, "height", index_as);
+        info->h = str2uint32 (&s);
+        /* this seems to default to 1. */
+        s = this->list_buf + mpd_stree_find (this, "SegmentTemplate.startNumber", index_as);
+        info->frag_start = s[0] ? str2uint32 (&s) : 1;
+        s = this->list_buf + mpd_stree_find (this, "SegmentTemplate.duration", index_as);
+        info->frag_duration = str2uint32 (&s);
+        info->id = 0;
+        info->bitrate = 0;
+
+        max_r = MPD_MAX_STREAMS - this->num_streams;
+        if (max_r > MPD_MAX_REPR - 1)
+          max_r = MPD_MAX_REPR - 1;
+        for (representation = 0; representation < max_r; representation++) {
+          uint32_t index_r;
+
+          path_r[15] = representation < 10 ? ' ' : '0' + representation / 10;
+          path_r[16] = '0' + representation % 10;
+          index_r = xine_stree_find (this->tree, this->list_buf + 4, path_r, index_as, 0);
+          if (!index_r)
+            break;
+          if (representation)
+            info[0] = info[-1];
+          info->index_r = index_r;
+          info->id = mpd_stree_find (this, "id", index_r);
+          info->sfile = mpd_stree_find (this, "BaseURL", index_r);
+          s = this->list_buf + mpd_stree_find (this, "SegmentBase.timescale", index_r);
+          if (s[0])
+            info->timebase = str2uint32 (&s);
+          s = this->list_buf + mpd_stree_find (this, "audioSamplingRate", index_r);
+          if (s[0])
+            info->samplerate = str2uint32 (&s);
+          s = this->list_buf + mpd_stree_find (this, "bandwidth", index_r);
+          info->bitrate = str2uint32 (&s);
+          s = this->list_buf + mpd_stree_find (this, "width", index_r);
+          info->w = str2uint32 (&s);
+          s = this->list_buf + mpd_stree_find (this, "height", index_r);
+          info->h = str2uint32 (&s);
+          xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "input_mpegdash.%d: stream[%2u]: %s %ux%u %uHz %ubps.\n",
+            (int)this->side_index,
+            (unsigned int)this->num_streams, this->list_buf + info->mime, (unsigned int)info->w, (unsigned int)info->h,
+            (unsigned int)info->samplerate, (unsigned int)info->bitrate);
+          info++;
+          this->side_have_streams[adaptationset][representation] = this->num_streams;
+          this->num_streams += 1;
+        }
+
+        if (!representation) {
+          /* FIXME: empty adaptationset?? */
+          info->sfile = 0;
+          xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "input_mpegdash.%d: stream[%2u]: %s %ux%u %uHz %ubps.\n",
+            (int)this->side_index,
+            (unsigned int)this->num_streams, this->list_buf + info->mime, (unsigned int)info->w, (unsigned int)info->h,
+            (unsigned int)info->samplerate, (unsigned int)info->bitrate);
+          this->side_have_streams[adaptationset][representation] = this->num_streams;
+          this->num_streams += 1;
+        }
+        this->side_have_streams[adaptationset][representation] = 255;
+      }
+      this->num_sides = adaptationset;
+    }
+  }
+
+  {
+    uint32_t u;
+
+    for (u = 0; u < this->num_streams; u++) {
+      mpd_stream_info_t *info = this->streams + u;
+
+      if (!this->list_buf[info->media])
+        info->media = info->sfile;
+    }
+  }
+
+  return 1;
+}
+
+static uint32_t mpd_input_get_capabilities (input_plugin_t *this_gen) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+  if (!this)
+    return 0;
+  if (MPD_IS_LIVE (this))
+    return INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW | INPUT_CAP_LIVE;
+  if (this->fraglist)
+    return INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW | INPUT_CAP_SLOW_SEEKABLE | INPUT_CAP_TIME_SEEKABLE;
+  if (this->in1) {
+    this->caps1 = this->in1->get_capabilities (this->in1);
+    return INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW | (this->caps1 & (INPUT_CAP_SEEKABLE | INPUT_CAP_SLOW_SEEKABLE));
+  }
+  return INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW;
+}
+
+static off_t mpd_input_read (input_plugin_t *this_gen, void *buf, off_t len) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+  if (!this)
+    return 0;
+  return mpd_read_int (this, buf, len, 1);
+}
+
+static buf_element_t *mpd_input_read_block (input_plugin_t *this_gen, fifo_buffer_t *fifo, off_t todo) {
+  (void)this_gen;
+  (void)fifo;
+  (void)todo;
+  return NULL;
+}
+
+static off_t mpd_input_time_seek (input_plugin_t *this_gen, int time_offs, int origin) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+
+  if (!this)
+    return 0;
+
+  do {
+    xine_mfrag_index_t idx;
+    int64_t frag_time1, frag_time2;
+    uint32_t new_time;
+
+    if (!this->fraglist)
+      return this->pos;
+
+    switch (origin) {
+      case SEEK_SET:
+        new_time = 0;
+        break;
+      case SEEK_CUR:
+        if (xine_mfrag_get_index_start (this->fraglist, this->frag_index, &frag_time1, NULL)
+          && xine_mfrag_get_index_start (this->fraglist, this->frag_index + 1, &frag_time2, NULL)) {
+          new_time = frag_time1 * 1000 / this->info.timebase;
+          if (this->frag_size)
+            new_time += ((frag_time2 - frag_time1) * 1000 / this->info.timebase) * (this->pos - this->frag_pos) / this->frag_size;
+        } else {
+          new_time = 0;
+        }
+        break;
+      case SEEK_END:
+        if (xine_mfrag_get_index_start (this->fraglist, xine_mfrag_get_frag_count (this->fraglist) + 1, &frag_time1, NULL)) {
+          new_time = frag_time1 * 1000 / this->info.timebase;
+        } else {
+          new_time = 0;
+        }
+        break;
+      default:
+        errno = EINVAL;
+        return (off_t)-1;
+    }
+    new_time += time_offs;
+
+    frag_time1 = (int64_t)new_time * this->info.timebase / 1000;
+    idx = xine_mfrag_find_time (this->fraglist, frag_time1);
+    if (idx < 1)
+      break;
+    if (!xine_mfrag_get_index_start (this->fraglist, idx, NULL, &frag_time1))
+      break;
+    if ((uint32_t)idx != this->frag_index) {
+      if (!mpd_set_frag_index (this, idx, 1))
+        break;
+    }
+    this->prev_size2 = 0;
+    this->pos = frag_time1;
+    mpd_frag_seen (this);
+    return this->pos;
+  } while (0);
+
+  errno = EINVAL;
+  return (off_t)-1;
+}
+
+static off_t mpd_input_seek (input_plugin_t *this_gen, off_t offset, int origin) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+  off_t new_offs;
+
+  if (!this)
+    return 0;
+
+  switch (origin) {
+    case SEEK_SET:
+      new_offs = offset;
+      break;
+    case SEEK_CUR:
+      new_offs = this->pos + offset;
+      break;
+    case SEEK_END:
+      if (MPD_IS_LIVE (this))
+        return this->pos;
+      if (this->fraglist) {
+        int n;
+        int64_t l;
+        n = xine_mfrag_get_frag_count (this->fraglist);
+        if (n < 1)
+          return this->pos;
+        this->info.frag_count = n;
+        if (!xine_mfrag_get_index_start (this->fraglist, n + 1, NULL, &l))
+          return this->pos;
+        if (l <= 0)
+          return this->pos;
+        this->all_size = l;
+        new_offs = l + offset;
+        break;
+      }
+      if (this->in1) {
+        off_t l = this->in1->get_length (this->in1);
+        if (l > 0) {
+          this->all_size = l;
+          new_offs = l + offset;
+          break;
+        }
+      }
+      /* fall through */
+    default:
+      return this->pos;
+  }
+
+  /* always seek within the preview. */
+  if ((this->pos <= (int)this->prev_size2) && (new_offs >= 0) && (new_offs <= (int)this->prev_size2)) {
+    this->pos = new_offs;
+    return this->pos;
+  }
+  this->prev_size2 = 0;
+
+  if (this->fraglist) {
+    int64_t frag_pos;
+    xine_mfrag_index_t idx = xine_mfrag_find_pos (this->fraglist, new_offs);
+    if (idx < 1)
+      return this->pos;
+    /* HACK: offsets around this fragment may be guessed ones,
+     * and the fragment itself may turn out to be smaller than expected.
+     * however, demux expects a seek to land at the exact byte offs.
+     * lets try to meet that, even if it is still wrong. */
+    idx -= 1;
+    do {
+      idx += 1;
+      if (!xine_mfrag_get_index_start (this->fraglist, idx, NULL, &frag_pos))
+        return this->pos;
+      if ((uint32_t)idx != this->frag_index) {
+        mpd_frag_end (this);
+        if (!mpd_set_frag_index (this, idx, 1))
+          return this->pos;
+        this->pos = frag_pos;
+        mpd_frag_seen (this);
+      }
+    } while (new_offs >= this->pos + this->frag_size);
+  }
+
+  this->caps1 = this->in1->get_capabilities (this->in1);
+  if (this->caps1 & (INPUT_CAP_SEEKABLE | INPUT_CAP_SLOW_SEEKABLE)) {
+    off_t r = this->in1->seek (this->in1, new_offs - this->frag_pos, SEEK_SET);
+
+    if (r >= 0)
+      this->pos = this->frag_pos + r;
+    return this->pos;
+  }
+
+  new_offs -= this->pos;
+  if (new_offs < 0)
+    return this->pos;
+  {
+    while (new_offs > 0) {
+      char buf[2048];
+      size_t l = new_offs > (int)sizeof (buf) ? sizeof (buf) : (size_t)new_offs;
+      ssize_t r = mpd_read_int (this, buf, l, 1);
+
+      if (r <= 0)
+        break;
+      new_offs -= r;
+    }
+  }
+  return this->pos;
+}
+
+static off_t mpd_input_get_current_pos (input_plugin_t *this_gen) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+  if (!this)
+    return 0;
+  return this->pos;
+}
+
+static off_t mpd_input_get_length (input_plugin_t *this_gen) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+  if (!this)
+    return 0;
+  if (MPD_IS_LIVE (this)) {
+    if (this->pos > this->all_size)
+      this->all_size = this->pos;
+  } else if (this->fraglist) {
+    int n;
+    int64_t l;
+    n = xine_mfrag_get_frag_count (this->fraglist);
+    if (n >= 1) {
+      this->info.frag_count = n;
+      if (xine_mfrag_get_index_start (this->fraglist, n + 1, NULL, &l) && (l > 0))
+        this->all_size = l;
+    }
+  } else if (this->in1) {
+    off_t l = this->in1->get_length (this->in1);
+    if (l > 0)
+      this->all_size = l;
+  }
+  return this->all_size;
+}
+
+static const char *mpd_input_get_mrl (input_plugin_t *this_gen) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+  if (!this)
+    return NULL;
+  return this->manifest_mrl;
+}
+
+static void mpd_input_dispose (input_plugin_t *this_gen) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+
+  if (!this)
+    return;
+
+  if (this->nbc) {
+    nbc_close (this->nbc);
+    this->nbc = NULL;
+  }
+  if (this->in1) {
+    _x_free_input_plugin (this->stream, this->in1);
+    this->in1 = NULL;
+  }
+  xine_mfrag_list_close (&this->fraglist);
+  xine_stree_delete (&this->tree);
+  _x_freep (&this->list_buf);
+
+  if (this->side_index) {
+    mpd_input_plugin_t *main_input = this->main_input;
+    this->sync.refs = 0;
+    free (this);
+    this = main_input;
+  }
+  if (this->sync.init) {
+    pthread_mutex_lock (&this->sync.mutex);
+    if (--this->sync.refs == 0) {
+      pthread_mutex_unlock (&this->sync.mutex);
+      pthread_mutex_destroy (&this->sync.mutex);
+      free (this);
+    } else {
+      pthread_mutex_unlock (&this->sync.mutex);
+    }
+  } else {
+    if (--this->sync.refs == 0)
+      free (this);
+  }
+}
+
+static int mpd_input_open (input_plugin_t *this_gen) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+  mpd_input_class_t  *cls  = (mpd_input_class_t *)this->input_plugin.input_class;
+  int n;
+
+  if (!this->side_index) {
+    uint32_t u;
+    if (!mpd_input_load_manifest (this))
+      return 0;
+    if (!this->num_streams) {
+      xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+        "input_mpegdash.%d: no streams.\n", (int)this->side_index);
+      return 0;
+    }
+    /* video decoding usually is much slower than audio.
+     * if there is video, make it the main stream.
+     * this way, its effective lag will be 0, and the
+     * engine need not drop video frames. */
+    for (u = 0; u < this->num_sides; u++) {
+      uint32_t v = this->side_have_streams[u][0];
+      if ((v != 255) && (this->streams[v].type & MPD_TYPE_VIDEO))
+        break;
+    }
+    if ((u > 0) && (u < this->num_sides)) {
+      uint8_t t[MPD_MAX_REPR];
+      memcpy (t, this->side_have_streams[0], sizeof (t));
+      memcpy (this->side_have_streams[0], this->side_have_streams[u], sizeof (t));
+      memcpy (this->side_have_streams[u], t, sizeof (t));
+    }
+    if ((this->num_sides > 1) && !this->sync.init) {
+      pthread_mutex_init (&this->sync.mutex, NULL);
+      this->sync.init = 1;
+    }
+  }
+
+  {
+    multirate_pref_t *item = this->items;
+    uint32_t u, i;
+    for (u = 0; (i = this->side_have_streams[this->side_index][u]) != 255; u++) {
+      mpd_stream_info_t *info = this->streams + i;
+      item->video_width = info->w;
+      item->video_height = info->h;
+      item->bitrate = info->bitrate;
+      item->lang[0] = 0;
+      item++;
+    }
+    n = multirate_autoselect (&cls->pref, this->items, u);
+  }
+  if (n < 0) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+        "input_mpegdash.%d: no auto selected item.\n", (int)this->side_index);
+    return 0;
+  }
+  this->used_stream = n = this->side_have_streams[this->side_index][n];
+  this->info = this->streams[n];
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "input_mpegdash.%d: auto selected stream #%d.\n", (int)this->side_index, n);
+  this->mode = this->list_buf[this->time_url]
+             ? (this->list_buf[this->info.init]
+                 ? MPD_INIT_LIVE
+                 : mpd_strcasestr (this->list_buf + this->info.media, "$Number$") ? MPD_LIVE : MPD_SINGLE_LIVE)
+             : (this->list_buf[this->info.init]
+                 ? MPD_INIT_VOD
+                 : mpd_strcasestr (this->list_buf + this->info.media, "$Number$") ? MPD_VOD : MPD_SINGLE_VOD);
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "input_mpegdash.%d: %s.\n", (int)this->side_index, mpd_mode_names[this->mode]);
+
+  if ((this->mode == MPD_INIT_VOD) || (this->mode == MPD_VOD)) {
+    xine_mfrag_list_open (&this->fraglist);
+    xine_mfrag_set_index_frag (this->fraglist, 0, this->info.timebase, 0);
+  }
+
+  this->frag_index = 0;
+  this->prev_size1 = 0;
+  this->prev_size2 = 0;
+  this->pos = 0;
+  n = mpd_read_int (this, this->preview, sizeof (this->preview), 0);
+  if (n <= 0) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_LOG,
+      "input_mpegdash.%d: failed to read preview.\n", (int)this->side_index);
+    return 0;
+  }
+  this->prev_size1 = n;
+  this->prev_size2 = n;
+  this->pos = 0;
+  /*
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "input_mpegdash.%d: got %u fragments for %u.%03u seconds.\n",
+    (int)this->side_index, (unsigned int)this->frag_have,
+    (unsigned int)(this->frags[this->frag_have].start_msec / 1000u),
+    (unsigned int)(this->frags[this->frag_have].start_msec % 1000u));
+  */
+
+  return 1;
+}
+
+static input_plugin_t *mpd_get_side (mpd_input_plugin_t *this, int side_index) {
+  mpd_input_plugin_t *side_input;
+
+  if (this->side_index)
+    return NULL;
+  if ((side_index < 1) || (side_index >= (int)this->num_sides))
+    return NULL;
+  side_input = malloc (sizeof (*side_input));
+  if (!side_input)
+    return NULL;
+
+  /* clone everything */
+  *side_input = *this;
+
+  /* sync */
+  if (this->sync.init) {
+    pthread_mutex_lock (&this->sync.mutex);
+    this->sync.refs++;
+    pthread_mutex_unlock (&this->sync.mutex);
+  } else {
+    this->sync.refs++;
+  }
+  memset (&side_input->sync.mutex, 0, sizeof (side_input->sync.mutex));
+  side_input->sync.init = 0;
+  side_input->sync.refs = 1;
+
+  /* detach */
+  side_input->side_index = side_index;
+  side_input->in1 = NULL;
+  side_input->caps1 = 0;
+  side_input->tree = NULL;
+  side_input->fraglist = NULL;
+
+  side_input->list_buf = malloc (this->list_bsize);
+  if (!side_input->list_buf) {
+    free (side_input);
+    return NULL;
+  }
+  memcpy (side_input->list_buf, this->list_buf, this->list_bsize);
+
+  side_input->stream = xine_get_side_stream (this->stream, side_index);
+  if (!side_input->stream) {
+    free (side_input->list_buf);
+    free (side_input);
+    return NULL;
+  }
+  side_input->nbc = nbc_init (side_input->stream);
+
+  return &side_input->input_plugin;
+}
+  
+static int mpd_input_get_optional_data (input_plugin_t *this_gen, void *data, int data_type) {
+  mpd_input_plugin_t *this = (mpd_input_plugin_t *)this_gen;
+
+  if (!this)
+    return INPUT_OPTIONAL_UNSUPPORTED;
+
+  switch (data_type) {
+
+    case INPUT_OPTIONAL_DATA_PREVIEW:
+      if (!data || (this->prev_size1 <= 0))
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      {
+        uint32_t l = this->prev_size1 > MAX_PREVIEW_SIZE ? MAX_PREVIEW_SIZE : this->prev_size1;
+        memcpy (data, this->preview, l);
+        return l;
+      }
+
+    case INPUT_OPTIONAL_DATA_SIZED_PREVIEW:
+      if (!data || (this->prev_size1 <= 0))
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      {
+        int want;
+        memcpy (&want, data, sizeof (want));
+        want = want < 0 ? 0
+             : want > (int)this->prev_size1 ? (int)this->prev_size1
+             : want;
+        memcpy (data, this->preview, want);
+        return want;
+      }
+
+    case INPUT_OPTIONAL_DATA_DURATION:
+      if (!data)
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      if (this->fraglist) {
+        int64_t d;
+        int n = xine_mfrag_get_frag_count (this->fraglist);
+        if (n > 0) {
+          if (xine_mfrag_get_index_start (this->fraglist, n + 1, &d, NULL))
+            this->duration = d * 1000 / this->info.timebase;
+        }
+      } else {
+        this->duration = (int64_t)this->info.frag_count * this->info.frag_duration * 1000 / this->info.timebase;
+      }
+      memcpy (data, &this->duration, sizeof (this->duration));
+      return INPUT_OPTIONAL_SUCCESS;
+
+    case INPUT_OPTIONAL_DATA_FRAGLIST:
+      if (!data)
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      memcpy (data, &this->fraglist, sizeof (this->fraglist));
+      return INPUT_OPTIONAL_SUCCESS;
+
+    case INPUT_OPTIONAL_DATA_SIDE:
+      if (!data)
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      {
+        int side_index;
+        input_plugin_t *side_input;
+        memcpy (&side_index, data, sizeof (side_index));
+        side_input = mpd_get_side (this, side_index);
+        if (!side_input)
+          return INPUT_OPTIONAL_UNSUPPORTED;
+        memcpy (data, &side_input, sizeof (side_input));
+        return INPUT_OPTIONAL_SUCCESS;
+      }
+
+    case INPUT_OPTIONAL_DATA_PTSOFFS:
+      return this->sync.lag - this->lag;
+
+    case INPUT_OPTIONAL_DATA_REWIND:
+      if (!data)
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      memcpy (&this->rewind, data, sizeof (this->rewind));
+      return INPUT_OPTIONAL_SUCCESS;
+
+    default:
+      return INPUT_OPTIONAL_UNSUPPORTED;
+  }
+}
+
+static input_plugin_t *mpd_input_get_instance (input_class_t *cls_gen, xine_stream_t *stream, const char *mrl) {
+
+  mpd_input_class_t  *cls = (mpd_input_class_t *)cls_gen;
+  mpd_input_plugin_t *this;
+  input_plugin_t     *in1;
+  char                hbuf[2048];
+  int                 n;
+
+  if (!cls || !mrl)
+    return NULL;
+  lprintf("mpd_input_get_instance\n");
+
+  do {
+    n = !strncasecmp (mrl, "mpegdash:/", 10) ? 10 : 0;
+    in1 = _x_find_input_plugin (stream, mrl + n);
+    if (in1) {
+      if (in1->open (in1) > 0) {
+        int l;
+        if (mpd_input_is_mpd (mrl))
+          break;
+        l = _x_demux_read_header (in1, hbuf, sizeof (hbuf) - 1);
+        if (l > 5) {
+          char *p = hbuf;
+          p[l] = 0;
+          while ((p = strchr (p, '<'))) {
+            p++;
+            if (!strncasecmp (p, "mpd ", 4))
+              break;
+          }
+        }
+      }
+      _x_free_input_plugin (stream, in1);
+    }
+    return NULL;
+  } while (0);
+
+  this = calloc (1, sizeof (*this));
+  if (!this)
+    return NULL;
+
+#ifndef HAVE_ZERO_SAFE_MEM
+  this->side_index   = 0;
+  this->caps1        = 0;
+  this->fraglist     = NULL;
+  this->list_buf     = NULL;
+  this->list_bsize   = 0;
+  this->duration     = 0;
+  this->all_size     = 0;
+  this->sync.lag     = 0;
+  this->sync.type    = 0;
+  this->sync.init    = 0;
+  this->lag          = 0;
+  this->rewind       = 0;
+#endif
+
+  this->main_input = this;
+  this->stream = stream;
+  this->in1    = in1;
+  this->num_sides = 0;
+  this->sync.avail_start =
+  this->sync.play_start  = (time_t)-1;
+  this->sync.refs = 1;
+
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "input_mpegdash.%d: %s.\n", (int)this->side_index, mrl + n);
+
+  strlcpy (this->manifest_mrl, mrl + n, MPD_MAX_MRL);
+
+  this->input_plugin.open               = mpd_input_open;
+  this->input_plugin.get_capabilities   = mpd_input_get_capabilities;
+  this->input_plugin.read               = mpd_input_read;
+  this->input_plugin.read_block         = mpd_input_read_block;
+  this->input_plugin.seek               = mpd_input_seek;
+  this->input_plugin.seek_time          = mpd_input_time_seek;
+  this->input_plugin.get_current_pos    = mpd_input_get_current_pos;
+  this->input_plugin.get_length         = mpd_input_get_length;
+  this->input_plugin.get_blocksize      = _x_input_default_get_blocksize;
+  this->input_plugin.get_mrl            = mpd_input_get_mrl;
+  this->input_plugin.get_optional_data  = mpd_input_get_optional_data;
+  this->input_plugin.dispose            = mpd_input_dispose;
+  this->input_plugin.input_class        = &cls->input_class;
+
+  this->nbc = stream ? nbc_init (stream) : NULL;
+
+  return &this->input_plugin;
+}
+
+
+/*
+ * plugin class functions
+ */
+
+static void mpd_input_class_dispose (input_class_t *this_gen) {
+  mpd_input_class_t *this = (mpd_input_class_t *)this_gen;
+  config_values_t   *config = this->xine->config;
+
+  config->unregister_callbacks (config, NULL, NULL, this, sizeof (*this));
+
+  free (this);
+}
+
+void *input_mpegdash_init_class (xine_t *xine, const void *data) {
+
+  mpd_input_class_t *this;
+
+  (void)data;
+  this = calloc (1, sizeof (*this));
+  if (!this)
+    return NULL;
+
+  this->xine = xine;
+  multirate_pref_get (xine->config, &this->pref);
+
+  this->input_class.get_instance       = mpd_input_get_instance;
+  this->input_class.identifier         = "mpegdash";
+  this->input_class.description        = N_("MPEG Dynamic Adaptive Streaming over Http input plugin");
+  this->input_class.get_dir            = NULL;
+  this->input_class.get_autoplay_list  = NULL;
+  this->input_class.dispose            = mpd_input_class_dispose;
+  this->input_class.eject_media        = NULL;
+
+  return this;
+}
diff -urN xine-lib-1.2.11/src/input/input_pvr.c xine-lib-1.2/src/input/input_pvr.c
--- xine-lib-1.2.11/src/input/input_pvr.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_pvr.c	2022-01-15 22:03:19.590547196 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  * March 2003 - Miguel Freitas
  * This plugin was sponsored by 1Control
  *
@@ -1007,7 +1007,8 @@
         this->input = v4l2_data->input;
 
         /* as of ivtv 0.10.6: must close and reopen to set input */
-        close(this->dev_fd);
+        if (this->dev_fd >= 0)
+          close(this->dev_fd);
         this->dev_fd = xine_open_cloexec(this->devname, O_RDWR);
         if (this->dev_fd < 0) {
           xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
@@ -1157,7 +1158,8 @@
        pthread_mutex_lock(&this->dev_lock);
 
        /* how lame. we must close and reopen to change bitrate. */
-       close(this->dev_fd);
+       if (this->dev_fd >= 0)
+         close(this->dev_fd);
        this->dev_fd = xine_open_cloexec(this->devname, O_RDWR);
        if (this->dev_fd == -1) {
          pthread_mutex_unlock(&this->dev_lock);
diff -urN xine-lib-1.2.11/src/input/input_stdin_fifo.c xine-lib-1.2/src/input/input_stdin_fifo.c
--- xine-lib-1.2.11/src/input/input_stdin_fifo.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_stdin_fifo.c	2022-01-15 22:03:19.610547280 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -43,6 +43,7 @@
 #include "input_helper.h"
 
 #define BUFSIZE                 1024
+
 #if defined(WIN32) || defined(__CYGWIN__)
 #  define FILE_FLAGS (O_RDONLY | O_BINARY)
 #else
@@ -351,11 +352,17 @@
 
   lprintf ("trying to open '%s'...\n", this->mrl);
 
+/* POSIX manpage: "If  O_NONBLOCK is clear, an open() for reading-only shall block
+ * the calling thread until a thread opens the file for writing."
+ * This seems to include the case when that pipe already is open for write,
+ * as may result from a race with Kaffeine live DVB when user zaps channels quickly.
+ * Try to avoid this with an early O_NONBLOCK. */
+
   if (this->fh == -1) {
     const char *filename;
 
     filename = (const char *) &this->mrl[5];
-    this->fh = xine_open_cloexec(filename, FILE_FLAGS);
+    this->fh = xine_open_cloexec (filename, FILE_FLAGS | O_NONBLOCK);
 
     lprintf("filename '%s'\n", filename);
 
@@ -373,15 +380,20 @@
   this->ring_read = 0;
   _x_freep (&this->ring_buf);
 
+  this->mode = 0;
 #ifdef WIN32
-  setmode(this->fh, FILE_FLAGS);
+  setmode (this->fh, FILE_FLAGS | O_NONBLOCK);
 #else
   this->old_mode = fcntl (this->fh, F_GETFL);
   if (this->old_mode != -1) {
-    fcntl (this->fh, F_SETFL, this->old_mode | O_NONBLOCK);
-    this->mode = fcntl (this->fh, F_GETFL);
-    this->nonblock = !!(this->mode & O_NONBLOCK);
+    if (!(this->old_mode & O_NONBLOCK)) {
+      fcntl (this->fh, F_SETFL, this->old_mode | O_NONBLOCK);
+      this->mode = fcntl (this->fh, F_GETFL);
+    } else {
+      this->mode = this->old_mode;
+    }
   }
+  this->nonblock = !!(this->mode & O_NONBLOCK);
   if (this->nonblock)
     this->ring_buf = malloc (RING_SIZE);
 #endif
diff -urN xine-lib-1.2.11/src/input/input_test.c xine-lib-1.2/src/input/input_test.c
--- xine-lib-1.2.11/src/input/input_test.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_test.c	2022-01-15 22:03:19.601547242 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2019 the xine project
+ * Copyright (C) 2012-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -539,7 +539,7 @@
 
   /* add readable title */
   {
-    char *test_titles[5] = {
+    const char *test_titles[5] = {
       _("Colour Circle"),
       _("RGB Levels"),
       _("Saturation Levels"),
diff -urN xine-lib-1.2.11/src/input/input_vcd.c xine-lib-1.2/src/input/input_vcd.c
--- xine-lib-1.2.11/src/input/input_vcd.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/input_vcd.c	2022-01-15 22:03:19.596547221 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -50,6 +50,7 @@
 #include <xine/xineutils.h>
 #include <xine/input_plugin.h>
 #include "media_helper.h"
+#include "input_helper.h"
 
 #if defined(__sun)
 #define	CDROM	       "/vol/dev/aliases/cdrom0"
@@ -89,7 +90,6 @@
 
   char                 **filelist;
 
-  int                    mrls_allocated_entries;
   xine_mrl_t           **mrls;
 
 #if defined (__linux__) || defined(__sun)
@@ -943,7 +943,7 @@
     free(*(entry++));
   }
 
-  free(this->filelist);
+  _x_freep(&this->filelist);
 }
 
 static void vcd_class_dispose (input_class_t *this_gen) {
@@ -955,12 +955,7 @@
 
   vcd_filelist_dispose(this);
 
-  while (this->mrls_allocated_entries) {
-    this->mrls_allocated_entries--;
-    MRL_ZERO(this->mrls[this->mrls_allocated_entries]);
-    _x_freep(&this->mrls[this->mrls_allocated_entries]);
-  }
-  _x_freep(&this->mrls);
+  _x_input_free_mrls(&this->mrls);
 
   free (this);
 }
@@ -979,6 +974,7 @@
   int i, fd;
 
   *num_files = 0;
+  _x_input_free_mrls(&this->mrls);
 
   if (filename)
     return NULL;
@@ -1004,20 +1000,17 @@
   close (fd);
   fd = -1;
 
+  if (this->total_tracks < 2)
+    return NULL;
+
+  this->mrls = _x_input_alloc_mrls(this->total_tracks - 1);
+  if (!this->mrls)
+    return NULL;
+
   *num_files = this->total_tracks - 1;
   /* printf ("%d tracks\n", this->total_tracks); */
 
   for (i=1; i<this->total_tracks; i++) { /* FIXME: check if track 0 contains valid data */
-    if((i-1) >= this->mrls_allocated_entries) {
-      ++this->mrls_allocated_entries;
-      /* note: 1 extra pointer for terminating NULL */
-      this->mrls = realloc(this->mrls, (this->mrls_allocated_entries+1) * sizeof(xine_mrl_t*));
-      this->mrls[(i-1)] = calloc(1, sizeof(xine_mrl_t));
-    }
-    else {
-      MRL_ZERO(this->mrls[(i-1)]);
-    }
-
     this->mrls[i-1]->mrl  = _x_asprintf("vcdo:/%d", i);
     this->mrls[i-1]->type = mrl_vcd;
 
@@ -1025,18 +1018,6 @@
     this->mrls[i-1]->size = vcd_plugin_get_length ((input_plugin_t *) this);
   }
 
-
-  /*
-   * Freeing exceeded mrls if exists.
-   */
-  while(this->mrls_allocated_entries > *num_files) {
-    this->mrls_allocated_entries--;
-    MRL_ZERO(this->mrls[this->mrls_allocated_entries]);
-    _x_freep(&this->mrls[this->mrls_allocated_entries]);
-  }
-
-  this->mrls[*num_files] = NULL;
-
   return this->mrls;
 }
 
@@ -1070,6 +1051,8 @@
 
   vcd_filelist_dispose(this);
   this->filelist = calloc(this->total_tracks+1, sizeof(char*));
+  if (!this->filelist)
+    return NULL;
 
   /* FIXME: check if track 0 contains valid data */
   for (i = 1; i < this->total_tracks; i++)
@@ -1106,9 +1089,6 @@
 					    "you intend to play your VideoCDs with."),
 					  10, device_change_cb, (void *)this);
 
-  this->mrls = calloc(1, sizeof(xine_mrl_t*));
-  this->mrls_allocated_entries = 0;
-
   return this;
 }
 
diff -urN xine-lib-1.2.11/src/input/libdvdnav/bswap.h xine-lib-1.2/src/input/libdvdnav/bswap.h
--- xine-lib-1.2.11/src/input/libdvdnav/bswap.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/bswap.h	2022-01-15 22:03:19.581547158 +0100
@@ -23,12 +23,12 @@
 #include "config.h"
 
 #if defined(WORDS_BIGENDIAN)
-/* All bigendian systems are fine, just ignore the swaps. */  
+/* All bigendian systems are fine, just ignore the swaps. */
 #define B2N_16(x) (void)(x)
 #define B2N_32(x) (void)(x)
 #define B2N_64(x) (void)(x)
 
-#else 
+#else
 
 /* For __FreeBSD_version */
 #if defined(HAVE_SYS_PARAM_H)
@@ -71,10 +71,10 @@
 #define B2N_32(x) x = be32toh(x)
 #define B2N_64(x) x = be64toh(x)
 
-/* This is a slow but portable implementation, it has multiple evaluation 
+/* This is a slow but portable implementation, it has multiple evaluation
  * problems so beware.
- * Old FreeBSD and Windows don't have <byteswap.h> or any other such 
- * functionality! 
+ * Old FreeBSD and Windows don't have <byteswap.h> or any other such
+ * functionality!
  */
 
 #elif defined(__FreeBSD__) || defined(__bsdi__) || defined(WIN32) || defined(__CYGWIN__)
diff -urN xine-lib-1.2.11/src/input/libdvdnav/decoder.h xine-lib-1.2/src/input/libdvdnav/decoder.h
--- xine-lib-1.2.11/src/input/libdvdnav/decoder.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/decoder.h	2022-01-15 22:03:19.574547128 +0100
@@ -1,19 +1,19 @@
 /*
  * Copyright (C) 2000, 2001 Martin Norbäck, Håkan Hjort
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library. It is modified
  * from a file originally part of the Ogle DVD player.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -98,8 +98,8 @@
 /* the big VM function, executing the given commands and writing
  * the link where to continue, the return value indicates if a jump
  * has been performed */
-int32_t vmEval_CMD(vm_cmd_t commands[], int32_t num_commands, 
-	       registers_t *registers, link_t *return_values);
+int32_t vmEval_CMD(vm_cmd_t commands[], int32_t num_commands,
+                   registers_t *registers, link_t *return_values);
 
 /* extracts some bits from the command */
 uint32_t vm_getbits(command_t* command, int32_t start, int32_t count);
diff -urN xine-lib-1.2.11/src/input/libdvdnav/diff_against_cvs.patch xine-lib-1.2/src/input/libdvdnav/diff_against_cvs.patch
--- xine-lib-1.2.11/src/input/libdvdnav/diff_against_cvs.patch	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/diff_against_cvs.patch	2022-01-15 22:03:19.596547221 +0100
@@ -0,0 +1,467 @@
+--- src/input/libdvdnav/dvdnav.c
++++ src/input/libdvdnav/dvdnav.c
+@@ -67,7 +67,7 @@
+   struct timeval time;
+   
+   /* Create a new structure */
+-  fprintf(MSG_OUT, "libdvdnav: Using dvdnav version %s from http://dvd.sf.net\n", VERSION);
++  fprintf(MSG_OUT, "libdvdnav: Using dvdnav version %s from http://xine.sf.net\n", VERSION);
+ 
+   (*dest) = NULL;
+   this = (dvdnav_t*)malloc(sizeof(dvdnav_t));
+--- src/input/libdvdnav/dvd_reader.c
++++ src/input/libdvdnav/dvd_reader.c
+@@ -61,6 +61,7 @@
+ #include <mntent.h>
+ #endif
+ 
++#include "compat.h"
+ #include "dvd_udf.h"
+ #include "dvd_input.h"
+ #include "dvd_reader.h"
+@@ -409,7 +410,7 @@
+ 	    
+ 	    if( cdir >= 0 ) {
+ 		chdir( path_copy );
+-		new_path = getcwd( NULL, PATH_MAX );
++		new_path = getcwd( NULL, XINE_PATH_MAX );
+ 		fchdir( cdir );
+ 		close( cdir );
+ 		if( new_path ) {
+@@ -595,7 +596,7 @@
+ 
+ static int findDVDFile( dvd_reader_t *dvd, const char *file, char *filename )
+ {
+-    char video_path[ PATH_MAX + 1 ];
++    char video_path[ XINE_PATH_MAX + 1 ];
+     const char *nodirfile;
+     int ret;
+ 
+@@ -629,7 +630,7 @@
+  */
+ static dvd_file_t *DVDOpenFilePath( dvd_reader_t *dvd, char *filename )
+ {
+-    char full_path[ PATH_MAX + 1 ];
++    char full_path[ XINE_PATH_MAX + 1 ];
+     dvd_file_t *dvd_file;
+     struct stat fileinfo;
+     dvd_input_t dev;
+@@ -722,7 +723,7 @@
+ static dvd_file_t *DVDOpenVOBPath( dvd_reader_t *dvd, int title, int menu )
+ {
+     char filename[ MAX_UDF_FILE_NAME_LEN ];
+-    char full_path[ PATH_MAX + 1 ];
++    char full_path[ XINE_PATH_MAX + 1 ];
+     struct stat fileinfo;
+     dvd_file_t *dvd_file;
+     int i;
+Index: dvd_input.c
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/dvd_input.c,v
+retrieving revision 1.6
+diff -u -r1.6 dvd_input.c
+--- dvd_input.c	5 Apr 2004 18:01:09 -0000	1.6
++++ dvd_input.c	27 May 2006 16:11:09 -0000
+@@ -35,6 +35,7 @@
+ int         (*dvdinput_title) (dvd_input_t, int); 
+ int         (*dvdinput_read)  (dvd_input_t, void *, int, int);
+ char *      (*dvdinput_error) (dvd_input_t);
++int         (*dvdinput_is_encrypted) (dvd_input_t);
+ 
+ #ifdef HAVE_DVDCSS_DVDCSS_H
+ /* linking to libdvdcss */
+@@ -55,6 +56,73 @@
+ #include "../../msvc/contrib/dlfcn.c"
+ #endif
+ 
++/* Copied from css.h */
++#define KEY_SIZE 5
++
++typedef uint8_t dvd_key_t[KEY_SIZE];
++
++typedef struct dvd_title_s
++{
++    int                 i_startlb;
++    dvd_key_t           p_key;
++    struct dvd_title_s *p_next;
++} dvd_title_t;
++
++typedef struct css_s
++{
++    int             i_agid;      /* Current Authenication Grant ID. */
++    dvd_key_t       p_bus_key;   /* Current session key. */
++    dvd_key_t       p_disc_key;  /* This DVD disc's key. */
++    dvd_key_t       p_title_key; /* Current title key. */
++} css_t;
++
++/* Copied from libdvdcss.h */
++
++#ifndef PATH_MAX
++#define PATH_MAX 4096
++#endif
++
++struct dvdcss_s
++{
++    /* File descriptor */
++    char * psz_device;
++    int    i_fd;
++    int    i_read_fd;
++    int    i_pos;
++
++    /* File handling */
++    void *pf_seek;
++    void *pf_read;
++    void *pf_readv;
++
++    /* Decryption stuff */
++    int          i_method;
++    css_t        css;
++    int          b_ioctls;
++    int          b_scrambled;
++    dvd_title_t *p_titles;
++
++    /* Key cache directory and pointer to the filename */
++    char   psz_cachefile[PATH_MAX];
++    char * psz_block;
++
++    /* Error management */
++    char * psz_error;
++    int    b_errors;
++    int    b_debug;
++
++#ifdef WIN32
++    int    b_file;
++    char * p_readv_buffer;
++    int    i_readv_buf_size;
++#endif
++
++#ifndef WIN32
++    int    i_raw_fd;
++#endif
++};
++
++
+ typedef struct dvdcss_s *dvdcss_handle;
+ static dvdcss_handle (*DVDcss_open)  (const char *);
+ static int           (*DVDcss_close) (dvdcss_handle);
+@@ -149,8 +217,13 @@
+   return 0;
+ }
+ 
+-
+-
++static int css_is_encrypted (dvd_input_t dev)
++{
++  if (dev->dvdcss == NULL) {
++    return 0;
++  }
++  return dev->dvdcss->b_scrambled;
++}
+ 
+ 
+ 
+@@ -269,6 +342,10 @@
+   return 0;
+ }
+ 
++static int file_is_encrypted (dvd_input_t dev)
++{
++  return 0;
++}
+ 
+ /**
+  * Setup read functions with either libdvdcss or minimal DVD access.
+@@ -347,6 +424,7 @@
+     dvdinput_title = css_title;
+     dvdinput_read  = css_read;
+     dvdinput_error = css_error;
++    dvdinput_is_encrypted = css_is_encrypted;
+     return 1;
+     
+   } else {
+@@ -359,6 +437,7 @@
+     dvdinput_title = file_title;
+     dvdinput_read  = file_read;
+     dvdinput_error = file_error;
++    dvdinput_is_encrypted = file_is_encrypted;
+     return 0;
+   }
+ }
+Index: dvd_input.h
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/dvd_input.h,v
+retrieving revision 1.1
+diff -u -r1.1 dvd_input.h
+--- dvd_input.h	29 Apr 2003 15:58:29 -0000	1.1
++++ dvd_input.h	27 May 2006 16:11:09 -0000
+@@ -38,6 +38,7 @@
+ extern int         (*dvdinput_title) (dvd_input_t, int); 
+ extern int         (*dvdinput_read)  (dvd_input_t, void *, int, int);
+ extern char *      (*dvdinput_error) (dvd_input_t);
++extern int         (*dvdinput_is_encrypted) (dvd_input_t);
+ 
+ /**
+  * Setup function accessed by dvd_reader.c.  Returns 1 if there is CSS support.
+Index: dvd_reader.c
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/dvd_reader.c,v
+retrieving revision 1.11
+diff -u -r1.11 dvd_reader.c
+--- dvd_reader.c	20 Sep 2004 19:30:04 -0000	1.11
++++ dvd_reader.c	27 May 2006 16:11:09 -0000
+@@ -480,6 +480,13 @@
+ 			     me->mnt_fsname,
+ 			     me->mnt_dir );
+                     auth_drive = DVDOpenImageFile( me->mnt_fsname, have_css );
++		    /* If the device is not encrypted, don't access the device
++		     * directly as it would fail for non-UDF DVDs */
++		    if ( dvdinput_is_encrypted( auth_drive->dev ) == 0) {
++		      DVDClose( auth_drive );
++		      auth_drive = NULL;
++		      break;
++		    }
+ 		    dev_name = strdup(me->mnt_fsname);
+                     break;
+                 }
+Index: src/input/libdvdnav/md5.c
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/md5.c,v
+retrieving revision 1.2
+diff -u -r1.2 md5.c
+--- src/input/libdvdnav/md5.c	29 Apr 2003 21:46:05 -0000	1.2
++++ src/input/libdvdnav/md5.c	2 Jun 2006 19:14:50 -0000
+@@ -26,14 +26,8 @@
+ 
+ #include <sys/types.h>
+ 
+-#if STDC_HEADERS || defined _LIBC
+-# include <stdlib.h>
+-# include <string.h>
+-#else
+-# ifndef HAVE_MEMCPY
+-#  define memcpy(d, s, n) bcopy ((s), (d), (n))
+-# endif
+-#endif
++#include <stdlib.h>
++#include <string.h>
+ 
+ #include "md5.h"
+ /* #include "unlocked-io.h" */
+Index: src/input/libdvdnav/bswap.h
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/bswap.h,v
+retrieving revision 1.3
+diff -u -p -u -r1.3 bswap.h
+--- src/input/libdvdnav/bswap.h	26 May 2003 23:11:44 -0000	1.3
++++ src/input/libdvdnav/bswap.h	17 Sep 2006 12:50:16 -0000
+@@ -35,7 +35,7 @@
+ #include <sys/param.h>
+ #endif
+ 
+-#if defined(__linux__)
++#if defined(__linux__) || defined(__GLIBC__)
+ #include <byteswap.h>
+ #define B2N_16(x) x = bswap_16(x)
+ #define B2N_32(x) x = bswap_32(x)
+@@ -41,6 +41,12 @@
+ #define B2N_32(x) x = bswap_32(x)
+ #define B2N_64(x) x = bswap_64(x)
+
++#elif defined(__APPLE__)
++#include <libkern/OSByteOrder.h>
++#define B2N_16(x) x = OSSwapBigToHostInt16(x)
++#define B2N_32(x) x = OSSwapBigToHostInt32(x)
++#define B2N_64(x) x = OSSwapBigToHostInt64(x)
++
+ #elif defined(__NetBSD__)
+ #include <sys/endian.h>
+ #define B2N_16(x) BE16TOH(x)
+Index: src/input/libdvdnav/dvd_reader.c
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/dvd_reader.c,v
+retrieving revision 1.13
+diff -u -p -u -r1.13 dvd_reader.c
+--- src/input/libdvdnav/dvd_reader.c	15 Jun 2006 14:26:40 -0000	1.13
++++ src/input/libdvdnav/dvd_reader.c	17 Sep 2006 12:50:16 -0000
+@@ -32,8 +32,13 @@
+ #include <limits.h>
+ #include <dirent.h>
+ 
+-/* misc win32 helpers */
+-#ifdef WIN32
++#ifndef HAVE_GETTIMEOFDAY
++#  ifdef WIN32
++#    include <winsock.h>
++struct timezone;
++#  else
++#    include <sys/time.h>
++#  endif
+ /* replacement gettimeofday implementation */
+ #include <sys/timeb.h>
+ static inline int _private_gettimeofday( struct timeval *tv, void *tz )
+@@ -45,6 +50,10 @@ static inline int _private_gettimeofday(
+   return 0;
+ }
+ #define gettimeofday(TV, TZ) _private_gettimeofday((TV), (TZ))
++#endif
++
++/* misc win32 helpers */
++#ifdef WIN32
+ #include <io.h> /* read() */
+ #define lseek64 _lseeki64
+ #endif
+Index: src/input/libdvdnav/dvd_reader.h
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/dvd_reader.h,v
+retrieving revision 1.5
+diff -u -p -u -r1.5 dvd_reader.h
+--- src/input/libdvdnav/dvd_reader.h	16 Mar 2004 11:43:38 -0000	1.5
++++ src/input/libdvdnav/dvd_reader.h	17 Sep 2006 12:50:16 -0000
+@@ -21,9 +21,11 @@
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+ 
+-#ifdef _MSC_VER
++#ifdef HAVE_CONFIG_H
+ #include "config.h"
++#endif
+ 
++#ifdef _MSC_VER
+ #include <stdio.h>
+ #include <stdlib.h>
+ #endif
+Index: src/input/libdvdnav/dvdnav_internal.h
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/dvdnav_internal.h,v
+retrieving revision 1.15
+diff -u -p -u -r1.15 dvdnav_internal.h
+--- src/input/libdvdnav/dvdnav_internal.h	20 Sep 2004 19:30:04 -0000	1.15
++++ src/input/libdvdnav/dvdnav_internal.h	17 Sep 2006 12:50:16 -0000
+@@ -34,6 +34,34 @@
+ #include <limits.h>
+ #include <string.h>
+ 
++#ifndef HAVE_GETTIMEOFDAY
++#  ifdef WIN32
++#    include <winsock.h>
++struct timezone;
++#  else
++#    include <sys/time.h>
++#  endif
++/* replacement gettimeofday implementation */
++#include <sys/timeb.h>
++static inline int dvdnav_private_gettimeofday( struct timeval *tv, void *tz )
++{
++  struct timeb t;
++  ftime( &t );
++  tv->tv_sec = t.time;
++  tv->tv_usec = t.millitm * 1000;
++  return 0;
++}
++#define gettimeofday(TV, TZ) dvdnav_private_gettimeofday((TV), (TZ))
++#define HAVE_GETTIMEOFDAY 1
++#endif
++
++#ifndef HAVE_SNPRINTF
++#  ifdef HAVE__SNPRINTF
++#    define snprintf _snprintf
++#    define HAVE_SNPRINTF 1
++#  endif
++#endif
++
+ #ifdef WIN32
+ 
+ /* pthread_mutex_* wrapper for win32 */
+@@ -45,17 +73,6 @@ typedef CRITICAL_SECTION pthread_mutex_t
+ #define pthread_mutex_unlock(a)  LeaveCriticalSection(a)
+ #define pthread_mutex_destroy(a)
+ 
+-/* replacement gettimeofday implementation */
+-#include <sys/timeb.h>
+-static inline int _private_gettimeofday( struct timeval *tv, void *tz )
+-{
+-  struct timeb t;
+-  ftime( &t );
+-  tv->tv_sec = t.time;
+-  tv->tv_usec = t.millitm * 1000;
+-  return 0;
+-}
+-#define gettimeofday(TV, TZ) _private_gettimeofday((TV), (TZ))
+ #include <io.h> /* read() */
+ #define lseek64 _lseeki64
+ 
+Index: src/input/libdvdnav/remap.c
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/remap.c,v
+retrieving revision 1.4
+diff -u -p -u -r1.4 remap.c
+--- src/input/libdvdnav/remap.c	25 Aug 2003 21:51:40 -0000	1.4
++++ src/input/libdvdnav/remap.c	17 Sep 2006 12:50:16 -0000
+@@ -22,14 +22,17 @@
+ #include <string.h>
+ #include <stdio.h>
+ 
+-#ifndef _MSC_VER 
++#ifdef HAVE_SYS_PARAM_H
+ #include <sys/param.h>
++#endif
++
++#ifdef HAVE_SYS_FCNTL_H
+ #include <sys/fcntl.h>
+ #else
+ #ifndef MAXPATHLEN
+ #define MAXPATHLEN 255
+ #endif
+-#endif /* _MSC_VER */
++#endif /* HAVE fcntl.h */
+ 
+ #include <assert.h>
+ #include "remap.h"
+Index: src/input/libdvdnav/searching.c
+===================================================================
+RCS file: /cvsroot/xine/xine-lib/src/input/libdvdnav/searching.c,v
+retrieving revision 1.19
+diff -u -p -u -r1.19 searching.c
+--- src/input/libdvdnav/searching.c	14 Oct 2005 21:02:16 -0000	1.19
++++ src/input/libdvdnav/searching.c	17 Sep 2006 12:50:16 -0000
+@@ -105,7 +105,6 @@ dvdnav_status_t dvdnav_time_search(dvdna
+   int32_t found;
+   cell_playback_t *cell;
+   dvd_state_t *state;
+-  dvdnav_status_t result;
+ 
+   if(this->position_current.still != 0) {
+     printerr("Cannot seek in a still frame.");
+--- src/input/libdvdnav/ifo_types.h	Tue Apr 10 13:13:59 2007 +0200
++++ src/input/libdvdnav/ifo_types.h	Tue Apr 10 13:38:19 2007 +0200
+@@ -23,2 +25,2 @@
+ #include <inttypes.h>
+ #include "dvd_reader.h"
+
++#include "config.h"
++ 
+-
+-#undef ATTRIBUTE_PACKED
+-#undef PRAGMA_PACK_BEGIN 
+-#undef PRAGMA_PACK_END
+-
+-#if defined(__GNUC__)
+-#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
+-#define ATTRIBUTE_PACKED __attribute__ ((packed))
+-#define PRAGMA_PACK 0
+-#endif
+-#endif
+-
+-#if !defined(ATTRIBUTE_PACKED)
+-#define ATTRIBUTE_PACKED
+-#define PRAGMA_PACK 1
+-#endif
+-
+-#if PRAGMA_PACK
+-#pragma pack(1)
+-#endif
+-
++#define ATTRIBUTE_PACKED XINE_PACKED
+ 
+ /**
+  * Common
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvd_input.c xine-lib-1.2/src/input/libdvdnav/dvd_input.c
--- xine-lib-1.2.11/src/input/libdvdnav/dvd_input.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvd_input.c	2022-01-15 22:03:19.582547162 +0100
@@ -6,7 +6,7 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@@ -32,7 +32,7 @@
 dvd_input_t (*dvdinput_open)  (const char *);
 int         (*dvdinput_close) (dvd_input_t);
 int         (*dvdinput_seek)  (dvd_input_t, int);
-int         (*dvdinput_title) (dvd_input_t, int); 
+int         (*dvdinput_title) (dvd_input_t, int);
 int         (*dvdinput_read)  (dvd_input_t, void *, int, int);
 char *      (*dvdinput_error) (dvd_input_t);
 int         (*dvdinput_is_encrypted) (dvd_input_t);
@@ -129,7 +129,7 @@
 static dvdcss_handle (*DVDcss_open)  (const char *);
 static int           (*DVDcss_close) (dvdcss_handle);
 static int           (*DVDcss_seek)  (dvdcss_handle, int, int);
-static int           (*DVDcss_title) (dvdcss_handle, int); 
+static int           (*DVDcss_title) (dvdcss_handle, int);
 static int           (*DVDcss_read)  (dvdcss_handle, void *, int, int);
 static char *        (*DVDcss_error) (dvdcss_handle);
 static int           (*DVDcss_is_scrambled) (dvdcss_handle);
@@ -140,7 +140,7 @@
 struct dvd_input_s {
   /* libdvdcss handle */
   dvdcss_handle dvdcss;
-  
+
   /* dummy file input */
   int fd;
 };
@@ -152,14 +152,14 @@
 static dvd_input_t css_open(const char *target)
 {
   dvd_input_t dev;
-    
+
   /* Allocate the handle structure */
   dev = (dvd_input_t) malloc(sizeof(*dev));
   if(dev == NULL) {
     fprintf(stderr, "libdvdread: Could not allocate memory.\n");
     return NULL;
   }
-  
+
   /* Really open it with libdvdcss */
   dev->dvdcss = DVDcss_open(target);
   if(dev->dvdcss == 0) {
@@ -167,7 +167,7 @@
     free(dev);
     return NULL;
   }
-  
+
   return dev;
 }
 
@@ -250,14 +250,14 @@
 static dvd_input_t file_open(const char *target)
 {
   dvd_input_t dev;
-  
+
   /* Allocate the library structure */
   dev = (dvd_input_t) malloc(sizeof(*dev));
   if(dev == NULL) {
     fprintf(stderr, "libdvdread: Could not allocate memory.\n");
     return NULL;
   }
-  
+
   /* Open the device */
 #ifndef WIN32
   dev->fd = open(target, O_RDONLY);
@@ -269,7 +269,7 @@
     free(dev);
     return NULL;
   }
-  
+
   return dev;
 }
 
@@ -321,28 +321,28 @@
   (void)flags;
 
   len = (size_t)blocks * DVD_VIDEO_LB_LEN;
-  
+
   while(len > 0) {
-    
+
     ret = read(dev->fd, q, len);
-    
+
     if(ret < 0) {
       /* One of the reads failed, too bad.  We won't even bother
        * returning the reads that went ok, and as in the posix spec
        * the file postition is left unspecified after a failure. */
       return ret;
     }
-    
+
     if(ret == 0) {
       /* Nothing more to read.  Return the whole blocks, if any, that we got.
-	 and adjust the file possition back to the previous block boundary. */
+         and adjust the file possition back to the previous block boundary. */
       size_t bytes = (size_t)blocks * DVD_VIDEO_LB_LEN - len;
       off_t over_read = -(bytes % DVD_VIDEO_LB_LEN);
       /*off_t pos =*/ lseek(dev->fd, over_read, SEEK_CUR);
       /* should have pos % 2048 == 0 */
       return (int) (bytes / DVD_VIDEO_LB_LEN);
     }
-    
+
     q += ret;
     len -= ret;
   }
@@ -419,26 +419,26 @@
       dlsym(dvdcss_library, U_S "dvdcss_error");
     DVDcss_is_scrambled = (int (*)(dvdcss_handle))
       dlsym(dvdcss_library, U_S "dvdcss_is_scrambled");
-    
+
     dvdcss_version = (char **)dlsym(dvdcss_library, U_S "dvdcss_interface_2");
 
     if(dlsym(dvdcss_library, U_S "dvdcss_crack")) {
-      fprintf(stderr, 
-	      "libdvdread: Old (pre-0.0.2) version of libdvdcss found.\n"
-	      "libdvdread: You should get the latest version from "
-	      "http://www.videolan.org/\n" );
+      fprintf(stderr,
+              "libdvdread: Old (pre-0.0.2) version of libdvdcss found.\n"
+              "libdvdread: You should get the latest version from "
+              "http://www.videolan.org/\n" );
       dlclose(dvdcss_library);
       dvdcss_library = NULL;
     } else if(!DVDcss_open  || !DVDcss_close || !DVDcss_seek
-	      || !DVDcss_read || !DVDcss_error) {
+              || !DVDcss_read || !DVDcss_error) {
       fprintf(stderr,  "libdvdread: Missing symbols in libdvdcss, "
-	      "this shouldn't happen !\n");
+              "this shouldn't happen !\n");
       dlclose(dvdcss_library);
       dvdcss_library = NULL;
     }
   }
 #endif /* HAVE_DVDCSS_DVDCSS_H */
-  
+
   if(dvdcss_library != NULL) {
     /*
     char *psz_method = getenv( "DVDCSS_METHOD" );
@@ -447,8 +447,8 @@
     fprintf(stderr, "DVDCSS_VERBOSE %s\n", psz_verbose);
     */
     fprintf(stderr, "libdvdread: Using libdvdcss version %s for DVD access\n",
-	    dvdcss_version ? *dvdcss_version : "?");
-    
+            dvdcss_version ? *dvdcss_version : "?");
+
     /* libdvdcss wrapper functions */
     dvdinput_open  = css_open;
     dvdinput_close = css_close;
@@ -458,7 +458,7 @@
     dvdinput_error = css_error;
     dvdinput_is_encrypted = css_is_encrypted;
     return 1;
-    
+
   } else {
     fprintf(stderr, "libdvdread: Encrypted DVD support unavailable.\n");
 
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvd_input.h xine-lib-1.2/src/input/libdvdnav/dvd_input.h
--- xine-lib-1.2.11/src/input/libdvdnav/dvd_input.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvd_input.h	2022-01-15 22:03:19.587547183 +0100
@@ -9,7 +9,7 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@@ -35,7 +35,7 @@
 extern dvd_input_t (*dvdinput_open)  (const char *);
 extern int         (*dvdinput_close) (dvd_input_t);
 extern int         (*dvdinput_seek)  (dvd_input_t, int);
-extern int         (*dvdinput_title) (dvd_input_t, int); 
+extern int         (*dvdinput_title) (dvd_input_t, int);
 extern int         (*dvdinput_read)  (dvd_input_t, void *, int, int);
 extern char *      (*dvdinput_error) (dvd_input_t);
 extern int         (*dvdinput_is_encrypted) (dvd_input_t);
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvdnav.c xine-lib-1.2/src/input/libdvdnav/dvdnav.c
--- xine-lib-1.2.11/src/input/libdvdnav/dvdnav.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvdnav.c	2022-01-15 22:03:19.611547284 +0100
@@ -1,18 +1,18 @@
-/* 
+/*
  * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -55,14 +55,14 @@
   this->started = 0;
 
   dvdnav_read_cache_clear(this->cache);
-  
+
   return DVDNAV_STATUS_OK;
 }
 
 dvdnav_status_t dvdnav_open(dvdnav_t** dest, const char *path) {
   dvdnav_t *this;
   struct timeval time;
-  
+
   /* Create a new structure */
   fprintf(MSG_OUT, "libdvdnav: Using dvdnav version %s from http://xine.sf.net\n", VERSION);
 
@@ -71,7 +71,7 @@
   if(!this)
     return DVDNAV_STATUS_ERR;
   memset(this, 0, (sizeof(dvdnav_t) ) ); /* Make sure this structure is clean */
- 
+
   pthread_mutex_init(&this->vm_lock, NULL);
   /* Initialise the error string */
   printerr("");
@@ -97,7 +97,7 @@
 
   /* Pre-open and close a file so that the CSS-keys are cached. */
   this->file = DVDOpenFile(vm_get_dvd_reader(this->vm), 0, DVD_READ_MENU_VOBS);
-    
+
   /* Start the read-ahead cache. */
   this->cache = dvdnav_read_cache_new(this);
 
@@ -105,9 +105,9 @@
    * gives a different start value each time a DVD is played. */
   gettimeofday(&time, NULL);
   srand(time.tv_usec);
- 
+
   dvdnav_clear(this);
- 
+
   (*dest) = this;
   return DVDNAV_STATUS_OK;
 }
@@ -144,7 +144,7 @@
     dvdnav_read_cache_free(this->cache);
   else
     free(this);
-  
+
   return DVDNAV_STATUS_OK;
 }
 
@@ -160,14 +160,14 @@
     return DVDNAV_STATUS_ERR;
   }
 
-  pthread_mutex_lock(&this->vm_lock); 
+  pthread_mutex_lock(&this->vm_lock);
 
 #ifdef LOG_DEBUG
   fprintf(MSG_OUT, "libdvdnav: reseting vm\n");
 #endif
   if(!vm_reset(this->vm, NULL)) {
     printerr("Error restarting the VM.");
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_ERR;
   }
 #ifdef LOG_DEBUG
@@ -175,7 +175,7 @@
 #endif
   result = dvdnav_clear(this);
 
-  pthread_mutex_unlock(&this->vm_lock); 
+  pthread_mutex_unlock(&this->vm_lock);
   return result;
 }
 
@@ -192,10 +192,10 @@
 }
 
 const char* dvdnav_err_to_string(dvdnav_t *this) {
-  
+
   if(!this)
     return "Hey! You gave me a NULL pointer you naughty person!";
-  
+
   return this->err_str;
 }
 
@@ -203,22 +203,22 @@
 int64_t dvdnav_convert_time(dvd_time_t *time) {
   int64_t result;
   int64_t frames;
-  
+
   result  = (time->hour    >> 4  ) * 10 * 60 * 60 * 90000;
   result += (time->hour    & 0x0f)      * 60 * 60 * 90000;
   result += (time->minute  >> 4  )      * 10 * 60 * 90000;
   result += (time->minute  & 0x0f)           * 60 * 90000;
   result += (time->second  >> 4  )           * 10 * 90000;
   result += (time->second  & 0x0f)                * 90000;
-  
+
   frames  = ((time->frame_u & 0x30) >> 4) * 10;
   frames += ((time->frame_u & 0x0f)     )     ;
-  
+
   if (time->frame_u & 0x80)
     result += frames * 3000;
   else
     result += frames * 3600;
-  
+
   return result;
 }
 
@@ -287,22 +287,22 @@
       nPacketLen = p[4] << 8 | p[5];
       p += 6;
       navRead_DSI(nav_dsi, p+1);
-    } 
+    }
     return 1;
   }
   return 0;
 }
 
-/* DSI is used for most angle stuff. 
+/* DSI is used for most angle stuff.
  * PCI is used for only non-seemless angle stuff
- */ 
+ */
 static int32_t dvdnav_get_vobu(dvdnav_t *this, dsi_t *nav_dsi, pci_t *nav_pci, dvdnav_vobu_t *vobu) {
   uint32_t next;
   int32_t angle, num_angle;
 
   vobu->vobu_start = nav_dsi->dsi_gi.nv_pck_lbn; /* Absolute offset from start of disk */
   vobu->vobu_length = nav_dsi->dsi_gi.vobu_ea; /* Relative offset from vobu_start */
-     
+
   /*
    * If we're not at the end of this cell, we can determine the next
    * VOBU to display using the VOBU_SRI information section of the
@@ -314,7 +314,7 @@
    * DVDs are about 6 Gigs, which is only up to 0x300000 blocks
    * Should really assert if bit 31 != 1
    */
-  
+
 #if 0
   /* Old code -- may still be useful one day */
   if(nav_dsi->vobu_sri.next_vobu != SRI_END_OF_CELL ) {
@@ -326,36 +326,36 @@
   /* Relative offset from vobu_start */
   vobu->vobu_next = ( nav_dsi->vobu_sri.next_vobu & 0x3fffffff );
 #endif
-  
+
   vm_get_angle_info(this->vm, &angle, &num_angle);
 
   /* FIMXE: The angle reset doesn't work for some reason for the moment */
 #if 0
   if((num_angle < angle) && (angle != 1)) {
     fprintf(MSG_OUT, "libdvdnav: angle ends!\n");
-    
+
     /* This is to switch back to angle one when we
      * finish with angles. */
     dvdnav_angle_change(this, 1);
-  } 
+  }
 #endif
 
   if(num_angle != 0) {
-    
+
     if((next = nav_pci->nsml_agli.nsml_agl_dsta[angle-1]) != 0) {
       if((next & 0x3fffffff) != 0) {
-	if(next & 0x80000000)
-	  vobu->vobu_next = - (int32_t)(next & 0x3fffffff);
-	else
-	  vobu->vobu_next = + (int32_t)(next & 0x3fffffff);
+        if(next & 0x80000000)
+          vobu->vobu_next = - (int32_t)(next & 0x3fffffff);
+        else
+          vobu->vobu_next = + (int32_t)(next & 0x3fffffff);
       }
     } else if((next = nav_dsi->sml_agli.data[angle-1].address) != 0) {
       vobu->vobu_length = nav_dsi->sml_pbi.ilvu_ea;
-      
+
       if((next & 0x80000000) && (next != 0x7fffffff))
-	vobu->vobu_next =  - (int32_t)(next & 0x3fffffff);
+        vobu->vobu_next =  - (int32_t)(next & 0x3fffffff);
       else
-	vobu->vobu_next =  + (int32_t)(next & 0x3fffffff);
+        vobu->vobu_next =  + (int32_t)(next & 0x3fffffff);
     }
   }
 
@@ -374,10 +374,10 @@
  */
 
 dvdnav_status_t dvdnav_get_next_block(dvdnav_t *this, uint8_t *buf,
-				      int32_t *event, int32_t *len) {
+                                      int32_t *event, int32_t *len) {
   unsigned char *block;
   dvdnav_status_t status;
-  
+
   block = buf;
   status = dvdnav_get_next_cache_block(this, &block, event, len);
   if (status == DVDNAV_STATUS_OK && block != buf) {
@@ -387,9 +387,9 @@
   }
   return status;
 }
- 
+
 dvdnav_status_t dvdnav_get_next_cache_block(dvdnav_t *this, uint8_t **buf,
-					    int32_t *event, int32_t *len) {
+                                            int32_t *event, int32_t *len) {
   dvd_state_t *state;
   int32_t result;
 
@@ -399,7 +399,7 @@
   }
 
   pthread_mutex_lock(&this->vm_lock);
-  
+
   if(!this->started) {
     /* Start the VM */
     if (!vm_start(this->vm)) {
@@ -412,18 +412,18 @@
   state = &(this->vm->state);
   (*event) = DVDNAV_NOP;
   (*len) = 0;
- 
+
   /* Check the STOP flag */
   if(this->vm->stopped) {
     vm_stop(this->vm);
     (*event) = DVDNAV_STOP;
     this->started = 0;
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
 
   vm_position_get(this->vm, &this->position_next);
-  
+
 #ifdef LOG_DEBUG
   fprintf(MSG_OUT, "libdvdnav: POS-NEXT ");
   vm_position_print(this->vm, &this->position_next);
@@ -439,34 +439,34 @@
 #endif
     if (this->position_next.hop_channel - this->position_current.hop_channel >= HOP_SEEK) {
       int32_t num_angles = 0, current;
-      
+
       /* we seeked -> check for multiple angles */
       vm_get_angle_info(this->vm, &current, &num_angles);
       if (num_angles > 1) {
         int32_t result, block;
-	/* we have to skip the first VOBU when seeking in a multiangle feature,
-	 * because it might belong to the wrong angle */
-	block = this->position_next.cell_start + this->position_next.block;
-	result = dvdnav_read_cache_block(this->cache, block, 1, buf);
-	if(result <= 0) {
-	  printerr("Error reading NAV packet.");
-	  pthread_mutex_unlock(&this->vm_lock); 
-	  return DVDNAV_STATUS_ERR;
-	}
-	/* Decode nav into pci and dsi. Then get next VOBU info. */
-	if(!dvdnav_decode_packet(this, *buf, &this->dsi, &this->pci)) {
-	  printerr("Expected NAV packet but none found.");
-	  pthread_mutex_unlock(&this->vm_lock); 
-	  return DVDNAV_STATUS_ERR;
-	}
-	dvdnav_get_vobu(this, &this->dsi, &this->pci, &this->vobu);
-	/* skip to next, if there is a next */
-	if (this->vobu.vobu_next != SRI_END_OF_CELL) {
-	  this->vobu.vobu_start += this->vobu.vobu_next;
-	  this->vobu.vobu_next   = 0;
-	}
-	/* update VM state */
-	this->vm->state.blockN = this->vobu.vobu_start - this->position_next.cell_start;
+        /* we have to skip the first VOBU when seeking in a multiangle feature,
+         * because it might belong to the wrong angle */
+        block = this->position_next.cell_start + this->position_next.block;
+        result = dvdnav_read_cache_block(this->cache, block, 1, buf);
+        if(result <= 0) {
+          printerr("Error reading NAV packet.");
+          pthread_mutex_unlock(&this->vm_lock);
+          return DVDNAV_STATUS_ERR;
+        }
+        /* Decode nav into pci and dsi. Then get next VOBU info. */
+        if(!dvdnav_decode_packet(this, *buf, &this->dsi, &this->pci)) {
+          printerr("Expected NAV packet but none found.");
+          pthread_mutex_unlock(&this->vm_lock);
+          return DVDNAV_STATUS_ERR;
+        }
+        dvdnav_get_vobu(this, &this->dsi, &this->pci, &this->vobu);
+        /* skip to next, if there is a next */
+        if (this->vobu.vobu_next != SRI_END_OF_CELL) {
+          this->vobu.vobu_start += this->vobu.vobu_next;
+          this->vobu.vobu_next   = 0;
+        }
+        /* update VM state */
+        this->vm->state.blockN = this->vobu.vobu_start - this->position_next.cell_start;
       }
     }
     this->position_current.hop_channel = this->position_next.hop_channel;
@@ -477,7 +477,7 @@
     this->vobu.vobu_length = 0;
     this->vobu.blockN      = 0;
     this->sync_wait        = 0;
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
 
@@ -493,10 +493,10 @@
     hevent->display = 1;
     hevent->buttonN = this->position_next.button;
     this->position_current.button = this->position_next.button;
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
-  
+
   /* Check the WAIT flag */
   if(this->sync_wait) {
     (*event) = DVDNAV_WAIT;
@@ -509,12 +509,12 @@
   }
 
   /* Check to see if we need to change the currently opened VOB */
-  if((this->position_current.vts != this->position_next.vts) || 
+  if((this->position_current.vts != this->position_next.vts) ||
      (this->position_current.domain != this->position_next.domain)) {
     dvd_read_domain_t domain;
     int32_t vtsN;
     dvdnav_vts_change_event_t *vts_event = (dvdnav_vts_change_event_t *)*buf;
-    
+
     if(this->file) {
       DVDCloseFile(this->file);
       this->file = NULL;
@@ -522,7 +522,7 @@
 
     vts_event->old_vtsN = this->position_current.vts;
     vts_event->old_domain = this->position_current.domain;
-     
+
     /* Use the DOMAIN to find whether to open menu or title VOBs */
     switch(this->position_next.domain) {
     case FP_DOMAIN:
@@ -532,29 +532,29 @@
       break;
     case VTSM_DOMAIN:
       domain = DVD_READ_MENU_VOBS;
-      vtsN = this->position_next.vts; 
+      vtsN = this->position_next.vts;
       break;
     case VTS_DOMAIN:
       domain = DVD_READ_TITLE_VOBS;
-      vtsN = this->position_next.vts; 
+      vtsN = this->position_next.vts;
       break;
     default:
       printerr("Unknown domain when changing VTS.");
-      pthread_mutex_unlock(&this->vm_lock); 
+      pthread_mutex_unlock(&this->vm_lock);
       return DVDNAV_STATUS_ERR;
     }
-    
-    this->position_current.vts = this->position_next.vts; 
+
+    this->position_current.vts = this->position_next.vts;
     this->position_current.domain = this->position_next.domain;
     dvdnav_read_cache_clear(this->cache);
     this->file = DVDOpenFile(vm_get_dvd_reader(this->vm), vtsN, domain);
-    vts_event->new_vtsN = this->position_next.vts; 
-    vts_event->new_domain = this->position_next.domain; 
+    vts_event->new_vtsN = this->position_next.vts;
+    vts_event->new_domain = this->position_next.domain;
 
     /* If couldn't open the file for some reason, moan */
     if(this->file == NULL) {
       printerrf("Error opening vtsN=%i, domain=%i.", vtsN, domain);
-      pthread_mutex_unlock(&this->vm_lock); 
+      pthread_mutex_unlock(&this->vm_lock);
       return DVDNAV_STATUS_ERR;
     }
 
@@ -569,25 +569,25 @@
     this->position_current.cell = -1; /* Force an update */
     this->position_current.spu_channel = -1; /* Force an update */
     this->position_current.audio_channel = -1; /* Force an update */;
-     
-    pthread_mutex_unlock(&this->vm_lock); 
+
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
 
-  /* Check if the cell changed */  
+  /* Check if the cell changed */
   if( (this->position_current.cell != this->position_next.cell) ||
       (this->position_current.cell_restart != this->position_next.cell_restart) ||
       (this->position_current.cell_start != this->position_next.cell_start) ) {
     dvdnav_cell_change_event_t *cell_event = (dvdnav_cell_change_event_t *)*buf;
     int32_t first_cell_nr, last_cell_nr, i;
     dvd_state_t *state = &this->vm->state;
-    
+
     (*event) = DVDNAV_CELL_CHANGE;
 #ifdef LOG_DEBUG
     fprintf(MSG_OUT, "libdvdnav: CELL_CHANGE\n");
 #endif
     (*len) = sizeof(dvdnav_cell_change_event_t);
-    
+
     cell_event->cellN = state->cellN;
     cell_event->pgN   = state->pgN;
     cell_event->cell_length =
@@ -620,23 +620,23 @@
     this->position_current.cell_restart = this->position_next.cell_restart;
     this->position_current.cell_start   = this->position_next.cell_start;
     this->position_current.block        = this->position_next.block;
-    
+
     /* vobu info is used for mid cell resumes */
     this->vobu.vobu_start               = this->position_next.cell_start + this->position_next.block;
     this->vobu.vobu_next                = 0;
     /* Make blockN == vobu_length to do expected_nav */
     this->vobu.vobu_length = 0;
     this->vobu.blockN      = 0;
-    
+
     /* update the spu palette at least on PGC changes */
     this->spu_clut_changed = 1;
     this->position_current.spu_channel = -1; /* Force an update */
     this->position_current.audio_channel = -1; /* Force an update */
 
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
- 
+
   /* has the CLUT changed? */
   if(this->spu_clut_changed) {
     (*event) = DVDNAV_SPU_CLUT_CHANGE;
@@ -646,11 +646,11 @@
     (*len) = 16 * sizeof(uint32_t);
     memcpy(*buf, &(state->pgc->palette), 16 * sizeof(uint32_t));
     this->spu_clut_changed = 0;
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
 
-  /* has the SPU channel changed? */  
+  /* has the SPU channel changed? */
   if(this->position_current.spu_channel != this->position_next.spu_channel) {
     dvdnav_spu_stream_change_event_t *stream_change = (dvdnav_spu_stream_change_event_t *)*buf;
 
@@ -669,14 +669,14 @@
     fprintf(MSG_OUT, "libdvdnav: SPU_STREAM_CHANGE stream_id_pan_scan=%d\n",stream_change->physical_pan_scan);
     fprintf(MSG_OUT, "libdvdnav: SPU_STREAM_CHANGE returning DVDNAV_STATUS_OK\n");
 #endif
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
 
-  /* has the audio channel changed? */  
+  /* has the audio channel changed? */
   if(this->position_current.audio_channel != this->position_next.audio_channel) {
     dvdnav_audio_stream_change_event_t *stream_change = (dvdnav_audio_stream_change_event_t *)*buf;
-    
+
     (*event) = DVDNAV_AUDIO_STREAM_CHANGE;
 #ifdef LOG_DEBUG
     fprintf(MSG_OUT, "libdvdnav: AUDIO_STREAM_CHANGE\n");
@@ -687,10 +687,10 @@
 #ifdef LOG_DEBUG
     fprintf(MSG_OUT, "libdvdnav: AUDIO_STREAM_CHANGE stream_id=%d returning DVDNAV_STATUS_OK\n",stream_change->physical);
 #endif
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
-     
+
   /* Check the STILLFRAME flag */
   if(this->position_current.still != 0) {
     dvdnav_still_event_t *still_event = (dvdnav_still_event_t *)*buf;
@@ -701,7 +701,7 @@
 #endif
     (*len) = sizeof(dvdnav_still_event_t);
     still_event->length = this->position_current.still;
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
 
@@ -722,22 +722,22 @@
       if ((this->position_current.still || this->pci.hli.hl_gi.hli_ss) && !this->sync_wait_skip) {
         this->sync_wait = 1;
       } else {
-	if( this->position_current.still == 0 || this->skip_still ) {
-	  /* no active cell still -> get us to the next cell */
-	  vm_get_next_cell(this->vm);
-	  this->position_current.still = 0; /* still gets activated at end of cell */
-	  this->skip_still = 0;
-	  this->sync_wait_skip = 0;
-	}
+        if( this->position_current.still == 0 || this->skip_still ) {
+          /* no active cell still -> get us to the next cell */
+          vm_get_next_cell(this->vm);
+          this->position_current.still = 0; /* still gets activated at end of cell */
+          this->skip_still = 0;
+          this->sync_wait_skip = 0;
+        }
       }
       /* handle related state changes in next iteration */
       (*event) = DVDNAV_NOP;
       (*len) = 0;
-      pthread_mutex_unlock(&this->vm_lock); 
+      pthread_mutex_unlock(&this->vm_lock);
       return DVDNAV_STATUS_OK;
     }
 
-    /* Perform remapping jump if necessary (this is always a 
+    /* Perform remapping jump if necessary (this is always a
      * VOBU boundary). */
     if (this->vm->map) {
       this->vobu.vobu_next = remap_block( this->vm->map,
@@ -751,13 +751,13 @@
 
     if(result <= 0) {
       printerr("Error reading NAV packet.");
-      pthread_mutex_unlock(&this->vm_lock); 
+      pthread_mutex_unlock(&this->vm_lock);
       return DVDNAV_STATUS_ERR;
     }
     /* Decode nav into pci and dsi. Then get next VOBU info. */
     if(!dvdnav_decode_packet(this, *buf, &this->dsi, &this->pci)) {
       printerr("Expected NAV packet but none found.");
-      pthread_mutex_unlock(&this->vm_lock); 
+      pthread_mutex_unlock(&this->vm_lock);
       return DVDNAV_STATUS_ERR;
     }
     /* We need to update the vm state->blockN with which VOBU we are in.
@@ -765,31 +765,31 @@
      */
     this->vm->state.blockN = this->vobu.vobu_start - this->position_current.cell_start;
 
-    dvdnav_get_vobu(this, &this->dsi, &this->pci, &this->vobu); 
+    dvdnav_get_vobu(this, &this->dsi, &this->pci, &this->vobu);
     this->vobu.blockN = 0;
     /* Give the cache a hint about the size of next VOBU.
      * This improves pre-caching, because the VOBU will almost certainly be read entirely.
      */
     dvdnav_pre_cache_blocks(this->cache, this->vobu.vobu_start+1, this->vobu.vobu_length+1);
-    
+
     /* release NAV menu filter, when we reach the same NAV packet again */
     if (this->last_cmd_nav_lbn == this->pci.pci_gi.nv_pck_lbn)
       this->last_cmd_nav_lbn = SRI_END_OF_CELL;
-    
+
     /* Successfully got a NAV packet */
     (*event) = DVDNAV_NAV_PACKET;
 #ifdef LOG_DEBUG
     fprintf(MSG_OUT, "libdvdnav: NAV_PACKET\n");
 #endif
-    (*len) = 2048; 
-    pthread_mutex_unlock(&this->vm_lock); 
+    (*len) = 2048;
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_OK;
   }
-  
+
   /* If we've got here, it must just be a normal block. */
   if(!this->file) {
     printerr("Attempting to read without opening file.");
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_ERR;
   }
 
@@ -797,18 +797,18 @@
   result = dvdnav_read_cache_block(this->cache, this->vobu.vobu_start + this->vobu.blockN, 1, buf);
   if(result <= 0) {
     printerr("Error reading from DVD.");
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_ERR;
   }
   (*event) = DVDNAV_BLOCK_OK;
   (*len) = 2048;
 
-  pthread_mutex_unlock(&this->vm_lock); 
+  pthread_mutex_unlock(&this->vm_lock);
   return DVDNAV_STATUS_OK;
 }
 
 dvdnav_status_t dvdnav_get_title_string(dvdnav_t *this, const char **title_str) {
-  
+
   if(!this || !title_str) {
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
@@ -820,7 +820,7 @@
 
 uint8_t dvdnav_get_video_aspect(dvdnav_t *this) {
   uint8_t         retval;
-  
+
   if(!this) {
     printerr("Passed a NULL pointer.");
     return -1;
@@ -833,13 +833,13 @@
   pthread_mutex_lock(&this->vm_lock);
   retval = (uint8_t)vm_get_video_aspect(this->vm);
   pthread_mutex_unlock(&this->vm_lock);
-  
+
   return retval;
 }
 
 uint8_t dvdnav_get_video_scale_permission(dvdnav_t *this) {
   uint8_t         retval;
-  
+
   if(!this) {
     printerr("Passed a NULL pointer.");
     return -1;
@@ -848,17 +848,17 @@
     printerr("Virtual DVD machine not started.");
     return -1;
   }
-  
+
   pthread_mutex_lock(&this->vm_lock);
   retval = (uint8_t)vm_get_video_scale_permission(this->vm);
   pthread_mutex_unlock(&this->vm_lock);
-  
+
   return retval;
 }
 
 uint16_t dvdnav_audio_stream_to_lang(dvdnav_t *this, uint8_t stream) {
   audio_attr_t  attr;
-  
+
   if(!this) {
     printerr("Passed a NULL pointer.");
     return -1;
@@ -867,20 +867,20 @@
     printerr("Virtual DVD machine not started.");
     return -1;
   }
-  
-  pthread_mutex_lock(&this->vm_lock); 
+
+  pthread_mutex_lock(&this->vm_lock);
   attr = vm_get_audio_attr(this->vm, stream);
-  pthread_mutex_unlock(&this->vm_lock); 
-  
+  pthread_mutex_unlock(&this->vm_lock);
+
   if(attr.lang_type != 1)
     return 0xffff;
-  
+
   return attr.lang_code;
 }
 
 uint16_t dvdnav_spu_stream_to_lang(dvdnav_t *this, uint8_t stream) {
   subp_attr_t  attr;
-  
+
   if(!this) {
     printerr("Passed a NULL pointer.");
     return -1;
@@ -889,20 +889,20 @@
     printerr("Virtual DVD machine not started.");
     return -1;
   }
-  
-  pthread_mutex_lock(&this->vm_lock); 
+
+  pthread_mutex_lock(&this->vm_lock);
   attr = vm_get_subp_attr(this->vm, stream);
-  pthread_mutex_unlock(&this->vm_lock); 
-  
+  pthread_mutex_unlock(&this->vm_lock);
+
   if(attr.type != 1)
     return 0xffff;
-  
+
   return attr.lang_code;
 }
 
 int8_t dvdnav_get_audio_logical_stream(dvdnav_t *this, uint8_t audio_num) {
   int8_t       retval;
-  
+
   if(!this) {
     printerr("Passed a NULL pointer.");
     return -1;
@@ -911,15 +911,15 @@
     printerr("Virtual DVD machine not started.");
     return -1;
   }
-  
+
   pthread_mutex_lock(&this->vm_lock);
   if (!this->vm->state.pgc) {
     printerr("No current PGC.");
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return -1;
   }
   retval = vm_get_audio_stream(this->vm, audio_num);
-  pthread_mutex_unlock(&this->vm_lock); 
+  pthread_mutex_unlock(&this->vm_lock);
 
   return retval;
 }
@@ -939,7 +939,7 @@
   pthread_mutex_lock(&this->vm_lock);
   if (!this->vm->state.pgc) {
     printerr("No current PGC.");
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return -1;
   }
   retval = vm_get_subp_stream(this->vm, subp_num, 0);
@@ -959,16 +959,16 @@
     printerr("Virtual DVD machine not started.");
     return -1;
   }
-  
-  pthread_mutex_lock(&this->vm_lock); 
+
+  pthread_mutex_lock(&this->vm_lock);
   if (!this->vm->state.pgc) {
     printerr("No current PGC.");
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return -1;
   }
   retval = vm_get_audio_active_stream(this->vm);
-  pthread_mutex_unlock(&this->vm_lock); 
-  
+  pthread_mutex_unlock(&this->vm_lock);
+
   return retval;
 }
 
@@ -983,22 +983,22 @@
     printerr("Virtual DVD machine not started.");
     return -1;
   }
-  
-  pthread_mutex_lock(&this->vm_lock); 
+
+  pthread_mutex_lock(&this->vm_lock);
   if (!this->vm->state.pgc) {
     printerr("No current PGC.");
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return -1;
   }
   retval = vm_get_subp_active_stream(this->vm, 0);
-  pthread_mutex_unlock(&this->vm_lock); 
-  
+  pthread_mutex_unlock(&this->vm_lock);
+
   return retval;
 }
 
 static int8_t dvdnav_is_domain(dvdnav_t *this, domain_t domain) {
   int8_t        retval;
-  
+
   if(!this) {
     printerr("Passed a NULL pointer.");
     return -1;
@@ -1007,11 +1007,11 @@
     printerr("Virtual DVD machine not started.");
     return -1;
   }
-  
+
   pthread_mutex_lock(&this->vm_lock);
   retval = (this->vm->state.domain == domain);
   pthread_mutex_unlock(&this->vm_lock);
-  
+
   return retval;
 }
 
@@ -1028,14 +1028,14 @@
   return dvdnav_is_domain(this, VTSM_DOMAIN);
 }
 /* Video Title domain (playing movie). */
-int8_t dvdnav_is_domain_vts(dvdnav_t *this) { 
+int8_t dvdnav_is_domain_vts(dvdnav_t *this) {
   return dvdnav_is_domain(this, VTS_DOMAIN);
 }
 
 /* Generally delegate angle information handling to VM */
 dvdnav_status_t dvdnav_angle_change(dvdnav_t *this, int32_t angle) {
   int32_t num, current;
-  
+
   if(!this) {
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
@@ -1057,7 +1057,7 @@
 }
 
 dvdnav_status_t dvdnav_get_angle_info(dvdnav_t *this, int32_t *current_angle,
-				      int32_t *number_of_angles) {
+                                      int32_t *number_of_angles) {
   if(!this || !current_angle || !number_of_angles) {
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvdnav_events.h xine-lib-1.2/src/input/libdvdnav/dvdnav_events.h
--- xine-lib-1.2.11/src/input/libdvdnav/dvdnav_events.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvdnav_events.h	2022-01-15 22:03:19.589547192 +0100
@@ -1,25 +1,25 @@
-/* 
+/*
  * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
  */
 
 /*
- * This header defines events and event types 
+ * This header defines events and event types
  */
 
 #ifndef DVDNAV_EVENTS_H_INCLUDED
@@ -36,7 +36,7 @@
  * A regular data block from the DVD has been returned.
  * This one should be demuxed and decoded for playback.
  */
-#define DVDNAV_BLOCK_OK			 0
+#define DVDNAV_BLOCK_OK                  0
 
 
 /*
@@ -44,7 +44,7 @@
  *
  * Just ignore this.
  */
-#define DVDNAV_NOP			 1
+#define DVDNAV_NOP                       1
 
 
 /*
@@ -58,7 +58,7 @@
  * A length of 0xff means an infinite still which has to be skipped
  * indirectly by some user interaction.
  */
-#define DVDNAV_STILL_FRAME		 2
+#define DVDNAV_STILL_FRAME               2
 
 typedef struct {
   /* The length (in seconds) the still frame should be displayed for,
@@ -72,7 +72,7 @@
  *
  * Inform the SPU decoding/overlaying engine to switch SPU channels.
  */
-#define DVDNAV_SPU_STREAM_CHANGE	 3
+#define DVDNAV_SPU_STREAM_CHANGE         3
 
 typedef struct {
   /* The physical (MPEG) stream number for widescreen SPU display.
@@ -89,7 +89,7 @@
    * Use this, if you blend the SPU on an anamorphic image after
    * unsqueezing it the pan&scan way. */
   int physical_pan_scan;
-  
+
   /* The logical (DVD) stream number. */
   int logical;
 } dvdnav_spu_stream_change_event_t;
@@ -100,7 +100,7 @@
  *
  * Inform the audio decoder to switch channels.
  */
-#define DVDNAV_AUDIO_STREAM_CHANGE	 4
+#define DVDNAV_AUDIO_STREAM_CHANGE       4
 
 typedef struct {
   /* The physical (MPEG) stream number. */
@@ -119,7 +119,7 @@
  * information only when necessary and update the decoding/displaying
  * accordingly.
  */
-#define DVDNAV_VTS_CHANGE		 5
+#define DVDNAV_VTS_CHANGE                5
 
 typedef struct {
   int old_vtsN;                 /* the old VTS number */
@@ -139,7 +139,7 @@
  * Some useful information for accurate time display is also reported
  * together with this event.
  */
-#define DVDNAV_CELL_CHANGE		 6
+#define DVDNAV_CELL_CHANGE               6
 
 typedef struct {
   int     cellN;       /* the new cell number */
@@ -166,7 +166,7 @@
  * NAV packets can also be used for time display, because they are
  * timestamped relatively to the current Cell.
  */
-#define DVDNAV_NAV_PACKET		 7
+#define DVDNAV_NAV_PACKET                7
 
 
 /*
@@ -175,7 +175,7 @@
  * Applications should end playback here. A subsequent dvdnav_get_next_block()
  * call will restart the VM from the beginning of the DVD.
  */
-#define DVDNAV_STOP			 8
+#define DVDNAV_STOP                      8
 
 
 /*
@@ -189,15 +189,15 @@
  * to handle the mode 2 highlighting (that is some different colour the
  * button turns to on activation) in your application.
  */
-#define DVDNAV_HIGHLIGHT		 9
+#define DVDNAV_HIGHLIGHT                 9
 
 typedef struct {
   /* highlight mode: 0 - hide, 1 - show, 2 - activate, currently always 1 */
   int display;
 
   /* FIXME: these fields are currently not set */
-  uint32_t palette;     /* The CLUT entries for the highlight palette 
-			   (4-bits per entry -> 4 entries) */
+  uint32_t palette;     /* The CLUT entries for the highlight palette
+                           (4-bits per entry -> 4 entries) */
   uint16_t sx,sy,ex,ey; /* The start/end x,y positions */
   uint32_t pts;         /* Highlight PTS to match with SPU */
 
@@ -212,7 +212,7 @@
  * Inform the SPU decoder/overlaying engine to update its colour lookup table.
  * The CLUT is given as 16 uint32_t's in the buffer.
  */
-#define DVDNAV_SPU_CLUT_CHANGE		10
+#define DVDNAV_SPU_CLUT_CHANGE          10
 
 
 /*
@@ -221,7 +221,7 @@
  * A non-seamless operation has been performed. Applications can drop all
  * their internal fifo's content, which will speed up the response.
  */
-#define DVDNAV_HOP_CHANNEL		12
+#define DVDNAV_HOP_CHANNEL              12
 
 
 /*
@@ -235,7 +235,7 @@
  * when they receive this type of event.
  * Once this is achieved, call dvdnav_skip_wait().
  */
-#define DVDNAV_WAIT			13
+#define DVDNAV_WAIT                     13
 
 
 #endif /* DVDNAV_EVENTS_H_INCLUDED */
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvdnav.h xine-lib-1.2/src/input/libdvdnav/dvdnav.h
--- xine-lib-1.2.11/src/input/libdvdnav/dvdnav.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvdnav.h	2022-01-15 22:03:19.593547208 +0100
@@ -1,18 +1,18 @@
-/* 
+/*
  * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -89,7 +89,7 @@
 dvdnav_status_t dvdnav_open(dvdnav_t **dest, const char *path);
 
 /*
- * Closes a dvdnav_t previously opened with dvdnav_open(), freeing any 
+ * Closes a dvdnav_t previously opened with dvdnav_open(), freeing any
  * memory associated with it.
  */
 dvdnav_status_t dvdnav_close(dvdnav_t *self);
@@ -127,7 +127,7 @@
  * Sets the region mask (bit 0 set implies region 1, bit 1 set implies
  * region 2, etc) of the virtual machine. Generally you will only need to set
  * this if you are playing RCE discs which query the virtual machine as to its
- * region setting. 
+ * region setting.
  *
  * This has _nothing_ to do with the region setting of the DVD drive.
  */
@@ -181,12 +181,12 @@
  *********************************************************************/
 
 /*
- * These functions are used to poll the playback enginge and actually get data 
+ * These functions are used to poll the playback enginge and actually get data
  * off the DVD.
  */
 
 /*
- * Attempts to get the next block off the DVD and copies it into the buffer 'buf'. 
+ * Attempts to get the next block off the DVD and copies it into the buffer 'buf'.
  * If there is any special actions that may need to be performed, the value
  * pointed to by 'event' gets set accordingly.
  *
@@ -200,7 +200,7 @@
  * See the dvdnav_events.h header for information on the various events.
  */
 dvdnav_status_t dvdnav_get_next_block(dvdnav_t *self, uint8_t *buf,
-				      int32_t *event, int32_t *len);
+                                      int32_t *event, int32_t *len);
 
 /*
  * This basically does the same as dvdnav_get_next_block. The only difference is
@@ -211,7 +211,7 @@
  * dvdnav_free_cache_block().
  */
 dvdnav_status_t dvdnav_get_next_cache_block(dvdnav_t *self, uint8_t **buf,
-					    int32_t *event, int32_t *len);
+                                            int32_t *event, int32_t *len);
 
 /*
  * All buffers which came from the internal cache (when dvdnav_get_next_cache_block()
@@ -286,7 +286,7 @@
  * Currently unimplemented!
  */
 dvdnav_status_t dvdnav_part_play_auto_stop(dvdnav_t *self, int32_t title,
-					   int32_t part, int32_t parts_to_play);
+                                           int32_t part, int32_t parts_to_play);
 
 /*
  * Play the specified title starting from the specified time.
@@ -294,7 +294,7 @@
  * Currently unimplemented!
  */
 dvdnav_status_t dvdnav_time_play(dvdnav_t *self, int32_t title,
-				 uint64_t time);
+                                 uint64_t time);
 
 /*
  * Stop playing the current position and jump to the specified menu.
@@ -309,18 +309,18 @@
  * is set to the current menu's ID.
  */
 dvdnav_status_t dvdnav_current_title_info(dvdnav_t *self, int32_t *title,
-					  int32_t *part);
+                                          int32_t *part);
 
 /*
  * Return the current position (in blocks) within the current
  * title and the length (in blocks) of said title.
- * 
+ *
  * Current implementation is wrong and likely to behave unpredictably!
  * Use is discouraged!
  */
 dvdnav_status_t dvdnav_get_position_in_title(dvdnav_t *self,
-					     uint32_t *pos,
-					     uint32_t *len);
+                                             uint32_t *pos,
+                                             uint32_t *len);
 
 /*
  * This function is only available for compatibility reasons.
@@ -349,8 +349,8 @@
  * 'origin' can be one of SEEK_SET, SEEK_CUR, SEEK_END as defined in
  * fcntl.h.
  */
-dvdnav_status_t dvdnav_sector_search(dvdnav_t *self, 
-				     uint64_t offset, int32_t origin);
+dvdnav_status_t dvdnav_sector_search(dvdnav_t *self,
+                                     uint64_t offset, int32_t origin);
 
 /*
  * Stop playing the current position and start playback of the title
@@ -358,8 +358,8 @@
  *
  * Currently unimplemented!
  */
-dvdnav_status_t dvdnav_time_search(dvdnav_t *self, 
-				   uint64_t time);
+dvdnav_status_t dvdnav_time_search(dvdnav_t *self,
+                                   uint64_t time);
 
 /*
  * Stop playing current position and play the "GoUp"-program chain.
@@ -394,7 +394,7 @@
  * relative position in and the length of the current program chain.
  */
 dvdnav_status_t dvdnav_get_position(dvdnav_t *self, uint32_t *pos,
-				    uint32_t *len);
+                                    uint32_t *len);
 
 
 /*********************************************************************
@@ -412,7 +412,7 @@
  */
 
 /*
- * Get the currently highlighted button 
+ * Get the currently highlighted button
  * number (1..36) or 0 if no button is highlighted.
  */
 dvdnav_status_t dvdnav_get_current_highlight(dvdnav_t *self, int32_t *button);
@@ -439,7 +439,7 @@
  * Get the area associated with a certain button.
  */
 dvdnav_status_t dvdnav_get_highlight_area(pci_t *nav_pci , int32_t button, int32_t mode,
-					  dvdnav_highlight_area_t *highlight);
+                                          dvdnav_highlight_area_t *highlight);
 
 /*
  * Move button highlight around as suggested by function name (e.g. with arrow keys).
@@ -484,7 +484,7 @@
  * languages                                                         *
  *********************************************************************/
 
-/* 
+/*
  * The language codes expected by these functions are two character
  * codes as defined in ISO639.
  */
@@ -493,19 +493,19 @@
  * Set which menu language we should use per default.
  */
 dvdnav_status_t dvdnav_menu_language_select(dvdnav_t *self,
-					   char *code);
+                                           char *code);
 
 /*
  * Set which audio language we should use per default.
  */
 dvdnav_status_t dvdnav_audio_language_select(dvdnav_t *self,
-					    char *code);
+                                            char *code);
 
 /*
  * Set which spu language we should use per default.
  */
 dvdnav_status_t dvdnav_spu_language_select(dvdnav_t *self,
-					  char *code);
+                                          char *code);
 
 
 /*********************************************************************
@@ -526,7 +526,7 @@
  * Get video aspect code.
  * The aspect code does only change on VTS boundaries.
  * See the DVDNAV_VTS_CHANGE event.
- * 
+ *
  * 0 -- 4:3, 2 -- 16:9
  */
 uint8_t dvdnav_get_video_aspect(dvdnav_t *self);
@@ -547,7 +547,7 @@
 uint16_t dvdnav_audio_stream_to_lang(dvdnav_t *self, uint8_t stream);
 
 /*
- * Converts a *logical* subpicture stream id into country code 
+ * Converts a *logical* subpicture stream id into country code
  * (returns 0xffff if no such stream).
  */
 uint16_t dvdnav_spu_stream_to_lang(dvdnav_t *self, uint8_t stream);
@@ -600,7 +600,7 @@
  * Returns the current angle and number of angles present.
  */
 dvdnav_status_t dvdnav_get_angle_info(dvdnav_t *self, int32_t *current_angle,
-				      int32_t *number_of_angles);
+                                      int32_t *number_of_angles);
 
 /*********************************************************************
  * domain queries                                                    *
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvdnav_internal.h xine-lib-1.2/src/input/libdvdnav/dvdnav_internal.h
--- xine-lib-1.2.11/src/input/libdvdnav/dvdnav_internal.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvdnav_internal.h	2022-01-15 22:03:19.613547293 +0100
@@ -1,18 +1,18 @@
-/* 
+/*
  * Copyright (C) 2001-2004 Rich Wareham <richwareham@users.sourceforge.net>
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -108,7 +108,7 @@
 
 /*
  * These are defined here because they are
- * not in ifo_types.h, they maybe one day 
+ * not in ifo_types.h, they maybe one day
  */
 
 #ifndef audio_status_t
@@ -121,7 +121,7 @@
 #else
   uint8_t zero2;
   unsigned int stream_number : 3;
-  unsigned int zero1         : 4;  
+  unsigned int zero1         : 4;
   unsigned int available     : 1;
 #endif
 } ATTRIBUTE_PACKED audio_status_t;
@@ -158,34 +158,34 @@
   int32_t vobu_length;
   int32_t blockN;      /* Relative offset */
   int32_t vobu_next;   /* Relative offset */
-} dvdnav_vobu_t;  
-   
+} dvdnav_vobu_t;
+
 /** The main DVDNAV type **/
 
 struct dvdnav_s {
   /* General data */
   char        path[MAX_PATH_LEN]; /* Path to DVD device/dir */
   dvd_file_t *file;               /* Currently opened file */
- 
+
   /* Position data */
   vm_position_t position_next;
   vm_position_t position_current;
-  dvdnav_vobu_t vobu;  
+  dvdnav_vobu_t vobu;
 
   /* NAV data */
   pci_t pci;
   dsi_t dsi;
   uint32_t last_cmd_nav_lbn;      /* detects when a command is issued on an already left NAV */
-  
+
   /* Flags */
   int skip_still;                 /* Set when skipping a still */
   int sync_wait;                  /* applications should wait till they are in sync with us */
   int sync_wait_skip;             /* Set when skipping wait state */
-  int spu_clut_changed;           /* The SPU CLUT changed */ 
+  int spu_clut_changed;           /* The SPU CLUT changed */
   int started;                    /* vm_start has been called? */
   int use_read_ahead;             /* 1 - use read-ahead cache, 0 - don't */
   int pgc_based;                  /* positioning works PGC based instead of PG based */
-  
+
   /* VM */
   vm_t *vm;
   pthread_mutex_t vm_lock;
@@ -203,34 +203,34 @@
  * more common prints
  */
 #ifdef __GNUC__
-#define printerrf(format, args...)					\
-  do {									\
+#define printerrf(format, args...)                                      \
+  do {                                                                  \
     if ( ! this ) fprintf(stderr, "Missing 'this' pointer while erroring:" format "\n", ## args); \
-    else snprintf(this->err_str, MAX_ERR_LEN, format, ## args);		\
+    else snprintf(this->err_str, MAX_ERR_LEN, format, ## args);         \
   } while(0);
 #else
 #ifdef _MSC_VER
 #define printerrf(str) snprintf(this->err_str, MAX_ERR_LEN, str);
 #else
-#define printerrf(...)						 \
-  do {								 \
-    if ( ! this ) {						 \
+#define printerrf(...)                                           \
+  do {                                                           \
+    if ( ! this ) {                                              \
       fprintf(stderr, "Missing 'this' pointer while erroring:"); \
-      fprintf(stderr, __VA_ARGS__);				 \
-      fprintf(stderr, "\n");					 \
-    } else {							 \
-      snprintf(this->err_str, MAX_ERR_LEN, __VA_ARGS__);	 \
-    }								 \
+      fprintf(stderr, __VA_ARGS__);                              \
+      fprintf(stderr, "\n");                                     \
+    } else {                                                     \
+      snprintf(this->err_str, MAX_ERR_LEN, __VA_ARGS__);         \
+    }                                                            \
   } while(0);
 #endif /* WIN32 */
 #endif
-#define printerr(str)							\
-  do {									\
-    if ( ! this ) {							\
+#define printerr(str)                                                   \
+  do {                                                                  \
+    if ( ! this ) {                                                     \
       fprintf(stderr, "Missing 'this' pointer while erroring: %s\n", str); \
-    } else {								\
-      strncpy(this->err_str, str, MAX_ERR_LEN);				\
-    }									\
+    } else {                                                            \
+      strncpy(this->err_str, str, MAX_ERR_LEN);                         \
+    }                                                                   \
   } while(0);
 
 #endif /* DVDNAV_INTERNAL_H_INCLUDED */
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvd_reader.c xine-lib-1.2/src/input/libdvdnav/dvd_reader.c
--- xine-lib-1.2.11/src/input/libdvdnav/dvd_reader.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvd_reader.c	2022-01-15 22:03:19.607547268 +0100
@@ -59,7 +59,7 @@
 #include <io.h> /* read() */
 #define lseek64 _lseeki64
 #endif
- 
+
 #if defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__bsdi__)|| defined(__DARWIN__)
 #define SYS_BSD 1
 #endif
@@ -83,8 +83,8 @@
 struct dvd_reader_s {
     /* Basic information. */
     int isImageFile;
-  
-    /* Hack for keeping track of the css status. 
+
+    /* Hack for keeping track of the css status.
      * 0: no css, 1: perhaps (need init of keys), 2: have done init */
     int css_state;
     int css_title; /* Last title that we have called dvdinpute_title for. */
@@ -94,7 +94,7 @@
 
     /* Information required for a directory path drive. */
     char *path_root;
-  
+
     /* Filesystem cache */
     int udfcache_level; /* 0 - turned off, 1 - on */
     void *udfcache;
@@ -103,7 +103,7 @@
 struct dvd_file_s {
     /* Basic information. */
     dvd_reader_t *dvd;
-  
+
     /* Hack for selecting the right css title. */
     int css_title;
 
@@ -120,7 +120,7 @@
 };
 
 int UDFReadBlocksRaw( dvd_reader_t *device, uint32_t lb_number,
-                     size_t block_count, unsigned char *data, 
+                     size_t block_count, unsigned char *data,
                      int encrypted );
 
 /**
@@ -131,7 +131,7 @@
 int DVDUDFCacheLevel(dvd_reader_t *device, int level)
 {
   struct dvd_reader_s *dev = (struct dvd_reader_s *)device;
-  
+
   if(level > 0) {
     level = 1;
   } else if(level < 0) {
@@ -139,14 +139,14 @@
   }
 
   dev->udfcache_level = level;
-  
+
   return level;
 }
 
 void *GetUDFCacheHandle(dvd_reader_t *device)
 {
   struct dvd_reader_s *dev = (struct dvd_reader_s *)device;
-  
+
   return dev->udfcache;
 }
 
@@ -167,62 +167,62 @@
     char filename[ MAX_UDF_FILE_NAME_LEN ];
     uint32_t start, len;
     int title;
-	
+
     char *nokeys_str = getenv("DVDREAD_NOKEYS");
     if(nokeys_str != NULL)
       return 0;
-    
+
     fprintf( stderr, "\n" );
     fprintf( stderr, "libdvdread: Attempting to retrieve all CSS keys\n" );
     fprintf( stderr, "libdvdread: This can take a _long_ time, "
-	     "please be patient\n\n" );
-	
+             "please be patient\n\n" );
+
     gettimeofday(&all_s, NULL);
-	
+
     for( title = 0; title < 100; title++ ) {
-	gettimeofday( &t_s, NULL );
-	if( title == 0 ) {
-	    sprintf( filename, "/VIDEO_TS/VIDEO_TS.VOB" );
-	} else {
-	    sprintf( filename, "/VIDEO_TS/VTS_%02d_%d.VOB", title, 0 );
-	}
-	start = UDFFindFile( dvd, filename, &len );
-	if( start != 0 && len != 0 ) {
-	    /* Perform CSS key cracking for this title. */
-	    fprintf( stderr, "libdvdread: Get key for %s at 0x%08x\n", 
-		     filename, start );
-	    if( dvdinput_title( dvd->dev, (int)start ) < 0 ) {
-		fprintf( stderr, "libdvdread: Error cracking CSS key for %s (0x%08x)\n", filename, start);
-	    }
-	    gettimeofday( &t_e, NULL );
-	    fprintf( stderr, "libdvdread: Elapsed time %ld\n",  
-		     (long int) t_e.tv_sec - t_s.tv_sec );
-	}
-	    
-	if( title == 0 ) continue;
-	    
-	gettimeofday( &t_s, NULL );
-	sprintf( filename, "/VIDEO_TS/VTS_%02d_%d.VOB", title, 1 );
-	start = UDFFindFile( dvd, filename, &len );
-	if( start == 0 || len == 0 ) break;
-	    
-	/* Perform CSS key cracking for this title. */
-	fprintf( stderr, "libdvdread: Get key for %s at 0x%08x\n", 
-		 filename, start );
-	if( dvdinput_title( dvd->dev, (int)start ) < 0 ) {
-	    fprintf( stderr, "libdvdread: Error cracking CSS key for %s (0x%08x)!!\n", filename, start);
-	}
-	gettimeofday( &t_e, NULL );
-	fprintf( stderr, "libdvdread: Elapsed time %ld\n",  
-		 (long int) t_e.tv_sec - t_s.tv_sec );
+        gettimeofday( &t_s, NULL );
+        if( title == 0 ) {
+            sprintf( filename, "/VIDEO_TS/VIDEO_TS.VOB" );
+        } else {
+            sprintf( filename, "/VIDEO_TS/VTS_%02d_%d.VOB", title, 0 );
+        }
+        start = UDFFindFile( dvd, filename, &len );
+        if( start != 0 && len != 0 ) {
+            /* Perform CSS key cracking for this title. */
+            fprintf( stderr, "libdvdread: Get key for %s at 0x%08x\n",
+                     filename, start );
+            if( dvdinput_title( dvd->dev, (int)start ) < 0 ) {
+                fprintf( stderr, "libdvdread: Error cracking CSS key for %s (0x%08x)\n", filename, start);
+            }
+            gettimeofday( &t_e, NULL );
+            fprintf( stderr, "libdvdread: Elapsed time %ld\n",
+                     (long int) t_e.tv_sec - t_s.tv_sec );
+        }
+
+        if( title == 0 ) continue;
+
+        gettimeofday( &t_s, NULL );
+        sprintf( filename, "/VIDEO_TS/VTS_%02d_%d.VOB", title, 1 );
+        start = UDFFindFile( dvd, filename, &len );
+        if( start == 0 || len == 0 ) break;
+
+        /* Perform CSS key cracking for this title. */
+        fprintf( stderr, "libdvdread: Get key for %s at 0x%08x\n",
+                 filename, start );
+        if( dvdinput_title( dvd->dev, (int)start ) < 0 ) {
+            fprintf( stderr, "libdvdread: Error cracking CSS key for %s (0x%08x)!!\n", filename, start);
+        }
+        gettimeofday( &t_e, NULL );
+        fprintf( stderr, "libdvdread: Elapsed time %ld\n",
+                 (long int) t_e.tv_sec - t_s.tv_sec );
     }
     title--;
-    
+
     fprintf( stderr, "libdvdread: Found %d VTS's\n", title );
     gettimeofday(&all_e, NULL);
-    fprintf( stderr, "libdvdread: Elapsed time %ld\n",  
-	     (long int) all_e.tv_sec - all_s.tv_sec );
-    
+    fprintf( stderr, "libdvdread: Elapsed time %ld\n",
+             (long int) all_e.tv_sec - all_s.tv_sec );
+
     return 0;
 }
 
@@ -235,11 +235,11 @@
 {
     dvd_reader_t *dvd;
     dvd_input_t dev;
-    
+
     dev = dvdinput_open( location );
     if( !dev ) {
-	fprintf( stderr, "libdvdread: Can't open %s for reading\n", location );
-	return 0;
+        fprintf( stderr, "libdvdread: Can't open %s for reading\n", location );
+        return 0;
     }
 
     dvd = (dvd_reader_t *) malloc( sizeof( dvd_reader_t ) );
@@ -247,7 +247,7 @@
     dvd->isImageFile = 1;
     dvd->dev = dev;
     dvd->path_root = 0;
-    
+
     dvd->udfcache_level = DEFAULT_UDF_CACHE_LEVEL;
     dvd->udfcache = NULL;
 
@@ -255,11 +255,11 @@
       /* Only if DVDCSS_METHOD = title, a bit if it's disc or if
        * DVDCSS_METHOD = key but region missmatch. Unfortunaly we
        * don't have that information. */
-    
+
       dvd->css_state = 1; /* Need key init. */
     }
     dvd->css_title = 0;
-    
+
     return dvd;
 }
 
@@ -275,7 +275,7 @@
 
     dvd->udfcache_level = DEFAULT_UDF_CACHE_LEVEL;
     dvd->udfcache = NULL;
-    
+
     dvd->css_state = 0; /* Only used in the UDF path */
     dvd->css_title = 0; /* Only matters in the UDF path */
 
@@ -290,7 +290,7 @@
 {
     char *new_path;
 
-    /* Must contain "/dsk/" */ 
+    /* Must contain "/dsk/" */
     if( !strstr( path, "/dsk/" ) ) return (char *) strdup( path );
 
     /* Replace "/dsk/" with "/rdsk/" */
@@ -314,8 +314,8 @@
 {
     char *new_path;
 
-    /* If it doesn't start with "/dev/" or does start with "/dev/r" exit */ 
-    if( !strncmp( path, "/dev/",  5 ) || strncmp( path, "/dev/r", 6 ) ) 
+    /* If it doesn't start with "/dev/" or does start with "/dev/r" exit */
+    if( !strncmp( path, "/dev/",  5 ) || strncmp( path, "/dev/r", 6 ) )
       return (char *) strdup( path );
 
     /* Replace "/dev/" with "/dev/r" */
@@ -332,218 +332,218 @@
     struct stat fileinfo;
     int ret;
     int have_css;
-	dvd_reader_t *ret_val = NULL;
+        dvd_reader_t *ret_val = NULL;
     char *dev_name = 0;
-	char *path;
+        char *path;
 
 #ifdef _MSC_VER
-	int len;
+        int len;
 #endif
 
     if( ppath == NULL )
       return 0;
 
-	path = strdup(ppath);
-	
+        path = strdup(ppath);
+
     /* Try to open libdvdcss or fall back to standard functions */
     have_css = dvdinput_setup();
 
 #ifdef _MSC_VER
-	/* Strip off the trailing \ if it is not a drive */
-	len = strlen(path);
-	if ((len > 1) && 
-		(path[len - 1] == '\\')  && 
-		(path[len - 2] != ':'))
-	{
-		path[len-1] = '\0';
-	}
+        /* Strip off the trailing \ if it is not a drive */
+        len = strlen(path);
+        if ((len > 1) &&
+                (path[len - 1] == '\\')  &&
+                (path[len - 2] != ':'))
+        {
+                path[len-1] = '\0';
+        }
 #endif
-    
+
     ret = stat( path, &fileinfo );
 
     if( ret < 0 ) {
 
         /* maybe "host:port" url? try opening it with acCeSS library */
         if( strchr(path,':') ) {
-			ret_val = DVDOpenImageFile( path, have_css );
-			free(path);
-	        return ret_val;
-        }
-      
-	/* If we can't stat the file, give up */
-	fprintf( stderr, "libdvdread: Can't stat %s\n", path );
-	perror("");
-	free(path);
-	return 0;
+                        ret_val = DVDOpenImageFile( path, have_css );
+                        free(path);
+                return ret_val;
+        }
+
+        /* If we can't stat the file, give up */
+        fprintf( stderr, "libdvdread: Can't stat %s\n", path );
+        perror("");
+        free(path);
+        return 0;
     }
 
     /* First check if this is a block/char device or a file*/
-    if( S_ISBLK( fileinfo.st_mode ) || 
-	S_ISCHR( fileinfo.st_mode ) || 
-	S_ISREG( fileinfo.st_mode ) ) {
-
-	/**
-	 * Block devices and regular files are assumed to be DVD-Video images.
-	 */
+    if( S_ISBLK( fileinfo.st_mode ) ||
+        S_ISCHR( fileinfo.st_mode ) ||
+        S_ISREG( fileinfo.st_mode ) ) {
+
+        /**
+         * Block devices and regular files are assumed to be DVD-Video images.
+         */
 #if defined(__sun)
-	ret_val = DVDOpenImageFile( sun_block2char( path ), have_css );
+        ret_val = DVDOpenImageFile( sun_block2char( path ), have_css );
 #elif defined(SYS_BSD)
-	ret_val = DVDOpenImageFile( bsd_block2char( path ), have_css );
+        ret_val = DVDOpenImageFile( bsd_block2char( path ), have_css );
 #else
-	ret_val = DVDOpenImageFile( path, have_css );
+        ret_val = DVDOpenImageFile( path, have_css );
 #endif
 
-	free(path);
-	return ret_val;
+        free(path);
+        return ret_val;
 
     } else if( S_ISDIR( fileinfo.st_mode ) ) {
-	dvd_reader_t *auth_drive = 0;
-	char *path_copy;
+        dvd_reader_t *auth_drive = 0;
+        char *path_copy;
 #if defined(SYS_BSD)
-	struct fstab* fe;
+        struct fstab* fe;
 #elif defined(__sun) || defined(__linux__)
-	FILE *mntfile;
+        FILE *mntfile;
 #endif
 
-	/* XXX: We should scream real loud here. */
-	if( !(path_copy = strdup( path ) ) ) {
-		free(path);	
-		return 0;
-	}
+        /* XXX: We should scream real loud here. */
+        if( !(path_copy = strdup( path ) ) ) {
+                free(path);
+                return 0;
+        }
 
 #ifndef WIN32 /* don't have fchdir, and getcwd( NULL, ... ) is strange */
               /* Also WIN32 does not have symlinks, so we don't need this bit of code. */
 
-	/* Resolve any symlinks and get the absolut dir name. */
-	{
-	    char *new_path;
-	    int cdir = open( ".", O_RDONLY );
-	    
-	    if( cdir >= 0 ) {
-		chdir( path_copy );
-		new_path = getcwd( NULL, XINE_PATH_MAX );
-		fchdir( cdir );
-		close( cdir );
-		if( new_path ) {
-		    free( path_copy );
-		    path_copy = new_path;
-		}
-	    }
-	}
-#endif	
-	/**
-	 * If we're being asked to open a directory, check if that directory
-	 * is the mountpoint for a DVD-ROM which we can use instead.
-	 */
-
-	if( strlen( path_copy ) > 1 ) {
-	    if( path_copy[ strlen( path_copy ) - 1 ] == '/' ) 
-		path_copy[ strlen( path_copy ) - 1 ] = '\0';
-	}
-
-	if( strlen( path_copy ) > 9 ) {
-	    if( !strcasecmp( &(path_copy[ strlen( path_copy ) - 9 ]), 
-			     "/video_ts" ) ) {
-	      path_copy[ strlen( path_copy ) - 9 ] = '\0';
-	    }
-	}
+        /* Resolve any symlinks and get the absolut dir name. */
+        {
+            char *new_path;
+            int cdir = open( ".", O_RDONLY );
+
+            if( cdir >= 0 ) {
+                chdir( path_copy );
+                new_path = getcwd( NULL, XINE_PATH_MAX );
+                fchdir( cdir );
+                close( cdir );
+                if( new_path ) {
+                    free( path_copy );
+                    path_copy = new_path;
+                }
+            }
+        }
+#endif
+        /**
+         * If we're being asked to open a directory, check if that directory
+         * is the mountpoint for a DVD-ROM which we can use instead.
+         */
+
+        if( strlen( path_copy ) > 1 ) {
+            if( path_copy[ strlen( path_copy ) - 1 ] == '/' )
+                path_copy[ strlen( path_copy ) - 1 ] = '\0';
+        }
+
+        if( strlen( path_copy ) > 9 ) {
+            if( !strcasecmp( &(path_copy[ strlen( path_copy ) - 9 ]),
+                             "/video_ts" ) ) {
+              path_copy[ strlen( path_copy ) - 9 ] = '\0';
+            }
+        }
 
 #if defined(SYS_BSD)
-	if( ( fe = getfsfile( path_copy ) ) ) {
-	    dev_name = bsd_block2char( fe->fs_spec );
-	    fprintf( stderr,
-		     "libdvdread: Attempting to use device %s"
-		     " mounted on %s for CSS authentication\n",
-		     dev_name,
-		     fe->fs_file );
-	    auth_drive = DVDOpenImageFile( dev_name, have_css );
-	}
+        if( ( fe = getfsfile( path_copy ) ) ) {
+            dev_name = bsd_block2char( fe->fs_spec );
+            fprintf( stderr,
+                     "libdvdread: Attempting to use device %s"
+                     " mounted on %s for CSS authentication\n",
+                     dev_name,
+                     fe->fs_file );
+            auth_drive = DVDOpenImageFile( dev_name, have_css );
+        }
 #elif defined(__sun)
-	mntfile = fopen( MNTTAB, "r" );
-	if( mntfile ) {
-	    struct mnttab mp;
-	    int res;
-
-	    while( ( res = getmntent( mntfile, &mp ) ) != -1 ) {
-		if( res == 0 && !strcmp( mp.mnt_mountp, path_copy ) ) {
-		    dev_name = sun_block2char( mp.mnt_special );
-		    fprintf( stderr, 
-			     "libdvdread: Attempting to use device %s"
-			     " mounted on %s for CSS authentication\n",
-			     dev_name,
-			     mp.mnt_mountp );
-		    auth_drive = DVDOpenImageFile( dev_name, have_css );
-		    break;
-		}
-	    }
-	    fclose( mntfile );
-	}
+        mntfile = fopen( MNTTAB, "r" );
+        if( mntfile ) {
+            struct mnttab mp;
+            int res;
+
+            while( ( res = getmntent( mntfile, &mp ) ) != -1 ) {
+                if( res == 0 && !strcmp( mp.mnt_mountp, path_copy ) ) {
+                    dev_name = sun_block2char( mp.mnt_special );
+                    fprintf( stderr,
+                             "libdvdread: Attempting to use device %s"
+                             " mounted on %s for CSS authentication\n",
+                             dev_name,
+                             mp.mnt_mountp );
+                    auth_drive = DVDOpenImageFile( dev_name, have_css );
+                    break;
+                }
+            }
+            fclose( mntfile );
+        }
 #elif defined(__linux__)
         mntfile = fopen( MOUNTED, "r" );
         if( mntfile ) {
             struct mntent *me;
- 
+
             while( ( me = getmntent( mntfile ) ) ) {
                 if( !strcmp( me->mnt_dir, path_copy ) ) {
-		    fprintf( stderr, 
-			     "libdvdread: Attempting to use device %s"
-			     " mounted on %s for CSS authentication\n",
-			     me->mnt_fsname,
-			     me->mnt_dir );
+                    fprintf( stderr,
+                             "libdvdread: Attempting to use device %s"
+                             " mounted on %s for CSS authentication\n",
+                             me->mnt_fsname,
+                             me->mnt_dir );
                     auth_drive = DVDOpenImageFile( me->mnt_fsname, have_css );
-		    /* If the device is not encrypted, don't access the device
-		     * directly as it would fail for non-UDF DVDs */
-		    if ( auth_drive && dvdinput_is_encrypted( auth_drive->dev ) == 0) {
-		      DVDClose( auth_drive );
-		      auth_drive = NULL;
-		      break;
-		    }
-		    dev_name = strdup(me->mnt_fsname);
+                    /* If the device is not encrypted, don't access the device
+                     * directly as it would fail for non-UDF DVDs */
+                    if ( auth_drive && dvdinput_is_encrypted( auth_drive->dev ) == 0) {
+                      DVDClose( auth_drive );
+                      auth_drive = NULL;
+                      break;
+                    }
+                    dev_name = strdup(me->mnt_fsname);
                     break;
                 }
             }
             fclose( mntfile );
-	}
+        }
 #elif defined(_MSC_VER)
     auth_drive = DVDOpenImageFile( path, have_css );
 #endif
 
 #ifndef _MSC_VER
-	if( !dev_name ) {
-	  fprintf( stderr, "libdvdread: Couldn't find device name.\n" );
-	} else if( !auth_drive ) {
-	    fprintf( stderr, "libdvdread: Device %s inaccessible, "
-		     "CSS authentication not available.\n", dev_name );
-	}
+        if( !dev_name ) {
+          fprintf( stderr, "libdvdread: Couldn't find device name.\n" );
+        } else if( !auth_drive ) {
+            fprintf( stderr, "libdvdread: Device %s inaccessible, "
+                     "CSS authentication not available.\n", dev_name );
+        }
 #else
-	if( !auth_drive ) {
-	    fprintf( stderr, "libdvdread: Device %s inaccessible, "
-		     "CSS authentication not available.\n", dev_name );
-	}
+        if( !auth_drive ) {
+            fprintf( stderr, "libdvdread: Device %s inaccessible, "
+                     "CSS authentication not available.\n", dev_name );
+        }
 #endif
 
-	free( dev_name );
-	free( path_copy );
+        free( dev_name );
+        free( path_copy );
 
         /**
          * If we've opened a drive, just use that.
          */
-	if( auth_drive ) {
-		free(path);
-		return auth_drive;
-	}
+        if( auth_drive ) {
+                free(path);
+                return auth_drive;
+        }
 
         /**
          * Otherwise, we now try to open the directory tree instead.
          */
         ret_val = DVDOpenPath( path );
-		free( path );
-		return ret_val;
+                free( path );
+                return ret_val;
     }
 
     /* If it's none of the above, screw it. */
     fprintf( stderr, "libdvdread: Could not open %s\n", path );
-	free( path );
+        free( path );
     return 0;
 }
 
@@ -552,7 +552,7 @@
     if( dvd ) {
         if( dvd->dev ) dvdinput_close( dvd->dev );
         if( dvd->path_root ) free( dvd->path_root );
-	if( dvd->udfcache ) FreeUDFCache( dvd->udfcache );
+        if( dvd->udfcache ) FreeUDFCache( dvd->udfcache );
         free( dvd );
     }
 }
@@ -592,7 +592,7 @@
  *     or -1 on file not found.
  *     or -2 on path not found.
  */
-static int findDirFile( const char *path, const char *file, char *filename ) 
+static int findDirFile( const char *path, const char *file, char *filename )
 {
     DIR *dir;
     struct dirent *ent;
@@ -725,18 +725,18 @@
             dvd_file->filesize += len / DVD_VIDEO_LB_LEN;
         }
     }
-    
+
     if( dvd->css_state == 1 /* Need key init */ ) {
         initAllCSSKeys( dvd );
-	dvd->css_state = 2;
+        dvd->css_state = 2;
     }
-    /*    
+    /*
     if( dvdinput_title( dvd_file->dvd->dev, (int)start ) < 0 ) {
         fprintf( stderr, "libdvdread: Error cracking CSS key for %s\n",
-		 filename );
+                 filename );
     }
     */
-    
+
     return dvd_file;
 }
 
@@ -757,7 +757,7 @@
     memset( dvd_file->title_sizes, 0, sizeof( dvd_file->title_sizes ) );
     memset( dvd_file->title_devs, 0, sizeof( dvd_file->title_devs ) );
     dvd_file->filesize = 0;
-    
+
     if( menu ) {
         dvd_input_t dev;
 
@@ -784,7 +784,7 @@
         }
         dvd_file->title_sizes[ 0 ] = fileinfo.st_size / DVD_VIDEO_LB_LEN;
         dvd_file->title_devs[ 0 ] = dev;
-	dvdinput_title( dvd_file->title_devs[0], 0);
+        dvdinput_title( dvd_file->title_devs[0], 0);
         dvd_file->filesize = dvd_file->title_sizes[ 0 ];
 
     } else {
@@ -802,7 +802,7 @@
 
             dvd_file->title_sizes[ i ] = fileinfo.st_size / DVD_VIDEO_LB_LEN;
             dvd_file->title_devs[ i ] = dvdinput_open( full_path );
-	    dvdinput_title( dvd_file->title_devs[ i ], 0 );
+            dvdinput_title( dvd_file->title_devs[ i ], 0 );
             dvd_file->filesize += dvd_file->title_sizes[ i ];
         }
         if( !dvd_file->title_devs[ 0 ] ) {
@@ -814,11 +814,11 @@
     return dvd_file;
 }
 
-dvd_file_t *DVDOpenFile( dvd_reader_t *dvd, int titlenum, 
-			 dvd_read_domain_t domain )
+dvd_file_t *DVDOpenFile( dvd_reader_t *dvd, int titlenum,
+                         dvd_read_domain_t domain )
 {
     char filename[ MAX_UDF_FILE_NAME_LEN ];
-    
+
     /* Check arguments. */
     if( dvd == NULL || titlenum < 0 )
       return NULL;
@@ -857,7 +857,7 @@
         fprintf( stderr, "libdvdread: Invalid domain for file open.\n" );
         return NULL;
     }
-    
+
     if( dvd->isImageFile ) {
         return DVDOpenFileUDF( dvd, filename );
     } else {
@@ -871,8 +871,8 @@
 
     if( dvd_file ) {
         if( dvd_file->dvd->isImageFile ) {
-	    ;
-	} else {
+            ;
+        } else {
             for( i = 0; i < 9; ++i ) {
                 if( dvd_file->title_devs[ i ] ) {
                     dvdinput_close( dvd_file->title_devs[i] );
@@ -887,23 +887,23 @@
 
 /* Internal, but used from dvd_udf.c */
 int UDFReadBlocksRaw( dvd_reader_t *device, uint32_t lb_number,
-			 size_t block_count, unsigned char *data, 
-			 int encrypted )
+                         size_t block_count, unsigned char *data,
+                         int encrypted )
 {
    int ret;
    if( !device->dev ) {
-     	fprintf( stderr, "libdvdread: Fatal error in block read.\n" );
-	return 0;
+        fprintf( stderr, "libdvdread: Fatal error in block read.\n" );
+        return 0;
    }
 
    ret = dvdinput_seek( device->dev, (int) lb_number );
    if( ret != (int) lb_number ) {
-     	fprintf( stderr, "libdvdread: Can't seek to block %u\n", lb_number );
-	return 0;
+        fprintf( stderr, "libdvdread: Can't seek to block %u\n", lb_number );
+        return 0;
    }
 
-   ret = dvdinput_read( device->dev, (char *) data, 
-			 (int) block_count, encrypted );
+   ret = dvdinput_read( device->dev, (char *) data,
+                         (int) block_count, encrypted );
    return ret;
 }
 
@@ -914,11 +914,11 @@
  * descramble the data if it's encrypted.  Returning either an
  * negative error or the number of blocks read. */
 static int DVDReadBlocksUDF( dvd_file_t *dvd_file, uint32_t offset,
-			     size_t block_count, unsigned char *data,
-			     int encrypted )
+                             size_t block_count, unsigned char *data,
+                             int encrypted )
 {
     return UDFReadBlocksRaw( dvd_file->dvd, dvd_file->lb_start + offset,
-			     block_count, data, encrypted );
+                             block_count, data, encrypted );
 }
 
 /* This is using possibly several inputs and starting from an offset of '0'.
@@ -928,8 +928,8 @@
  * descramble the data if it's encrypted.  Returning either an
  * negative error or the number of blocks read. */
 static int DVDReadBlocksPath( dvd_file_t *dvd_file, unsigned int offset,
-			      size_t block_count, unsigned char *data,
-			      int encrypted )
+                              size_t block_count, unsigned char *data,
+                              int encrypted )
 {
     int i;
     int ret, ret2, off;
@@ -941,50 +941,50 @@
 
         if( offset < dvd_file->title_sizes[ i ] ) {
             if( ( offset + block_count ) <= dvd_file->title_sizes[ i ] ) {
-		off = dvdinput_seek( dvd_file->title_devs[ i ], (int)offset );
+                off = dvdinput_seek( dvd_file->title_devs[ i ], (int)offset );
                 if( off < 0 || off != (int)offset ) {
-		    fprintf( stderr, "libdvdread: Can't seek to block %d\n", 
-			     offset );
-		    return off < 0 ? off : 0;
-		}
+                    fprintf( stderr, "libdvdread: Can't seek to block %d\n",
+                             offset );
+                    return off < 0 ? off : 0;
+                }
                 ret = dvdinput_read( dvd_file->title_devs[ i ], data,
-				     (int)block_count, encrypted );
+                                     (int)block_count, encrypted );
                 break;
             } else {
                 size_t part1_size = dvd_file->title_sizes[ i ] - offset;
-		/* FIXME: Really needs to be a while loop.
+                /* FIXME: Really needs to be a while loop.
                  * (This is only true if you try and read >1GB at a time) */
-		
+
                 /* Read part 1 */
                 off = dvdinput_seek( dvd_file->title_devs[ i ], (int)offset );
                 if( off < 0 || off != (int)offset ) {
-		    fprintf( stderr, "libdvdread: Can't seek to block %d\n", 
-			     offset );
-		    return off < 0 ? off : 0;
-		}
+                    fprintf( stderr, "libdvdread: Can't seek to block %d\n",
+                             offset );
+                    return off < 0 ? off : 0;
+                }
                 ret = dvdinput_read( dvd_file->title_devs[ i ], data,
-				     (int)part1_size, encrypted );
-		if( ret < 0 ) return ret;
-		/* FIXME: This is wrong if i is the last file in the set. 
+                                     (int)part1_size, encrypted );
+                if( ret < 0 ) return ret;
+                /* FIXME: This is wrong if i is the last file in the set.
                  * also error from this read will not show in ret. */
-		
-		/* Does the next part exist? If not then return now. */
-		if( !dvd_file->title_devs[ i + 1 ] ) return ret;
+
+                /* Does the next part exist? If not then return now. */
+                if( !dvd_file->title_devs[ i + 1 ] ) return ret;
 
                 /* Read part 2 */
                 off = dvdinput_seek( dvd_file->title_devs[ i + 1 ], 0 );
                 if( off < 0 || off != 0 ) {
-		    fprintf( stderr, "libdvdread: Can't seek to block %d\n", 
-			     0 );
-		    return off < 0 ? off : 0;
-		}
-                ret2 = dvdinput_read( dvd_file->title_devs[ i + 1 ], 
-				      data + ( part1_size
-					       * (int64_t)DVD_VIDEO_LB_LEN ),
-				      (int)(block_count - part1_size),
-				      encrypted );
+                    fprintf( stderr, "libdvdread: Can't seek to block %d\n",
+                             0 );
+                    return off < 0 ? off : 0;
+                }
+                ret2 = dvdinput_read( dvd_file->title_devs[ i + 1 ],
+                                      data + ( part1_size
+                                               * (int64_t)DVD_VIDEO_LB_LEN ),
+                                      (int)(block_count - part1_size),
+                                      encrypted );
                 if( ret2 < 0 ) return ret2;
-		break;
+                break;
             }
         } else {
             offset -= dvd_file->title_sizes[ i ];
@@ -995,34 +995,34 @@
 }
 
 /* This is broken reading more than 2Gb at a time is ssize_t is 32-bit. */
-ssize_t DVDReadBlocks( dvd_file_t *dvd_file, int offset, 
-		       size_t block_count, unsigned char *data )
+ssize_t DVDReadBlocks( dvd_file_t *dvd_file, int offset,
+                       size_t block_count, unsigned char *data )
 {
     int ret;
     /* Check arguments. */
     if( dvd_file == NULL || offset < 0 || data == NULL )
       return -1;
-    
+
     /* Hack, and it will still fail for multiple opens in a threaded app ! */
     if( dvd_file->dvd->css_title != dvd_file->css_title ) {
       dvd_file->dvd->css_title = dvd_file->css_title;
       if( dvd_file->dvd->isImageFile ) {
-	dvdinput_title( dvd_file->dvd->dev, (int)dvd_file->lb_start );
-      } 
-      /* Here each vobu has it's own dvdcss handle, so no need to update 
+        dvdinput_title( dvd_file->dvd->dev, (int)dvd_file->lb_start );
+      }
+      /* Here each vobu has it's own dvdcss handle, so no need to update
       else {
-	dvdinput_title( dvd_file->title_devs[ 0 ], (int)dvd_file->lb_start );
+        dvdinput_title( dvd_file->title_devs[ 0 ], (int)dvd_file->lb_start );
       }*/
     }
-    
+
     if( dvd_file->dvd->isImageFile ) {
-	ret = DVDReadBlocksUDF( dvd_file, (uint32_t)offset, 
-				block_count, data, DVDINPUT_READ_DECRYPT );
+        ret = DVDReadBlocksUDF( dvd_file, (uint32_t)offset,
+                                block_count, data, DVDINPUT_READ_DECRYPT );
     } else {
-	ret = DVDReadBlocksPath( dvd_file, (unsigned int)offset, 
-				 block_count, data, DVDINPUT_READ_DECRYPT );
+        ret = DVDReadBlocksPath( dvd_file, (unsigned int)offset,
+                                 block_count, data, DVDINPUT_READ_DECRYPT );
     }
-    
+
     return (ssize_t)ret;
 }
 
@@ -1031,7 +1031,7 @@
     /* Check arguments. */
     if( dvd_file == NULL || offset < 0 )
        return -1;
-    
+
     if( offset > dvd_file->filesize * DVD_VIDEO_LB_LEN ) {
        return -1;
     }
@@ -1066,7 +1066,7 @@
     unsigned char *secbuf_base, *secbuf;
     unsigned int numsec, seek_sector, seek_byte;
     int ret;
-    
+
     /* Check arguments. */
     if( dvd_file == NULL || data == NULL )
       return -1;
@@ -1076,21 +1076,21 @@
 
     numsec = ( ( seek_byte + byte_size ) / DVD_VIDEO_LB_LEN ) +
       ( ( ( seek_byte + byte_size ) % DVD_VIDEO_LB_LEN ) ? 1 : 0 );
-    
+
     secbuf_base = (unsigned char *) malloc( numsec * DVD_VIDEO_LB_LEN + 2048 );
     secbuf = (unsigned char *)(((uintptr_t)secbuf_base & ~((uintptr_t)2047)) + 2048);
     if( !secbuf_base ) {
-	fprintf( stderr, "libdvdread: Can't allocate memory " 
-		 "for file read!\n" );
+        fprintf( stderr, "libdvdread: Can't allocate memory "
+                 "for file read!\n" );
         return 0;
     }
-    
+
     if( dvd_file->dvd->isImageFile ) {
-	ret = DVDReadBlocksUDF( dvd_file, (uint32_t) seek_sector, 
-				(size_t) numsec, secbuf, DVDINPUT_NOFLAGS );
+        ret = DVDReadBlocksUDF( dvd_file, (uint32_t) seek_sector,
+                                (size_t) numsec, secbuf, DVDINPUT_NOFLAGS );
     } else {
-	ret = DVDReadBlocksPath( dvd_file, seek_sector, 
-				 (size_t) numsec, secbuf, DVDINPUT_NOFLAGS );
+        ret = DVDReadBlocksPath( dvd_file, seek_sector,
+                                 (size_t) numsec, secbuf, DVDINPUT_NOFLAGS );
     }
 
     if( ret != (int) numsec ) {
@@ -1110,7 +1110,7 @@
     /* Check arguments. */
     if( dvd_file == NULL )
       return -1;
-    
+
     return dvd_file->filesize;
 }
 
@@ -1122,47 +1122,47 @@
     /* Check arguments. */
     if( dvd == NULL || discid == NULL )
       return 0;
-    
-    /* Go through the first 10 IFO:s, in order, 
+
+    /* Go through the first 10 IFO:s, in order,
      * and md5sum them, i.e  VIDEO_TS.IFO and VTS_0?_0.IFO */
     md5_init_ctx( &ctx );
     for( title = 0; title < 10; title++ ) {
-	dvd_file_t *dvd_file = DVDOpenFile( dvd, title, DVD_READ_INFO_FILE );
-	if( dvd_file != NULL ) {
-	    ssize_t bytes_read;
-	    size_t file_size = dvd_file->filesize * DVD_VIDEO_LB_LEN;
-	    char *buffer_base = malloc( file_size + 2048 );
-	    char *buffer = (unsigned char *)(((uintptr_t)buffer_base & ~((uintptr_t)2047)) + 2048);
-	    
-	    if( buffer_base == NULL ) {
-		fprintf( stderr, "libdvdread: DVDDiscId, failed to "
-			 "allocate memory for file read!\n" );
-		return -1;
-	    }
-	    bytes_read = DVDReadBytes( dvd_file, buffer, file_size );
-	    if( (size_t)bytes_read != file_size ) {
-		fprintf( stderr, "libdvdread: DVDDiscId read returned %zd bytes"
-			 ", wanted %zd\n", bytes_read, file_size );
-		DVDCloseFile( dvd_file );
-		free( buffer_base );
-		return -1;
-	    }
-	    
-	    md5_process_bytes( buffer, file_size,  &ctx );
-	    
-	    DVDCloseFile( dvd_file );
-	    free( buffer_base );
-	}
+        dvd_file_t *dvd_file = DVDOpenFile( dvd, title, DVD_READ_INFO_FILE );
+        if( dvd_file != NULL ) {
+            ssize_t bytes_read;
+            size_t file_size = dvd_file->filesize * DVD_VIDEO_LB_LEN;
+            char *buffer_base = malloc( file_size + 2048 );
+            char *buffer = (unsigned char *)(((uintptr_t)buffer_base & ~((uintptr_t)2047)) + 2048);
+
+            if( buffer_base == NULL ) {
+                fprintf( stderr, "libdvdread: DVDDiscId, failed to "
+                         "allocate memory for file read!\n" );
+                return -1;
+            }
+            bytes_read = DVDReadBytes( dvd_file, buffer, file_size );
+            if( (size_t)bytes_read != file_size ) {
+                fprintf( stderr, "libdvdread: DVDDiscId read returned %zd bytes"
+                         ", wanted %zd\n", bytes_read, file_size );
+                DVDCloseFile( dvd_file );
+                free( buffer_base );
+                return -1;
+            }
+
+            md5_process_bytes( buffer, file_size,  &ctx );
+
+            DVDCloseFile( dvd_file );
+            free( buffer_base );
+        }
     }
     md5_finish_ctx( &ctx, discid );
-    
+
     return 0;
 }
 
 
 int DVDISOVolumeInfo( dvd_reader_t *dvd,
-		      char *volid, unsigned int volid_size,
-		      unsigned char *volsetid, unsigned int volsetid_size )
+                      char *volid, unsigned int volid_size,
+                      unsigned char *volsetid, unsigned int volsetid_size )
 {
   unsigned char *buffer, *buffer_base;
   int ret;
@@ -1170,37 +1170,37 @@
   /* Check arguments. */
   if( dvd == NULL )
     return 0;
-  
+
   if( dvd->dev == NULL ) {
     /* No block access, so no ISO... */
     return -1;
   }
-  
+
   buffer_base = malloc( DVD_VIDEO_LB_LEN + 2048 );
   buffer = (unsigned char *)(((uintptr_t)buffer_base & ~((uintptr_t)2047)) + 2048);
 
   if( buffer_base == NULL ) {
     fprintf( stderr, "libdvdread: DVDISOVolumeInfo, failed to "
-	     "allocate memory for file read!\n" );
+             "allocate memory for file read!\n" );
     return -1;
   }
 
   ret = UDFReadBlocksRaw( dvd, 16, 1, buffer, 0 );
   if( ret != 1 ) {
     fprintf( stderr, "libdvdread: DVDISOVolumeInfo, failed to "
-	     "read ISO9660 Primary Volume Descriptor!\n" );
+             "read ISO9660 Primary Volume Descriptor!\n" );
     free( buffer_base );
     return -1;
   }
-  
+
   if( (volid != NULL) && (volid_size > 0) ) {
     unsigned int n;
     for(n = 0; n < 32; n++) {
       if(buffer[40+n] == 0x20) {
-	break;
+        break;
       }
     }
-    
+
     if(volid_size > n+1) {
       volid_size = n+1;
     }
@@ -1208,7 +1208,7 @@
     memcpy(volid, &buffer[40], volid_size-1);
     volid[volid_size-1] = '\0';
   }
-  
+
   if( (volsetid != NULL) && (volsetid_size > 0) ) {
     if(volsetid_size > 128) {
       volsetid_size = 128;
@@ -1221,19 +1221,19 @@
 
 
 int DVDUDFVolumeInfo( dvd_reader_t *dvd,
-		      char *volid, unsigned int volid_size,
-		      unsigned char *volsetid, unsigned int volsetid_size )
+                      char *volid, unsigned int volid_size,
+                      unsigned char *volsetid, unsigned int volsetid_size )
 {
   int ret;
   /* Check arguments. */
   if( dvd == NULL )
     return -1;
-  
+
   if( dvd->dev == NULL ) {
     /* No block access, so no UDF VolumeSet Identifier */
     return -1;
   }
-  
+
   if( (volid != NULL) && (volid_size > 0) ) {
     ret = UDFGetVolumeIdentifier(dvd, volid, volid_size);
     if(!ret) {
@@ -1246,6 +1246,6 @@
       return -1;
     }
   }
-    
-  return 0;  
+
+  return 0;
 }
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvd_reader.h xine-lib-1.2/src/input/libdvdnav/dvd_reader.h
--- xine-lib-1.2.11/src/input/libdvdnav/dvd_reader.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvd_reader.h	2022-01-15 22:03:19.606547263 +0100
@@ -58,12 +58,12 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
-  
+
 /**
  * Opaque type that is used as a handle for one instance of an opened DVD.
  */
 typedef struct dvd_reader_s dvd_reader_t;
-  
+
 /**
  * Opaque type for a file read handle, much like a normal fd or FILE *.
  */
@@ -75,7 +75,7 @@
  *
  * If the given file is a block device, or is the mountpoint for a block
  * device, then that device is used for CSS authentication using libdvdcss.
- * If no device is available, then no CSS authentication is performed, 
+ * If no device is available, then no CSS authentication is performed,
  * and we hope that the image is decrypted.
  *
  * If the path given is a directory, then the files in that directory may be
@@ -86,7 +86,7 @@
  *   path/VTS_01_1.VOB
  *   path/vts_01_1.vob
  *
- * @param path Specifies the the device, file or directory to be used. 
+ * @param path Specifies the the device, file or directory to be used.
  * @return If successful a a read handle is returned. Otherwise 0 is returned.
  *
  * dvd = DVDOpen(path);
@@ -105,15 +105,15 @@
 void DVDClose( dvd_reader_t * );
 
 /**
- * 
+ *
  */
 typedef enum {
   DVD_READ_INFO_FILE,        /**< VIDEO_TS.IFO  or VTS_XX_0.IFO (title) */
   DVD_READ_INFO_BACKUP_FILE, /**< VIDEO_TS.BUP  or VTS_XX_0.BUP (title) */
   DVD_READ_MENU_VOBS,        /**< VIDEO_TS.VOB  or VTS_XX_0.VOB (title) */
-  DVD_READ_TITLE_VOBS        /**< VTS_XX_[1-9].VOB (title).  All files in 
-				  the title set are opened and read as a
-				  single file. */
+  DVD_READ_TITLE_VOBS        /**< VTS_XX_[1-9].VOB (title).  All files in
+                                  the title set are opened and read as a
+                                  single file. */
 } dvd_read_domain_t;
 
 /**
@@ -125,7 +125,7 @@
  *
  * @param dvd  A dvd read handle.
  * @param titlenum Which Video Title Set should be used, VIDEO_TS is 0.
- * @param domain Which domain. 
+ * @param domain Which domain.
  * @return If successful a a file read handle is returned, otherwise 0.
  *
  * dvd_file = DVDOpenFile(dvd, titlenum, domain); */
@@ -143,8 +143,8 @@
 /**
  * Reads block_count number of blocks from the file at the given block offset.
  * Returns number of blocks read on success, -1 on error.  This call is only
- * for reading VOB data, and should not be used when reading the IFO files.  
- * When reading from an encrypted drive, blocks are decrypted using libdvdcss 
+ * for reading VOB data, and should not be used when reading the IFO files.
+ * When reading from an encrypted drive, blocks are decrypted using libdvdcss
  * where required.
  *
  * @param dvd_file  A file read handle.
@@ -202,7 +202,7 @@
  * This is the MD5 sum of VIDEO_TS.IFO and the VTS_0?_0.IFO files
  * in title order (those that exist).
  * If you need a 'text' representation of the id, print it as a
- * hexadecimal number, using lowercase letters, discid[0] first. 
+ * hexadecimal number, using lowercase letters, discid[0] first.
  * I.e. the same format as the command-line 'md5sum' program uses.
  *
  * @param dvd A read handle to get the disc ID from
@@ -231,7 +231,7 @@
  * @return 0 on success, -1 on error.
  */
 int DVDUDFVolumeInfo( dvd_reader_t *, char *, unsigned int,
-		      unsigned char *, unsigned int );
+                      unsigned char *, unsigned int );
 
 /**
  * Get the ISO9660 VolumeIdentifier and VolumeSetIdentifier
@@ -255,7 +255,7 @@
  * @return 0 on success, -1 on error.
  */
 int DVDISOVolumeInfo( dvd_reader_t *, char *, unsigned int,
-		      unsigned char *, unsigned int );
+                      unsigned char *, unsigned int );
 
 /**
  * Sets the level of caching that is done when reading from a device
@@ -265,7 +265,7 @@
  *             -1 - returns the current setting.
  *              0 - UDF Cache turned off.
  *              1 - (default level) Pointers to IFO files and some data from
- *                  PrimaryVolumeDescriptor are cached. 
+ *                  PrimaryVolumeDescriptor are cached.
  *
  * @return The level of caching.
  */
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvd_types.h xine-lib-1.2/src/input/libdvdnav/dvd_types.h
--- xine-lib-1.2.11/src/input/libdvdnav/dvd_types.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvd_types.h	2022-01-15 22:03:19.574547128 +0100
@@ -3,17 +3,17 @@
  *
  * This file is part of libdvdnav, a DVD navigation library. It is a modified
  * file originally part of the Ogle DVD player project.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -51,8 +51,8 @@
  * (see dvdnav_get_highlight_area())
  */
 typedef struct {
-  uint32_t palette;     /* The CLUT entries for the highlight palette 
-			   (4-bits per entry -> 4 entries) */
+  uint32_t palette;     /* The CLUT entries for the highlight palette
+                           (4-bits per entry -> 4 entries) */
   uint16_t sx,sy,ex,ey; /* The start/end x,y positions */
   uint32_t pts;         /* Highlight PTS to match with SPU */
 
@@ -76,15 +76,15 @@
 
 /* User operation permissions */
 typedef enum {
-  UOP_FLAG_TitleOrTimePlay            = 0x00000001, 
-  UOP_FLAG_ChapterSearchOrPlay        = 0x00000002, 
-  UOP_FLAG_TitlePlay                  = 0x00000004, 
-  UOP_FLAG_Stop                       = 0x00000008,  
+  UOP_FLAG_TitleOrTimePlay            = 0x00000001,
+  UOP_FLAG_ChapterSearchOrPlay        = 0x00000002,
+  UOP_FLAG_TitlePlay                  = 0x00000004,
+  UOP_FLAG_Stop                       = 0x00000008,
   UOP_FLAG_GoUp                       = 0x00000010,
-  UOP_FLAG_TimeOrChapterSearch        = 0x00000020, 
-  UOP_FLAG_PrevOrTopPGSearch          = 0x00000040,  
-  UOP_FLAG_NextPGSearch               = 0x00000080,   
-  UOP_FLAG_ForwardScan                = 0x00000100,  
+  UOP_FLAG_TimeOrChapterSearch        = 0x00000020,
+  UOP_FLAG_PrevOrTopPGSearch          = 0x00000040,
+  UOP_FLAG_NextPGSearch               = 0x00000080,
+  UOP_FLAG_ForwardScan                = 0x00000100,
   UOP_FLAG_BackwardScan               = 0x00000200,
   UOP_FLAG_TitleMenuCall              = 0x00000400,
   UOP_FLAG_RootMenuCall               = 0x00000800,
@@ -100,7 +100,7 @@
   UOP_FLAG_SubPicStreamChange         = 0x00200000,
   UOP_FLAG_AngleChange                = 0x00400000,
   UOP_FLAG_KaraokeAudioPresModeChange = 0x00800000,
-  UOP_FLAG_VideoPresModeChange        = 0x01000000 
+  UOP_FLAG_VideoPresModeChange        = 0x01000000
 } DVDUOP_t;
 
 /* Parental Level */
@@ -127,7 +127,7 @@
 typedef enum {
   DVDFalse = 0,
   DVDTrue = 1
-} DVDBool_t; 
+} DVDBool_t;
 typedef DVDRegister_t DVDGPRMArray_t[16];
 typedef DVDRegister_t DVDSPRMArray_t[24];
 
@@ -148,10 +148,10 @@
 } DVDTimecode_t;
 
 /* Subpicture stream number (0-31,62,63) */
-typedef int DVDSubpictureStream_t;  
+typedef int DVDSubpictureStream_t;
 
 /* Audio stream number (0-7, 15(none)) */
-typedef int DVDAudioStream_t;  
+typedef int DVDAudioStream_t;
 
 /* The audio application mode */
 typedef enum {
@@ -196,7 +196,7 @@
   DVD_SUBPICTURE_LANG_EXT_NormalDirectorsComments  = 13,
   DVD_SUBPICTURE_LANG_EXT_BigDirectorsComments  = 14,
   DVD_SUBPICTURE_LANG_EXT_ChildrensDirectorsComments  = 15,
-} DVDSubpictureLangExt_t;  
+} DVDSubpictureLangExt_t;
 
 /* Karaoke Downmix mode */
 typedef enum {
@@ -222,7 +222,7 @@
   DVD_DISPLAY_MODE_ContentDefault = 0,
   DVD_DISPLAY_MODE_16x9 = 1,
   DVD_DISPLAY_MODE_4x3PanScan = 2,
-  DVD_DISPLAY_MODE_4x3Letterboxed = 3  
+  DVD_DISPLAY_MODE_4x3Letterboxed = 3
 } DVDDisplayMode_t;
 
 /* Audio attributes */
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvd_udf.c xine-lib-1.2/src/input/libdvdnav/dvd_udf.c
--- xine-lib-1.2.11/src/input/libdvdnav/dvd_udf.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvd_udf.c	2022-01-15 22:03:19.581547158 +0100
@@ -10,24 +10,24 @@
  * Copyright (C) 1999 Christian Wolff for convergence integrated media
  * GmbH The author can be reached at scarabaeus@convergence.de, the
  * project's page is at http://linuxtv.org/dvd/
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or (at
  * your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.  Or, point your browser to
  * http://www.gnu.org/copyleft/gpl.html
  */
- 
+
 #include "config.h"
 
 #include <stdio.h>
@@ -44,27 +44,27 @@
 
 /* Private but located in/shared with dvd_reader.c */
 extern int UDFReadBlocksRaw( dvd_reader_t *device, uint32_t lb_number,
-				size_t block_count, unsigned char *data, 
-				int encrypted );
+                                size_t block_count, unsigned char *data,
+                                int encrypted );
 
 /* It's required to either fail or deliver all the blocks asked for. */
 static int DVDReadLBUDF( dvd_reader_t *device, uint32_t lb_number,
-			 size_t block_count, unsigned char *data, 
-			 int encrypted )
+                         size_t block_count, unsigned char *data,
+                         int encrypted )
 {
   int ret;
   size_t count = block_count;
-  
+
   while(count > 0) {
-    
+
     ret = UDFReadBlocksRaw(device, lb_number, count, data, encrypted);
-        
+
     if(ret <= 0) {
       /* One of the reads failed or nothing more to read, too bad.
        * We won't even bother returning the reads that went ok. */
       return ret;
     }
-    
+
     count -= (size_t)ret;
     lb_number += (uint32_t)ret;
   }
@@ -157,7 +157,7 @@
 
 
 static int GetUDFCache(dvd_reader_t *device, UDFCacheType type,
-		       uint32_t nr, void *data)
+                       uint32_t nr, void *data)
 {
   int n;
   struct udf_cache *c;
@@ -165,25 +165,25 @@
   if(DVDUDFCacheLevel(device, -1) <= 0) {
     return 0;
   }
-  
+
   c = (struct udf_cache *)GetUDFCacheHandle(device);
-  
+
   if(c == NULL) {
     return 0;
   }
-  
+
   switch(type) {
   case AVDPCache:
     if(c->avdp_valid) {
       *(struct avdp_t *)data = c->avdp;
       return 1;
-    }    
+    }
     break;
   case PVDCache:
     if(c->pvd_valid) {
       *(struct pvd_t *)data = c->pvd;
       return 1;
-    }    
+    }
     break;
   case PartitionCache:
     if(c->partition_valid) {
@@ -216,12 +216,12 @@
   default:
     break;
   }
-  
+
   return 0;
 }
 
 static int SetUDFCache(dvd_reader_t *device, UDFCacheType type,
-		       uint32_t nr, void *data)
+                       uint32_t nr, void *data)
 {
   int n;
   struct udf_cache *c;
@@ -231,32 +231,32 @@
   }
 
   c = (struct udf_cache *)GetUDFCacheHandle(device);
-  
+
   if(c == NULL) {
-    c = calloc(1, sizeof(struct udf_cache));    
+    c = calloc(1, sizeof(struct udf_cache));
     /* fprintf(stderr, "calloc: %d\n", sizeof(struct udf_cache)); */
     if(c == NULL) {
       return 0;
     }
     SetUDFCacheHandle(device, c);
   }
-  
-  
+
+
   switch(type) {
   case AVDPCache:
-    c->avdp = *(struct avdp_t *)data; 
+    c->avdp = *(struct avdp_t *)data;
     c->avdp_valid = 1;
     break;
   case PVDCache:
-    c->pvd = *(struct pvd_t *)data; 
+    c->pvd = *(struct pvd_t *)data;
     c->pvd_valid = 1;
     break;
   case PartitionCache:
-    c->partition = *(struct Partition *)data; 
+    c->partition = *(struct Partition *)data;
     c->partition_valid = 1;
     break;
   case RootICBCache:
-    c->rooticb = *(struct AD *)data; 
+    c->rooticb = *(struct AD *)data;
     c->rooticb_valid = 1;
     break;
   case LBUDFCache:
@@ -272,8 +272,8 @@
     c->lbs = realloc(c->lbs, c->lb_num * sizeof(struct lbudf));
     /*
     fprintf(stderr, "realloc lb: %d * %d = %d\n",
-	    c->lb_num, sizeof(struct lbudf),
-	    c->lb_num * sizeof(struct lbudf));
+            c->lb_num, sizeof(struct lbudf),
+            c->lb_num * sizeof(struct lbudf));
     */
     if(c->lbs == NULL) {
       c->lb_num = 0;
@@ -295,8 +295,8 @@
     c->maps = realloc(c->maps, c->map_num * sizeof(struct icbmap));
     /*
     fprintf(stderr, "realloc maps: %d * %d = %d\n",
-	    c->map_num, sizeof(struct icbmap),
-	    c->map_num * sizeof(struct icbmap));
+            c->map_num, sizeof(struct icbmap),
+            c->map_num * sizeof(struct icbmap));
     */
     if(c->maps == NULL) {
       c->map_num = 0;
@@ -308,7 +308,7 @@
   default:
     return 0;
   }
-    
+
   return 1;
 }
 
@@ -317,15 +317,15 @@
 #define GETN1(p) ((uint8_t)data[p])
 #define GETN2(p) ((uint16_t)data[p] | ((uint16_t)data[(p) + 1] << 8))
 #define GETN3(p) ((uint32_t)data[p] | ((uint32_t)data[(p) + 1] << 8) \
-		  | ((uint32_t)data[(p) + 2] << 16))
+                  | ((uint32_t)data[(p) + 2] << 16))
 #define GETN4(p) ((uint32_t)data[p] \
-		  | ((uint32_t)data[(p) + 1] << 8) \
-		  | ((uint32_t)data[(p) + 2] << 16) \
-		  | ((uint32_t)data[(p) + 3] << 24))
+                  | ((uint32_t)data[(p) + 1] << 8) \
+                  | ((uint32_t)data[(p) + 2] << 16) \
+                  | ((uint32_t)data[(p) + 3] << 24))
 /* This is wrong with regard to endianess */
 #define GETN(p, n, target) memcpy(target, &data[p], n)
 
-static int Unicodedecode( uint8_t *data, int len, char *target ) 
+static int Unicodedecode( uint8_t *data, int len, char *target )
 {
     int p = 1, i = 0;
 
@@ -340,22 +340,22 @@
     return 0;
 }
 
-static int UDFDescriptor( uint8_t *data, uint16_t *TagID ) 
+static int UDFDescriptor( uint8_t *data, uint16_t *TagID )
 {
     *TagID = GETN2(0);
     /* TODO: check CRC 'n stuff */
     return 0;
 }
 
-static int UDFExtentAD( uint8_t *data, uint32_t *Length, uint32_t *Location ) 
+static int UDFExtentAD( uint8_t *data, uint32_t *Length, uint32_t *Location )
 {
     *Length   = GETN4(0);
     *Location = GETN4(4);
     return 0;
 }
 
-static int UDFShortAD( uint8_t *data, struct AD *ad, 
-		       struct Partition *partition ) 
+static int UDFShortAD( uint8_t *data, struct AD *ad,
+                       struct Partition *partition )
 {
     ad->Length = GETN4(0);
     ad->Flags = ad->Length >> 30;
@@ -396,7 +396,7 @@
 
 
 static int UDFPartition( uint8_t *data, uint16_t *Flags, uint16_t *Number,
-			 char *Contents, uint32_t *Start, uint32_t *Length )
+                         char *Contents, uint32_t *Start, uint32_t *Length )
 {
     *Flags = GETN2(20);
     *Number = GETN2(22);
@@ -426,15 +426,15 @@
     return 0;
 }
 
-static int UDFFileEntry( uint8_t *data, uint8_t *FileType, 
-			 struct Partition *partition, struct AD *ad )
+static int UDFFileEntry( uint8_t *data, uint8_t *FileType,
+                         struct Partition *partition, struct AD *ad )
 {
     uint16_t flags;
     uint32_t L_EA, L_AD;
     unsigned int p;
 
     UDFICB( &data[ 16 ], FileType, &flags );
-   
+
     /* Init ad for an empty file (i.e. there isn't a AD, L_AD == 0 ) */
     ad->Length = GETN4( 60 ); /* Really 8 bytes a 56 */
     ad->Flags = 0;
@@ -465,7 +465,7 @@
 }
 
 static int UDFFileIdentifier( uint8_t *data, uint8_t *FileCharacteristics,
-			      char *FileName, struct AD *FileICB )
+                              char *FileName, struct AD *FileICB )
 {
     uint8_t L_FI;
     uint16_t L_IU;
@@ -487,7 +487,7 @@
  * return 1 on success, 0 on error;
  */
 static int UDFMapICB( dvd_reader_t *device, struct AD ICB, uint8_t *FileType,
-		      struct Partition *partition, struct AD *File ) 
+                      struct Partition *partition, struct AD *File )
 {
     uint8_t LogBlock_base[DVD_VIDEO_LB_LEN + 2048];
     uint8_t *LogBlock = (uint8_t *)(((uintptr_t)LogBlock_base & ~((uintptr_t)2047)) + 2048);
@@ -531,7 +531,7 @@
  */
 static int UDFScanDir( dvd_reader_t *device, struct AD Dir, char *FileName,
                        struct Partition *partition, struct AD *FileICB,
-		       int cache_file_info) 
+                       int cache_file_info)
 {
     char filename[ MAX_UDF_FILE_NAME_LEN ];
     uint8_t directory_base[ 2 * DVD_VIDEO_LB_LEN + 2048];
@@ -548,68 +548,68 @@
 
     /* Scan dir for ICB of file */
     lbnum = partition->Start + Dir.Location;
-    
+
     if(DVDUDFCacheLevel(device, -1) > 0) {
       /* caching */
-      
+
       if(!GetUDFCache(device, LBUDFCache, lbnum, &cached_dir)) {
-	dir_lba = (Dir.Length + DVD_VIDEO_LB_LEN) / DVD_VIDEO_LB_LEN;
-	if((cached_dir_base = malloc(dir_lba * DVD_VIDEO_LB_LEN + 2048)) == NULL) {
-	  return 0;
-	}
-	cached_dir = (uint8_t *)(((uintptr_t)cached_dir_base & ~((uintptr_t)2047)) + 2048);
-	if( DVDReadLBUDF( device, lbnum, dir_lba, cached_dir, 0) <= 0 ) {
-	  free(cached_dir_base);
-	  cached_dir = NULL;
-	}
-	/*
-	if(cached_dir) {
-	  fprintf(stderr, "malloc dir: %d\n",
-		  dir_lba * DVD_VIDEO_LB_LEN);
-	}
-	*/
-	SetUDFCache(device, LBUDFCache, lbnum, &cached_dir);
+        dir_lba = (Dir.Length + DVD_VIDEO_LB_LEN) / DVD_VIDEO_LB_LEN;
+        if((cached_dir_base = malloc(dir_lba * DVD_VIDEO_LB_LEN + 2048)) == NULL) {
+          return 0;
+        }
+        cached_dir = (uint8_t *)(((uintptr_t)cached_dir_base & ~((uintptr_t)2047)) + 2048);
+        if( DVDReadLBUDF( device, lbnum, dir_lba, cached_dir, 0) <= 0 ) {
+          free(cached_dir_base);
+          cached_dir = NULL;
+        }
+        /*
+        if(cached_dir) {
+          fprintf(stderr, "malloc dir: %d\n",
+                  dir_lba * DVD_VIDEO_LB_LEN);
+        }
+        */
+        SetUDFCache(device, LBUDFCache, lbnum, &cached_dir);
       } else {
-	in_cache = 1;
+        in_cache = 1;
       }
-      
+
       if(cached_dir == NULL) {
-	return 0;
+        return 0;
       }
-      
+
       p = 0;
-      
+
       while( p < Dir.Length ) {
         UDFDescriptor( &cached_dir[ p ], &TagID );
         if( TagID == 257 ) {
-	  p += UDFFileIdentifier( &cached_dir[ p ], &filechar,
-				  filename, &tmpICB );
-	  if(cache_file_info && !in_cache) {
-	    uint8_t tmpFiletype;
-	    struct AD tmpFile;
-	    
-	    if( !strcasecmp( FileName, filename ) ) {
-	      *FileICB = tmpICB;
-	      found = 1;
-	      
-	    }
-	    UDFMapICB(device, tmpICB, &tmpFiletype,
-		      partition, &tmpFile);
-	  } else {
-	    if( !strcasecmp( FileName, filename ) ) {
-	      *FileICB = tmpICB;
-	      return 1;
-	    }
-	  }
+          p += UDFFileIdentifier( &cached_dir[ p ], &filechar,
+                                  filename, &tmpICB );
+          if(cache_file_info && !in_cache) {
+            uint8_t tmpFiletype;
+            struct AD tmpFile;
+
+            if( !strcasecmp( FileName, filename ) ) {
+              *FileICB = tmpICB;
+              found = 1;
+
+            }
+            UDFMapICB(device, tmpICB, &tmpFiletype,
+                      partition, &tmpFile);
+          } else {
+            if( !strcasecmp( FileName, filename ) ) {
+              *FileICB = tmpICB;
+              return 1;
+            }
+          }
         } else {
-	  if(cache_file_info && (!in_cache) && found) {
-	    return 1;
-	  }
-	  return 0;
+          if(cache_file_info && (!in_cache) && found) {
+            return 1;
+          }
+          return 0;
         }
       }
       if(cache_file_info && (!in_cache) && found) {
-	return 1;
+        return 1;
       }
       return 0;
     }
@@ -645,7 +645,7 @@
 
 
 static int UDFGetAVDP( dvd_reader_t *device,
-		       struct avdp_t *avdp)
+                       struct avdp_t *avdp)
 {
   uint8_t Anchor_base[ DVD_VIDEO_LB_LEN + 2048 ];
   uint8_t *Anchor = (uint8_t *)(((uintptr_t)Anchor_base & ~((uintptr_t)2047)) + 2048);
@@ -653,8 +653,8 @@
   uint16_t TagID;
   uint32_t lastsector;
   int terminate;
-  struct avdp_t; 
-  
+  struct avdp_t;
+
   if(GetUDFCache(device, AVDPCache, 0, avdp)) {
     return 1;
   }
@@ -663,7 +663,7 @@
   lastsector = 0;
   lbnum = 256;   /* Try #1, prime anchor */
   terminate = 0;
-  
+
   for(;;) {
     if( DVDReadLBUDF( device, lbnum, 1, Anchor, 0 ) > 0 ) {
       UDFDescriptor( Anchor, &TagID );
@@ -673,23 +673,23 @@
     if (TagID != 2) {
       /* Not an anchor */
       if( terminate ) return 0; /* Final try failed */
-      
+
       if( lastsector ) {
-	
-	/* We already found the last sector.  Try #3, alternative
-	 * backup anchor.  If that fails, don't try again.
-	 */
-	lbnum = lastsector;
-	terminate = 1;
+
+        /* We already found the last sector.  Try #3, alternative
+         * backup anchor.  If that fails, don't try again.
+         */
+        lbnum = lastsector;
+        terminate = 1;
       } else {
-	/* TODO: Find last sector of the disc (this is optional). */
-	if( lastsector ) {
-	  /* Try #2, backup anchor */
-	  lbnum = lastsector - 256;
-	} else {
-	  /* Unable to find last sector */
-	  return 0;
-	}
+        /* TODO: Find last sector of the disc (this is optional). */
+        if( lastsector ) {
+          /* Try #2, backup anchor */
+          lbnum = lastsector - 256;
+        } else {
+          /* Unable to find last sector */
+          return 0;
+        }
       }
     } else {
       /* It's an anchor! We can leave */
@@ -700,14 +700,14 @@
   UDFExtentAD( &Anchor[ 16 ], &MVDS_length, &MVDS_location );
   avdp->mvds.location = MVDS_location;
   avdp->mvds.length = MVDS_length;
-  
+
   /* Backup volume descriptor */
   UDFExtentAD( &Anchor[ 24 ], &MVDS_length, &MVDS_location );
   avdp->rvds.location = MVDS_location;
   avdp->rvds.length = MVDS_length;
-  
+
   SetUDFCache(device, AVDPCache, 0, avdp);
-  
+
   return 1;
 }
 
@@ -717,7 +717,7 @@
  *   part: structure to fill with the partition information
  */
 static int UDFFindPartition( dvd_reader_t *device, int partnum,
-			     struct Partition *part ) 
+                             struct Partition *part )
 {
     uint8_t LogBlock_base[ DVD_VIDEO_LB_LEN + 2048 ];
     uint8_t *LogBlock = (uint8_t *)(((uintptr_t)LogBlock_base & ~((uintptr_t)2047)) + 2048);
@@ -726,7 +726,7 @@
     int i, volvalid;
     struct avdp_t avdp;
 
-    
+
     if(!UDFGetAVDP(device, &avdp)) {
       return 0;
     }
@@ -757,7 +757,7 @@
                 part->valid = ( partnum == part->Number );
             } else if( ( TagID == 6 ) && ( !volvalid ) ) {
                 /* Logical Volume Descriptor */
-                if( UDFLogVolume( LogBlock, part->VolumeDesc ) ) {  
+                if( UDFLogVolume( LogBlock, part->VolumeDesc ) ) {
                     /* TODO: sector size wrong! */
                 } else {
                     volvalid = 1;
@@ -769,9 +769,9 @@
                  && ( ( !part->valid ) || ( !volvalid ) ) );
 
         if( ( !part->valid) || ( !volvalid ) ) {
-	  /* Backup volume descriptor */
-	  MVDS_location = avdp.mvds.location;
-	  MVDS_length = avdp.mvds.length;
+          /* Backup volume descriptor */
+          MVDS_location = avdp.mvds.location;
+          MVDS_length = avdp.mvds.length;
         }
     } while( i-- && ( ( !part->valid ) || ( !volvalid ) ) );
 
@@ -780,7 +780,7 @@
 }
 
 uint32_t UDFFindFile( dvd_reader_t *device, char *filename,
-		      uint32_t *filesize )
+                      uint32_t *filesize )
 {
     uint8_t LogBlock_base[ DVD_VIDEO_LB_LEN + 2048 ];
     uint8_t *LogBlock = (uint8_t *)(((uintptr_t)LogBlock_base & ~((uintptr_t)2047)) + 2048);
@@ -796,13 +796,13 @@
     tokenline[0] = '\0';
     strcat( tokenline, filename );
 
-    
+
     if(!(GetUDFCache(device, PartitionCache, 0, &partition) &&
         GetUDFCache(device, RootICBCache, 0, &RootICB))) {
       /* Find partition, 0 is the standard location for DVD Video.*/
       if( !UDFFindPartition( device, 0, &partition ) ) return 0;
       SetUDFCache(device, PartitionCache, 0, &partition);
-      
+
       /* Find root dir ICB */
       lbnum = partition.Start;
       do {
@@ -833,9 +833,9 @@
       int cache_file_info = 0;
       /* Tokenize filepath */
       token = strtok(tokenline, "/");
-      
+
       while( token != NULL ) {
-       
+
         if( !UDFScanDir( device, File, token, &partition, &ICB,
                         cache_file_info)) {
          return 0;
@@ -848,11 +848,11 @@
        }
         token = strtok( NULL, "/" );
       }
-    } 
+    }
 
     /* Sanity check. */
     if( File.Partition != 0 ) return 0;
-   
+
     *filesize = File.Length;
     /* Hack to not return partition.Start for empty files. */
     if( !File.Location )
@@ -870,7 +870,7 @@
  * bufsize, size of BlockBuf (must be >= DVD_VIDEO_LB_LEN).
  */
 static int UDFGetDescriptor( dvd_reader_t *device, int id,
-			     uint8_t *descriptor, int bufsize) 
+                             uint8_t *descriptor, int bufsize)
 {
   uint32_t lbnum, MVDS_location, MVDS_length;
   struct avdp_t avdp;
@@ -886,7 +886,7 @@
   if(bufsize < DVD_VIDEO_LB_LEN) {
     return 0;
   }
-  
+
   if(!UDFGetAVDP(device, &avdp)) {
     return 0;
   }
@@ -894,34 +894,34 @@
   /* Main volume descriptor */
   MVDS_location = avdp.mvds.location;
   MVDS_length = avdp.mvds.length;
-  
+
   i = 1;
   do {
     /* Find  Descriptor */
     lbnum = MVDS_location;
     do {
-      
+
       if( DVDReadLBUDF( device, lbnum++, 1, descriptor, 0 ) <= 0 ) {
-	TagID = 0;
+        TagID = 0;
       } else {
-	UDFDescriptor( descriptor, &TagID );
+        UDFDescriptor( descriptor, &TagID );
       }
-      
+
       if( (TagID == id) && ( !desc_found ) ) {
-	/* Descriptor */
-	desc_found = 1;
+        /* Descriptor */
+        desc_found = 1;
       }
     } while( ( lbnum <= MVDS_location + ( MVDS_length - 1 )
-	       / DVD_VIDEO_LB_LEN ) && ( TagID != 8 )
-	     && ( !desc_found) );
-    
+               / DVD_VIDEO_LB_LEN ) && ( TagID != 8 )
+             && ( !desc_found) );
+
     if( !desc_found ) {
       /* Backup volume descriptor */
       MVDS_location = avdp.rvds.location;
       MVDS_length = avdp.rvds.length;
     }
   } while( i-- && ( !desc_found )  );
-  
+
   return desc_found;
 }
 
@@ -930,7 +930,7 @@
 {
   uint8_t pvd_buf_base[DVD_VIDEO_LB_LEN + 2048];
   uint8_t *pvd_buf = (uint8_t *)(((uintptr_t)pvd_buf_base & ~((uintptr_t)2047)) + 2048);
-  
+
   if(GetUDFCache(device, PVDCache, 0, pvd)) {
     return 1;
   }
@@ -938,11 +938,11 @@
   if(!UDFGetDescriptor( device, 1, pvd_buf, sizeof(pvd_buf))) {
     return 0;
   }
-  
+
   memcpy(pvd->VolumeIdentifier, &pvd_buf[24], 32);
   memcpy(pvd->VolumeSetIdentifier, &pvd_buf[72], 128);
   SetUDFCache(device, PVDCache, 0, pvd);
-  
+
   return 1;
 }
 
@@ -953,7 +953,7 @@
  * returns the size of buffer needed for all data
  */
 int UDFGetVolumeIdentifier(dvd_reader_t *device, char *volid,
-			   unsigned int volid_size)
+                           unsigned int volid_size)
 {
   struct pvd_t pvd;
   unsigned int volid_len;
@@ -972,7 +972,7 @@
     volid_size = volid_len;
   }
   Unicodedecode(pvd.VolumeIdentifier, volid_size, volid);
-  
+
   return volid_len;
 }
 
@@ -980,13 +980,13 @@
  * Gets the Volume Set Identifier, as a 128-byte dstring (not decoded)
  * WARNING This is not a null terminated string
  * volsetid, place to put the data
- * volsetid_size, size of the buffer volsetid points to 
+ * volsetid_size, size of the buffer volsetid points to
  * the buffer should be >=128 bytes to store the whole volumesetidentifier
  * returns the size of the available volsetid information (128)
  * or 0 on error
  */
 int UDFGetVolumeSetIdentifier(dvd_reader_t *device, uint8_t *volsetid,
-			      unsigned int volsetid_size)
+                              unsigned int volsetid_size)
 {
   struct pvd_t pvd;
 
@@ -999,8 +999,8 @@
   if(volsetid_size > 128) {
     volsetid_size = 128;
   }
-  
+
   memcpy(volsetid, pvd.VolumeSetIdentifier, volsetid_size);
-  
+
   return 128;
 }
diff -urN xine-lib-1.2.11/src/input/libdvdnav/dvd_udf.h xine-lib-1.2/src/input/libdvdnav/dvd_udf.h
--- xine-lib-1.2.11/src/input/libdvdnav/dvd_udf.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/dvd_udf.h	2022-01-15 22:03:19.580547154 +0100
@@ -8,22 +8,22 @@
  * Modifications by:
  *   Billy Biggs <vektor@dumbterm.net>.
  *   Björn Englund <d4bjorn@dtek.chalmers.se>.
- * 
+ *
  * dvdudf: parse and read the UDF volume information of a DVD Video
  * Copyright (C) 1999 Christian Wolff for convergence integrated media
  * GmbH The author can be reached at scarabaeus@convergence.de, the
  * project's page is at http://linuxtv.org/dvd/
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or (at
  * your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
@@ -50,9 +50,9 @@
 
 void FreeUDFCache(void *cache);
 int UDFGetVolumeIdentifier(dvd_reader_t *device,
-			   char *volid, unsigned int volid_size);
+                           char *volid, unsigned int volid_size);
 int UDFGetVolumeSetIdentifier(dvd_reader_t *device,
-			      uint8_t *volsetid, unsigned int volsetid_size);
+                              uint8_t *volsetid, unsigned int volsetid_size);
 void *GetUDFCacheHandle(dvd_reader_t *device);
 void SetUDFCacheHandle(dvd_reader_t *device, void *cache);
 
diff -urN xine-lib-1.2.11/src/input/libdvdnav/highlight.c xine-lib-1.2/src/input/libdvdnav/highlight.c
--- xine-lib-1.2.11/src/input/libdvdnav/highlight.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/highlight.c	2022-01-15 22:03:19.598547229 +0100
@@ -1,18 +1,18 @@
-/* 
+/*
  * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -203,7 +203,7 @@
 /* Highlighting API calls */
 
 dvdnav_status_t dvdnav_get_current_highlight(dvdnav_t *this, int32_t *button) {
-  
+
   if(!this || !button) {
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
@@ -212,7 +212,7 @@
   /* Simply return the appropriate value based on the SPRM */
   if(((*button) = this->position_current.button) == -1)
     (*button) = this->vm->state.HL_BTNN_REG >> 10;
-  
+
   return DVDNAV_STATUS_OK;
 }
 
@@ -236,7 +236,7 @@
 #ifdef BUTTON_TESTING
   nav_print_PCI(pci);
 #endif
-  
+
   return &(pci->hli.btnit[button-1]);
 }
 
@@ -248,7 +248,7 @@
 
 dvdnav_status_t dvdnav_upper_button_select(dvdnav_t *this, pci_t *pci) {
   btni_t *button_ptr;
-  
+
   if(!(button_ptr = get_current_button(this, pci)))
     return DVDNAV_STATUS_ERR;
 
@@ -258,7 +258,7 @@
 
 dvdnav_status_t dvdnav_lower_button_select(dvdnav_t *this, pci_t *pci) {
   btni_t *button_ptr;
-  
+
   if(!(button_ptr = get_current_button(this, pci)))
     return DVDNAV_STATUS_ERR;
 
@@ -268,7 +268,7 @@
 
 dvdnav_status_t dvdnav_right_button_select(dvdnav_t *this, pci_t *pci) {
   btni_t *button_ptr;
-  
+
   if(!(button_ptr = get_current_button(this, pci)))
     return DVDNAV_STATUS_ERR;
 
@@ -278,7 +278,7 @@
 
 dvdnav_status_t dvdnav_left_button_select(dvdnav_t *this, pci_t *pci) {
   btni_t *button_ptr;
-  
+
   if(!(button_ptr = get_current_button(this, pci)))
     return DVDNAV_STATUS_ERR;
 
@@ -286,14 +286,14 @@
   return button_auto_action(this, pci);
 }
 
-dvdnav_status_t dvdnav_get_highlight_area(pci_t *nav_pci , int32_t button, int32_t mode, 
-					  dvdnav_highlight_area_t *highlight) {
+dvdnav_status_t dvdnav_get_highlight_area(pci_t *nav_pci , int32_t button, int32_t mode,
+                                          dvdnav_highlight_area_t *highlight) {
   btni_t *button_ptr;
 
 #ifdef BUTTON_TESTING
   fprintf(MSG_OUT, "libdvdnav: Button get_highlight_area %i\n", button);
 #endif
-  
+
   if(!nav_pci->hli.hl_gi.hli_ss)
     return DVDNAV_STATUS_ERR;
   if((button <= 0) || (button > nav_pci->hli.hl_gi.btn_ns))
@@ -340,7 +340,7 @@
     printerr("This NAV has already been left.");
     return DVDNAV_STATUS_ERR;
   }
-  pthread_mutex_lock(&this->vm_lock); 
+  pthread_mutex_lock(&this->vm_lock);
 
   button = this->vm->state.HL_BTNN_REG >> 10;
 
@@ -365,10 +365,10 @@
       printerr("");
       return DVDNAV_STATUS_OK;
     }
-    pthread_mutex_unlock(&this->vm_lock); 
+    pthread_mutex_unlock(&this->vm_lock);
     return DVDNAV_STATUS_ERR;
   }
-  
+
   button_ptr = get_current_button(this, pci);
   /* Finally, make the VM execute the appropriate code and probably
    * scedule a jump */
@@ -381,8 +381,8 @@
     this->position_current.still = 0;
     this->last_cmd_nav_lbn = pci->pci_gi.nv_pck_lbn;
   }
-  
-  pthread_mutex_unlock(&this->vm_lock); 
+
+  pthread_mutex_unlock(&this->vm_lock);
   return DVDNAV_STATUS_OK;
 }
 
@@ -392,7 +392,7 @@
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
   }
-  
+
   pthread_mutex_lock(&this->vm_lock);
   /* make the VM execute the appropriate code and probably
    * schedule a jump */
@@ -411,10 +411,10 @@
   this->sync_wait = 0;
   pthread_mutex_unlock(&this->vm_lock);
   return DVDNAV_STATUS_OK;
-}  
+}
 
 dvdnav_status_t dvdnav_button_select(dvdnav_t *this, pci_t *pci, int32_t button) {
-  
+
   if(!this || !pci) {
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
@@ -427,24 +427,24 @@
     printerr("This NAV has already been left.");
     return DVDNAV_STATUS_ERR;
   }
- 
+
 #ifdef BUTTON_TESTING
-  fprintf(MSG_OUT, "libdvdnav: Button select %i\n", button); 
+  fprintf(MSG_OUT, "libdvdnav: Button select %i\n", button);
 #endif
-  
+
   if((button <= 0) || (button > pci->hli.hl_gi.btn_ns)) {
     printerr("Button does not exist.");
     return DVDNAV_STATUS_ERR;
   }
-  
+
   this->vm->state.HL_BTNN_REG = (button << 10);
   this->position_current.button = -1; /* Force Highligh change */
 
   return DVDNAV_STATUS_OK;
 }
 
-dvdnav_status_t dvdnav_button_select_and_activate(dvdnav_t *this, pci_t *pci, 
-						  int32_t button) {
+dvdnav_status_t dvdnav_button_select_and_activate(dvdnav_t *this, pci_t *pci,
+                                                  int32_t button) {
   /* A trivial function */
   if(dvdnav_button_select(this, pci, button) != DVDNAV_STATUS_ERR)
     return dvdnav_button_activate(this, pci);
@@ -473,7 +473,7 @@
 
   best = 0;
   dist = 0x08000000; /* >> than  (720*720)+(567*567); */
-  
+
   /* Loop through all buttons */
   for(button = 1; button <= pci->hli.hl_gi.btn_ns; button++) {
     btni_t *button_ptr = &(pci->hli.btnit[button-1]);
diff -urN xine-lib-1.2.11/src/input/libdvdnav/ifo_read.c xine-lib-1.2/src/input/libdvdnav/ifo_read.c
--- xine-lib-1.2.11/src/input/libdvdnav/ifo_read.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/ifo_read.c	2022-01-15 22:03:19.581547158 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2000, 2001, 2002, 2003
- *               Björn Englund <d4bjorn@dtek.chalmers.se>, 
+ *               Björn Englund <d4bjorn@dtek.chalmers.se>,
  *               Håkan Hjort <d95hjort@dtek.chalmers.se>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -61,27 +61,27 @@
 static int ifoRead_VMG(ifo_handle_t *ifofile);
 static int ifoRead_VTS(ifo_handle_t *ifofile);
 static int ifoRead_PGC(ifo_handle_t *ifofile, pgc_t *pgc, unsigned int offset);
-static int ifoRead_PGC_COMMAND_TBL(ifo_handle_t *ifofile, 
-                                   pgc_command_tbl_t *cmd_tbl, 
-				   unsigned int offset);
-static int ifoRead_PGC_PROGRAM_MAP(ifo_handle_t *ifofile, 
-                                   pgc_program_map_t *program_map, 
+static int ifoRead_PGC_COMMAND_TBL(ifo_handle_t *ifofile,
+                                   pgc_command_tbl_t *cmd_tbl,
+                                   unsigned int offset);
+static int ifoRead_PGC_PROGRAM_MAP(ifo_handle_t *ifofile,
+                                   pgc_program_map_t *program_map,
                                    unsigned int nr, unsigned int offset);
-static int ifoRead_CELL_PLAYBACK_TBL(ifo_handle_t *ifofile, 
-                                     cell_playback_t *cell_playback, 
+static int ifoRead_CELL_PLAYBACK_TBL(ifo_handle_t *ifofile,
+                                     cell_playback_t *cell_playback,
                                      unsigned int nr, unsigned int offset);
-static int ifoRead_CELL_POSITION_TBL(ifo_handle_t *ifofile, 
-                                     cell_position_t *cell_position, 
+static int ifoRead_CELL_POSITION_TBL(ifo_handle_t *ifofile,
+                                     cell_position_t *cell_position,
                                      unsigned int nr, unsigned int offset);
-static int ifoRead_VTS_ATTRIBUTES(ifo_handle_t *ifofile, 
-                                  vts_attributes_t *vts_attributes, 
+static int ifoRead_VTS_ATTRIBUTES(ifo_handle_t *ifofile,
+                                  vts_attributes_t *vts_attributes,
                                   unsigned int offset);
-static int ifoRead_C_ADT_internal(ifo_handle_t *ifofile, c_adt_t *c_adt, 
+static int ifoRead_C_ADT_internal(ifo_handle_t *ifofile, c_adt_t *c_adt,
                                   unsigned int sector);
-static int ifoRead_VOBU_ADMAP_internal(ifo_handle_t *ifofile, 
-                                       vobu_admap_t *vobu_admap, 
-				       unsigned int sector);
-static int ifoRead_PGCIT_internal(ifo_handle_t *ifofile, pgcit_t *pgcit, 
+static int ifoRead_VOBU_ADMAP_internal(ifo_handle_t *ifofile,
+                                       vobu_admap_t *vobu_admap,
+                                       unsigned int sector);
+static int ifoRead_PGCIT_internal(ifo_handle_t *ifofile, pgcit_t *pgcit,
                                   unsigned int offset);
 
 static void ifoFree_PGC(pgc_t *pgc);
@@ -174,7 +174,7 @@
 
   if(title) {
     fprintf(stderr, "libdvdread: Invalid IFO for title %d (VTS_%02d_0.IFO).\n",
-	    title, title);
+            title, title);
   } else {
     fprintf(stderr, "libdvdread: Invalid IFO for VMGM (VIDEO_TS.IFO).\n");
   }
@@ -212,19 +212,19 @@
 
 ifo_handle_t *ifoOpenVTSI(dvd_reader_t *dvd, int title) {
   ifo_handle_t *ifofile;
-  
+
   ifofile = (ifo_handle_t *)malloc(sizeof(ifo_handle_t));
   if(!ifofile)
     return 0;
 
   memset(ifofile, 0, sizeof(ifo_handle_t));
-  
+
   if(title <= 0 || title > 99) {
     fprintf(stderr, "libdvdread: ifoOpenVTSI invalid title (%d).\n", title);
     free(ifofile);
     return 0;
   }
-    
+
   ifofile->file = DVDOpenFile(dvd, title, DVD_READ_INFO_FILE);
   if(!ifofile->file) /* Should really catch any error and try to fallback */
     ifofile->file = DVDOpenFile(dvd, title, DVD_READ_INFO_BACKUP_FILE);
@@ -248,7 +248,7 @@
 void ifoClose(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   ifoFree_VOBU_ADMAP(ifofile);
   ifoFree_TITLE_VOBU_ADMAP(ifofile);
   ifoFree_C_ADT(ifofile);
@@ -301,7 +301,7 @@
     ifofile->vmgi_mat = 0;
     return 0;
   }
-  
+
   B2N_32(vmgi_mat->vmg_last_sector);
   B2N_32(vmgi_mat->vmgi_last_sector);
   B2N_32(vmgi_mat->vmg_category);
@@ -332,7 +332,7 @@
   CHECK_ZERO(vmgi_mat->zero_7);
   CHECK_ZERO(vmgi_mat->zero_8);
   CHECK_ZERO(vmgi_mat->zero_9);
-  CHECK_ZERO(vmgi_mat->zero_10);  
+  CHECK_ZERO(vmgi_mat->zero_10);
   CHECK_VALUE(vmgi_mat->vmg_last_sector != 0);
   CHECK_VALUE(vmgi_mat->vmgi_last_sector != 0);
   CHECK_VALUE(vmgi_mat->vmgi_last_sector * 2 <= vmgi_mat->vmg_last_sector);
@@ -343,11 +343,11 @@
   CHECK_VALUE(vmgi_mat->disc_side == 1 || vmgi_mat->disc_side == 2);
   CHECK_VALUE(vmgi_mat->vmg_nr_of_title_sets != 0);
   CHECK_VALUE(vmgi_mat->vmgi_last_byte >= 341);
-  CHECK_VALUE(vmgi_mat->vmgi_last_byte / DVD_BLOCK_LEN <= 
+  CHECK_VALUE(vmgi_mat->vmgi_last_byte / DVD_BLOCK_LEN <=
          vmgi_mat->vmgi_last_sector);
   /* It seems that first_play_pgc is optional. */
   CHECK_VALUE(vmgi_mat->first_play_pgc < vmgi_mat->vmgi_last_byte);
-  CHECK_VALUE(vmgi_mat->vmgm_vobs == 0 || 
+  CHECK_VALUE(vmgi_mat->vmgm_vobs == 0 ||
         (vmgi_mat->vmgm_vobs > vmgi_mat->vmgi_last_sector &&
          vmgi_mat->vmgm_vobs < vmgi_mat->vmg_last_sector));
   CHECK_VALUE(vmgi_mat->tt_srpt <= vmgi_mat->vmgi_last_sector);
@@ -372,7 +372,7 @@
   vtsi_mat = (vtsi_mat_t *)malloc(sizeof(vtsi_mat_t));
   if(!vtsi_mat)
     return 0;
-  
+
   ifofile->vtsi_mat = vtsi_mat;
 
   if(!DVDFileSeek_(ifofile->file, 0)) {
@@ -438,10 +438,10 @@
   CHECK_ZERO(vtsi_mat->zero_21);
   CHECK_VALUE(vtsi_mat->vtsi_last_sector*2 <= vtsi_mat->vts_last_sector);
   CHECK_VALUE(vtsi_mat->vtsi_last_byte/DVD_BLOCK_LEN <= vtsi_mat->vtsi_last_sector);
-  CHECK_VALUE(vtsi_mat->vtsm_vobs == 0 || 
+  CHECK_VALUE(vtsi_mat->vtsm_vobs == 0 ||
        (vtsi_mat->vtsm_vobs > vtsi_mat->vtsi_last_sector &&
          vtsi_mat->vtsm_vobs < vtsi_mat->vts_last_sector));
-  CHECK_VALUE(vtsi_mat->vtstt_vobs == 0 || 
+  CHECK_VALUE(vtsi_mat->vtstt_vobs == 0 ||
         (vtsi_mat->vtstt_vobs > vtsi_mat->vtsi_last_sector &&
          vtsi_mat->vtstt_vobs < vtsi_mat->vts_last_sector));
   CHECK_VALUE(vtsi_mat->vts_ptt_srpt <= vtsi_mat->vtsi_last_sector);
@@ -452,7 +452,7 @@
   CHECK_VALUE(vtsi_mat->vtsm_vobu_admap <= vtsi_mat->vtsi_last_sector);
   CHECK_VALUE(vtsi_mat->vts_c_adt <= vtsi_mat->vtsi_last_sector);
   CHECK_VALUE(vtsi_mat->vts_vobu_admap <= vtsi_mat->vtsi_last_sector);
-  
+
   CHECK_VALUE(vtsi_mat->nr_of_vtsm_audio_streams <= 1);
   CHECK_VALUE(vtsi_mat->nr_of_vtsm_subp_streams <= 1);
 
@@ -462,8 +462,8 @@
 
   CHECK_VALUE(vtsi_mat->nr_of_vts_subp_streams <= 32);
   for(i = vtsi_mat->nr_of_vts_subp_streams; i < 32; i++)
-    CHECK_ZERO(vtsi_mat->vts_subp_attr[i]);      
-  
+    CHECK_ZERO(vtsi_mat->vts_subp_attr[i]);
+
   for(i = 0; i < 8; i++) {
     CHECK_ZERO0(vtsi_mat->vts_mu_audio_attr[i].zero1);
     CHECK_ZERO0(vtsi_mat->vts_mu_audio_attr[i].zero2);
@@ -472,17 +472,17 @@
     CHECK_ZERO0(vtsi_mat->vts_mu_audio_attr[i].zero5);
     CHECK_ZERO(vtsi_mat->vts_mu_audio_attr[i].zero6);
   }
-  
+
   return 1;
 }
 
 
-static int ifoRead_PGC_COMMAND_TBL(ifo_handle_t *ifofile, 
-                                   pgc_command_tbl_t *cmd_tbl, 
-				   unsigned int offset) {
-  
+static int ifoRead_PGC_COMMAND_TBL(ifo_handle_t *ifofile,
+                                   pgc_command_tbl_t *cmd_tbl,
+                                   unsigned int offset) {
+
   memset(cmd_tbl, 0, sizeof(pgc_command_tbl_t));
-  
+
   if(!DVDFileSeek_(ifofile->file, offset))
     return 0;
 
@@ -494,7 +494,7 @@
   B2N_16(cmd_tbl->nr_of_cell);
 
   CHECK_VALUE(cmd_tbl->nr_of_pre + cmd_tbl->nr_of_post + cmd_tbl->nr_of_cell<= 255);
-     
+
   if(cmd_tbl->nr_of_pre != 0) {
     unsigned int pre_cmds_size  = cmd_tbl->nr_of_pre * COMMAND_DATA_SIZE;
     cmd_tbl->pre_cmds = (vm_cmd_t *)malloc(pre_cmds_size);
@@ -506,18 +506,18 @@
       return 0;
     }
   }
-  
+
   if(cmd_tbl->nr_of_post != 0) {
     unsigned int post_cmds_size = cmd_tbl->nr_of_post * COMMAND_DATA_SIZE;
     cmd_tbl->post_cmds = (vm_cmd_t *)malloc(post_cmds_size);
     if(!cmd_tbl->post_cmds) {
-      if(cmd_tbl->pre_cmds) 
-	free(cmd_tbl->pre_cmds);
+      if(cmd_tbl->pre_cmds)
+        free(cmd_tbl->pre_cmds);
       return 0;
     }
     if(!(DVDReadBytes(ifofile->file, cmd_tbl->post_cmds, post_cmds_size))) {
-      if(cmd_tbl->pre_cmds) 
-	free(cmd_tbl->pre_cmds);
+      if(cmd_tbl->pre_cmds)
+        free(cmd_tbl->pre_cmds);
       free(cmd_tbl->post_cmds);
       return 0;
     }
@@ -528,22 +528,22 @@
     cmd_tbl->cell_cmds = (vm_cmd_t *)malloc(cell_cmds_size);
     if(!cmd_tbl->cell_cmds) {
       if(cmd_tbl->pre_cmds)
-	free(cmd_tbl->pre_cmds);
+        free(cmd_tbl->pre_cmds);
       if(cmd_tbl->post_cmds)
-	free(cmd_tbl->post_cmds);
+        free(cmd_tbl->post_cmds);
       return 0;
     }
     if(!(DVDReadBytes(ifofile->file, cmd_tbl->cell_cmds, cell_cmds_size))) {
-      if(cmd_tbl->pre_cmds) 
-	free(cmd_tbl->pre_cmds);
-      if(cmd_tbl->post_cmds) 
-	free(cmd_tbl->post_cmds);
+      if(cmd_tbl->pre_cmds)
+        free(cmd_tbl->pre_cmds);
+      if(cmd_tbl->post_cmds)
+        free(cmd_tbl->post_cmds);
       free(cmd_tbl->cell_cmds);
       return 0;
     }
   }
-  
-  /* 
+
+  /*
    * Make a run over all the commands and see that we can interpret them all?
    */
   return 1;
@@ -562,21 +562,21 @@
   }
 }
 
-static int ifoRead_PGC_PROGRAM_MAP(ifo_handle_t *ifofile, 
-                                   pgc_program_map_t *program_map, 
-				   unsigned int nr, unsigned int offset) {
+static int ifoRead_PGC_PROGRAM_MAP(ifo_handle_t *ifofile,
+                                   pgc_program_map_t *program_map,
+                                   unsigned int nr, unsigned int offset) {
   unsigned int size = nr * sizeof(pgc_program_map_t);
 
   if(!DVDFileSeek_(ifofile->file, offset))
     return 0;
- 
+
   if(!(DVDReadBytes(ifofile->file, program_map, size)))
     return 0;
 
   return 1;
 }
 
-static int ifoRead_CELL_PLAYBACK_TBL(ifo_handle_t *ifofile, 
+static int ifoRead_CELL_PLAYBACK_TBL(ifo_handle_t *ifofile,
                                      cell_playback_t *cell_playback,
                                      unsigned int nr, unsigned int offset) {
   unsigned int i;
@@ -593,11 +593,11 @@
     B2N_32(cell_playback[i].first_ilvu_end_sector);
     B2N_32(cell_playback[i].last_vobu_start_sector);
     B2N_32(cell_playback[i].last_sector);
-    
+
     /* Changed < to <= because this was false in the movie 'Pi'. */
-    CHECK_VALUE(cell_playback[i].last_vobu_start_sector <= 
+    CHECK_VALUE(cell_playback[i].last_vobu_start_sector <=
            cell_playback[i].last_sector);
-    CHECK_VALUE(cell_playback[i].first_sector <= 
+    CHECK_VALUE(cell_playback[i].first_sector <=
            cell_playback[i].last_vobu_start_sector);
   }
 
@@ -605,8 +605,8 @@
 }
 
 
-static int ifoRead_CELL_POSITION_TBL(ifo_handle_t *ifofile, 
-                                     cell_position_t *cell_position, 
+static int ifoRead_CELL_POSITION_TBL(ifo_handle_t *ifofile,
+                                     cell_position_t *cell_position,
                                      unsigned int nr, unsigned int offset) {
   unsigned int i;
   unsigned int size = nr * sizeof(cell_position_t);
@@ -630,7 +630,7 @@
 
   if(!DVDFileSeek_(ifofile->file, offset))
     return 0;
- 
+
   if(!(DVDReadBytes(ifofile->file, pgc, PGC_SIZE)))
     return 0;
 
@@ -648,7 +648,7 @@
     B2N_32(pgc->subp_control[i]);
   for(i = 0; i < 16; i++)
     B2N_32(pgc->palette[i]);
-  
+
   CHECK_ZERO(pgc->zero_1);
   CHECK_VALUE(pgc->nr_of_programs <= pgc->nr_of_cells);
 
@@ -659,7 +659,7 @@
   for(i = 0; i < 32; i++)
     if(!(pgc->subp_control[i] & 0x80000000)) /* The 'is present' bit */
       CHECK_ZERO(pgc->subp_control[i]);
-  
+
   /* Check that time is 0:0:0:0 also if nr_of_programs == 0 */
   if(pgc->nr_of_programs == 0) {
     CHECK_ZERO(pgc->still_time);
@@ -672,13 +672,13 @@
     CHECK_VALUE(pgc->cell_playback_offset != 0);
     CHECK_VALUE(pgc->cell_position_offset != 0);
   }
-  
+
   if(pgc->command_tbl_offset != 0) {
     pgc->command_tbl = malloc(sizeof(pgc_command_tbl_t));
     if(!pgc->command_tbl)
       return 0;
 
-    if(!ifoRead_PGC_COMMAND_TBL(ifofile, pgc->command_tbl, 
+    if(!ifoRead_PGC_COMMAND_TBL(ifofile, pgc->command_tbl,
                                 offset + pgc->command_tbl_offset)) {
       free(pgc->command_tbl);
       return 0;
@@ -686,7 +686,7 @@
   } else {
     pgc->command_tbl = NULL;
   }
-  
+
   if(pgc->program_map_offset != 0 && pgc->nr_of_programs>0) {
     pgc->program_map = malloc(pgc->nr_of_programs * sizeof(pgc_program_map_t));
     if(!pgc->program_map) {
@@ -702,36 +702,36 @@
   } else {
     pgc->program_map = NULL;
   }
-  
+
   if(pgc->cell_playback_offset != 0 && pgc->nr_of_cells>0) {
     pgc->cell_playback = malloc(pgc->nr_of_cells * sizeof(cell_playback_t));
     if(!pgc->cell_playback) {
       ifoFree_PGC_COMMAND_TBL(pgc->command_tbl);
       if(pgc->program_map)
-	free(pgc->program_map);
+        free(pgc->program_map);
       return 0;
     }
-    if(!ifoRead_CELL_PLAYBACK_TBL(ifofile, pgc->cell_playback, 
-				  pgc->nr_of_cells,
+    if(!ifoRead_CELL_PLAYBACK_TBL(ifofile, pgc->cell_playback,
+                                  pgc->nr_of_cells,
                                   offset + pgc->cell_playback_offset)) {
       ifoFree_PGC_COMMAND_TBL(pgc->command_tbl);
       if(pgc->program_map)
-	free(pgc->program_map);
+        free(pgc->program_map);
       free(pgc->cell_playback);
       return 0;
     }
   } else {
     pgc->cell_playback = NULL;
   }
-  
+
   if(pgc->cell_position_offset != 0 && pgc->nr_of_cells>0) {
     pgc->cell_position = malloc(pgc->nr_of_cells * sizeof(cell_position_t));
     if(!pgc->cell_position) {
       ifoFree_PGC(pgc);
       return 0;
     }
-    if(!ifoRead_CELL_POSITION_TBL(ifofile, pgc->cell_position, 
-				  pgc->nr_of_cells,
+    if(!ifoRead_CELL_POSITION_TBL(ifofile, pgc->cell_position,
+                                  pgc->nr_of_cells,
                                   offset + pgc->cell_position_offset)) {
       ifoFree_PGC(pgc);
       return 0;
@@ -750,17 +750,17 @@
 
   if(!ifofile->vmgi_mat)
     return 0;
-  
+
   /* It seems that first_play_pgc is optional after all. */
   ifofile->first_play_pgc = 0;
   if(ifofile->vmgi_mat->first_play_pgc == 0)
     return 1;
-  
+
   ifofile->first_play_pgc = (pgc_t *)malloc(sizeof(pgc_t));
   if(!ifofile->first_play_pgc)
     return 0;
-  
-  if(!ifoRead_PGC(ifofile, ifofile->first_play_pgc, 
+
+  if(!ifoRead_PGC(ifofile, ifofile->first_play_pgc,
                   ifofile->vmgi_mat->first_play_pgc)) {
     free(ifofile->first_play_pgc);
     ifofile->first_play_pgc = 0;
@@ -785,7 +785,7 @@
 void ifoFree_FP_PGC(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   if(ifofile->first_play_pgc) {
     ifoFree_PGC(ifofile->first_play_pgc);
     free(ifofile->first_play_pgc);
@@ -815,7 +815,7 @@
     return 0;
 
   ifofile->tt_srpt = tt_srpt;
-  
+
   if(!(DVDReadBytes(ifofile->file, tt_srpt, TT_SRPT_SIZE))) {
     fprintf(stderr, "libdvdread: Unable to read read TT_SRPT.\n");
     free(tt_srpt);
@@ -824,10 +824,10 @@
 
   B2N_16(tt_srpt->nr_of_srpts);
   B2N_32(tt_srpt->last_byte);
-  
+
   info_length = tt_srpt->last_byte + 1 - TT_SRPT_SIZE;
 
-  tt_srpt->title = (title_info_t *)malloc(info_length); 
+  tt_srpt->title = (title_info_t *)malloc(info_length);
   if(!tt_srpt->title) {
     free(tt_srpt);
     ifofile->tt_srpt = 0;
@@ -844,13 +844,13 @@
     B2N_16(tt_srpt->title[i].parental_id);
     B2N_32(tt_srpt->title[i].title_set_sector);
   }
-  
+
 
   CHECK_ZERO(tt_srpt->zero_1);
   CHECK_VALUE(tt_srpt->nr_of_srpts != 0);
   CHECK_VALUE(tt_srpt->nr_of_srpts < 100); /* ?? */
   CHECK_VALUE((int)tt_srpt->nr_of_srpts * (int)sizeof(title_info_t) <= info_length);
-  
+
   for(i = 0; i < tt_srpt->nr_of_srpts; i++) {
     CHECK_VALUE(tt_srpt->title[i].pb_ty.zero_1 == 0);
     CHECK_VALUE(tt_srpt->title[i].nr_of_angles != 0);
@@ -864,16 +864,16 @@
     CHECK_VALUE(tt_srpt->title[i].vts_ttn < 100); /* ?? */
     /* CHECK_VALUE(tt_srpt->title[i].title_set_sector != 0); */
   }
-  
+
   /* Make this a function */
 #if 0
-  if(memcmp((uint8_t *)tt_srpt->title + 
-            tt_srpt->nr_of_srpts * sizeof(title_info_t), 
-            my_friendly_zeros, 
+  if(memcmp((uint8_t *)tt_srpt->title +
+            tt_srpt->nr_of_srpts * sizeof(title_info_t),
+            my_friendly_zeros,
             info_length - tt_srpt->nr_of_srpts * sizeof(title_info_t))) {
     fprintf(stderr, "VMG_PTT_SRPT slack is != 0, ");
-    hexdump((uint8_t *)tt_srpt->title + 
-            tt_srpt->nr_of_srpts * sizeof(title_info_t), 
+    hexdump((uint8_t *)tt_srpt->title +
+            tt_srpt->nr_of_srpts * sizeof(title_info_t),
             info_length - tt_srpt->nr_of_srpts * sizeof(title_info_t));
   }
 #endif
@@ -885,7 +885,7 @@
 void ifoFree_TT_SRPT(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   if(ifofile->tt_srpt) {
     free(ifofile->tt_srpt->title);
     free(ifofile->tt_srpt);
@@ -901,15 +901,15 @@
 
   if(!ifofile)
     return 0;
-  
+
   if(!ifofile->vtsi_mat)
     return 0;
 
   if(ifofile->vtsi_mat->vts_ptt_srpt == 0) /* mandatory */
     return 0;
-    
+
   if(!DVDFileSeek_(ifofile->file,
-		   ifofile->vtsi_mat->vts_ptt_srpt * DVD_BLOCK_LEN))
+                   ifofile->vtsi_mat->vts_ptt_srpt * DVD_BLOCK_LEN))
     return 0;
 
   vts_ptt_srpt = (vts_ptt_srpt_t *)malloc(sizeof(vts_ptt_srpt_t));
@@ -930,10 +930,10 @@
   CHECK_ZERO(vts_ptt_srpt->zero_1);
   CHECK_VALUE(vts_ptt_srpt->nr_of_srpts != 0);
   CHECK_VALUE(vts_ptt_srpt->nr_of_srpts < 100); /* ?? */
-  
+
   info_length = vts_ptt_srpt->last_byte + 1 - VTS_PTT_SRPT_SIZE;
-  
-  data = (uint32_t *)malloc(info_length); 
+
+  data = (uint32_t *)malloc(info_length);
   if(!data) {
     free(vts_ptt_srpt);
     ifofile->vts_ptt_srpt = 0;
@@ -950,14 +950,14 @@
   for(i = 0; i < vts_ptt_srpt->nr_of_srpts; i++) {
     B2N_32(data[i]);
     /* assert(data[i] + sizeof(ptt_info_t) <= vts_ptt_srpt->last_byte + 1);
-       Magic Knight Rayearth Daybreak is mastered very strange and has 
+       Magic Knight Rayearth Daybreak is mastered very strange and has
        Titles with 0 PTTs. They all have a data[i] offsets beyond the end of
        of the vts_ptt_srpt structure. */
     CHECK_VALUE(data[i] + sizeof(ptt_info_t) <= vts_ptt_srpt->last_byte + 1 + 4);
   }
- 
+
   vts_ptt_srpt->ttu_offset = data;
-  
+
   vts_ptt_srpt->title = malloc(vts_ptt_srpt->nr_of_srpts * sizeof(ttu_t));
   if(!vts_ptt_srpt->title) {
     free(vts_ptt_srpt);
@@ -972,11 +972,11 @@
     else
       n = (vts_ptt_srpt->last_byte + 1 - data[i]);
     /* assert(n > 0 && (n % 4) == 0);
-       Magic Knight Rayearth Daybreak is mastered very strange and has 
+       Magic Knight Rayearth Daybreak is mastered very strange and has
        Titles with 0 PTTs. */
     if(n < 0) n = 0;
     CHECK_VALUE(n % 4 == 0);
-    
+
     vts_ptt_srpt->title[i].nr_of_ptts = n / 4;
     vts_ptt_srpt->title[i].ptt = malloc(n * sizeof(ptt_info_t));
     if(!vts_ptt_srpt->title[i].ptt) {
@@ -990,20 +990,20 @@
     for(j = 0; j < vts_ptt_srpt->title[i].nr_of_ptts; j++) {
       /* The assert placed here because of Magic Knight Rayearth Daybreak */
       CHECK_VALUE(data[i] + sizeof(ptt_info_t) <= vts_ptt_srpt->last_byte + 1);
-      vts_ptt_srpt->title[i].ptt[j].pgcn 
+      vts_ptt_srpt->title[i].ptt[j].pgcn
         = *(uint16_t*)(((char *)data) + data[i] + 4*j - VTS_PTT_SRPT_SIZE);
-      vts_ptt_srpt->title[i].ptt[j].pgn 
+      vts_ptt_srpt->title[i].ptt[j].pgn
         = *(uint16_t*)(((char *)data) + data[i] + 4*j + 2 - VTS_PTT_SRPT_SIZE);
     }
   }
-  
+
   for(i = 0; i < vts_ptt_srpt->nr_of_srpts; i++) {
     for(j = 0; j < vts_ptt_srpt->title[i].nr_of_ptts; j++) {
       B2N_16(vts_ptt_srpt->title[i].ptt[j].pgcn);
       B2N_16(vts_ptt_srpt->title[i].ptt[j].pgn);
     }
   }
-  
+
   for(i = 0; i < vts_ptt_srpt->nr_of_srpts; i++) {
     CHECK_VALUE(vts_ptt_srpt->title[i].nr_of_ptts < 1000); /* ?? */
     for(j = 0; j < vts_ptt_srpt->title[i].nr_of_ptts; j++) {
@@ -1021,7 +1021,7 @@
 void ifoFree_VTS_PTT_SRPT(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   if(ifofile->vts_ptt_srpt) {
     int i;
     for(i = 0; i < ifofile->vts_ptt_srpt->nr_of_srpts; i++)
@@ -1041,10 +1041,10 @@
 
   if(!ifofile)
     return 0;
-  
+
   if(!ifofile->vmgi_mat)
     return 0;
-  
+
   if(ifofile->vmgi_mat->ptl_mait == 0)
     return 1;
 
@@ -1066,14 +1066,14 @@
   B2N_16(ptl_mait->nr_of_countries);
   B2N_16(ptl_mait->nr_of_vtss);
   B2N_32(ptl_mait->last_byte);
-  
+
   CHECK_VALUE(ptl_mait->nr_of_countries != 0);
   CHECK_VALUE(ptl_mait->nr_of_countries < 100); /* ?? */
   CHECK_VALUE(ptl_mait->nr_of_vtss != 0);
   CHECK_VALUE(ptl_mait->nr_of_vtss < 100); /* ?? */
-  CHECK_VALUE(ptl_mait->nr_of_countries * PTL_MAIT_COUNTRY_SIZE 
-	      <= ptl_mait->last_byte + 1 - PTL_MAIT_SIZE);
-  
+  CHECK_VALUE(ptl_mait->nr_of_countries * PTL_MAIT_COUNTRY_SIZE
+              <= ptl_mait->last_byte + 1 - PTL_MAIT_SIZE);
+
   info_length = ptl_mait->nr_of_countries * sizeof(ptl_mait_country_t);
   ptl_mait->countries = (ptl_mait_country_t *)malloc(info_length);
   if(!ptl_mait->countries) {
@@ -1081,7 +1081,7 @@
     ifofile->ptl_mait = 0;
     return 0;
   }
-  
+
   for(i = 0; i < ptl_mait->nr_of_countries; i++) {
     if(!(DVDReadBytes(ifofile->file, &ptl_mait->countries[i], PTL_MAIT_COUNTRY_SIZE))) {
       fprintf(stderr, "libdvdread: Unable to read PTL_MAIT.\n");
@@ -1096,19 +1096,19 @@
     B2N_16(ptl_mait->countries[i].country_code);
     B2N_16(ptl_mait->countries[i].pf_ptl_mai_start_byte);
   }
-  
+
   for(i = 0; i < ptl_mait->nr_of_countries; i++) {
     CHECK_ZERO(ptl_mait->countries[i].zero_1);
-    CHECK_ZERO(ptl_mait->countries[i].zero_2);    
+    CHECK_ZERO(ptl_mait->countries[i].zero_2);
     CHECK_VALUE(ptl_mait->countries[i].pf_ptl_mai_start_byte
-		+ 8*2 * (ptl_mait->nr_of_vtss + 1) <= (int)ptl_mait->last_byte + 1);
+                + 8*2 * (ptl_mait->nr_of_vtss + 1) <= (int)ptl_mait->last_byte + 1);
   }
 
   for(i = 0; i < ptl_mait->nr_of_countries; i++) {
     uint16_t *pf_temp;
-    
-    if(!DVDFileSeek_(ifofile->file, 
-		     ifofile->vmgi_mat->ptl_mait * DVD_BLOCK_LEN
+
+    if(!DVDFileSeek_(ifofile->file,
+                     ifofile->vmgi_mat->ptl_mait * DVD_BLOCK_LEN
                      + ptl_mait->countries[i].pf_ptl_mai_start_byte)) {
       fprintf(stderr, "libdvdread: Unable to seak PTL_MAIT table.\n");
       free(ptl_mait->countries);
@@ -1129,7 +1129,7 @@
        fprintf(stderr, "libdvdread: Unable to read PTL_MAIT table.\n");
        free(pf_temp);
        for(j = 0; j < i ; j++) {
-	  free(ptl_mait->countries[j].pf_ptl_mai);
+          free(ptl_mait->countries[j].pf_ptl_mai);
        }
        free(ptl_mait->countries);
        free(ptl_mait);
@@ -1142,7 +1142,7 @@
     if(!ptl_mait->countries[i].pf_ptl_mai) {
       free(pf_temp);
       for(j = 0; j < i ; j++) {
-	free(ptl_mait->countries[j].pf_ptl_mai);
+        free(ptl_mait->countries[j].pf_ptl_mai);
       }
       free(ptl_mait->countries);
       free(ptl_mait);
@@ -1151,10 +1151,10 @@
     { /* Transpose the array so we can use C indexing. */
       int level, vts;
       for(level = 0; level < 8; level++) {
-	for(vts = 0; vts <= ptl_mait->nr_of_vtss; vts++) {
-	  ptl_mait->countries[i].pf_ptl_mai[vts][level] =
-	    pf_temp[(7-level)*(ptl_mait->nr_of_vtss+1) + vts];
-	}
+        for(vts = 0; vts <= ptl_mait->nr_of_vtss; vts++) {
+          ptl_mait->countries[i].pf_ptl_mai[vts][level] =
+            pf_temp[(7-level)*(ptl_mait->nr_of_vtss+1) + vts];
+        }
       }
       free(pf_temp);
     }
@@ -1164,10 +1164,10 @@
 
 void ifoFree_PTL_MAIT(ifo_handle_t *ifofile) {
   unsigned int i;
-  
+
   if(!ifofile)
     return;
-  
+
   if(ifofile->ptl_mait) {
     for(i = 0; i < ifofile->ptl_mait->nr_of_countries; i++) {
        free(ifofile->ptl_mait->countries[i].pf_ptl_mai);
@@ -1184,7 +1184,7 @@
   unsigned int offset;
   int info_length;
   unsigned int i, j;
-  
+
   if(!ifofile)
     return 0;
 
@@ -1196,18 +1196,18 @@
     fprintf(stderr,"Please send bug report - no VTS_TMAPT ?? \n");
     return 1;
   }
-  
+
   offset = ifofile->vtsi_mat->vts_tmapt * DVD_BLOCK_LEN;
-  
-  if(!DVDFileSeek_(ifofile->file, offset)) 
+
+  if(!DVDFileSeek_(ifofile->file, offset))
     return 0;
-  
+
   vts_tmapt = (vts_tmapt_t *)malloc(sizeof(vts_tmapt_t));
   if(!vts_tmapt)
     return 0;
-  
+
   ifofile->vts_tmapt = vts_tmapt;
-  
+
   if(!(DVDReadBytes(ifofile->file, vts_tmapt, VTS_TMAPT_SIZE))) {
     fprintf(stderr, "libdvdread: Unable to read VTS_TMAPT.\n");
     free(vts_tmapt);
@@ -1217,11 +1217,11 @@
 
   B2N_16(vts_tmapt->nr_of_tmaps);
   B2N_32(vts_tmapt->last_byte);
-  
+
   CHECK_ZERO(vts_tmapt->zero_1);
-  
+
   info_length = vts_tmapt->nr_of_tmaps * 4;
-  
+
   vts_tmap_srp = (uint32_t *)malloc(info_length);
   if(!vts_tmap_srp) {
     free(vts_tmapt);
@@ -1230,7 +1230,7 @@
   }
 
   vts_tmapt->tmap_offset = vts_tmap_srp;
-  
+
   if(!(DVDReadBytes(ifofile->file, vts_tmap_srp, info_length))) {
     fprintf(stderr, "libdvdread: Unable to read VTS_TMAPT.\n");
     free(vts_tmap_srp);
@@ -1240,12 +1240,12 @@
   }
 
   for (i = 0; i < vts_tmapt->nr_of_tmaps; i++) {
-     B2N_32(vts_tmap_srp[i]); 
+     B2N_32(vts_tmap_srp[i]);
   }
 
-  
+
   info_length = vts_tmapt->nr_of_tmaps * sizeof(vts_tmap_t);
-  
+
   vts_tmapt->tmap = (vts_tmap_t *)malloc(info_length);
   if(!vts_tmapt->tmap) {
     free(vts_tmap_srp);
@@ -1255,7 +1255,7 @@
   }
 
   memset(vts_tmapt->tmap, 0, info_length); /* So ifoFree_VTS_TMAPT works. */
-  
+
   for(i = 0; i < vts_tmapt->nr_of_tmaps; i++) {
     if(!DVDFileSeek_(ifofile->file, offset + vts_tmap_srp[i])) {
       ifoFree_VTS_TMAPT(ifofile);
@@ -1267,17 +1267,17 @@
       ifoFree_VTS_TMAPT(ifofile);
       return 0;
     }
-    
+
     B2N_16(vts_tmapt->tmap[i].nr_of_entries);
     CHECK_ZERO(vts_tmapt->tmap[i].zero_1);
-    
+
     if(vts_tmapt->tmap[i].nr_of_entries == 0) { /* Early out if zero entries */
       vts_tmapt->tmap[i].map_ent = NULL;
       continue;
     }
-    
+
     info_length = vts_tmapt->tmap[i].nr_of_entries * sizeof(map_ent_t);
-    
+
     vts_tmapt->tmap[i].map_ent = (map_ent_t *)malloc(info_length);
     if(!vts_tmapt->tmap[i].map_ent) {
       ifoFree_VTS_TMAPT(ifofile);
@@ -1289,24 +1289,24 @@
       ifoFree_VTS_TMAPT(ifofile);
       return 0;
     }
-    
+
     for(j = 0; j < vts_tmapt->tmap[i].nr_of_entries; j++)
       B2N_32(vts_tmapt->tmap[i].map_ent[j]);
-  }    
-  
+  }
+
   return 1;
 }
 
 void ifoFree_VTS_TMAPT(ifo_handle_t *ifofile) {
   unsigned int i;
-  
+
   if(!ifofile)
     return;
-  
-  if(ifofile->vts_tmapt) {  
+
+  if(ifofile->vts_tmapt) {
     for(i = 0; i < ifofile->vts_tmapt->nr_of_tmaps; i++)
       if(ifofile->vts_tmapt->tmap[i].map_ent)
-	free(ifofile->vts_tmapt->tmap[i].map_ent);
+        free(ifofile->vts_tmapt->tmap[i].map_ent);
     free(ifofile->vts_tmapt->tmap);
     free(ifofile->vts_tmapt->tmap_offset);
     free(ifofile->vts_tmapt);
@@ -1330,7 +1330,7 @@
   if(!ifofile->vts_c_adt)
     return 0;
 
-  if(!ifoRead_C_ADT_internal(ifofile, ifofile->vts_c_adt, 
+  if(!ifoRead_C_ADT_internal(ifofile, ifofile->vts_c_adt,
                              ifofile->vtsi_mat->vts_c_adt)) {
     free(ifofile->vts_c_adt);
     ifofile->vts_c_adt = 0;
@@ -1345,7 +1345,7 @@
 
   if(!ifofile)
     return 0;
-  
+
   if(ifofile->vmgi_mat) {
     if(ifofile->vmgi_mat->vmgm_c_adt == 0)
       return 1;
@@ -1357,7 +1357,7 @@
   } else {
     return 0;
   }
-  
+
   ifofile->menu_c_adt = (c_adt_t *)malloc(sizeof(c_adt_t));
   if(!ifofile->menu_c_adt)
     return 0;
@@ -1371,7 +1371,7 @@
   return 1;
 }
 
-static int ifoRead_C_ADT_internal(ifo_handle_t *ifofile, 
+static int ifoRead_C_ADT_internal(ifo_handle_t *ifofile,
                                   c_adt_t *c_adt, unsigned int sector) {
   int i, info_length;
 
@@ -1383,15 +1383,15 @@
 
   B2N_16(c_adt->nr_of_vobs);
   B2N_32(c_adt->last_byte);
-  
+
   info_length = c_adt->last_byte + 1 - C_ADT_SIZE;
-  
+
   CHECK_ZERO(c_adt->zero_1);
-  /* assert(c_adt->nr_of_vobs > 0);  
-     Magic Knight Rayearth Daybreak is mastered very strange and has 
+  /* assert(c_adt->nr_of_vobs > 0);
+     Magic Knight Rayearth Daybreak is mastered very strange and has
      Titles with a VOBS that has no cells. */
   CHECK_VALUE(info_length % sizeof(cell_adr_t) == 0);
-  
+
   /* assert(info_length / sizeof(cell_adr_t) >= c_adt->nr_of_vobs);
      Enemy of the State region 2 (de) has Titles where nr_of_vobs field
      is to high, they high ones are never referenced though. */
@@ -1399,12 +1399,12 @@
     fprintf(stderr, "libdvdread: *C_ADT nr_of_vobs > avaiable info entries\n");
     c_adt->nr_of_vobs = info_length / sizeof(cell_adr_t);
   }
-  
+
   c_adt->cell_adr_table = (cell_adr_t *)malloc(info_length);
   if(!c_adt->cell_adr_table)
     return 0;
 
-  if(info_length && 
+  if(info_length &&
      !(DVDReadBytes(ifofile->file, c_adt->cell_adr_table, info_length))) {
     free(c_adt->cell_adr_table);
     return 0;
@@ -1419,8 +1419,8 @@
     CHECK_VALUE(c_adt->cell_adr_table[i].vob_id > 0);
     CHECK_VALUE(c_adt->cell_adr_table[i].vob_id <= c_adt->nr_of_vobs);
     CHECK_VALUE(c_adt->cell_adr_table[i].cell_id > 0);
-    CHECK_VALUE(c_adt->cell_adr_table[i].start_sector < 
-	   c_adt->cell_adr_table[i].last_sector);
+    CHECK_VALUE(c_adt->cell_adr_table[i].start_sector <
+           c_adt->cell_adr_table[i].last_sector);
   }
 
   return 1;
@@ -1437,7 +1437,7 @@
 void ifoFree_C_ADT(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   ifoFree_C_ADT_internal(ifofile->menu_c_adt);
   ifofile->menu_c_adt = 0;
 }
@@ -1445,7 +1445,7 @@
 void ifoFree_TITLE_C_ADT(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   ifoFree_C_ADT_internal(ifofile->vts_c_adt);
   ifofile->vts_c_adt = 0;
 }
@@ -1456,10 +1456,10 @@
 
   if(!ifofile->vtsi_mat)
     return 0;
-  
+
   if(ifofile->vtsi_mat->vts_vobu_admap == 0) /* mandatory */
     return 0;
-  
+
   ifofile->vts_vobu_admap = (vobu_admap_t *)malloc(sizeof(vobu_admap_t));
   if(!ifofile->vts_vobu_admap)
     return 0;
@@ -1479,7 +1479,7 @@
 
   if(!ifofile)
     return 0;
-     
+
   if(ifofile->vmgi_mat) {
     if(ifofile->vmgi_mat->vmgm_vobu_admap == 0)
       return 1;
@@ -1491,11 +1491,11 @@
   } else {
     return 0;
   }
-  
+
   ifofile->menu_vobu_admap = (vobu_admap_t *)malloc(sizeof(vobu_admap_t));
   if(!ifofile->menu_vobu_admap)
     return 0;
-  
+
   if(!ifoRead_VOBU_ADMAP_internal(ifofile, ifofile->menu_vobu_admap, sector)) {
     free(ifofile->menu_vobu_admap);
     ifofile->menu_vobu_admap = 0;
@@ -1505,9 +1505,9 @@
   return 1;
 }
 
-static int ifoRead_VOBU_ADMAP_internal(ifo_handle_t *ifofile, 
-                                       vobu_admap_t *vobu_admap, 
-				       unsigned int sector) {
+static int ifoRead_VOBU_ADMAP_internal(ifo_handle_t *ifofile,
+                                       vobu_admap_t *vobu_admap,
+                                       unsigned int sector) {
   unsigned int i;
   int info_length;
 
@@ -1518,20 +1518,20 @@
     return 0;
 
   B2N_32(vobu_admap->last_byte);
-  
+
   info_length = vobu_admap->last_byte + 1 - VOBU_ADMAP_SIZE;
   /* assert(info_length > 0);
-     Magic Knight Rayearth Daybreak is mastered very strange and has 
+     Magic Knight Rayearth Daybreak is mastered very strange and has
      Titles with a VOBS that has no VOBUs. */
   CHECK_VALUE(info_length % sizeof(uint32_t) == 0);
-  
-  vobu_admap->vobu_start_sectors = (uint32_t *)malloc(info_length); 
+
+  vobu_admap->vobu_start_sectors = (uint32_t *)malloc(info_length);
   if(!vobu_admap->vobu_start_sectors) {
     return 0;
   }
-  if(info_length && 
-     !(DVDReadBytes(ifofile->file, 
-		    vobu_admap->vobu_start_sectors, info_length))) {
+  if(info_length &&
+     !(DVDReadBytes(ifofile->file,
+                    vobu_admap->vobu_start_sectors, info_length))) {
     free(vobu_admap->vobu_start_sectors);
     return 0;
   }
@@ -1553,7 +1553,7 @@
 void ifoFree_VOBU_ADMAP(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   ifoFree_VOBU_ADMAP_internal(ifofile->menu_vobu_admap);
   ifofile->menu_vobu_admap = 0;
 }
@@ -1561,7 +1561,7 @@
 void ifoFree_TITLE_VOBU_ADMAP(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   ifoFree_VOBU_ADMAP_internal(ifofile->vts_vobu_admap);
   ifofile->vts_vobu_admap = 0;
 }
@@ -1570,18 +1570,18 @@
 
   if(!ifofile)
     return 0;
-  
+
   if(!ifofile->vtsi_mat)
     return 0;
-  
+
   if(ifofile->vtsi_mat->vts_pgcit == 0) /* mandatory */
     return 0;
-  
+
   ifofile->vts_pgcit = (pgcit_t *)malloc(sizeof(pgcit_t));
   if(!ifofile->vts_pgcit)
     return 0;
 
-  if(!ifoRead_PGCIT_internal(ifofile, ifofile->vts_pgcit, 
+  if(!ifoRead_PGCIT_internal(ifofile, ifofile->vts_pgcit,
                              ifofile->vtsi_mat->vts_pgcit * DVD_BLOCK_LEN)) {
     free(ifofile->vts_pgcit);
     ifofile->vts_pgcit = 0;
@@ -1591,11 +1591,11 @@
   return 1;
 }
 
-static int ifoRead_PGCIT_internal(ifo_handle_t *ifofile, pgcit_t *pgcit, 
+static int ifoRead_PGCIT_internal(ifo_handle_t *ifofile, pgcit_t *pgcit,
                                   unsigned int offset) {
   int i, info_length;
   uint8_t *data, *ptr;
-  
+
   if(!DVDFileSeek_(ifofile->file, offset))
     return 0;
 
@@ -1604,13 +1604,13 @@
 
   B2N_16(pgcit->nr_of_pgci_srp);
   B2N_32(pgcit->last_byte);
-  
+
   CHECK_ZERO(pgcit->zero_1);
   /* assert(pgcit->nr_of_pgci_srp != 0);
-     Magic Knight Rayearth Daybreak is mastered very strange and has 
+     Magic Knight Rayearth Daybreak is mastered very strange and has
      Titles with 0 PTTs. */
   CHECK_VALUE(pgcit->nr_of_pgci_srp < 10000); /* ?? seen max of 1338 */
-  
+
   info_length = pgcit->nr_of_pgci_srp * PGCI_SRP_SIZE;
   data = malloc(info_length);
   if(!data)
@@ -1635,10 +1635,10 @@
     CHECK_VALUE(pgcit->pgci_srp[i].unknown1 == 0);
   }
   free(data);
-  
+
   for(i = 0; i < pgcit->nr_of_pgci_srp; i++)
     CHECK_VALUE(pgcit->pgci_srp[i].pgc_start_byte + PGC_SIZE <= pgcit->last_byte+1);
-  
+
   for(i = 0; i < pgcit->nr_of_pgci_srp; i++) {
     pgcit->pgci_srp[i].pgc = malloc(sizeof(pgc_t));
     if(!pgcit->pgci_srp[i].pgc) {
@@ -1649,7 +1649,7 @@
       }
       return 0;
     }
-    if(!ifoRead_PGC(ifofile, pgcit->pgci_srp[i].pgc, 
+    if(!ifoRead_PGC(ifofile, pgcit->pgci_srp[i].pgc,
                     offset + pgcit->pgci_srp[i].pgc_start_byte)) {
       int j;
       for(j = 0; j < i; j++) {
@@ -1676,7 +1676,7 @@
 void ifoFree_PGCIT(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   if(ifofile->vts_pgcit) {
     ifoFree_PGCIT_internal(ifofile->vts_pgcit);
     free(ifofile->vts_pgcit);
@@ -1688,13 +1688,13 @@
 int ifoRead_PGCI_UT(ifo_handle_t *ifofile) {
   pgci_ut_t *pgci_ut;
   unsigned int sector;
-  unsigned int i;  
+  unsigned int i;
   int info_length;
   uint8_t *data, *ptr;
 
   if(!ifofile)
     return 0;
-  
+
   if(ifofile->vmgi_mat) {
     if(ifofile->vmgi_mat->vmgm_pgci_ut == 0)
       return 1;
@@ -1706,28 +1706,28 @@
   } else {
     return 0;
   }
-  
+
   ifofile->pgci_ut = (pgci_ut_t *)malloc(sizeof(pgci_ut_t));
   if(!ifofile->pgci_ut)
     return 0;
-  
+
   if(!DVDFileSeek_(ifofile->file, sector * DVD_BLOCK_LEN)) {
     free(ifofile->pgci_ut);
     ifofile->pgci_ut = 0;
     return 0;
   }
-  
+
   if(!(DVDReadBytes(ifofile->file, ifofile->pgci_ut, PGCI_UT_SIZE))) {
     free(ifofile->pgci_ut);
     ifofile->pgci_ut = 0;
     return 0;
   }
-  
+
   pgci_ut = ifofile->pgci_ut;
-  
+
   B2N_16(pgci_ut->nr_of_lus);
   B2N_32(pgci_ut->last_byte);
-  
+
   CHECK_ZERO(pgci_ut->zero_1);
   CHECK_VALUE(pgci_ut->nr_of_lus != 0);
   CHECK_VALUE(pgci_ut->nr_of_lus < 100); /* ?? 3-4 ? */
@@ -1758,11 +1758,11 @@
   for(i = 0; i < pgci_ut->nr_of_lus; i++) {
     memcpy(&pgci_ut->lu[i], ptr, PGCI_LU_SIZE);
     ptr += PGCI_LU_SIZE;
-    B2N_16(pgci_ut->lu[i].lang_code); 
-    B2N_32(pgci_ut->lu[i].lang_start_byte); 
+    B2N_16(pgci_ut->lu[i].lang_code);
+    B2N_32(pgci_ut->lu[i].lang_start_byte);
   }
   free(data);
-  
+
   for(i = 0; i < pgci_ut->nr_of_lus; i++) {
     /* Maybe this is only defined for v1.1 and later titles? */
     /* If the bits in 'lu[i].exists' are enumerated abcd efgh then:
@@ -1789,8 +1789,8 @@
       ifofile->pgci_ut = 0;
       return 0;
     }
-    if(!ifoRead_PGCIT_internal(ifofile, pgci_ut->lu[i].pgcit, 
-                               sector * DVD_BLOCK_LEN 
+    if(!ifoRead_PGCIT_internal(ifofile, pgci_ut->lu[i].pgcit,
+                               sector * DVD_BLOCK_LEN
                                + pgci_ut->lu[i].lang_start_byte)) {
       unsigned int j;
       for(j = 0; j < i; j++) {
@@ -1804,9 +1804,9 @@
       return 0;
     }
     /*
-		 * FIXME: Iterate and verify that all menus that should exists accordingly
-		 * to pgci_ut->lu[i].exists really do?
-		 */
+                 * FIXME: Iterate and verify that all menus that should exists accordingly
+                 * to pgci_ut->lu[i].exists really do?
+                 */
   }
 
   return 1;
@@ -1818,7 +1818,7 @@
 
   if(!ifofile)
     return;
-  
+
   if(ifofile->pgci_ut) {
     for(i = 0; i < ifofile->pgci_ut->nr_of_lus; i++) {
       ifoFree_PGCIT_internal(ifofile->pgci_ut->lu[i].pgcit);
@@ -1830,8 +1830,8 @@
   }
 }
 
-static int ifoRead_VTS_ATTRIBUTES(ifo_handle_t *ifofile, 
-                                  vts_attributes_t *vts_attributes, 
+static int ifoRead_VTS_ATTRIBUTES(ifo_handle_t *ifofile,
+                                  vts_attributes_t *vts_attributes,
                                   unsigned int offset) {
   unsigned int i;
 
@@ -1849,7 +1849,7 @@
     B2N_16(vts_attributes->vtstt_audio_attr[i].lang_code);
   for(i = 0; i < 32; i++)
     B2N_16(vts_attributes->vtstt_subp_attr[i].lang_code);
-  
+
   CHECK_ZERO(vts_attributes->zero_1);
   CHECK_ZERO(vts_attributes->zero_2);
   CHECK_ZERO(vts_attributes->zero_3);
@@ -1865,7 +1865,7 @@
   CHECK_VALUE(vts_attributes->nr_of_vtstt_subp_streams <= 32);
   {
     unsigned int nr_coded;
-    CHECK_VALUE(vts_attributes->last_byte + 1 >= VTS_ATTRIBUTES_MIN_SIZE);  
+    CHECK_VALUE(vts_attributes->last_byte + 1 >= VTS_ATTRIBUTES_MIN_SIZE);
     nr_coded = (vts_attributes->last_byte + 1 - VTS_ATTRIBUTES_MIN_SIZE)/6;
     /* This is often nr_coded = 70, how do you know how many there really are? */
     if(nr_coded > 32) { /* We haven't read more from disk/file anyway */
@@ -1888,13 +1888,13 @@
 
   if(!ifofile)
     return 0;
-  
+
   if(!ifofile->vmgi_mat)
     return 0;
-  
+
   if(ifofile->vmgi_mat->vts_atrt == 0) /* mandatory */
     return 0;
-  
+
   sector = ifofile->vmgi_mat->vts_atrt;
   if(!DVDFileSeek_(ifofile->file, sector * DVD_BLOCK_LEN))
     return 0;
@@ -1904,7 +1904,7 @@
     return 0;
 
   ifofile->vts_atrt = vts_atrt;
-  
+
   if(!(DVDReadBytes(ifofile->file, vts_atrt, VTS_ATRT_SIZE))) {
     free(vts_atrt);
     ifofile->vts_atrt = 0;
@@ -1917,7 +1917,7 @@
   CHECK_ZERO(vts_atrt->zero_1);
   CHECK_VALUE(vts_atrt->nr_of_vtss != 0);
   CHECK_VALUE(vts_atrt->nr_of_vtss < 100); /* ?? */
-  CHECK_VALUE((uint32_t)vts_atrt->nr_of_vtss * (4 + VTS_ATTRIBUTES_MIN_SIZE) + 
+  CHECK_VALUE((uint32_t)vts_atrt->nr_of_vtss * (4 + VTS_ATTRIBUTES_MIN_SIZE) +
          VTS_ATRT_SIZE < vts_atrt->last_byte + 1);
 
   info_length = vts_atrt->nr_of_vtss * sizeof(uint32_t);
@@ -1928,7 +1928,7 @@
     return 0;
   }
 
-  vts_atrt->vts_atrt_offsets = data;   
+  vts_atrt->vts_atrt_offsets = data;
 
   if(!(DVDReadBytes(ifofile->file, data, info_length))) {
     free(data);
@@ -1936,12 +1936,12 @@
     ifofile->vts_atrt = 0;
     return 0;
   }
-  
+
   for(i = 0; i < vts_atrt->nr_of_vtss; i++) {
     B2N_32(data[i]);
     CHECK_VALUE(data[i] + VTS_ATTRIBUTES_MIN_SIZE < vts_atrt->last_byte + 1);
   }
-  
+
   info_length = vts_atrt->nr_of_vtss * sizeof(vts_attributes_t);
   vts_atrt->vts = (vts_attributes_t *)malloc(info_length);
   if(!vts_atrt->vts) {
@@ -1972,7 +1972,7 @@
 void ifoFree_VTS_ATRT(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   if(ifofile->vts_atrt) {
     free(ifofile->vts_atrt->vts);
     free(ifofile->vts_atrt->vts_atrt_offsets);
@@ -1987,18 +1987,18 @@
 
   if(!ifofile)
     return 0;
-  
+
   if(!ifofile->vmgi_mat)
     return 0;
- 
-  /* Return successfully if there is nothing to read. */ 
+
+  /* Return successfully if there is nothing to read. */
   if(ifofile->vmgi_mat->txtdt_mgi == 0)
     return 1;
 
-  if(!DVDFileSeek_(ifofile->file, 
-		   ifofile->vmgi_mat->txtdt_mgi * DVD_BLOCK_LEN))
+  if(!DVDFileSeek_(ifofile->file,
+                   ifofile->vmgi_mat->txtdt_mgi * DVD_BLOCK_LEN))
     return 0;
-  
+
   txtdt_mgi = (txtdt_mgi_t *)malloc(sizeof(txtdt_mgi_t));
   if(!txtdt_mgi) {
     return 0;
@@ -2019,7 +2019,7 @@
 void ifoFree_TXTDT_MGI(ifo_handle_t *ifofile) {
   if(!ifofile)
     return;
-  
+
   if(ifofile->txtdt_mgi) {
     free(ifofile->txtdt_mgi);
     ifofile->txtdt_mgi = 0;
diff -urN xine-lib-1.2.11/src/input/libdvdnav/ifo_read.h xine-lib-1.2/src/input/libdvdnav/ifo_read.h
--- xine-lib-1.2.11/src/input/libdvdnav/ifo_read.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/ifo_read.h	2022-01-15 22:03:19.586547179 +0100
@@ -136,7 +136,7 @@
  * VTSI files, this fills the ifofile->vtsm_pgci_ut structure.
  */
 int ifoRead_PGCI_UT(ifo_handle_t *);
-  
+
 /**
  * okay = ifoRead_VTS_TMAPT(ifofile);
  *
@@ -146,7 +146,7 @@
  * seeking for One_Sequential_PGC_Titles.
  */
 int ifoRead_VTS_TMAPT(ifo_handle_t *);
-  
+
 /**
  * okay = ifoRead_C_ADT(ifofile);
  *
diff -urN xine-lib-1.2.11/src/input/libdvdnav/ifo_types.h xine-lib-1.2/src/input/libdvdnav/ifo_types.h
--- xine-lib-1.2.11/src/input/libdvdnav/ifo_types.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/ifo_types.h	2022-01-15 22:03:19.591547200 +0100
@@ -62,12 +62,12 @@
   unsigned char video_format         : 2;
   unsigned char display_aspect_ratio : 2;
   unsigned char permitted_df         : 2;
-  
+
   unsigned char line21_cc_1          : 1;
   unsigned char line21_cc_2          : 1;
   unsigned char unknown1             : 1;
   unsigned char bit_rate             : 1;
-  
+
   unsigned char picture_size         : 2;
   unsigned char letterboxed          : 1;
   unsigned char film_mode            : 1;
@@ -76,11 +76,11 @@
   unsigned char display_aspect_ratio : 2;
   unsigned char video_format         : 2;
   unsigned char mpeg_version         : 2;
-  
+
   unsigned char film_mode            : 1;
   unsigned char letterboxed          : 1;
   unsigned char picture_size         : 2;
-  
+
   unsigned char bit_rate             : 1;
   unsigned char unknown1             : 1;
   unsigned char line21_cc_2          : 1;
@@ -97,7 +97,7 @@
   unsigned char multichannel_extension : 1;
   unsigned char lang_type              : 2;
   unsigned char application_mode       : 2;
-  
+
   unsigned char quantization           : 2;
   unsigned char sample_frequency       : 2;
   unsigned char unknown1               : 1;
@@ -107,7 +107,7 @@
   unsigned char lang_type              : 2;
   unsigned char multichannel_extension : 1;
   unsigned char audio_format           : 3;
-  
+
   unsigned char channels               : 3;
   unsigned char unknown1               : 1;
   unsigned char sample_frequency       : 2;
@@ -238,7 +238,7 @@
 
 /**
  * PGC Command Table.
- */ 
+ */
 typedef struct {
   uint16_t nr_of_pre;
   uint16_t nr_of_post;
@@ -253,7 +253,7 @@
 /**
  * PGC Program Map
  */
-typedef uint8_t pgc_program_map_t; 
+typedef uint8_t pgc_program_map_t;
 
 /**
  * Cell Playback Information.
@@ -266,7 +266,7 @@
   unsigned int interleaved      : 1;
   unsigned int stc_discontinuity: 1;
   unsigned int seamless_angle   : 1;
-  
+
   unsigned int playback_mode    : 1;  /**< When set, enter StillMode after each VOBU */
   unsigned int restricted       : 1;  /**< ?? drop out of fastforward? */
   unsigned int unknown2         : 6;
@@ -277,7 +277,7 @@
   unsigned char seamless_play    : 1;
   unsigned char block_type       : 2;
   unsigned char block_mode       : 2;
-  
+
   unsigned char unknown2         : 6;
   unsigned char restricted       : 1;
   unsigned char playback_mode    : 1;
@@ -315,7 +315,7 @@
 #ifdef WORDS_BIGENDIAN
   unsigned int zero                           : 7; /* 25-31 */
   unsigned int video_pres_mode_change         : 1; /* 24 */
-  
+
   unsigned int karaoke_audio_pres_mode_change : 1; /* 23 */
   unsigned int angle_change                   : 1;
   unsigned int subpic_stream_change           : 1;
@@ -324,7 +324,7 @@
   unsigned int still_off                      : 1;
   unsigned int button_select_or_activate      : 1;
   unsigned int resume                         : 1; /* 16 */
-  
+
   unsigned int chapter_menu_call              : 1; /* 15 */
   unsigned int angle_menu_call                : 1;
   unsigned int audio_menu_call                : 1;
@@ -333,7 +333,7 @@
   unsigned int title_menu_call                : 1;
   unsigned int backward_scan                  : 1;
   unsigned int forward_scan                   : 1; /* 8 */
-  
+
   unsigned int next_pg_search                 : 1; /* 7 */
   unsigned int prev_or_top_pg_search          : 1;
   unsigned int time_or_chapter_search         : 1;
@@ -345,7 +345,7 @@
 #else
   unsigned int video_pres_mode_change         : 1; /* 24 */
   unsigned int zero                           : 7; /* 25-31 */
-  
+
   unsigned int resume                         : 1; /* 16 */
   unsigned int button_select_or_activate      : 1;
   unsigned int still_off                      : 1;
@@ -354,7 +354,7 @@
   unsigned int subpic_stream_change           : 1;
   unsigned int angle_change                   : 1;
   unsigned int karaoke_audio_pres_mode_change : 1; /* 23 */
-  
+
   unsigned int forward_scan                   : 1; /* 8 */
   unsigned int backward_scan                  : 1;
   unsigned int title_menu_call                : 1;
@@ -363,7 +363,7 @@
   unsigned int audio_menu_call                : 1;
   unsigned int angle_menu_call                : 1;
   unsigned int chapter_menu_call              : 1; /* 15 */
-  
+
   unsigned int title_or_time_play             : 1; /* 0 */
   unsigned int chapter_search_or_play         : 1;
   unsigned int title_play                     : 1;
@@ -416,7 +416,7 @@
   unsigned char unknown1   : 4;
   unsigned char block_type : 2;
   unsigned char block_mode : 2;
-#endif  
+#endif
   uint16_t ptl_id_mask;
   uint32_t pgc_start_byte;
   pgc_t *pgc;
@@ -528,7 +528,7 @@
   uint32_t vmgm_c_adt;            /* sector */
   uint32_t vmgm_vobu_admap;       /* sector */
   uint8_t  zero_6[32];
-  
+
   video_attr_t vmgm_video_attr;
   uint8_t  zero_7;
   uint8_t  nr_of_vmgm_audio_streams; /* should be 0 or 1 */
@@ -622,20 +622,20 @@
 typedef struct {
   uint32_t last_byte;
   uint32_t vts_cat;
-  
+
   video_attr_t vtsm_vobs_attr;
   uint8_t  zero_1;
   uint8_t  nr_of_vtsm_audio_streams; /* should be 0 or 1 */
   audio_attr_t vtsm_audio_attr;
-  audio_attr_t zero_2[7];  
+  audio_attr_t zero_2[7];
   uint8_t  zero_3[16];
   uint8_t  zero_4;
   uint8_t  nr_of_vtsm_subp_streams; /* should be 0 or 1 */
   subp_attr_t vtsm_subp_attr;
   subp_attr_t zero_5[27];
-  
+
   uint8_t  zero_6[2];
-  
+
   video_attr_t vtstt_vobs_video_attr;
   uint8_t  zero_7;
   uint8_t  nr_of_vtstt_audio_streams;
@@ -666,10 +666,10 @@
 typedef struct {
   uint32_t last_byte;    /* offsets are relative here */
   uint16_t offsets[100]; /* == nr_of_srpts + 1 (first is disc title) */
-#if 0  
+#if 0
   uint16_t unknown; /* 0x48 ?? 0x48 words (16bit) info following */
   uint16_t zero_1;
-  
+
   uint8_t type_of_info; /* ?? 01 == disc, 02 == Title, 04 == Title part */
   uint8_t unknown1;
   uint8_t unknown2;
@@ -677,14 +677,14 @@
   uint8_t unknown4; /* ?? allways 0x30 language?, text format? */
   uint8_t unknown5;
   uint16_t offset; /* from first */
-  
+
   char text[12]; /* ended by 0x09 */
 #endif
 } ATTRIBUTE_PACKED txtdt_t;
 
 /**
  * Text Data Language Unit. (Incomplete)
- */ 
+ */
 typedef struct {
   uint16_t lang_code;
   uint16_t unknown;      /* 0x0001, title 1? disc 1? side 1? */
@@ -744,7 +744,7 @@
   uint32_t vts_c_adt;       /* sector */
   uint32_t vts_vobu_admap;  /* sector */
   uint8_t  zero_13[24];
-  
+
   video_attr_t vtsm_video_attr;
   uint8_t  zero_14;
   uint8_t  nr_of_vtsm_audio_streams; /* should be 0 or 1 */
@@ -755,7 +755,7 @@
   subp_attr_t vtsm_subp_attr;
   subp_attr_t zero_17[27];
   uint8_t  zero_18[2];
-  
+
   video_attr_t vts_video_attr;
   uint8_t  zero_19;
   uint8_t  nr_of_vts_audio_streams;
@@ -840,20 +840,20 @@
  */
 typedef struct {
   dvd_file_t *file;
-  
+
   /* VMGI */
   vmgi_mat_t     *vmgi_mat;
   tt_srpt_t      *tt_srpt;
-  pgc_t          *first_play_pgc;    
+  pgc_t          *first_play_pgc;
   ptl_mait_t     *ptl_mait;
   vts_atrt_t     *vts_atrt;
   txtdt_mgi_t    *txtdt_mgi;
-  
+
   /* Common */
   pgci_ut_t      *pgci_ut;
   c_adt_t        *menu_c_adt;
   vobu_admap_t   *menu_vobu_admap;
-  
+
   /* VTSI */
   vtsi_mat_t     *vtsi_mat;
   vts_ptt_srpt_t *vts_ptt_srpt;
diff -urN xine-lib-1.2.11/src/input/libdvdnav/md5.c xine-lib-1.2/src/input/libdvdnav/md5.c
--- xine-lib-1.2.11/src/input/libdvdnav/md5.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/md5.c	2022-01-15 22:03:19.591547200 +0100
@@ -40,7 +40,7 @@
 #endif
 
 #ifdef WORDS_BIGENDIAN
-# define SWAP(n)							\
+# define SWAP(n)                                                        \
     (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))
 #else
 # define SWAP(n) (n)
@@ -140,28 +140,28 @@
   while (1)
     {
       /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
-	 computation function processes the whole buffer so that with the
-	 next round of the loop another block can be read.  */
+         computation function processes the whole buffer so that with the
+         next round of the loop another block can be read.  */
       size_t n;
       sum = 0;
 
       /* Read block.  Take care for partial reads.  */
       do
-	{
-	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+        {
+          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
 
-	  sum += n;
-	}
+          sum += n;
+        }
       while (sum < BLOCKSIZE && n != 0);
       if (n == 0 && ferror (stream))
         return 1;
 
       /* If end of file is reached, end the loop.  */
       if (n == 0)
-	break;
+        break;
 
       /* Process buffer with BLOCKSIZE bytes.  Note that
-			BLOCKSIZE % 64 == 0
+                        BLOCKSIZE % 64 == 0
        */
       md5_process_block (buffer, BLOCKSIZE, &ctx);
     }
@@ -215,13 +215,13 @@
       ctx->buflen += add;
 
       if (left_over + add > 64)
-	{
-	  md5_process_block (ctx->buffer, (left_over + add) & ~63, ctx);
-	  /* The regions in the following copy operation cannot overlap.  */
-	  memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~63],
-		  (left_over + add) & 63);
-	  ctx->buflen = (left_over + add) & 63;
-	}
+        {
+          md5_process_block (ctx->buffer, (left_over + add) & ~63, ctx);
+          /* The regions in the following copy operation cannot overlap.  */
+          memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~63],
+                  (left_over + add) & 63);
+          ctx->buflen = (left_over + add) & 63;
+        }
 
       buffer = (const char *) buffer + add;
       len -= add;
@@ -289,27 +289,27 @@
       md5_uint32 D_save = D;
 
       /* First round: using the given function, the context and a constant
-	 the next context is computed.  Because the algorithms processing
-	 unit is a 32-bit word and it is determined to work on words in
-	 little endian byte order we perhaps have to change the byte order
-	 before the computation.  To reduce the work for the next steps
-	 we store the swapped words in the array CORRECT_WORDS.  */
-
-#define OP(a, b, c, d, s, T)						\
-      do								\
-        {								\
-	  a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;		\
-	  ++words;							\
-	  a = rol (a, s);						\
-	  a += b;							\
-        }								\
+         the next context is computed.  Because the algorithms processing
+         unit is a 32-bit word and it is determined to work on words in
+         little endian byte order we perhaps have to change the byte order
+         before the computation.  To reduce the work for the next steps
+         we store the swapped words in the array CORRECT_WORDS.  */
+
+#define OP(a, b, c, d, s, T)                                            \
+      do                                                                \
+        {                                                               \
+          a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;             \
+          ++words;                                                      \
+          a = rol (a, s);                                               \
+          a += b;                                                       \
+        }                                                               \
       while (0)
 
       /* Before we start, one word to the strange constants.
-	 They are defined in RFC 1321 as
+         They are defined in RFC 1321 as
 
-	 T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64, or
-	 perl -e 'foreach(1..64){printf "0x%08x\n", int (4294967296 * abs (sin $_))}'
+         T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64, or
+         perl -e 'foreach(1..64){printf "0x%08x\n", int (4294967296 * abs (sin $_))}'
        */
 
       /* Round 1.  */
@@ -331,16 +331,16 @@
       OP (B, C, D, A, 22, 0x49b40821);
 
       /* For the second to fourth round we have the possibly swapped words
-	 in CORRECT_WORDS.  Redefine the macro to take an additional first
-	 argument specifying the function to use.  */
+         in CORRECT_WORDS.  Redefine the macro to take an additional first
+         argument specifying the function to use.  */
 #undef OP
-#define OP(f, a, b, c, d, k, s, T)					\
-      do 								\
-	{								\
-	  a += f (b, c, d) + correct_words[k] + T;			\
-	  a = rol (a, s);						\
-	  a += b;							\
-	}								\
+#define OP(f, a, b, c, d, k, s, T)                                      \
+      do                                                                \
+        {                                                               \
+          a += f (b, c, d) + correct_words[k] + T;                      \
+          a = rol (a, s);                                               \
+          a += b;                                                       \
+        }                                                               \
       while (0)
 
       /* Round 2.  */
diff -urN xine-lib-1.2.11/src/input/libdvdnav/md5.h xine-lib-1.2/src/input/libdvdnav/md5.h
--- xine-lib-1.2.11/src/input/libdvdnav/md5.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/md5.h	2022-01-15 22:03:19.614547297 +0100
@@ -72,9 +72,9 @@
 
 #undef __P
 #if defined (__STDC__) && __STDC__
-#define	__P(x) x
+#define __P(x) x
 #else
-#define	__P(x) ()
+#define __P(x) ()
 #endif
 
 /* Structure to save state of computation between the single steps.  */
@@ -104,14 +104,14 @@
    starting at BUFFER.
    It is necessary that LEN is a multiple of 64!!! */
 extern void md5_process_block __P ((const void *buffer, size_t len,
-				    struct md5_ctx *ctx));
+                                    struct md5_ctx *ctx));
 
 /* Starting with the result of former calls of this function (or the
    initialization function update the context for the next LEN bytes
    starting at BUFFER.
    It is NOT required that LEN is a multiple of 64.  */
 extern void md5_process_bytes __P ((const void *buffer, size_t len,
-				    struct md5_ctx *ctx));
+                                    struct md5_ctx *ctx));
 
 /* Process the remaining bytes in the buffer and put result from CTX
    in first 16 bytes following RESBUF.  The result is always in little
@@ -150,8 +150,8 @@
 rol(md5_uint32 x, int n)
 {
   __asm__("roll %%cl,%0"
-	  :"=r" (x)
-	  :"0" (x),"c" (n));
+          :"=r" (x)
+          :"0" (x),"c" (n));
   return x;
 }
 #else
diff -urN xine-lib-1.2.11/src/input/libdvdnav/navigation.c xine-lib-1.2/src/input/libdvdnav/navigation.c
--- xine-lib-1.2.11/src/input/libdvdnav/navigation.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/navigation.c	2022-01-15 22:03:19.612547289 +0100
@@ -1,18 +1,18 @@
-/* 
+/*
  * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -88,12 +88,12 @@
 
 dvdnav_status_t dvdnav_current_title_info(dvdnav_t *this, int32_t *title, int32_t *part) {
   int32_t retval;
-  
+
   if(!this || !title || !part) {
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
   }
-  
+
   pthread_mutex_lock(&this->vm_lock);
   if (!this->vm->vtsi || !this->vm->vmgi) {
     printerr("Bad VM state.");
@@ -145,7 +145,7 @@
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
   }
-  
+
   pthread_mutex_lock(&this->vm_lock);
   if (!this->vm->vmgi) {
     printerr("Bad VM state.");
@@ -182,7 +182,7 @@
 }
 
 dvdnav_status_t dvdnav_part_play_auto_stop(dvdnav_t *this, int32_t title,
-					   int32_t part, int32_t parts_to_play) {
+                                           int32_t part, int32_t parts_to_play) {
   /* FIXME: Implement auto-stop */
   (void)parts_to_play;
  if (dvdnav_part_play(this, title, part) == DVDNAV_STATUS_OK)
@@ -191,12 +191,12 @@
 }
 
 dvdnav_status_t dvdnav_time_play(dvdnav_t *this, int32_t title,
-				 uint64_t time) {
+                                 uint64_t time) {
   if(!this) {
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
   }
-  
+
   /* FIXME: Implement */
   (void)title;
   (void)time;
@@ -209,7 +209,7 @@
     printerr("Passed a NULL pointer.");
     return DVDNAV_STATUS_ERR;
   }
-  
+
   pthread_mutex_lock(&this->vm_lock);
   this->vm->stopped = 1;
   pthread_mutex_unlock(&this->vm_lock);
diff -urN xine-lib-1.2.11/src/input/libdvdnav/nav_print.c xine-lib-1.2/src/input/libdvdnav/nav_print.c
--- xine-lib-1.2.11/src/input/libdvdnav/nav_print.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/nav_print.c	2022-01-15 22:03:19.616547306 +0100
@@ -38,12 +38,12 @@
   CHECK_VALUE((dtime->minute>>4) < 0x7 && (dtime->minute&0xf) < 0xa);
   CHECK_VALUE((dtime->second>>4) < 0x7 && (dtime->second&0xf) < 0xa);
   CHECK_VALUE((dtime->frame_u&0xf) < 0xa);
-  
-  printf("%02x:%02x:%02x.%02x", 
-	 dtime->hour,
-	 dtime->minute,
-	 dtime->second,
-	 dtime->frame_u & 0x3f);
+
+  printf("%02x:%02x:%02x.%02x",
+         dtime->hour,
+         dtime->minute,
+         dtime->second,
+         dtime->frame_u & 0x3f);
   switch((dtime->frame_u & 0xc0) >> 6) {
   case 1:
     rate = "25.00";
@@ -54,7 +54,7 @@
   default:
     rate = "(please send a bug report)";
     break;
-  } 
+  }
   printf(" @ %s fps", rate);
 }
 
@@ -73,7 +73,7 @@
   printf("e_eltm        ");
   print_time(&pci_gi->e_eltm);
   printf("\n");
-  
+
   printf("vobu_isrc     \"");
   for(i = 0; i < 32; i++) {
     char c = pci_gi->vobu_isrc[i];
@@ -87,24 +87,24 @@
 
 static void navPrint_NSML_AGLI(nsml_agli_t *nsml_agli) {
   int i, j = 0;
-  
+
   for(i = 0; i < 9; i++)
     j |= nsml_agli->nsml_agl_dsta[i];
   if(j == 0)
     return;
-  
+
   printf("nsml_agli:\n");
   for(i = 0; i < 9; i++)
     if(nsml_agli->nsml_agl_dsta[i])
-      printf("nsml_agl_c%d_dsta  0x%08x\n", i + 1, 
-	     nsml_agli->nsml_agl_dsta[i]);
+      printf("nsml_agl_c%d_dsta  0x%08x\n", i + 1,
+             nsml_agli->nsml_agl_dsta[i]);
 }
 
 static void navPrint_HL_GI(hl_gi_t *hl_gi, int *btngr_ns, int *btn_ns) {
-  
+
   if((hl_gi->hli_ss & 0x03) == 0)
     return;
-  
+
   printf("hl_gi:\n");
   printf("hli_ss        0x%01x\n", hl_gi->hli_ss & 0x03);
   printf("hli_s_ptm     0x%08x\n", hl_gi->hli_s_ptm);
@@ -116,7 +116,7 @@
   printf("btngr%d_dsp_ty    0x%02x\n", 1, hl_gi->btngr1_dsp_ty);
   printf("btngr%d_dsp_ty    0x%02x\n", 2, hl_gi->btngr2_dsp_ty);
   printf("btngr%d_dsp_ty    0x%02x\n", 3, hl_gi->btngr3_dsp_ty);
-  
+
   printf("btn_ofn       %d\n", hl_gi->btn_ofn);
   *btn_ns = hl_gi->btn_ns;
   printf("btn_ns        %d\n", hl_gi->btn_ns);
@@ -127,49 +127,49 @@
 
 static void navPrint_BTN_COLIT(btn_colit_t *btn_colit) {
   int i, j;
-  
+
   j = 0;
   for(i = 0; i < 6; i++)
     j |= btn_colit->btn_coli[i/2][i&1];
   if(j == 0)
     return;
-  
+
   printf("btn_colit:\n");
   for(i = 0; i < 3; i++)
     for(j = 0; j < 2; j++)
       printf("btn_cqoli %d  %s_coli:  %08x\n",
-	     i, (j == 0) ? "sl" : "ac",
-	     btn_colit->btn_coli[i][j]);
+             i, (j == 0) ? "sl" : "ac",
+             btn_colit->btn_coli[i][j]);
 }
 
 static void navPrint_BTNIT(btni_t *btni_table, int btngr_ns, int btn_ns) {
   int i, j;
-  
+
   printf("btnit:\n");
   printf("btngr_ns: %i\n", btngr_ns);
   printf("btn_ns: %i\n", btn_ns);
-  
+
   if(btngr_ns == 0)
     return;
-  
+
   for(i = 0; i < btngr_ns; i++) {
     for(j = 0; j < (36 / btngr_ns); j++) {
       if(j < btn_ns) {
-	btni_t *btni = &btni_table[(36 / btngr_ns) * i + j];
-	
-	printf("group %d btni %d:  ", i+1, j+1);
-	printf("btn_coln %d, auto_action_mode %d\n",
-	       btni->btn_coln, btni->auto_action_mode);
-	printf("coords   (%d, %d) .. (%d, %d)\n",
-	       btni->x_start, btni->y_start, btni->x_end, btni->y_end);
-	
-	printf("up %d, ", btni->up);
-	printf("down %d, ", btni->down);
-	printf("left %d, ", btni->left);
-	printf("right %d\n", btni->right);
-	
-	/* ifoPrint_COMMAND(&btni->cmd); */
-	printf("\n");
+        btni_t *btni = &btni_table[(36 / btngr_ns) * i + j];
+
+        printf("group %d btni %d:  ", i+1, j+1);
+        printf("btn_coln %d, auto_action_mode %d\n",
+               btni->btn_coln, btni->auto_action_mode);
+        printf("coords   (%d, %d) .. (%d, %d)\n",
+               btni->x_start, btni->y_start, btni->x_end, btni->y_end);
+
+        printf("up %d, ", btni->up);
+        printf("down %d, ", btni->down);
+        printf("left %d, ", btni->left);
+        printf("right %d\n", btni->right);
+
+        /* ifoPrint_COMMAND(&btni->cmd); */
+        printf("\n");
       }
     }
   }
@@ -177,7 +177,7 @@
 
 static void navPrint_HLI(hli_t *hli) {
   int btngr_ns = 0, btn_ns = 0;
-  
+
   printf("hli:\n");
   navPrint_HL_GI(&hli->hl_gi, & btngr_ns, & btn_ns);
   navPrint_BTN_COLIT(&hli->btn_colit);
@@ -217,14 +217,14 @@
     printf("VOBU at the beginning of ILVU\n");
   if(sml_pbi->category & 0x1000)
     printf("VOBU at end of PREU of ILVU\n");
-  
+
   printf("ilvu_ea       0x%08x\n", sml_pbi->ilvu_ea);
   printf("nxt_ilvu_sa   0x%08x\n", sml_pbi->ilvu_sa);
   printf("nxt_ilvu_size 0x%04x\n", sml_pbi->size);
-  
+
   printf("vob_v_s_s_ptm 0x%08x\n", sml_pbi->vob_v_s_s_ptm);
   printf("vob_v_e_e_ptm 0x%08x\n", sml_pbi->vob_v_e_e_ptm);
-  
+
   /* $$$ more code needed here */
 }
 
@@ -233,14 +233,14 @@
   printf("sml_agli:\n");
   for(i = 0; i < 9; i++) {
     printf("agl_c%d address: 0x%08x size 0x%04x\n", i,
-	   sml_agli->data[i].address, sml_agli->data[i].size);
+           sml_agli->data[i].address, sml_agli->data[i].size);
   }
 }
 
 static void navPrint_VOBU_SRI(vobu_sri_t *vobu_sri) {
   int i;
-  int stime[19] = { 240, 120, 60, 20, 15, 14, 13, 12, 11, 
-		     10,   9,  8,  7,  6,  5,  4,  3,  2, 1};
+  int stime[19] = { 240, 120, 60, 20, 15, 14, 13, 12, 11,
+                     10,   9,  8,  7,  6,  5,  4,  3,  2, 1};
   printf("vobu_sri:\n");
   printf("Next VOBU with Video %08x\n", vobu_sri->next_video);
   for(i = 0; i < 19; i++) {
@@ -259,7 +259,7 @@
 
 static void navPrint_SYNCI(synci_t *synci) {
   int i;
-  
+
   printf("synci:\n");
   /* $$$ more code needed here */
   for(i = 0; i < 8; i++)
diff -urN xine-lib-1.2.11/src/input/libdvdnav/nav_print.h xine-lib-1.2/src/input/libdvdnav/nav_print.h
--- xine-lib-1.2.11/src/input/libdvdnav/nav_print.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/nav_print.h	2022-01-15 22:03:19.585547175 +0100
@@ -36,7 +36,7 @@
  * @param pci Pointer to the PCI data structure to be printed.
  */
 void navPrint_PCI(pci_t *);
-  
+
 /**
  * Prints information contained in the DSI to stdout.
  *
diff -urN xine-lib-1.2.11/src/input/libdvdnav/nav_read.c xine-lib-1.2/src/input/libdvdnav/nav_read.c
--- xine-lib-1.2.11/src/input/libdvdnav/nav_read.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/nav_read.c	2022-01-15 22:03:19.597547225 +0100
@@ -141,7 +141,7 @@
   pci->pci_gi.vobu_uop_ctl.zero = getbits(&state, 7 );
   pci->pci_gi.vobu_uop_ctl.video_pres_mode_change         = getbits(&state, 1 );
 
-  pci->pci_gi.vobu_uop_ctl.karaoke_audio_pres_mode_change = getbits(&state, 1 ); 
+  pci->pci_gi.vobu_uop_ctl.karaoke_audio_pres_mode_change = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.angle_change                   = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.subpic_stream_change           = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.audio_stream_change            = getbits(&state, 1 );
@@ -150,7 +150,7 @@
   pci->pci_gi.vobu_uop_ctl.button_select_or_activate      = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.resume                         = getbits(&state, 1 );
 
-  pci->pci_gi.vobu_uop_ctl.chapter_menu_call              = getbits(&state, 1 ); 
+  pci->pci_gi.vobu_uop_ctl.chapter_menu_call              = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.angle_menu_call                = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.audio_menu_call                = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.subpic_menu_call               = getbits(&state, 1 );
@@ -159,7 +159,7 @@
   pci->pci_gi.vobu_uop_ctl.backward_scan                  = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.forward_scan                   = getbits(&state, 1 );
 
-  pci->pci_gi.vobu_uop_ctl.next_pg_search                 = getbits(&state, 1 ); 
+  pci->pci_gi.vobu_uop_ctl.next_pg_search                 = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.prev_or_top_pg_search          = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.time_or_chapter_search         = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.go_up                          = getbits(&state, 1 );
@@ -167,9 +167,9 @@
   pci->pci_gi.vobu_uop_ctl.title_play                     = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.chapter_search_or_play         = getbits(&state, 1 );
   pci->pci_gi.vobu_uop_ctl.title_or_time_play             = getbits(&state, 1 );
-  pci->pci_gi.vobu_s_ptm = getbits(&state, 32 ); 
-  pci->pci_gi.vobu_e_ptm = getbits(&state, 32 ); 
-  pci->pci_gi.vobu_se_e_ptm = getbits(&state, 32 ); 
+  pci->pci_gi.vobu_s_ptm = getbits(&state, 32 );
+  pci->pci_gi.vobu_e_ptm = getbits(&state, 32 );
+  pci->pci_gi.vobu_se_e_ptm = getbits(&state, 32 );
   pci->pci_gi.e_eltm.hour   = getbits(&state, 8 );
   pci->pci_gi.e_eltm.minute = getbits(&state, 8 );
   pci->pci_gi.e_eltm.second = getbits(&state, 8 );
@@ -183,7 +183,7 @@
 
   /* pci hli hli_gi */
   pci->hli.hl_gi.hli_ss = getbits(&state, 16 );
-  pci->hli.hl_gi.hli_s_ptm = getbits(&state, 32 ); 
+  pci->hli.hl_gi.hli_s_ptm = getbits(&state, 32 );
   pci->hli.hl_gi.hli_e_ptm = getbits(&state, 32 );
   pci->hli.hl_gi.btn_se_e_ptm = getbits(&state, 32 );
   pci->hli.hl_gi.zero1 = getbits(&state, 2 );
@@ -196,7 +196,7 @@
   pci->hli.hl_gi.btngr3_dsp_ty = getbits(&state, 3 );
   pci->hli.hl_gi.btn_ofn = getbits(&state, 8 );
   pci->hli.hl_gi.btn_ns = getbits(&state, 8 );
-  pci->hli.hl_gi.nsl_btn_ns = getbits(&state, 8 ); 
+  pci->hli.hl_gi.nsl_btn_ns = getbits(&state, 8 );
   pci->hli.hl_gi.zero5 = getbits(&state, 8 );
   pci->hli.hl_gi.fosl_btnn = getbits(&state, 8 );
   pci->hli.hl_gi.foac_btnn = getbits(&state, 8 );
@@ -204,11 +204,11 @@
   /* pci hli btn_colit */
   for(i = 0; i < 3; i++)
     for(j = 0; j < 2; j++)
-      pci->hli.btn_colit.btn_coli[i][j] = getbits(&state, 32 ); 
+      pci->hli.btn_colit.btn_coli[i][j] = getbits(&state, 32 );
 
   /* NOTE: I've had to change the structure from the disk layout to get
    * the packing to work with Sun's Forte C compiler. */
-  
+
   /* pci hli btni */
   for(i = 0; i < 36; i++) {
     pci->hli.btnit[i].btn_coln = getbits(&state, 2 );
@@ -235,11 +235,10 @@
   }
 
 
-
 #ifndef NDEBUG
   /* Asserts */
 
-  /* pci pci gi */ 
+  /* pci pci gi */
   CHECK_VALUE(pci->pci_gi.zero1 == 0);
 
   /* pci hli hli_gi */
@@ -251,11 +250,11 @@
 
   /* Are there buttons defined here? */
   if((pci->hli.hl_gi.hli_ss & 0x03) != 0) {
-    CHECK_VALUE(pci->hli.hl_gi.btn_ns != 0); 
-    CHECK_VALUE(pci->hli.hl_gi.btngr_ns != 0); 
+    CHECK_VALUE(pci->hli.hl_gi.btn_ns != 0);
+    CHECK_VALUE(pci->hli.hl_gi.btngr_ns != 0);
   } else {
-    CHECK_VALUE((pci->hli.hl_gi.btn_ns != 0 && pci->hli.hl_gi.btngr_ns != 0) 
-	   || (pci->hli.hl_gi.btn_ns == 0 && pci->hli.hl_gi.btngr_ns == 0));
+    CHECK_VALUE((pci->hli.hl_gi.btn_ns != 0 && pci->hli.hl_gi.btngr_ns != 0)
+                || (pci->hli.hl_gi.btn_ns == 0 && pci->hli.hl_gi.btngr_ns == 0));
   }
 
   /* pci hli btnit */
@@ -268,29 +267,29 @@
       CHECK_VALUE(pci->hli.btnit[n].zero4 == 0);
       CHECK_VALUE(pci->hli.btnit[n].zero5 == 0);
       CHECK_VALUE(pci->hli.btnit[n].zero6 == 0);
-      
-      if (j < pci->hli.hl_gi.btn_ns) {	
-	CHECK_VALUE(pci->hli.btnit[n].x_start <= pci->hli.btnit[n].x_end);
-	CHECK_VALUE(pci->hli.btnit[n].y_start <= pci->hli.btnit[n].y_end);
-	CHECK_VALUE(pci->hli.btnit[n].up <= pci->hli.hl_gi.btn_ns);
-	CHECK_VALUE(pci->hli.btnit[n].down <= pci->hli.hl_gi.btn_ns);
-	CHECK_VALUE(pci->hli.btnit[n].left <= pci->hli.hl_gi.btn_ns);
-	CHECK_VALUE(pci->hli.btnit[n].right <= pci->hli.hl_gi.btn_ns);
-	/* vmcmd_verify(pci->hli.btnit[n].cmd); */
+
+      if (j < pci->hli.hl_gi.btn_ns) {
+        CHECK_VALUE(pci->hli.btnit[n].x_start <= pci->hli.btnit[n].x_end);
+        CHECK_VALUE(pci->hli.btnit[n].y_start <= pci->hli.btnit[n].y_end);
+        CHECK_VALUE(pci->hli.btnit[n].up <= pci->hli.hl_gi.btn_ns);
+        CHECK_VALUE(pci->hli.btnit[n].down <= pci->hli.hl_gi.btn_ns);
+        CHECK_VALUE(pci->hli.btnit[n].left <= pci->hli.hl_gi.btn_ns);
+        CHECK_VALUE(pci->hli.btnit[n].right <= pci->hli.hl_gi.btn_ns);
+        /* vmcmd_verify(pci->hli.btnit[n].cmd); */
       } else {
-	int k;
-	CHECK_VALUE(pci->hli.btnit[n].btn_coln == 0);
-	CHECK_VALUE(pci->hli.btnit[n].auto_action_mode == 0);
-	CHECK_VALUE(pci->hli.btnit[n].x_start == 0);
-	CHECK_VALUE(pci->hli.btnit[n].y_start == 0);
-	CHECK_VALUE(pci->hli.btnit[n].x_end == 0);
-	CHECK_VALUE(pci->hli.btnit[n].y_end == 0);
-	CHECK_VALUE(pci->hli.btnit[n].up == 0);
-	CHECK_VALUE(pci->hli.btnit[n].down == 0);
-	CHECK_VALUE(pci->hli.btnit[n].left == 0);
-	CHECK_VALUE(pci->hli.btnit[n].right == 0);
-	for (k = 0; k < 8; k++)
-	  CHECK_VALUE(pci->hli.btnit[n].cmd.bytes[k] == 0); /* CHECK_ZERO? */
+        int k;
+        CHECK_VALUE(pci->hli.btnit[n].btn_coln == 0);
+        CHECK_VALUE(pci->hli.btnit[n].auto_action_mode == 0);
+        CHECK_VALUE(pci->hli.btnit[n].x_start == 0);
+        CHECK_VALUE(pci->hli.btnit[n].y_start == 0);
+        CHECK_VALUE(pci->hli.btnit[n].x_end == 0);
+        CHECK_VALUE(pci->hli.btnit[n].y_end == 0);
+        CHECK_VALUE(pci->hli.btnit[n].up == 0);
+        CHECK_VALUE(pci->hli.btnit[n].down == 0);
+        CHECK_VALUE(pci->hli.btnit[n].left == 0);
+        CHECK_VALUE(pci->hli.btnit[n].right == 0);
+        for (k = 0; k < 8; k++)
+          CHECK_VALUE(pci->hli.btnit[n].cmd.bytes[k] == 0); /* CHECK_ZERO? */
       }
     }
   }
@@ -353,10 +352,9 @@
   for(i = 0; i < 32; i++)
     dsi->synci.sp_synca[i] = getbits(&state, 32 );
 
-  
+
   /* Asserts */
 
   /* dsi dsi gi */
   CHECK_VALUE(dsi->dsi_gi.zero1 == 0);
 }
-
diff -urN xine-lib-1.2.11/src/input/libdvdnav/nav_read.h xine-lib-1.2/src/input/libdvdnav/nav_read.h
--- xine-lib-1.2.11/src/input/libdvdnav/nav_read.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/nav_read.h	2022-01-15 22:03:19.610547280 +0100
@@ -31,15 +31,15 @@
 
 /**
  * Reads the PCI packet data pointed to into th pci struct.
- * 
+ *
  * @param pci Pointer to the PCI data structure to be filled in.
  * @param bufffer Pointer to the buffer of the on disc PCI data.
- */  
+ */
 void navRead_PCI(pci_t *, unsigned char *);
 
 /**
  * Reads the DSI packet data pointed to into dsi struct.
- * 
+ *
  * @param dsi Pointer to the DSI data structure to be filled in.
  * @param bufffer Pointer to the buffer of the on disc DSI data.
  */
diff -urN xine-lib-1.2.11/src/input/libdvdnav/nav_types.h xine-lib-1.2/src/input/libdvdnav/nav_types.h
--- xine-lib-1.2.11/src/input/libdvdnav/nav_types.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/nav_types.h	2022-01-15 22:03:19.602547246 +0100
@@ -34,7 +34,7 @@
 
 
 #undef ATTRIBUTE_PACKED
-#undef PRAGMA_PACK_BEGIN 
+#undef PRAGMA_PACK_BEGIN
 #undef PRAGMA_PACK_END
 
 #if defined(__GNUC__)
@@ -67,7 +67,7 @@
 
 
 /**
- * PCI General Information 
+ * PCI General Information
  */
 typedef struct {
   uint32_t nv_pck_lbn;      /**< sector address of this nav pack */
@@ -88,8 +88,8 @@
   uint32_t nsml_agl_dsta[9];  /**< address of destination vobu in AGL_C#n */
 } ATTRIBUTE_PACKED nsml_agli_t;
 
-/** 
- * Highlight General Information 
+/**
+ * Highlight General Information
  *
  * For btngrX_dsp_ty the bits have the following meaning:
  * 000b: normal 4/3 only buttons
@@ -111,7 +111,7 @@
   unsigned int zero4 : 1;          /**< reserved */
   unsigned int btngr3_dsp_ty : 3;  /**< display type of subpic stream for button group 3 */
   uint8_t btn_ofn;     /**< button offset number range 0-255 */
-  uint8_t btn_ns;      /**< number of valid buttons  <= 36/18/12 (low 6 bits) */  
+  uint8_t btn_ns;      /**< number of valid buttons  <= 36/18/12 (low 6 bits) */
   uint8_t nsl_btn_ns;  /**< number of buttons selectable by U_BTNNi (low 6 bits)   nsl_btn_ns <= btn_ns */
   uint8_t zero5;       /**< reserved */
   uint8_t fosl_btnn;   /**< forcedly selected button  (low 6 bits) */
@@ -119,8 +119,8 @@
 } ATTRIBUTE_PACKED hl_gi_t;
 
 
-/** 
- * Button Color Information Table 
+/**
+ * Button Color Information Table
  * Each entry beeing a 32bit word that contains the color indexs and alpha
  * values to use.  They are all represented by 4 bit number and stored
  * like this [Ci3, Ci2, Ci1, Ci0, A3, A2, A1, A0].   The actual palette
@@ -131,7 +131,7 @@
   uint32_t btn_coli[3][2];  /**< [button color number-1][select:0/action:1] */
 } ATTRIBUTE_PACKED btn_colit_t;
 
-/** 
+/**
  * Button Information
  *
  * NOTE: I've had to change the structure from the disk layout to get
@@ -161,7 +161,7 @@
 } ATTRIBUTE_PACKED btni_t;
 
 /**
- * Highlight Information 
+ * Highlight Information
  */
 typedef struct {
   hl_gi_t     hl_gi;
@@ -183,7 +183,7 @@
 
 
 /**
- * DSI General Information 
+ * DSI General Information
  */
 typedef struct {
   uint32_t nv_pck_scr;
@@ -212,7 +212,7 @@
     uint32_t stp_ptm1;
     uint32_t stp_ptm2;
     uint32_t gap_len1;
-    uint32_t gap_len2;      
+    uint32_t gap_len2;
   } vob_a[8];
 } ATTRIBUTE_PACKED sml_pbi_t;
 
@@ -232,7 +232,7 @@
 } ATTRIBUTE_PACKED sml_agli_t;
 
 /**
- * VOBU Search Information 
+ * VOBU Search Information
  */
 typedef struct {
   uint32_t next_video; /**< Next vobu that contains video */
@@ -247,7 +247,7 @@
 
 /**
  * Synchronous Information
- */ 
+ */
 typedef struct {
   uint16_t a_synca[8];   /**< offset to first audio packet for this VOBU */
   uint32_t sp_synca[32]; /**< offset to first subpicture packet */
diff -urN xine-lib-1.2.11/src/input/libdvdnav/read_cache.h xine-lib-1.2/src/input/libdvdnav/read_cache.h
--- xine-lib-1.2.11/src/input/libdvdnav/read_cache.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/read_cache.h	2022-01-15 22:03:19.597547225 +0100
@@ -1,18 +1,18 @@
-/* 
+/*
  * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -27,7 +27,7 @@
 /* typedef struct read_cache_s read_cache_t; */
 
 /* EXPERIMENTAL: Setting the following to 1 will use an experimental multi-threaded
- *               read-ahead cache. 
+ *               read-ahead cache.
  */
 #define _MULTITHREAD_ 0
 
diff -urN xine-lib-1.2.11/src/input/libdvdnav/remap.h xine-lib-1.2/src/input/libdvdnav/remap.h
--- xine-lib-1.2.11/src/input/libdvdnav/remap.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/remap.h	2022-01-15 22:03:19.611547284 +0100
@@ -1,16 +1,16 @@
-/* 
+/*
  * This file is part of libdvdnav, a DVD navigation library.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -24,8 +24,8 @@
 
 remap_t* remap_loadmap( char *title);
 
-unsigned long remap_block( 
-	remap_t *map, int domain, int title, int program, 
-	unsigned long cblock, unsigned long offset);
+unsigned long remap_block(
+        remap_t *map, int domain, int title, int program,
+        unsigned long cblock, unsigned long offset);
 
 #endif
diff -urN xine-lib-1.2.11/src/input/libdvdnav/settings.c xine-lib-1.2/src/input/libdvdnav/settings.c
--- xine-lib-1.2.11/src/input/libdvdnav/settings.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/settings.c	2022-01-15 22:03:19.592547204 +0100
@@ -1,18 +1,18 @@
-/* 
+/*
  * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -73,12 +73,12 @@
     printerr("Passed a NULL this pointer.");
     return DVDNAV_STATUS_ERR;
   }
-    
+
   if(!code[0] || !code[1]) {
     printerr("Passed illegal language code.");
     return DVDNAV_STATUS_ERR;
   }
-  
+
   pthread_mutex_lock(&this->vm_lock);
   this->vm->state.registers.SPRM[reg] = (code[0] << 8) | code[1];
   pthread_mutex_unlock(&this->vm_lock);
diff -urN xine-lib-1.2.11/src/input/libdvdnav/vmcmd.h xine-lib-1.2/src/input/libdvdnav/vmcmd.h
--- xine-lib-1.2.11/src/input/libdvdnav/vmcmd.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/vmcmd.h	2022-01-15 22:03:19.588547187 +0100
@@ -1,19 +1,19 @@
 /*
  * Copyright (C) 2000, 2001 Martin Norbäck, Håkan Hjort
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library. It is modified
  * from a file originally part of the Ogle DVD player.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
diff -urN xine-lib-1.2.11/src/input/libdvdnav/vm.h xine-lib-1.2/src/input/libdvdnav/vm.h
--- xine-lib-1.2.11/src/input/libdvdnav/vm.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/vm.h	2022-01-15 22:03:19.597547225 +0100
@@ -1,20 +1,20 @@
 /*
  * Copyright (C) 2000, 2001 Håkan Hjort
  * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
- * 
+ *
  * This file is part of libdvdnav, a DVD navigation library. It is modified
  * from a file originally part of the Ogle DVD player.
- * 
+ *
  * libdvdnav is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * libdvdnav is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
@@ -33,14 +33,14 @@
   VTS_DOMAIN  = 2,
   VMGM_DOMAIN = 4,
   VTSM_DOMAIN = 8
-} domain_t;  
+} domain_t;
 
 /**
  * State: SPRM, GPRM, Domain, pgc, pgN, cellN, ?
  */
 typedef struct {
   registers_t registers;
-  
+
   domain_t  domain;
   int       vtsN;         /* 0 is vmgm? */
   pgc_t    *pgc;          /* either this or 'int pgcN' is enough? */
@@ -49,7 +49,7 @@
   int       cellN;
   int32_t   cell_restart; /* get cell to restart */
   int       blockN;
-  
+
   /* Resume info */
   int      rsm_vtsN;
   int      rsm_blockN;    /* of nav_packet */
diff -urN xine-lib-1.2.11/src/input/libdvdnav/WARNING_TO_DEVELOPERS xine-lib-1.2/src/input/libdvdnav/WARNING_TO_DEVELOPERS
--- xine-lib-1.2.11/src/input/libdvdnav/WARNING_TO_DEVELOPERS	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/input/libdvdnav/WARNING_TO_DEVELOPERS	2022-01-15 22:03:19.610547280 +0100
@@ -0,0 +1,13 @@
+./xine-lib/src/input/libdvdnav.
+This part of the tree should never be modified directly.
+The entire libdvdnav directory is periodically updated from dvd.sf.net libdvdnav cvs.
+If any developers notice a bug in this code, please report it to the dvd-devel@lists.sourceforge.net mailing list.
+If any developers have any patches for this code, please report it to the dvd-devel@lists.sourceforge.net mailing list.
+The dvd.sf.net libdvdnav cvs will then be updated, and xine-lib will receive the update when the next periodic update from dvd.sf.net libdvdnav cvs happens.
+
+If one uses the following command in ./xine-lib directory, One can bypass this code, and force xine-lib to use the dvd.sf.net libdvdnav cvs code directly, thus simplifying the developers testing of bug fixes/new features in libdvdnav.
+
+./configure --with-external-dvdnav
+
+Thank you for your understanding.
+
diff -urN xine-lib-1.2.11/src/input/libreal/rmff.c xine-lib-1.2/src/input/libreal/rmff.c
--- xine-lib-1.2.11/src/input/libreal/rmff.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libreal/rmff.c	2022-01-15 22:03:19.583547166 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2002-2020 the xine project
+ * Copyright (C) 2002-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -293,6 +293,7 @@
   data[11]=h->flags;
 }
 
+#if 0
 static rmff_fileheader_t *rmff_scan_fileheader(const char *data) {
 
   rmff_fileheader_t *fileheader = malloc(sizeof(rmff_fileheader_t));
@@ -309,7 +310,8 @@
 
   return fileheader;
 }
-
+#endif
+#if 0
 static rmff_prop_t *rmff_scan_prop(const char *data) {
 
   rmff_prop_t *prop = malloc(sizeof(rmff_prop_t));
@@ -335,7 +337,8 @@
 
   return prop;
 }
-
+#endif
+#if 0
 static rmff_mdpr_t *rmff_scan_mdpr(const char *data)
 {
   rmff_mdpr_t *mdpr = calloc(sizeof(rmff_mdpr_t), 1);
@@ -391,7 +394,9 @@
   free (mdpr);
   return NULL;
 }
+#endif
 
+#if 0
 static rmff_cont_t *rmff_scan_cont(const char *data) {
 
   rmff_cont_t *cont = malloc(sizeof(rmff_cont_t));
@@ -419,7 +424,9 @@
 
   return cont;
 }
+#endif
 
+#if 0
 static rmff_data_t *rmff_scan_dataheader(const char *data) {
 
   rmff_data_t *dh = malloc(sizeof(rmff_data_t));
@@ -436,7 +443,9 @@
 
   return dh;
 }
+#endif
 
+#if 0
 rmff_header_t *rmff_scan_header(const char *data) {
 
 	rmff_header_t *header = malloc(sizeof(rmff_header_t));
@@ -509,6 +518,7 @@
 
 	return header;
 }
+#endif
 
 #if 0
 rmff_header_t *rmff_scan_header_stream(int fd) {
diff -urN xine-lib-1.2.11/src/input/libreal/rmff.h xine-lib-1.2/src/input/libreal/rmff.h
--- xine-lib-1.2.11/src/input/libreal/rmff.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libreal/rmff.h	2022-01-15 22:03:19.612547289 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2002-2017 the xine project
+ * Copyright (C) 2002-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -223,12 +223,12 @@
 rmff_data_t *rmff_new_dataheader(
     uint32_t num_packets, uint32_t next_data_header);
 
+#if 0
 /*
  * reads header infos from data and returns a newly allocated header struct
  */
 rmff_header_t *rmff_scan_header(const char *data) XINE_MALLOC;
 
-#if 0
 /*
  * scans a data packet header. Notice, that this function does not allocate
  * the header struct itself.
diff -urN xine-lib-1.2.11/src/input/libreal/sdpplin.c xine-lib-1.2/src/input/libreal/sdpplin.c
--- xine-lib-1.2.11/src/input/libreal/sdpplin.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/libreal/sdpplin.c	2022-01-15 22:03:19.594547213 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2002-2020 the xine project
+ * Copyright (C) 2002-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -210,11 +210,21 @@
 
 sdpplin_t *sdpplin_parse(char *data) {
 
-  sdpplin_t        *desc = calloc(1, sizeof(sdpplin_t));
-  char             *buf=xine_buffer_init(32);
+  sdpplin_t        *desc;
+  char             *buf;
   int              handled;
   int              len;
 
+  desc = calloc(1, sizeof(sdpplin_t));
+  if (!desc)
+    return NULL;
+
+  buf = xine_buffer_init(32);
+  if (!buf) {
+    free(desc);
+    return NULL;
+  }
+
   desc->stream = NULL;
 
   while (data && *data) {
diff -urN xine-lib-1.2.11/src/input/librtsp/rtsp.c xine-lib-1.2/src/input/librtsp/rtsp.c
--- xine-lib-1.2.11/src/input/librtsp/rtsp.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/librtsp/rtsp.c	2022-01-15 22:03:19.614547297 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -447,6 +447,9 @@
   int hostend, i;
   size_t pathbegin;
 
+  if (!s)
+    return NULL;
+
   if (strncmp(mrl,"rtsp://",7))
   {
     xprintf(stream->xine, XINE_VERBOSITY_LOG, _("rtsp: bad mrl: %s\n"), mrl);
diff -urN xine-lib-1.2.11/src/input/Makefile.am xine-lib-1.2/src/input/Makefile.am
--- xine-lib-1.2.11/src/input/Makefile.am	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/Makefile.am	2022-01-15 22:03:19.610547280 +0100
@@ -199,6 +199,7 @@
 	input_pnm.c \
 	input_rtsp.c \
 	input_hls.c \
+	input_mpegdash.c \
 	pnm.c \
 	pnm.h
 xineplug_inp_network_la_CPPFLAGS = $(AM_CPPFLAGS) $(ZLIB_CPPFLAGS)
@@ -217,7 +218,7 @@
 xineplug_inp_vcd_la_CFLAGS  = $(AM_CFLAGS) $(LIBCDIO_CFLAGS) $(LIBVCD_CFLAGS)
 
 xineplug_inp_vcdo_la_SOURCES = input_vcd.c
-xineplug_inp_vcdo_la_LIBADD = $(XINE_LIB) $(LTLIBINTL) media_helper.la
+xineplug_inp_vcdo_la_LIBADD = $(XINE_LIB) $(LTLIBINTL) media_helper.la input_helper.la
 
 xineplug_inp_stdin_fifo_la_SOURCES = input_stdin_fifo.c
 xineplug_inp_stdin_fifo_la_LIBADD = $(XINE_LIB) $(LTLIBINTL) input_helper.la
@@ -272,3 +273,4 @@
 xineplug_tls_openssl_la_SOURCES = tls/tls_openssl.c tls/xine_tls_plugin.h
 xineplug_tls_openssl_la_CFLAGS = $(AM_CFLAGS) $(OPENSSL_CFLAGS)
 xineplug_tls_openssl_la_LIBADD = $(XINE_LIB) $(LTLIBINTL) $(OPENSSL_LIBS)
+
diff -urN xine-lib-1.2.11/src/input/pnm.c xine-lib-1.2/src/input/pnm.c
--- xine-lib-1.2.11/src/input/pnm.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/pnm.c	2022-01-15 22:03:19.604547255 +0100
@@ -722,22 +722,22 @@
 
 pnm_t *pnm_connect(xine_stream_t *stream, const char *mrl) {
 
-  char *mrl_ptr=strdup(mrl);
-  char *slash, *colon;
+  const char *mrl_ptr, *slash, *colon;
   size_t pathbegin, hostend;
   pnm_t *p;
   int fd;
   int need_response=0;
 
-  if (strncmp(mrl,"pnm://",6))
-  {
-    free (mrl_ptr);
+  if (strncmp(mrl, "pnm://", 6)) {
     return NULL;
   }
 
-  mrl_ptr+=6;
+  mrl_ptr = mrl + 6;
 
   p = calloc(1, sizeof(pnm_t));
+  if (!p) {
+    return NULL;
+  }
   p->stream = stream;
   p->port=7070;
   p->url=strdup(mrl);
@@ -763,8 +763,6 @@
     p->port=atoi(p->buffer);
   }
 
-  free(mrl_ptr-6);
-
   lprintf("got mrl: %s %i %s\n",p->host,p->port,p->path);
 
   fd = _x_io_tcp_connect (stream, p->host, p->port);
diff -urN xine-lib-1.2.11/src/input/vcd/xineplug_inp_vcd.c xine-lib-1.2/src/input/vcd/xineplug_inp_vcd.c
--- xine-lib-1.2.11/src/input/vcd/xineplug_inp_vcd.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/input/vcd/xineplug_inp_vcd.c	2022-01-15 22:03:19.593547208 +0100
@@ -962,7 +962,8 @@
   bool used_default;
 
   if (!class->ip) {
-    if (!this_gen->get_instance (this_gen, NULL, MRL_PREFIX)) {
+    if (!this_gen->get_instance (this_gen, NULL, MRL_PREFIX) ||
+        !class->ip) {
       *num_files = 0;
       return NULL;
     }
@@ -1101,6 +1102,9 @@
      the 10_ADD keypresses */
   static unsigned int number_addend = 0;
 
+  if (!this->event_queue)
+    return false;
+
   while ((p_event = xine_event_get (this->event_queue))) {
 
     dbg_print (this->class,  (INPUT_DBG_CALL), "processing %d\n", p_event->type );
@@ -1162,6 +1166,7 @@
     case XINE_EVENT_INPUT_MENU2:
     case XINE_EVENT_INPUT_NEXT:
     case XINE_EVENT_INPUT_PREVIOUS:
+      if (this->stream)
       {
         int num = number_addend;
         vcdinfo_itemid_t itemid;
@@ -1235,9 +1240,10 @@
           vcdplayer_play(p_vcdplayer, itemid);
           return true;
         }
-        break;
       }
+      break;
     case XINE_EVENT_INPUT_SELECT:
+      if (this->stream)
       {
         /* In the future will have to test to see if we are in a menu
            selection. But if not... */
@@ -1257,8 +1263,8 @@
             return true;
           }
         }
-        break;
       }
+      break;
     case XINE_EVENT_INPUT_MOUSE_BUTTON:
       if (this->stream)
       {
@@ -1442,7 +1448,8 @@
   dbg_print (class, (INPUT_DBG_CALL|INPUT_DBG_EXT), "called\n");
 
   if (!class->ip) {
-    if (!this_gen->get_instance (this_gen, NULL, MRL_PREFIX)) {
+    if (!this_gen->get_instance (this_gen, NULL, MRL_PREFIX) ||
+        !class->ip) {
       *num_files = 0;
       return NULL;
     }
diff -urN xine-lib-1.2.11/src/libreal/real_common.h xine-lib-1.2/src/libreal/real_common.h
--- xine-lib-1.2.11/src/libreal/real_common.h	2020-12-05 23:27:04.000000000 +0100
+++ xine-lib-1.2/src/libreal/real_common.h	2022-01-15 22:03:19.578547145 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/src/libreal/xine_real_video_decoder.c xine-lib-1.2/src/libreal/xine_real_video_decoder.c
--- xine-lib-1.2.11/src/libreal/xine_real_video_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/libreal/xine_real_video_decoder.c	2022-01-15 22:03:19.584547170 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/src/post/audio/upmix.c xine-lib-1.2/src/post/audio/upmix.c
--- xine-lib-1.2.11/src/post/audio/upmix.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/audio/upmix.c	2022-01-15 22:03:19.616547306 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -324,7 +324,7 @@
       data8src+=num_frames_processed*src_step_frame;
       data8dst=(int8_t*)this->buf->mem;
       pthread_mutex_lock (&this->lock);
-      if ((this->sub) && (this->sub->fc != this->params.cut_off_freq)) {
+      if (this->sub->fc != this->params.cut_off_freq) {
         this->sub->fc = this->params.cut_off_freq;    /* LFE Cutoff frequency 100Hz */
         this->sub->k = 1.0;
         if((-1 == szxform(s_param[0].a, s_param[0].b, Q, this->sub->fc,
diff -urN xine-lib-1.2.11/src/post/deinterlace/plugins/x86-64_macros.inc xine-lib-1.2/src/post/deinterlace/plugins/x86-64_macros.inc
--- xine-lib-1.2.11/src/post/deinterlace/plugins/x86-64_macros.inc	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/deinterlace/plugins/x86-64_macros.inc	2022-01-15 22:03:19.590547196 +0100
@@ -21,9 +21,9 @@
  * Registers may be: "ax" "bx" "cx" "dx" "si" "di" "bp" "sp".
  */
 
-#ifdef HAVE_CONFIG_H
-#  include "config.h"
-#endif
+//#ifdef HAVE_CONFIG_H
+//#  include "config.h"
+//#endif
 
 #ifndef MEMREF1
 
diff -urN xine-lib-1.2.11/src/post/deinterlace/tvtime.c xine-lib-1.2/src/post/deinterlace/tvtime.c
--- xine-lib-1.2.11/src/post/deinterlace/tvtime.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/deinterlace/tvtime.c	2022-01-15 22:03:19.602547246 +0100
@@ -463,6 +463,8 @@
   tvtime_t *tvtime;
 
   tvtime = calloc(1, sizeof(tvtime_t));
+  if (!tvtime)
+    return NULL;
 
   tvtime->pulldown_alg = PULLDOWN_NONE;
 
diff -urN xine-lib-1.2.11/src/post/deinterlace/xine_plugin.c xine-lib-1.2/src/post/deinterlace/xine_plugin.c
--- xine-lib-1.2.11/src/post/deinterlace/xine_plugin.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/deinterlace/xine_plugin.c	2022-01-15 22:03:19.610547280 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -353,6 +353,7 @@
   post_in_t                 *input;
   post_out_t                *output;
   post_video_port_t *port;
+  tvtime_t *tvtime;
 
   static const xine_post_api_t post_api = {
     .set_parameters  = set_parameters,
@@ -388,9 +389,15 @@
   (void)inputs;
   (void)audio_target;
 
+  tvtime = tvtime_new_context();
+  if (!tvtime) {
+    free(this);
+    return NULL;
+  }
+
   _x_post_init(&this->post, 0, 1);
 
-  this->tvtime = tvtime_new_context();
+  this->tvtime = tvtime;
   this->tvtime_changed++;
   this->tvtime_last_filmmode = 0;
   this->class = (post_class_deinterlace_t *)class_gen;
diff -urN xine-lib-1.2.11/src/post/goom/config_param.c xine-lib-1.2/src/post/goom/config_param.c
--- xine-lib-1.2.11/src/post/goom/config_param.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/goom/config_param.c	2022-01-15 22:03:19.617547310 +0100
@@ -21,13 +21,16 @@
   (void)dummy;
 }
 
-PluginParam goom_secure_param() {
-  PluginParam p;
-  p.changed = empty_fct;
-  p.change_listener = empty_fct;
-  p.user_data = 0;
-  p.name = p.desc = 0;
-  p.rw = 1;
+static PluginParam secure_param() {
+  PluginParam p = {
+    .changed = empty_fct,
+    .change_listener = empty_fct,
+    .user_data = 0,
+    .name = 0,
+    .desc = 0,
+    .rw = 1,
+    .type = 0,
+  };
   return p;
 }
 
diff -urN xine-lib-1.2.11/src/post/goom/convolve_fx.c xine-lib-1.2/src/post/goom/convolve_fx.c
--- xine-lib-1.2.11/src/post/goom/convolve_fx.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/goom/convolve_fx.c	2022-01-15 22:03:19.599547234 +0100
@@ -79,6 +79,8 @@
   ConvData *data;
   data = (ConvData*)calloc(1, sizeof(ConvData));
   _this->fx_data = (void*)data;
+  if (!data)
+    return;
 
   data->light = secure_f_param("Screen Brightness");
   data->light.param.fval.max = 300.0f;
@@ -299,6 +301,11 @@
   float ff;
   int iff;
   
+  if (!data) {
+    memcpy(dest, src, info->screen.size * sizeof(Pixel));
+    return;
+  }
+
   ff = (FVAL(data->factor_p) * FVAL(data->factor_adj_p) + FVAL(data->light) ) / 100.0f;
   iff = (unsigned int)(ff * 256);
 
diff -urN xine-lib-1.2.11/src/post/goom/goom_config_param.h xine-lib-1.2/src/post/goom/goom_config_param.h
--- xine-lib-1.2.11/src/post/goom/goom_config_param.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/goom/goom_config_param.h	2022-01-15 22:03:19.588547187 +0100
@@ -79,8 +79,6 @@
 #define IMAX(p) ((p).param.ival.max)
 #define ISTEP(p) ((p).param.ival.step)
 
-PluginParam goom_secure_param(void);
-
 PluginParam goom_secure_f_param(const char *name);
 PluginParam goom_secure_i_param(const char *name);
 PluginParam goom_secure_b_param(const char *name, int value);
@@ -101,7 +99,6 @@
 
 PluginParameters goom_plugin_parameters(const char *name, int nb);
 
-#define secure_param goom_secure_param
 #define secure_f_param goom_secure_f_param
 #define secure_i_param goom_secure_i_param
 #define secure_b_param goom_secure_b_param
diff -urN xine-lib-1.2.11/src/post/goom/mmx.h xine-lib-1.2/src/post/goom/mmx.h
--- xine-lib-1.2.11/src/post/goom/mmx.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/goom/mmx.h	2022-01-15 22:03:19.613547293 +0100
@@ -27,9 +27,12 @@
 #ifndef _MMX_H
 #define _MMX_H
 
-#ifdef HAVE_CONFIG_H
-# include "config.h"
-#endif
+# if defined(HAVE_CONFIG_H) && !defined(__XINE_LIB_CONFIG_H__)
+#  error config.h not included in source file !
+# endif
+//#ifdef HAVE_CONFIG_H
+//# include "config.h"
+//#endif
 
 #include <xine/attributes.h>
 
diff -urN xine-lib-1.2.11/src/post/goom/ppc_drawings.s xine-lib-1.2/src/post/goom/ppc_drawings.s
--- xine-lib-1.2.11/src/post/goom/ppc_drawings.s	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/post/goom/ppc_drawings.s	2022-01-15 22:03:19.619547318 +0100
@@ -0,0 +1,381 @@
+; PowerPC optimized drawing methods for Goom
+; © 2003 Guillaume Borios
+; This Source Code is released under the terms of the General Public License
+
+; Change log :
+; 30 May 2003 : File creation
+
+; Section definition : We use a read only code section for the whole file
+.section __TEXT,__text,regular,pure_instructions
+
+
+; --------------------------------------------------------------------------------------
+; Single 32b pixel drawing macros
+; Usage :
+; 	DRAWMETHOD_XXXX_MACRO *pixelIN, *pixelOUT, COLOR, WR1, WR2, WR3, WR4
+;	Only the work registers (WR) can be touched by the macros
+;
+; Available methods :
+;	DRAWMETHOD_DFLT_MACRO : Default drawing method (Actually OVRW)
+;	DRAWMETHOD_PLUS_MACRO : RVB Saturated per channel addition (SLOWEST)
+;	DRAWMETHOD_HALF_MACRO : 50% Transparency color drawing
+;	DRAWMETHOD_OVRW_MACRO : Direct COLOR drawing (FASTEST)
+;	DRAWMETHOD_B_OR_MACRO : Bitwise OR
+;	DRAWMETHOD_BAND_MACRO : Bitwise AND
+;	DRAWMETHOD_BXOR_MACRO : Bitwise XOR
+;	DRAWMETHOD_BNOT_MACRO : Bitwise NOT
+; --------------------------------------------------------------------------------------
+
+.macro DRAWMETHOD_OVRW_MACRO
+    stw		$2,0($1)	;; *$1 <- $2
+.endmacro
+
+.macro DRAWMETHOD_B_OR_MACRO
+    lwz		$3,0($0)	;; $3 <- *$0
+    or		$3,$3,$2	;; $3 <- $3 | $2
+    stw		$3,0($1)	;; *$1 <- $3
+.endmacro
+
+.macro DRAWMETHOD_BAND_MACRO
+    lwz		$3,0($0)	;; $3 <- *$0
+    and		$3,$3,$2	;; $3 <- $3 & $2
+    stw		$3,0($1)	;; *$1 <- $3
+.endmacro
+
+.macro DRAWMETHOD_BXOR_MACRO
+    lwz		$3,0($0)	;; $3 <- *$0
+    xor		$3,$3,$2	;; $3 <- $3 ^ $2
+    stw		$3,0($1)	;; *$1 <- $3
+.endmacro
+
+.macro DRAWMETHOD_BNOT_MACRO
+    lwz		$3,0($0)	;; $3 <- *$0
+    nand	$3,$3,$3	;; $3 <- ~$3
+    stw		$3,0($1)	;; *$1 <- $3
+.endmacro
+
+.macro DRAWMETHOD_PLUS_MACRO
+    lwz		$4,0($0)	;; $4 <- *$0
+    andi.	$3,$4,0xFF00	;; $3 <- $4 & 0x0000FF00
+    andi.	$5,$2,0xFF00	;; $5 <- $2 & 0x0000FF00
+    add		$3,$3,$5	;; $3 <- $3 + $5
+    rlwinm	$5,$3,15,0,0	;; $5 <- 0 | ($3[15] << 15)
+    srawi	$5,$5,23	;; $5 <- $5 >> 23 (algebraic for sign extension)
+    or		$3,$3,$5	;; $3 <- $3 | $5
+    lis		$5,0xFF		;; $5 <- 0x00FF00FF
+    addi	$5,$5,0xFF
+    and		$4,$4,$5	;; $4 <- $4 & $5
+    and		$6,$2,$5	;; $6 <- $2 & $5
+    add		$4,$4,$6	;; $4 <- $4 + $6
+    rlwinm	$6,$4,7,0,0	;; $6 <- 0 | ($4[7] << 7)
+    srawi	$6,$6,15	;; $6 <- $6 >> 15 (algebraic for sign extension)
+    rlwinm	$5,$4,23,0,0	;; $5 <- 0 | ($4[23] << 23)
+    srawi	$5,$5,31	;; $5 <- $5 >> 31 (algebraic for sign extension)
+    rlwimi	$6,$5,0,24,31	;; $6[24..31] <- $5[24..31]
+    or		$4,$4,$6	;; $4 <- $4 | $6
+    rlwimi	$4,$3,0,16,23	;; $4[16..23] <- $3[16..23]
+    stw		$4,0($1)	;; *$1 <- $4
+.endmacro
+
+.macro	DRAWMETHOD_HALF_MACRO
+    lwz		$4,0($0)	;; $4 <- *$0
+    andi.	$3,$4,0xFF00	;; $3 <- $4 & 0x0000FF00
+    andi.	$5,$2,0xFF00	;; $5 <- $2 & 0x0000FF00
+    add		$3,$3,$5	;; $3 <- $3 + $5
+    lis		$5,0xFF		;; $5 <- 0x00FF00FF
+    addi	$5,$5,0xFF
+    and		$4,$4,$5	;; $4 <- $4 & $5
+    and		$5,$2,$5	;; $5 <- $2 & $5
+    add		$4,$4,$5	;; $4 <- $4 + $5
+    srwi	$4,$4,1		;; $4 <- $4 >> 1
+    rlwimi	$4,$3,31,16,23	;; $4[16..23] <- $3[15..22]
+    stw		$4,0($1)	;; *$1 <- $4
+.endmacro
+
+.macro DRAWMETHOD_DFLT_MACRO
+    DRAWMETHOD_PLUS_MACRO
+.endmacro
+
+; --------------------------------------------------------------------------------------
+
+
+
+; **************************************************************************************
+; void DRAWMETHOD_PLUS_PPC(unsigned int * buf, unsigned int _col);
+; void DRAWMETHOD_PLUS_2_PPC(unsigned * in, unsigned int * out, unsigned int _col);
+; **************************************************************************************
+.globl _DRAWMETHOD_PLUS_2_PPC
+.align 3
+_DRAWMETHOD_PLUS_2_PPC:
+    DRAWMETHOD_PLUS_MACRO	r3,r4,r5,r6,r7,r8,r9
+    blr				;; return
+
+.globl _DRAWMETHOD_PLUS_PPC
+.align 3
+_DRAWMETHOD_PLUS_PPC:
+    DRAWMETHOD_PLUS_MACRO	r3,r3,r4,r5,r6,r7,r9
+    blr				;; return
+
+
+; **************************************************************************************
+; void DRAWMETHOD_HALF_PPC(unsigned int * buf, unsigned int _col);
+; void DRAWMETHOD_HALF_2_PPC(unsigned * in, unsigned int * out, unsigned int _col);
+; **************************************************************************************
+.globl _DRAWMETHOD_HALF_2_PPC
+.align 3
+_DRAWMETHOD_HALF_2_PPC:
+    DRAWMETHOD_HALF_MACRO	r3,r4,r5,r6,r7,r8
+    blr				;; return
+
+.globl _DRAWMETHOD_HALF_PPC
+.align 3
+_DRAWMETHOD_HALF_PPC:
+    DRAWMETHOD_HALF_MACRO	r3,r3,r4,r5,r6,r7
+    blr				;; return
+
+
+; **************************************************************************************
+; void DRAW_LINE_PPC(unsigned int *data, int x1, int y1, int x2, int y2, unsigned int col,
+; 			unsigned int screenx, unsigned int screeny)
+; **************************************************************************************
+.globl _DRAW_LINE_PPC
+.align 3
+_DRAW_LINE_PPC:
+    ;; NOT IMPLEMENTED YET
+    blr				;; return
+
+
+; **************************************************************************************
+; void _ppc_brightness(Pixel * src, Pixel * dest, unsigned int size, unsigned int coeff)
+; **************************************************************************************
+
+
+.const
+.align 4
+vectorZERO:
+    .long 0,0,0,0
+    .long 0x10101000, 0x10101001, 0x10101002, 0x10101003
+    .long 0x10101004, 0x10101005, 0x10101006, 0x10101007
+    .long 0x10101008, 0x10101009, 0x1010100A, 0x1010100B
+    .long 0x1010100C, 0x1010100D, 0x1010100E, 0x1010100F
+
+
+.section __TEXT,__text,regular,pure_instructions
+
+.globl _ppc_brightness_G4
+.align 3
+_ppc_brightness_G4:
+
+
+;; PowerPC Altivec code
+    srwi    r5,r5,2
+    mtctr   r5
+
+;;vrsave
+    mfspr   r11,256
+    lis     r12,0xCFFC
+    mtspr   256,r12
+
+        mflr r0
+        bcl 20,31,"L00000000001$pb"
+"L00000000001$pb":
+        mflr r10
+        mtlr r0
+
+    addis   r9,r10,ha16(vectorZERO-"L00000000001$pb")
+    addi    r9,r9,lo16(vectorZERO-"L00000000001$pb")
+    
+    vxor    v0,v0,v0 ;; V0 = NULL vector
+
+    addi    r9,r9,16
+    lvx     v10,0,r9
+    addi    r9,r9,16
+    lvx     v11,0,r9
+    addi    r9,r9,16
+    lvx     v12,0,r9
+    addi    r9,r9,16
+    lvx     v13,0,r9
+
+    addis   r9,r10,ha16(vectortmpwork-"L00000000001$pb")
+    addi    r9,r9,lo16(vectortmpwork-"L00000000001$pb")
+    stw     r6,0(r9)
+    li      r6,8
+    stw     r6,4(r9)
+    lvx     v9,0,r9
+    li      r9,128
+    vspltw  v8,v9,0
+    vspltw  v9,v9,1
+
+;; elt counter
+    li      r9,0
+    lis     r7,0x0F01
+    b L7
+.align 4
+L7:
+    lvx     v1,r9,r3
+
+    vperm   v4,v1,v0,v10
+    ;*********************
+     add r10,r9,r3
+    ;*********************
+    vperm   v5,v1,v0,v11
+    vperm   v6,v1,v0,v12
+    vperm   v7,v1,v0,v13
+
+    vmulouh  v4,v4,v8
+    ;*********************
+     dst     r10,r7,3
+    ;*********************
+    vmulouh  v5,v5,v8
+    vmulouh  v6,v6,v8
+    vmulouh  v7,v7,v8
+    vsrw     v4,v4,v9
+    vsrw     v5,v5,v9
+    vsrw     v6,v6,v9
+    vsrw     v7,v7,v9 
+    
+    vpkuwus v4,v4,v5
+    vpkuwus v6,v6,v7
+    vpkuhus v1,v4,v6
+
+    stvx    v1,r9,r4
+    addi    r9,r9,16
+
+    bdnz L7
+
+    mtspr   256,r11
+    blr
+
+
+.globl _ppc_brightness_G5
+.align 3
+_ppc_brightness_G5:
+
+;; PowerPC Altivec G5 code
+    srwi    r5,r5,2
+    mtctr   r5
+
+;;vrsave
+    mfspr   r11,256
+    lis     r12,0xCFFC
+    mtspr   256,r12
+
+        mflr r0
+        bcl 20,31,"L00000000002$pb"
+"L00000000002$pb":
+        mflr r10
+        mtlr r0
+
+    addis   r9,r10,ha16(vectorZERO-"L00000000002$pb")
+    addi    r9,r9,lo16(vectorZERO-"L00000000002$pb")
+    
+    vxor    v0,v0,v0 ;; V0 = NULL vector
+
+    addi    r9,r9,16
+    lvx     v10,0,r9
+    addi    r9,r9,16
+    lvx     v11,0,r9
+    addi    r9,r9,16
+    lvx     v12,0,r9
+    addi    r9,r9,16
+    lvx     v13,0,r9
+
+    addis   r9,r10,ha16(vectortmpwork-"L00000000002$pb")
+    addi    r9,r9,lo16(vectortmpwork-"L00000000002$pb")
+    stw     r6,0(r9)
+    li      r6,8
+    stw     r6,4(r9)
+    lvx     v9,0,r9
+    li      r9,128
+    vspltw  v8,v9,0
+    vspltw  v9,v9,1
+
+;; elt counter
+    li      r9,0
+    lis     r7,0x0F01
+    b L6
+.align 4
+L6:
+    lvx     v1,r9,r3
+
+    vperm   v4,v1,v0,v10
+    ;*********************
+    add r10,r9,r3
+    ;*********************
+    vperm   v5,v1,v0,v11
+    vperm   v6,v1,v0,v12
+    vperm   v7,v1,v0,v13
+
+    vmulouh  v4,v4,v8
+    vmulouh  v5,v5,v8
+    vmulouh  v6,v6,v8
+    vmulouh  v7,v7,v8
+    vsrw     v4,v4,v9
+    vsrw     v5,v5,v9
+    vsrw     v6,v6,v9
+    vsrw     v7,v7,v9 
+    
+    vpkuwus v4,v4,v5
+    vpkuwus v6,v6,v7
+    vpkuhus v1,v4,v6
+
+    stvx    v1,r9,r4
+    addi    r9,r9,16
+
+    bdnz L6
+
+    mtspr   256,r11
+    blr
+
+
+.globl _ppc_brightness_generic
+.align 3
+_ppc_brightness_generic:
+    lis   r12,0x00FF
+    ori   r12,r12,0x00FF
+    subi  r3,r3,4
+    subi  r4,r4,4
+    mtctr r5
+    b L1
+.align 4
+L1:
+    lwzu  r7,4(r3)
+
+    rlwinm  r8,r7,16,24,31
+    rlwinm  r9,r7,24,24,31
+    mullw   r8,r8,r6
+    rlwinm  r10,r7,0,24,31
+    mullw   r9,r9,r6
+    srwi    r8,r8,8
+    mullw   r10,r10,r6
+    srwi    r9,r9,8
+
+    rlwinm. r11,r8,0,0,23
+    beq     L2
+    li      r8,0xFF
+L2:
+    srwi    r10,r10,8
+    rlwinm. r11,r9,0,0,23
+    beq     L3
+    li      r9,0xFF
+L3:
+    rlwinm  r7,r8,16,8,15
+    rlwinm. r11,r10,0,0,23
+    beq     L4
+    li      r10,0xFF
+L4:
+    rlwimi  r7,r9,8,16,23
+    rlwimi  r7,r10,0,24,31
+
+    stwu    r7,4(r4)
+    bdnz L1
+
+    blr
+
+
+
+.static_data
+.align 4
+vectortmpwork:
+    .long 0,0,0,0
+
diff -urN xine-lib-1.2.11/src/post/goom/ppc_zoom_ultimate.s xine-lib-1.2/src/post/goom/ppc_zoom_ultimate.s
--- xine-lib-1.2.11/src/post/goom/ppc_zoom_ultimate.s	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/post/goom/ppc_zoom_ultimate.s	2022-01-15 22:03:19.597547225 +0100
@@ -0,0 +1,323 @@
+; PowerPC optimized zoom for Goom
+; © 2001-2003 Guillaume Borios
+; This Source Code is released under the terms of the General Public License
+
+; Change log :
+; 21 Dec 2003 : Use of altivec is now determined with a parameter
+
+; Section definition : We use a read only section
+.text
+
+; name of the function to call by C program : ppc_zoom
+; We declare this label as a global to extend its scope outside this file
+.globl _ppc_zoom_generic
+.globl _ppc_zoom_G4
+
+; Description :
+; This routine dynamically computes and applies a zoom filter
+
+; parameters :
+; r3  <=> unsigned int sizeX (in pixels)
+; r4  <=> unsigned int sizeY (in pixels)
+; r5  <=> unsigned int * frompixmap
+; r6  <=> unsigned int * topixmap
+; r7  <=> unsigned int * brutS
+; r8  <=> unsigned int * brutD
+; r9  <=> unsigned int buffratio
+; r10 <=> int [16][16] precalccoeffs
+
+; globals after init
+; r5  <=> frompixmap - 1 byte needed for preincremental fetch (replaces r5)
+; r6  <=> topixmap - 1 byte needed for preincremental fetch (replaces r6)
+; r3 <=> ax = x max in 16th of pixels (replaces old r3)
+; r4 <=> ay = y max in 16th of pixels (replaces old r4)
+; r20 <=> row size in bytes
+; r12 <=> 0xFF00FF (mask for parallel 32 bits pixs computing)
+; r30 <=> brutS - 1 byte needed for preincremental fetch (replaces r7)
+; r31 <=> brutD - 1 byte needed for preincremental fetch (replaces r8)
+
+; ABI notes :
+; r1 is the Stack Pointer (SP) => Do not use
+; r13..r31 are non-volatiles => Do not use
+
+_ppc_zoom_generic:
+
+; Saves the used non volatile registers in the Mach-O stack s Red-Zone
+stmw 	r18,-56(r1)
+
+; init
+li      r18,0		; Default value if out of range : 0 (Black)
+mr      r11,r10
+lis     r12,0xFF
+mullw   r2,r3,r4	; Number of pixels to compute
+subi    r30,r8,0
+slwi	r20,r3,2
+srawi   r19,r20,2
+ori     r12,r12,0xFF
+subi    r3,r3,1
+subi    r4,r4,1
+mtspr	ctr,r2		; Init the loop count (one loop per pixel computed)
+subi    r31,r7,0
+subi    r6,r6,4
+slwi	r3,r3,4
+slwi	r4,r4,4
+
+;pre init for loop
+lwz	r2,0(r31)    ; px
+lwz	r29,4(r31)   ; py
+lwz	r8,0(r30)    ; px2
+lwz	r10,4(r30)   ; py2
+
+b       L1
+.align  5
+L1:
+
+; computes dynamically the position to fetch
+sub     r8,r8,r2
+sub     r10,r10,r29
+mullw   r8,r8,r9
+addi    r31,r31,8
+mullw   r10,r10,r9
+addi    r30,r30,8
+
+srawi   r8,r8,16
+srawi   r10,r10,16
+add     r2,r2,r8
+add     r29,r29,r10
+
+; if px>ax or py>ay goto outofrange
+; computes the attenuation coeffs and the original point address
+rlwinm  r10,r2,6,28-6,31-6 ; r10 <- (r2 << 2) & 0x000002D0   (r10=(r2%16)*4*16)
+cmpl    cr4,0,r2,r3
+rlwimi  r10, r29, 2, 28-2, 31-2 ; r10 <- ((r29 << 2) & 0x0000002D) | (r10 & !0x0000002D)      (r10=(r10%16)*4 | r10)
+cmpl    cr7,0,r29,r4
+srawi   r29,r29,4     ; pos computing
+bge-	cr4,L4
+srawi   r2,r2,4       ; pos computing
+mullw   r29, r29,r19  ; pos computing
+bge-	cr7,L4
+
+; Channels notation : 00112233 (AARRVVBB)
+
+add     r2,r2,r29    		; pos computing
+lwzx    r10,r11,r10		; Loads coefs
+slwi    r2,r2,2      		; pos computing
+add	r2,r2,r5     		; pos computing
+rlwinm  r21,r10,0,24,31	        ; Isolates coef1 (??????11 -> 00000011)
+lwz	r25,0(r2)		; Loads col1 -> r25
+lwz	r26,4(r2)		; Loads col2 -> r26
+rlwinm  r22,r10,24,24,31	; Isolates coef2 (????22?? -> 00000022)
+rlwinm  r23,r10,16,24,31	; Isolates coef3 (??33???? -> 00000033)
+add	r2,r2,r20		; Adds one line for future load of col3 and col4
+and	r8, r25,r12		; Masks col1 channels 1 & 3 : 0x00XX00XX
+rlwinm  r24,r10,8,24,31		; Isolates coef4 (44?????? -> 00000044)
+andi.	r25,r25,0xFF00		; Masks col1 channel 2 : 0x0000XX00
+mullw	r8, r8, r21		; Applies coef1 on col1 channels 1 & 3
+
+
+; computes final pixel color
+and	r10,r26,r12		; Masks col2 channels 1 & 3 : 0x00XX00XX
+lwz	r27,0(r2)		; Loads col3 -> r27
+mullw	r10,r10,r22		; Applies coef2 on col2 channels 1 & 3
+mullw	r25,r25,r21		; Applies coef1 on col1 channel 2
+andi.	r29,r26,0xFF00		; Masks col2 channel 2 : 0x0000XX00
+mullw	r29,r29,r22		; Applies coef2 on col2 channel 2
+lwz	r28,4(r2)		; Loads col4 -> r28
+add	r8 ,r8 ,r10		; Adds col1 & col2 channels 1 & 3
+and	r10,r27,r12		; Masks col3 channels 1 & 3 : 0x00XX00XX
+add	r25,r25,r29		; Adds col1 & col2 channel 2
+mullw	r10,r10,r23		; Applies coef3 on col3 channels 1 & 3
+andi.	r29,r27,0xFF00		; Masks col3 channel 2 : 0x0000XX00
+mullw	r29,r29,r23		; Applies coef3 on col3 channel 2
+lwz	r2,0(r31)		; px
+add	r7 ,r8 ,r10		; Adds col3 to (col1 + col2) channels 1 & 3
+and	r10,r28,r12		; Masks col4 channels 1 & 3 : 0x00XX00XX
+mullw	r10,r10,r24		; Applies coef4 on col4 channels 1 & 3
+add	r25,r25,r29		; Adds col 3 to (col1 + col2) channel 2
+lwz 	r8,0(r30)    		; px2
+andi.	r28,r28,0xFF00		; Masks col4 channel 2 : 0x0000XX00
+add	r7 ,r7 ,r10		; Adds col4 to (col1 + col2 + col3) channels 1 & 3
+lwz	r10,4(r30)   		; py2
+mullw	r28,r28,r24		; Applies coef4 on col4 channel 2
+srawi	r7, r7, 8		; (sum of channels 1 & 3) >> 8
+lwz	r29,4(r31)              ; py
+add	r25,r25,r28		; Adds col 4 to (col1 + col2 + col3) channel 2
+rlwimi  r7, r25, 24, 16, 23	; (((sum of channels 2) >> 8 ) & 0x0000FF00) | ((sum of channels 1 and 3) & 0xFFFF00FF)
+stwu	r7,4(r6)		; Stores the computed pixel
+bdnz	L1			; Iterate again if needed
+b       L3	;goto end	; If not, returns from the function
+
+
+; if out of range
+L4:
+stwu	r18,4(r6)
+lwz	r8,0(r30)    ; px2
+lwz	r10,4(r30)   ; py2
+lwz	r2,0(r31)    ; px
+lwz	r29,4(r31)   ; py
+bdnz	L1
+
+
+L3:
+
+; Restore saved registers and return
+lmw	r18,-56(r1)
+blr
+
+
+
+
+
+
+
+
+_ppc_zoom_G4:
+
+; Saves the used non volatile registers in the Mach-O stack s Red-Zone
+stmw 	r17,-60(r1)
+
+; init
+li      r18,0		; Default value if out of range : 0 (Black)
+mr      r11,r10
+lis     r12,0xFF
+mullw   r2,r3,r4	; Number of pixels to compute
+subi    r30,r8,0
+slwi	r20,r3,2
+srawi   r19,r20,2
+ori     r12,r12,0xFF
+subi    r3,r3,1
+subi    r4,r4,1
+mtspr	ctr,r2		; Init the loop count (one loop per pixel computed)
+subi    r31,r7,0
+subi    r6,r6,4
+slwi	r3,r3,4
+slwi	r4,r4,4
+
+;pre init for loop
+lwz	r2,0(r31)    ; px
+lwz	r29,4(r31)   ; py
+lwz	r8,0(r30)    ; px2
+lwz	r10,4(r30)   ; py2
+
+;*********************
+lis     r17,0x0F01
+
+b       L100
+.align  5
+L100:
+
+addi    r6,r6,4
+
+; Optimization to ensure the destination buffer
+; won't be loaded into the data cache
+rlwinm. r0,r6,0,27,31
+bne+    L500
+dcbz    0,r6
+;dcba    0,r6
+L500:
+
+; computes dynamically the position to fetch
+;mullw   r8,r8,r29
+;mullw   r2,r2,r29
+;add     r2,r8,r2
+;srawi   r2,r2,17
+
+sub     r8,r8,r2
+sub     r10,r10,r29
+mullw   r8,r8,r9
+addi    r31,r31,8
+mullw   r10,r10,r9
+addi    r30,r30,8
+
+dst     r30,r17,0
+
+srawi    r8,r8,16
+srawi    r10,r10,16
+add     r2,r2,r8
+add     r29,r29,r10
+
+dst     r31,r17,1
+
+; if px>ax or py>ay goto outofrange
+; computes the attenuation coeffs and the original point address
+rlwinm  r10,r2,6,28-6,31-6 ; r10 <- (r2 << 2) & 0x000002D0   (r10=(r2%16)*4*16)
+cmpl    cr4,0,r2,r3
+rlwimi  r10, r29, 2, 28-2, 31-2 ; r10 <- ((r29 << 2) & 0x0000002D) | (r10 & !0x0000002D)      (r10=(r29%16)*4 | r10)
+cmpl    cr7,0,r29,r4
+srawi   r29,r29,4     ; pos computing
+bge-	cr4,L400
+srawi   r2,r2,4       ; pos computing
+mullw   r29, r29,r19  ; pos computing
+bge-	cr7,L400
+
+; Channels notation : 00112233 (AARRVVBB)
+
+add     r2,r2,r29    		; pos computing
+lwzx    r10,r11,r10		; Loads coefs
+slwi    r2,r2,2      		; pos computing
+add	r2,r2,r5     		; pos computing
+rlwinm  r21,r10,0,24,31	        ; Isolates coef1 (??????11 -> 00000011)
+lwz	r25,0(r2)		; Loads col1 -> r25
+lwz	r26,4(r2)		; Loads col2 -> r26
+rlwinm  r22,r10,24,24,31	; Isolates coef2 (????22?? -> 00000022)
+rlwinm  r23,r10,16,24,31	; Isolates coef3 (??33???? -> 00000033)
+add	r2,r2,r20		; Adds one line for future load of col3 and col4
+and	r8, r25,r12		; Masks col1 channels 1 & 3 : 0x00XX00XX
+rlwinm  r24,r10,8,24,31		; Isolates coef4 (44?????? -> 00000044)
+dst     r2,r17,2
+rlwinm  r25,r25,0,16,23		; Masks col1 channel 2 : 0x0000XX00
+;andi.	r25,r25,0xFF00		; Masks col1 channel 2 : 0x0000XX00
+mullw	r8, r8, r21		; Applies coef1 on col1 channels 1 & 3
+
+
+; computes final pixel color
+and	r10,r26,r12		; Masks col2 channels 1 & 3 : 0x00XX00XX
+lwz	r27,0(r2)		; Loads col3 -> r27
+mullw	r10,r10,r22		; Applies coef2 on col2 channels 1 & 3
+mullw	r25,r25,r21		; Applies coef1 on col1 channel 2
+rlwinm  r29,r26,0,16,23		; Masks col2 channel 2 : 0x0000XX00
+;andi.	r29,r26,0xFF00		; Masks col2 channel 2 : 0x0000XX00
+mullw	r29,r29,r22		; Applies coef2 on col2 channel 2
+lwz	r28,4(r2)		; Loads col4 -> r28
+add	r8 ,r8 ,r10		; Adds col1 & col2 channels 1 & 3
+and	r10,r27,r12		; Masks col3 channels 1 & 3 : 0x00XX00XX
+add	r25,r25,r29		; Adds col1 & col2 channel 2
+mullw	r10,r10,r23		; Applies coef3 on col3 channels 1 & 3
+rlwinm  r29,r27,0,16,23		; Masks col3 channel 2 : 0x0000XX00
+;andi.	r29,r27,0xFF00		; Masks col3 channel 2 : 0x0000XX00
+mullw	r29,r29,r23		; Applies coef3 on col3 channel 2
+lwz	r2,0(r31)		; px
+add	r7 ,r8 ,r10		; Adds col3 to (col1 + col2) channels 1 & 3
+and	r10,r28,r12		; Masks col4 channels 1 & 3 : 0x00XX00XX
+mullw	r10,r10,r24		; Applies coef4 on col4 channels 1 & 3
+add	r25,r25,r29		; Adds col 3 to (col1 + col2) channel 2
+lwz 	r8,0(r30)    		; px2
+rlwinm  r28,r28,0,16,23		; Masks col4 channel 2 : 0x0000XX00
+;andi.	r28,r28,0xFF00		; Masks col4 channel 2 : 0x0000XX00
+add	r7 ,r7 ,r10		; Adds col4 to (col1 + col2 + col3) channels 1 & 3
+lwz	r10,4(r30)   		; py2
+mullw	r28,r28,r24		; Applies coef4 on col4 channel 2
+srawi	r7, r7, 8		; (sum of channels 1 & 3) >> 8
+lwz	r29,4(r31)              ; py
+add	r25,r25,r28		; Adds col 4 to (col1 + col2 + col3) channel 2
+rlwimi  r7, r25, 24, 16, 23	; (((sum of channels 2) >> 8 ) & 0x0000FF00) | ((sum of channels 1 and 3) & 0xFFFF00FF)
+stw	r7,0(r6)		; Stores the computed pixel
+bdnz	L100			; Iterate again if needed
+b       L300	;goto end	; If not, returns from the function
+
+
+; if out of range
+L400:
+stw	r18,0(r6)
+lwz	r8,0(r30)    ; px2
+lwz	r10,4(r30)   ; py2
+lwz	r2,0(r31)    ; px
+lwz	r29,4(r31)   ; py
+bdnz	L100
+
+
+L300:
+
+; Restore saved registers and return
+lmw	r17,-60(r1)
+blr
diff -urN xine-lib-1.2.11/src/post/mosaico/mosaico.c xine-lib-1.2/src/post/mosaico/mosaico.c
--- xine-lib-1.2.11/src/post/mosaico/mosaico.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/mosaico/mosaico.c	2022-01-15 22:03:19.605547259 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -372,6 +372,7 @@
                                           xine_video_port_t **video_target)
 {
   post_mosaico_t       *this = calloc(1, sizeof(post_mosaico_t));
+  mosaico_pip_t        *pip;
   post_in_t            *input;
   post_out_t           *output;
   post_video_port_t    *port;
@@ -399,9 +400,15 @@
     return NULL;
   }
 
+  pip = calloc((inputs - 1), sizeof(mosaico_pip_t));
+  if (!pip) {
+    free(this);
+    return NULL;
+  }
+
   _x_post_init(&this->post, 0, inputs);
 
-  this->pip       = (mosaico_pip_t *)calloc((inputs - 1), sizeof(mosaico_pip_t));
+  this->pip       = pip;
   this->pip_count = inputs - 1;
 
   pthread_cond_init(&this->vpts_limit_changed, NULL);
diff -urN xine-lib-1.2.11/src/post/planar/pp.c xine-lib-1.2/src/post/planar/pp.c
--- xine-lib-1.2.11/src/post/planar/pp.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/post/planar/pp.c	2022-01-15 22:03:19.590547196 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -26,8 +26,6 @@
 
 #include "planar.h"
 
-#include <config.h>
-
 #include <xine/xine_internal.h>
 #include <xine/post.h>
 #include <xine/xineutils.h>
diff -urN xine-lib-1.2.11/src/spu_dec/spu_decoder.c xine-lib-1.2/src/spu_dec/spu_decoder.c
--- xine-lib-1.2.11/src/spu_dec/spu_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/spu_dec/spu_decoder.c	2022-01-15 22:03:19.631547369 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * Copyright (C) James Courtier-Dutton James@superbug.demon.co.uk - July 2001
  *
@@ -232,6 +232,12 @@
   video_overlay_event_t *overlay_event = calloc(1, sizeof(video_overlay_event_t));
   vo_overlay_t        *overlay = calloc(1, sizeof(vo_overlay_t));
 
+  if (!overlay || !overlay_event) {
+    free(overlay_event);
+    free(overlay);
+    return;
+  }
+
   /* FIXME: Watch out for threads. We should really put a lock on this
    * because events is a different thread than decode_data */
 
diff -urN xine-lib-1.2.11/src/spu_dec/spudvb_decoder.c xine-lib-1.2/src/spu_dec/spudvb_decoder.c
--- xine-lib-1.2.11/src/spu_dec/spudvb_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/spu_dec/spudvb_decoder.c	2022-01-15 22:03:19.618547314 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2020 the xine project
+ * Copyright (C) 2010-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -1091,7 +1091,7 @@
           }
         }
         /* All DVB subs I have seen so far use same color matrix as main video. */
-        _X_SET_CLUT_CM (&this->dvbsub.colours[reg->CLUT_id * 256].u32, 4);
+        _X_SET_CLUT_CM (&this->dvbsub.colours[reg->CLUT_id * 256], 4);
         this->stream->osd_renderer->set_palette( reg->osd,
                                                  &this->dvbsub.colours[reg->CLUT_id * 256].u32,
                                                  &this->dvbsub.trans[reg->CLUT_id * 256]);
diff -urN xine-lib-1.2.11/src/spu_dec/sputext_decoder.c xine-lib-1.2/src/spu_dec/sputext_decoder.c
--- xine-lib-1.2.11/src/spu_dec/sputext_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/spu_dec/sputext_decoder.c	2022-01-15 22:03:19.621547327 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -249,10 +249,12 @@
 
   /* initialize decoder if needed */
   if( this->unscaled ) {
-    if( this->width != this->stream->video_out->get_property(this->stream->video_out,
-                                                             VO_PROP_WINDOW_WIDTH) ||
-        this->height != this->stream->video_out->get_property(this->stream->video_out,
-                                                             VO_PROP_WINDOW_HEIGHT) ||
+    int win_width = this->stream->video_out->get_property(this->stream->video_out,
+                                                          VO_PROP_WINDOW_WIDTH);
+    int win_height = this->stream->video_out->get_property(this->stream->video_out,
+                                                           VO_PROP_WINDOW_HEIGHT);
+
+    if( this->width != win_width || this->height != win_height ||
         !this->img_duration || !this->osd ) {
 
       int width = 0, height = 0;
@@ -261,10 +263,8 @@
                                       &width, &height, &this->img_duration );
       if( width && height ) {
 
-        this->width = this->stream->video_out->get_property(this->stream->video_out,
-                                                             VO_PROP_WINDOW_WIDTH);
-        this->height = this->stream->video_out->get_property(this->stream->video_out,
-                                                             VO_PROP_WINDOW_HEIGHT);
+        this->width = win_width;
+        this->height = win_height;
 
         if(!this->osd || (this->width && this->height)) {
 
@@ -1127,14 +1127,7 @@
 static void sputext_class_dispose (spu_decoder_class_t *class_gen) {
   sputext_class_t *this = (sputext_class_t *)class_gen;
 
-  this->xine->config->unregister_callback(this->xine->config,
-					  "subtitles.separate.src_encoding");
-  this->xine->config->unregister_callback(this->xine->config,
-					  "subtitles.separate.subtitle_size");
-  this->xine->config->unregister_callback(this->xine->config,
-					  "subtitles.separate.vertical_offset");
-  this->xine->config->unregister_callback(this->xine->config,
-					  "subtitles.separate.use_unscaled_osd");
+  this->xine->config->unregister_callbacks (this->xine->config, NULL, NULL, this, sizeof (*this));
 
   pthread_mutex_destroy(&this->font_name_mutex);
   _x_freep(&this->font);
diff -urN xine-lib-1.2.11/src/vdr/input_vdr.c xine-lib-1.2/src/vdr/input_vdr.c
--- xine-lib-1.2.11/src/vdr/input_vdr.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/vdr/input_vdr.c	2022-01-15 22:03:19.589547192 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2003-2020 the xine project
+ * Copyright (C) 2003-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -29,6 +29,12 @@
  * frames as if they had perfectly consecutive time stamps. We still need to register
  * first discontinuity early because server will wait for it, and video decoder may
  * delay it -> freeze.
+ * Issue #2: xine engine now uses a more efficient buffering scheme. Audio fifo
+ * default now is 700*2k with soft start vs 230*8k fixed. This is needed to support
+ * modern fragment streaming protocols. It also helps live DVB radio, and it speeds
+ * up seeking. However, vdr seems to freeze from it sometimes. We work around it
+ * by using fifo->buffer_pool_size_alloc (fifo, need), and by registering a dummy
+ * alloc callback that disables file_buf_ctrl soft start.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -197,6 +203,11 @@
   uint8_t             seek_buf[BUF_SIZE];
 };
 
+static void input_vdr_dummy (fifo_buffer_t *fifo, void *data) {
+  (void)fifo;
+  (void)data;
+}
+
 static void trick_speed_send_event (vdr_input_plugin_t *this, int mode) {
   xine_event_t event;
 
@@ -1762,7 +1773,7 @@
   if (todo < 0)
     return NULL;
 
-  buf = fifo->buffer_pool_size_alloc(fifo, todo);
+  buf = fifo->buffer_pool_size_alloc (fifo, todo);
 
   buf->content = buf->mem;
   buf->type = BUF_DEMUX_BLOCK;
@@ -1946,6 +1957,12 @@
 
   pthread_mutex_destroy (&this->metronom.mutex);
 
+  /* see comment above */
+  if (this->stream->audio_fifo)
+    this->stream->audio_fifo->unregister_alloc_cb (this->stream->audio_fifo, input_vdr_dummy);
+  if (this->stream->video_fifo)
+    this->stream->video_fifo->unregister_alloc_cb (this->stream->video_fifo, input_vdr_dummy);
+
   free(this);
 }
 
@@ -2752,6 +2769,12 @@
   if (this->event_queue)
     xine_event_create_listener_thread(this->event_queue, event_handler, this);
 
+  /* see comment above */
+  if (this->stream->audio_fifo)
+    this->stream->audio_fifo->register_alloc_cb (this->stream->audio_fifo, input_vdr_dummy, this);
+  if (this->stream->video_fifo)
+    this->stream->video_fifo->register_alloc_cb (this->stream->video_fifo, input_vdr_dummy, this);
+
   /* init metronom */
   this->metronom.input = this;
   this->metronom.metronom.set_audio_rate             = vdr_metronom_set_audio_rate;
diff -urN xine-lib-1.2.11/src/video_dec/bitplane.c xine-lib-1.2/src/video_dec/bitplane.c
--- xine-lib-1.2.11/src/video_dec/bitplane.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/bitplane.c	2022-01-15 22:03:19.615547301 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2004-2018 the xine project
+ * Copyright (C) 2004-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -253,6 +253,8 @@
   int j                                 = 0;
 
   uint8_t *uncompressed                 = calloc(1, size_uncompressed );
+  if (!uncompressed)
+    return NULL;
 
   while ( i < size_compressed &&
           pixel_ptr < size_uncompressed ) {
diff -urN xine-lib-1.2.11/src/video_dec/libjpeg.c xine-lib-1.2/src/video_dec/libjpeg.c
--- xine-lib-1.2.11/src/video_dec/libjpeg.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libjpeg.c	2022-01-15 22:03:19.620547323 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2003-2019 the xine project
+ * Copyright (C) 2003-2021 the xine project
  * Copyright (C) 2012      Petri Hintukainen <phintuka@users.sourceforge.net>
  *
  * This file is part of xine, a free video player.
@@ -160,6 +160,7 @@
 
     _x_stream_info_set(this->stream, XINE_STREAM_INFO_VIDEO_WIDTH,  cinfo.image_width);
     _x_stream_info_set(this->stream, XINE_STREAM_INFO_VIDEO_HEIGHT, cinfo.image_height);
+    _x_meta_info_set_utf8(this->stream, XINE_META_INFO_VIDEOCODEC, "JPEG");
 
     lprintf("header parsed\n");
 
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2/cpu_state.c xine-lib-1.2/src/video_dec/libmpeg2/cpu_state.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2/cpu_state.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2/cpu_state.c	2022-01-15 22:03:19.604547255 +0100
@@ -33,7 +33,7 @@
 void (* mpeg2_cpu_state_save) (cpu_state_t * state) = NULL;
 void (* mpeg2_cpu_state_restore) (cpu_state_t * state) = NULL;
 
-#if defined(ARCH_X86)
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
 static void state_restore_mmx (cpu_state_t * state)
 {
     (void)state;
@@ -170,7 +170,7 @@
 
 void mpeg2_cpu_state_init (uint32_t mm_accel)
 {
-#if defined(ARCH_X86)
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
     if (mm_accel & MM_ACCEL_X86_MMX) {
 	mpeg2_cpu_state_restore = state_restore_mmx;
     }
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2/idct.c xine-lib-1.2/src/video_dec/libmpeg2/idct.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2/idct.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2/idct.c	2022-01-15 22:03:19.594547213 +0100
@@ -282,7 +282,7 @@
 {
     mpeg2_zero_block = mpeg2_zero_block_c;
 
-#if defined(ARCH_X86)
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
     if (mm_accel & MM_ACCEL_X86_MMXEXT) {
 #ifdef LOG
 	fprintf (stderr, "Using MMXEXT for IDCT transform\n");
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2/idct_mmx.c xine-lib-1.2/src/video_dec/libmpeg2/idct_mmx.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2/idct_mmx.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2/idct_mmx.c	2022-01-15 22:03:19.632547373 +0100
@@ -23,7 +23,7 @@
 
 #include "config.h"
 
-#if defined(ARCH_X86)
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
 
 #include <inttypes.h>
 
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2/motion_comp.c xine-lib-1.2/src/video_dec/libmpeg2/motion_comp.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2/motion_comp.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2/motion_comp.c	2022-01-15 22:03:19.619547318 +0100
@@ -42,7 +42,7 @@
     }
 #endif
 
-#if defined(ARCH_X86)
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
     if (mm_accel & MM_ACCEL_X86_MMXEXT) {
 #ifdef LOG
 	fprintf (stderr, "Using MMXEXT for motion compensation\n");
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2/motion_comp_mmx.c xine-lib-1.2/src/video_dec/libmpeg2/motion_comp_mmx.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2/motion_comp_mmx.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2/motion_comp_mmx.c	2022-01-15 22:03:19.607547268 +0100
@@ -23,7 +23,7 @@
 
 #include "config.h"
 
-#if defined(ARCH_X86)
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
 
 #include <inttypes.h>
 
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2/xine_mpeg2_decoder.c xine-lib-1.2/src/video_dec/libmpeg2/xine_mpeg2_decoder.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2/xine_mpeg2_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2/xine_mpeg2_decoder.c	2022-01-15 22:03:19.616547306 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/include/sse.h xine-lib-1.2/src/video_dec/libmpeg2new/include/sse.h
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/include/sse.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/include/sse.h	2022-01-15 22:03:19.620547323 +0100
@@ -0,0 +1,256 @@
+/*
+ * sse.h
+ * Copyright (C) 1999-2003 R. Fisher
+ *
+ * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+ * See http://libmpeg2.sourceforge.net/ for updates.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+typedef	union {
+	float			sf[4];	/* Single-precision (32-bit) value */
+} ATTR_ALIGN(16) sse_t;	/* On a 16 byte (128-bit) boundary */
+
+
+#define	sse_i2r(op, imm, reg) \
+	__asm__ __volatile__ (#op " %0, %%" #reg \
+			      : /* nothing */ \
+			      : "X" (imm) )
+
+#define	sse_m2r(op, mem, reg) \
+	__asm__ __volatile__ (#op " %0, %%" #reg \
+			      : /* nothing */ \
+			      : "X" (mem))
+
+#define	sse_r2m(op, reg, mem) \
+	__asm__ __volatile__ (#op " %%" #reg ", %0" \
+			      : "=X" (mem) \
+			      : /* nothing */ )
+
+#define	sse_r2r(op, regs, regd) \
+	__asm__ __volatile__ (#op " %" #regs ", %" #regd)
+
+#define	sse_r2ri(op, regs, regd, imm) \
+	__asm__ __volatile__ (#op " %0, %%" #regs ", %%" #regd \
+			      : /* nothing */ \
+			      : "X" (imm) )
+
+#define	sse_m2ri(op, mem, reg, subop) \
+	__asm__ __volatile__ (#op " %0, %%" #reg ", " #subop \
+			      : /* nothing */ \
+			      : "X" (mem))
+
+
+#define	movaps_m2r(var, reg)	sse_m2r(movaps, var, reg)
+#define	movaps_r2m(reg, var)	sse_r2m(movaps, reg, var)
+#define	movaps_r2r(regs, regd)	sse_r2r(movaps, regs, regd)
+
+#define	movntps_r2m(xmmreg, var)	sse_r2m(movntps, xmmreg, var)
+
+#define	movups_m2r(var, reg)	sse_m2r(movups, var, reg)
+#define	movups_r2m(reg, var)	sse_r2m(movups, reg, var)
+#define	movups_r2r(regs, regd)	sse_r2r(movups, regs, regd)
+
+#define	movhlps_r2r(regs, regd)	sse_r2r(movhlps, regs, regd)
+
+#define	movlhps_r2r(regs, regd)	sse_r2r(movlhps, regs, regd)
+
+#define	movhps_m2r(var, reg)	sse_m2r(movhps, var, reg)
+#define	movhps_r2m(reg, var)	sse_r2m(movhps, reg, var)
+
+#define	movlps_m2r(var, reg)	sse_m2r(movlps, var, reg)
+#define	movlps_r2m(reg, var)	sse_r2m(movlps, reg, var)
+
+#define	movss_m2r(var, reg)	sse_m2r(movss, var, reg)
+#define	movss_r2m(reg, var)	sse_r2m(movss, reg, var)
+#define	movss_r2r(regs, regd)	sse_r2r(movss, regs, regd)
+
+#define	shufps_m2r(var, reg, index)	sse_m2ri(shufps, var, reg, index)
+#define	shufps_r2r(regs, regd, index)	sse_r2ri(shufps, regs, regd, index)
+
+#define	cvtpi2ps_m2r(var, xmmreg)	sse_m2r(cvtpi2ps, var, xmmreg)
+#define	cvtpi2ps_r2r(mmreg, xmmreg)	sse_r2r(cvtpi2ps, mmreg, xmmreg)
+
+#define	cvtps2pi_m2r(var, mmreg)	sse_m2r(cvtps2pi, var, mmreg)
+#define	cvtps2pi_r2r(xmmreg, mmreg)	sse_r2r(cvtps2pi, mmreg, xmmreg)
+
+#define	cvttps2pi_m2r(var, mmreg)	sse_m2r(cvttps2pi, var, mmreg)
+#define	cvttps2pi_r2r(xmmreg, mmreg)	sse_r2r(cvttps2pi, mmreg, xmmreg)
+
+#define	cvtsi2ss_m2r(var, xmmreg)	sse_m2r(cvtsi2ss, var, xmmreg)
+#define	cvtsi2ss_r2r(reg, xmmreg)	sse_r2r(cvtsi2ss, reg, xmmreg)
+
+#define	cvtss2si_m2r(var, reg)		sse_m2r(cvtss2si, var, reg)
+#define	cvtss2si_r2r(xmmreg, reg)	sse_r2r(cvtss2si, xmmreg, reg)
+
+#define	cvttss2si_m2r(var, reg)		sse_m2r(cvtss2si, var, reg)
+#define	cvttss2si_r2r(xmmreg, reg)	sse_r2r(cvtss2si, xmmreg, reg)
+
+#define	movmskps(xmmreg, reg) \
+	__asm__ __volatile__ ("movmskps %" #xmmreg ", %" #reg)
+
+#define	addps_m2r(var, reg)		sse_m2r(addps, var, reg)
+#define	addps_r2r(regs, regd)		sse_r2r(addps, regs, regd)
+
+#define	addss_m2r(var, reg)		sse_m2r(addss, var, reg)
+#define	addss_r2r(regs, regd)		sse_r2r(addss, regs, regd)
+
+#define	subps_m2r(var, reg)		sse_m2r(subps, var, reg)
+#define	subps_r2r(regs, regd)		sse_r2r(subps, regs, regd)
+
+#define	subss_m2r(var, reg)		sse_m2r(subss, var, reg)
+#define	subss_r2r(regs, regd)		sse_r2r(subss, regs, regd)
+
+#define	mulps_m2r(var, reg)		sse_m2r(mulps, var, reg)
+#define	mulps_r2r(regs, regd)		sse_r2r(mulps, regs, regd)
+
+#define	mulss_m2r(var, reg)		sse_m2r(mulss, var, reg)
+#define	mulss_r2r(regs, regd)		sse_r2r(mulss, regs, regd)
+
+#define	divps_m2r(var, reg)		sse_m2r(divps, var, reg)
+#define	divps_r2r(regs, regd)		sse_r2r(divps, regs, regd)
+
+#define	divss_m2r(var, reg)		sse_m2r(divss, var, reg)
+#define	divss_r2r(regs, regd)		sse_r2r(divss, regs, regd)
+
+#define	rcpps_m2r(var, reg)		sse_m2r(rcpps, var, reg)
+#define	rcpps_r2r(regs, regd)		sse_r2r(rcpps, regs, regd)
+
+#define	rcpss_m2r(var, reg)		sse_m2r(rcpss, var, reg)
+#define	rcpss_r2r(regs, regd)		sse_r2r(rcpss, regs, regd)
+
+#define	rsqrtps_m2r(var, reg)		sse_m2r(rsqrtps, var, reg)
+#define	rsqrtps_r2r(regs, regd)		sse_r2r(rsqrtps, regs, regd)
+
+#define	rsqrtss_m2r(var, reg)		sse_m2r(rsqrtss, var, reg)
+#define	rsqrtss_r2r(regs, regd)		sse_r2r(rsqrtss, regs, regd)
+
+#define	sqrtps_m2r(var, reg)		sse_m2r(sqrtps, var, reg)
+#define	sqrtps_r2r(regs, regd)		sse_r2r(sqrtps, regs, regd)
+
+#define	sqrtss_m2r(var, reg)		sse_m2r(sqrtss, var, reg)
+#define	sqrtss_r2r(regs, regd)		sse_r2r(sqrtss, regs, regd)
+
+#define	andps_m2r(var, reg)		sse_m2r(andps, var, reg)
+#define	andps_r2r(regs, regd)		sse_r2r(andps, regs, regd)
+
+#define	andnps_m2r(var, reg)		sse_m2r(andnps, var, reg)
+#define	andnps_r2r(regs, regd)		sse_r2r(andnps, regs, regd)
+
+#define	orps_m2r(var, reg)		sse_m2r(orps, var, reg)
+#define	orps_r2r(regs, regd)		sse_r2r(orps, regs, regd)
+
+#define	xorps_m2r(var, reg)		sse_m2r(xorps, var, reg)
+#define	xorps_r2r(regs, regd)		sse_r2r(xorps, regs, regd)
+
+#define	maxps_m2r(var, reg)		sse_m2r(maxps, var, reg)
+#define	maxps_r2r(regs, regd)		sse_r2r(maxps, regs, regd)
+
+#define	maxss_m2r(var, reg)		sse_m2r(maxss, var, reg)
+#define	maxss_r2r(regs, regd)		sse_r2r(maxss, regs, regd)
+
+#define	minps_m2r(var, reg)		sse_m2r(minps, var, reg)
+#define	minps_r2r(regs, regd)		sse_r2r(minps, regs, regd)
+
+#define	minss_m2r(var, reg)		sse_m2r(minss, var, reg)
+#define	minss_r2r(regs, regd)		sse_r2r(minss, regs, regd)
+
+#define	cmpps_m2r(var, reg, op)		sse_m2ri(cmpps, var, reg, op)
+#define	cmpps_r2r(regs, regd, op)	sse_r2ri(cmpps, regs, regd, op)
+
+#define	cmpeqps_m2r(var, reg)		sse_m2ri(cmpps, var, reg, 0)
+#define	cmpeqps_r2r(regs, regd)		sse_r2ri(cmpps, regs, regd, 0)
+
+#define	cmpltps_m2r(var, reg)		sse_m2ri(cmpps, var, reg, 1)
+#define	cmpltps_r2r(regs, regd)		sse_r2ri(cmpps, regs, regd, 1)
+
+#define	cmpleps_m2r(var, reg)		sse_m2ri(cmpps, var, reg, 2)
+#define	cmpleps_r2r(regs, regd)		sse_r2ri(cmpps, regs, regd, 2)
+
+#define	cmpunordps_m2r(var, reg)	sse_m2ri(cmpps, var, reg, 3)
+#define	cmpunordps_r2r(regs, regd)	sse_r2ri(cmpps, regs, regd, 3)
+
+#define	cmpneqps_m2r(var, reg)		sse_m2ri(cmpps, var, reg, 4)
+#define	cmpneqps_r2r(regs, regd)	sse_r2ri(cmpps, regs, regd, 4)
+
+#define	cmpnltps_m2r(var, reg)		sse_m2ri(cmpps, var, reg, 5)
+#define	cmpnltps_r2r(regs, regd)	sse_r2ri(cmpps, regs, regd, 5)
+
+#define	cmpnleps_m2r(var, reg)		sse_m2ri(cmpps, var, reg, 6)
+#define	cmpnleps_r2r(regs, regd)	sse_r2ri(cmpps, regs, regd, 6)
+
+#define	cmpordps_m2r(var, reg)		sse_m2ri(cmpps, var, reg, 7)
+#define	cmpordps_r2r(regs, regd)	sse_r2ri(cmpps, regs, regd, 7)
+
+#define	cmpss_m2r(var, reg, op)		sse_m2ri(cmpss, var, reg, op)
+#define	cmpss_r2r(regs, regd, op)	sse_r2ri(cmpss, regs, regd, op)
+
+#define	cmpeqss_m2r(var, reg)		sse_m2ri(cmpss, var, reg, 0)
+#define	cmpeqss_r2r(regs, regd)		sse_r2ri(cmpss, regs, regd, 0)
+
+#define	cmpltss_m2r(var, reg)		sse_m2ri(cmpss, var, reg, 1)
+#define	cmpltss_r2r(regs, regd)		sse_r2ri(cmpss, regs, regd, 1)
+
+#define	cmpless_m2r(var, reg)		sse_m2ri(cmpss, var, reg, 2)
+#define	cmpless_r2r(regs, regd)		sse_r2ri(cmpss, regs, regd, 2)
+
+#define	cmpunordss_m2r(var, reg)	sse_m2ri(cmpss, var, reg, 3)
+#define	cmpunordss_r2r(regs, regd)	sse_r2ri(cmpss, regs, regd, 3)
+
+#define	cmpneqss_m2r(var, reg)		sse_m2ri(cmpss, var, reg, 4)
+#define	cmpneqss_r2r(regs, regd)	sse_r2ri(cmpss, regs, regd, 4)
+
+#define	cmpnltss_m2r(var, reg)		sse_m2ri(cmpss, var, reg, 5)
+#define	cmpnltss_r2r(regs, regd)	sse_r2ri(cmpss, regs, regd, 5)
+
+#define	cmpnless_m2r(var, reg)		sse_m2ri(cmpss, var, reg, 6)
+#define	cmpnless_r2r(regs, regd)	sse_r2ri(cmpss, regs, regd, 6)
+
+#define	cmpordss_m2r(var, reg)		sse_m2ri(cmpss, var, reg, 7)
+#define	cmpordss_r2r(regs, regd)	sse_r2ri(cmpss, regs, regd, 7)
+
+#define	comiss_m2r(var, reg)		sse_m2r(comiss, var, reg)
+#define	comiss_r2r(regs, regd)		sse_r2r(comiss, regs, regd)
+
+#define	ucomiss_m2r(var, reg)		sse_m2r(ucomiss, var, reg)
+#define	ucomiss_r2r(regs, regd)		sse_r2r(ucomiss, regs, regd)
+
+#define	unpcklps_m2r(var, reg)		sse_m2r(unpcklps, var, reg)
+#define	unpcklps_r2r(regs, regd)	sse_r2r(unpcklps, regs, regd)
+
+#define	unpckhps_m2r(var, reg)		sse_m2r(unpckhps, var, reg)
+#define	unpckhps_r2r(regs, regd)	sse_r2r(unpckhps, regs, regd)
+
+#define	fxrstor(mem) \
+	__asm__ __volatile__ ("fxrstor %0" \
+			      : /* nothing */ \
+			      : "X" (mem))
+
+#define	fxsave(mem) \
+	__asm__ __volatile__ ("fxsave %0" \
+			      : /* nothing */ \
+			      : "X" (mem))
+
+#define	stmxcsr(mem) \
+	__asm__ __volatile__ ("stmxcsr %0" \
+			      : /* nothing */ \
+			      : "X" (mem))
+
+#define	ldmxcsr(mem) \
+	__asm__ __volatile__ ("ldmxcsr %0" \
+			      : /* nothing */ \
+			      : "X" (mem))
+
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/configure.incl xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/configure.incl
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/configure.incl	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/configure.incl	2022-01-15 22:03:19.599547234 +0100
@@ -0,0 +1,11 @@
+AC_SUBST([LIBMPEG2_CFLAGS])
+
+dnl avoid -fPIC when possible
+AC_LIBTOOL_NON_PIC([LIBMPEG2_CFLAGS="$LIBMPEG2_CFLAGS -prefer-non-pic"])
+
+dnl check for cpudetect
+AC_ARG_ENABLE([accel-detect],
+    [  --disable-accel-detect  make a version without accel detection code])
+if test x"$enable_accel_detect" != x"no"; then
+    AC_DEFINE([ACCEL_DETECT],,[autodetect accelerations])
+fi
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/convert_internal.h xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/convert_internal.h
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/convert_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/convert_internal.h	2022-01-15 22:03:19.604547255 +0100
@@ -0,0 +1,42 @@
+/*
+ * convert_internal.h
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ *
+ * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+ * See http://libmpeg2.sourceforge.net/ for updates.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+typedef struct {
+    uint8_t * rgb_ptr;
+    int width;
+    int field;
+    int y_stride, rgb_stride, y_increm, uv_increm, rgb_increm, rgb_slice;
+    int chroma420, convert420;
+    int dither_offset, dither_stride;
+    int y_stride_frame, uv_stride_frame, rgb_stride_frame, rgb_stride_min;
+} convert_rgb_t;
+
+typedef void mpeg2convert_copy_t (void * id, uint8_t * const * src,
+				  unsigned int v_offset);
+
+mpeg2convert_copy_t * mpeg2convert_rgb_mmxext (int bpp, int mode,
+					       const mpeg2_sequence_t * seq);
+mpeg2convert_copy_t * mpeg2convert_rgb_mmx (int bpp, int mode,
+					    const mpeg2_sequence_t * seq);
+mpeg2convert_copy_t * mpeg2convert_rgb_vis (int bpp, int mode,
+					    const mpeg2_sequence_t * seq);
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/idct_mlib.c xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/idct_mlib.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/idct_mlib.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/idct_mlib.c	2022-01-15 22:03:19.608547272 +0100
@@ -0,0 +1,60 @@
+/*
+ * idct_mlib.c
+ * Copyright (C) 1999-2003 Håkan Hjort <d95hjort@dtek.chalmers.se>
+ *
+ * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+ * See http://libmpeg2.sourceforge.net/ for updates.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+
+#ifdef LIBMPEG2_MLIB
+
+#include <mlib_types.h>
+#include <mlib_status.h>
+#include <mlib_sys.h>
+#include <mlib_video.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include "../include/mpeg2.h"
+#include "mpeg2_internal.h"
+
+void mpeg2_idct_add_mlib (const int last, int16_t * const block,
+			  uint8_t * const dest, const int stride)
+{
+    mlib_VideoIDCT_IEEE_S16_S16 (block, block);
+    mlib_VideoAddBlock_U8_S16 (dest, block, stride);
+    memset (block, 0, 64 * sizeof (uint16_t));
+}
+
+void mpeg2_idct_copy_mlib_non_ieee (int16_t * const block,
+				    uint8_t * const dest, const int stride)
+{
+    mlib_VideoIDCT8x8_U8_S16 (dest, block, stride);
+    memset (block, 0, 64 * sizeof (uint16_t));
+}
+
+void mpeg2_idct_add_mlib_non_ieee (const int last, int16_t * const block,
+				   uint8_t * const dest, const int stride)
+{
+    mlib_VideoIDCT8x8_S16_S16 (block, block);
+    mlib_VideoAddBlock_U8_S16 (dest, block, stride);
+    memset (block, 0, 64 * sizeof (uint16_t));
+}
+
+#endif
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in	2022-01-15 22:03:19.621547327 +0100
@@ -0,0 +1,10 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libmpeg2convert
+Description: libmpeg2 helper functions for converting to various formats.
+Version: @VERSION@
+Libs: -L${libdir} -lmpeg2convert
+Cflags: -I${includedir}/@PACKAGE@
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in	2022-01-15 22:03:19.576547137 +0100
@@ -0,0 +1,10 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libmpeg2
+Description: A decoding library for MPEG-1 and MPEG-2 streams.
+Version: @VERSION@
+Libs: -L${libdir} -lmpeg2
+Cflags: -I${includedir}/@PACKAGE@
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/motion_comp_mlib.c xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/motion_comp_mlib.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/motion_comp_mlib.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/motion_comp_mlib.c	2022-01-15 22:03:19.608547272 +0100
@@ -0,0 +1,190 @@
+/*
+ * motion_comp_mlib.c
+ * Copyright (C) 2000-2003 Håkan Hjort <d95hjort@dtek.chalmers.se>
+ *
+ * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+ * See http://libmpeg2.sourceforge.net/ for updates.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+
+#ifdef LIBMPEG2_MLIB
+
+#include <mlib_types.h>
+#include <mlib_status.h>
+#include <mlib_sys.h>
+#include <mlib_video.h>
+#include <inttypes.h>
+
+#include "../include/mpeg2.h"
+#include "mpeg2_internal.h"
+
+static void MC_put_o_16_mlib (uint8_t * dest, const uint8_t * ref,
+			      int stride, int height)
+{
+    if (height == 16)
+	mlib_VideoCopyRef_U8_U8_16x16 (dest, (uint8_t *) ref, stride);
+    else
+	mlib_VideoCopyRef_U8_U8_16x8 (dest, (uint8_t *) ref, stride);
+}
+
+static void MC_put_x_16_mlib (uint8_t * dest, const uint8_t * ref,
+			      int stride, int height)
+{
+    if (height == 16)
+	mlib_VideoInterpX_U8_U8_16x16 (dest, (uint8_t *) ref, stride, stride);
+    else
+	mlib_VideoInterpX_U8_U8_16x8 (dest, (uint8_t *) ref, stride, stride);
+}
+
+static void MC_put_y_16_mlib (uint8_t * dest, const uint8_t * ref,
+			      int stride, int height)
+{
+    if (height == 16)
+	mlib_VideoInterpY_U8_U8_16x16 (dest, (uint8_t *) ref, stride, stride);
+    else
+	mlib_VideoInterpY_U8_U8_16x8 (dest, (uint8_t *) ref, stride, stride);
+}
+
+static void MC_put_xy_16_mlib (uint8_t * dest, const uint8_t * ref,
+			       int stride, int height)
+{
+    if (height == 16)
+	mlib_VideoInterpXY_U8_U8_16x16 (dest, (uint8_t *) ref, stride, stride);
+    else
+	mlib_VideoInterpXY_U8_U8_16x8 (dest, (uint8_t *) ref, stride, stride);
+}
+
+static void MC_put_o_8_mlib (uint8_t * dest, const uint8_t * ref,
+			     int stride, int height)
+{
+    if (height == 8)
+	mlib_VideoCopyRef_U8_U8_8x8 (dest, (uint8_t *) ref, stride);
+    else
+	mlib_VideoCopyRef_U8_U8_8x4 (dest, (uint8_t *) ref, stride);
+}
+
+static void MC_put_x_8_mlib (uint8_t * dest, const uint8_t * ref,
+			     int stride, int height)
+{
+    if (height == 8)
+	mlib_VideoInterpX_U8_U8_8x8 (dest, (uint8_t *) ref, stride, stride);
+    else
+	mlib_VideoInterpX_U8_U8_8x4 (dest, (uint8_t *) ref, stride, stride);
+}
+
+static void MC_put_y_8_mlib (uint8_t * dest, const uint8_t * ref,
+			     int stride, int height)
+{
+    if (height == 8)
+	mlib_VideoInterpY_U8_U8_8x8 (dest, (uint8_t *) ref, stride, stride);
+    else
+	mlib_VideoInterpY_U8_U8_8x4 (dest, (uint8_t *) ref, stride, stride);
+}
+
+static void MC_put_xy_8_mlib (uint8_t * dest, const uint8_t * ref,
+			      int stride, int height)
+{
+    if (height == 8)
+	mlib_VideoInterpXY_U8_U8_8x8 (dest, (uint8_t *) ref, stride, stride);
+    else
+	mlib_VideoInterpXY_U8_U8_8x4 (dest, (uint8_t *) ref, stride, stride);
+}
+
+static void MC_avg_o_16_mlib (uint8_t * dest, const uint8_t * ref,
+			      int stride, int height)
+{
+    if (height == 16)
+	mlib_VideoCopyRefAve_U8_U8_16x16 (dest, (uint8_t *) ref, stride);
+    else
+	mlib_VideoCopyRefAve_U8_U8_16x8 (dest, (uint8_t *) ref, stride);
+}
+
+static void MC_avg_x_16_mlib (uint8_t * dest, const uint8_t * ref,
+			      int stride, int height)
+{
+    if (height == 16)
+	mlib_VideoInterpAveX_U8_U8_16x16 (dest, (uint8_t *) ref,
+					  stride, stride);
+    else
+	mlib_VideoInterpAveX_U8_U8_16x8 (dest, (uint8_t *) ref,
+					 stride, stride);
+}
+
+static void MC_avg_y_16_mlib (uint8_t * dest, const uint8_t * ref,
+			      int stride, int height)
+{
+    if (height == 16)
+	mlib_VideoInterpAveY_U8_U8_16x16 (dest, (uint8_t *) ref,
+					  stride, stride);
+    else
+	mlib_VideoInterpAveY_U8_U8_16x8 (dest, (uint8_t *) ref,
+					 stride, stride);
+}
+
+static void MC_avg_xy_16_mlib (uint8_t * dest, const uint8_t * ref,
+			       int stride, int height)
+{
+    if (height == 16)
+	mlib_VideoInterpAveXY_U8_U8_16x16 (dest, (uint8_t *) ref,
+					   stride, stride);
+    else
+	mlib_VideoInterpAveXY_U8_U8_16x8 (dest, (uint8_t *) ref,
+					  stride, stride);
+}
+
+static void MC_avg_o_8_mlib (uint8_t * dest, const uint8_t * ref,
+			     int stride, int height)
+{
+    if (height == 8)
+	mlib_VideoCopyRefAve_U8_U8_8x8 (dest, (uint8_t *) ref, stride);
+    else
+	mlib_VideoCopyRefAve_U8_U8_8x4 (dest, (uint8_t *) ref, stride);
+}
+
+static void MC_avg_x_8_mlib (uint8_t * dest, const uint8_t * ref,
+			     int stride, int height)
+{
+    if (height == 8)
+	mlib_VideoInterpAveX_U8_U8_8x8 (dest, (uint8_t *) ref, stride, stride);
+    else
+	mlib_VideoInterpAveX_U8_U8_8x4 (dest, (uint8_t *) ref, stride, stride);
+}
+
+static void MC_avg_y_8_mlib (uint8_t * dest, const uint8_t * ref,
+			     int stride, int height)
+{
+    if (height == 8)
+	mlib_VideoInterpAveY_U8_U8_8x8 (dest, (uint8_t *) ref, stride, stride);
+    else
+	mlib_VideoInterpAveY_U8_U8_8x4 (dest, (uint8_t *) ref, stride, stride);
+}
+
+static void MC_avg_xy_8_mlib (uint8_t * dest, const uint8_t * ref,
+			      int stride, int height)
+{
+    if (height == 8)
+	mlib_VideoInterpAveXY_U8_U8_8x8 (dest, (uint8_t *) ref,
+					 stride, stride);
+    else
+	mlib_VideoInterpAveXY_U8_U8_8x4 (dest, (uint8_t *) ref,
+					 stride, stride);
+}
+
+MPEG2_MC_EXTERN (mlib)
+
+#endif
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/rgb.c xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/rgb.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/rgb.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/rgb.c	2022-01-15 22:03:19.619547318 +0100
@@ -0,0 +1,598 @@
+/*
+ * rgb.c
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ *
+ * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+ * See http://libmpeg2.sourceforge.net/ for updates.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+#include <xine/attributes.h>
+
+#include <inttypes.h>
+
+#include "mpeg2.h"
+#include "mpeg2convert.h"
+#include "convert_internal.h"
+
+static int matrix_coefficients = 6;
+
+static const int Inverse_Table_6_9[8][4] = {
+    {117504, 138453, 13954, 34903}, /* no sequence_display_extension */
+    {117504, 138453, 13954, 34903}, /* ITU-R Rec. 709 (1990) */
+    {104597, 132201, 25675, 53279}, /* unspecified */
+    {104597, 132201, 25675, 53279}, /* reserved */
+    {104448, 132798, 24759, 53109}, /* FCC */
+    {104597, 132201, 25675, 53279}, /* ITU-R Rec. 624-4 System B, G */
+    {104597, 132201, 25675, 53279}, /* SMPTE 170M */
+    {117579, 136230, 16907, 35559}  /* SMPTE 240M (1987) */
+};
+
+static const uint8_t dither[] ATTR_ALIGN(32) = {
+     0,  0, 23, 54,  5, 13, 29, 68,  1,  3, 24, 58,  7, 17, 30, 71,
+     0,  0, 23, 54,  5, 13, 29, 68,  1,  3, 24, 58,  7, 17, 30, 71,
+     0,  0, 23, 54,  5, 13, 29, 68,  1,  3, 24, 58,  7, 17, 30, 71,
+     0,  0, 23, 54,  5, 13, 29, 68,  1,  3, 24, 58,  7, 17, 30, 71,
+    15, 36,  7, 18, 21, 50, 13, 31, 17, 39,  9, 21, 22, 53, 15, 35,
+    15, 36,  7, 18, 21, 50, 13, 31, 17, 39,  9, 21, 22, 53, 15, 35,
+    15, 36,  7, 18, 21, 50, 13, 31, 17, 39,  9, 21, 22, 53, 15, 35,
+    15, 36,  7, 18, 21, 50, 13, 31, 17, 39,  9, 21, 22, 53, 15, 35,
+     3,  9, 27, 63,  1,  4, 25, 59,  5, 12, 28, 67,  3,  7, 26, 62,
+     3,  9, 27, 63,  1,  4, 25, 59,  5, 12, 28, 67,  3,  7, 26, 62,
+     3,  9, 27, 63,  1,  4, 25, 59,  5, 12, 28, 67,  3,  7, 26, 62,
+     3,  9, 27, 63,  1,  4, 25, 59,  5, 12, 28, 67,  3,  7, 26, 62,
+    19, 45, 11, 27, 17, 41,  9, 22, 21, 49, 13, 30, 19, 44, 11, 26,
+    19, 45, 11, 27, 17, 41,  9, 22, 21, 49, 13, 30, 19, 44, 11, 26,
+    19, 45, 11, 27, 17, 41,  9, 22, 21, 49, 13, 30, 19, 44, 11, 26,
+    19, 45, 11, 27, 17, 41,  9, 22, 21, 49, 13, 30, 19, 44, 11, 26,
+     0,  2, 24, 57,  6, 15, 30, 70,  0,  1, 23, 55,  6, 14, 29, 69,
+     0,  2, 24, 57,  6, 15, 30, 70,  0,  1, 23, 55,  6, 14, 29, 69,
+     0,  2, 24, 57,  6, 15, 30, 70,  0,  1, 23, 55,  6, 14, 29, 69,
+     0,  2, 24, 57,  6, 15, 30, 70,  0,  1, 23, 55,  6, 14, 29, 69,
+    16, 38,  8, 20, 22, 52, 14, 34, 16, 37,  8, 19, 21, 51, 14, 33,
+    16, 38,  8, 20, 22, 52, 14, 34, 16, 37,  8, 19, 21, 51, 14, 33,
+    16, 38,  8, 20, 22, 52, 14, 34, 16, 37,  8, 19, 21, 51, 14, 33,
+    16, 38,  8, 20, 22, 52, 14, 34, 16, 37,  8, 19, 21, 51, 14, 33,
+     4, 11, 28, 66,  2,  6, 26, 61,  4, 10, 27, 65,  2,  5, 25, 60,
+     4, 11, 28, 66,  2,  6, 26, 61,  4, 10, 27, 65,  2,  5, 25, 60,
+     4, 11, 28, 66,  2,  6, 26, 61,  4, 10, 27, 65,  2,  5, 25, 60,
+     4, 11, 28, 66,  2,  6, 26, 61,  4, 10, 27, 65,  2,  5, 25, 60,
+    20, 47, 12, 29, 18, 43, 10, 25, 20, 46, 12, 28, 18, 42, 10, 23,
+    20, 47, 12, 29, 18, 43, 10, 25, 20, 46, 12, 28, 18, 42, 10, 23,
+    20, 47, 12, 29, 18, 43, 10, 25, 20, 46, 12, 28, 18, 42, 10, 23,
+    20, 47, 12, 29, 18, 43, 10, 25, 20, 46, 12, 28, 18, 42, 10, 23,
+     0,  0, 23, 54,  5, 13, 29, 68,  1,  3, 24, 58,  7, 17, 30, 71,
+     0,  0, 23, 54,  5, 13, 29, 68,  1,  3, 24, 58,  7, 17, 30, 71,
+     0,  0, 23, 54,  5, 13, 29, 68,  1,  3, 24, 58,  7, 17, 30, 71,
+     0,  0, 23, 54,  5, 13, 29, 68,  1,  3, 24, 58,  7, 17, 30, 71,
+    15, 36,  7, 18, 21, 50, 13, 31, 17, 39,  9, 21, 22, 53, 15, 35,
+    15, 36,  7, 18, 21, 50, 13, 31, 17, 39,  9, 21, 22, 53, 15, 35
+};
+
+static const uint8_t dither_temporal[64] = {
+    0x00, 0x20, 0x21, 0x01, 0x40, 0x60, 0x61, 0x41,
+    0x42, 0x62, 0x63, 0x43, 0x02, 0x22, 0x23, 0x03,
+    0x80, 0xa0, 0xa1, 0x81, 0xc0, 0xe0, 0xe1, 0xc1,
+    0xc2, 0xe2, 0xe3, 0xc3, 0x82, 0xa2, 0xa3, 0x83,
+    0x84, 0xa4, 0xa5, 0x85, 0xc4, 0xe4, 0xe5, 0xc5,
+    0xc6, 0xe6, 0xe7, 0xc7, 0x86, 0xa6, 0xa7, 0x87,
+    0x04, 0x24, 0x25, 0x05, 0x44, 0x64, 0x65, 0x45,
+    0x46, 0x66, 0x67, 0x47, 0x06, 0x26, 0x27, 0x07
+};
+
+typedef struct {
+    convert_rgb_t base;
+    void * table_rV[256];
+    void * table_gU[256];
+    int table_gV[256];
+    void * table_bU[256];
+} convert_rgb_c_t;
+
+#define RGB(type,i)							\
+    U = pu[i];								\
+    V = pv[i];								\
+    r = (type *) id->table_rV[V];					\
+    g = (type *) (((uint8_t *)id->table_gU[U]) + id->table_gV[V]);	\
+    b = (type *) id->table_bU[U];
+
+#define DST(py,dst,i,j)			\
+    Y = py[i];				\
+    dst[i] = r[Y] + g[Y] + b[Y];
+
+#define DSTRGB(py,dst,i,j)					\
+    Y = py[i];							\
+    dst[3*i] = r[Y]; dst[3*i+1] = g[Y]; dst[3*i+2] = b[Y];
+
+#define DSTBGR(py,dst,i,j)					\
+    Y = py[i];							\
+    dst[3*i] = b[Y]; dst[3*i+1] = g[Y]; dst[3*i+2] = r[Y];
+
+#define DSTDITHER(py,dst,i,j)						  \
+    Y = py[i];								  \
+    dst[i] = r[Y+pd[2*i+96*j]] + g[Y-pd[2*i+96*j]] + b[Y+pd[2*i+1+96*j]];
+
+#define DO(x) x
+#define SKIP(x)
+
+#define DECLARE_420(func,type,num,DST,DITHER)				\
+static void func (void * _id, uint8_t * const * src,			\
+		  unsigned int v_offset)				\
+{									\
+    const convert_rgb_c_t * const id = (convert_rgb_c_t *) _id;		\
+    type * dst_1;							\
+    const uint8_t * py_1, * pu, * pv;					\
+    int i;								\
+    DITHER(uint8_t dithpos = id->base.dither_offset;)			\
+									\
+    dst_1 = (type *)(id->base.rgb_ptr + id->base.rgb_slice * v_offset);	\
+    py_1 = src[0];	pu = src[1];	pv = src[2];			\
+									\
+    i = 8;								\
+    do {								\
+	const uint8_t * py_2;						\
+	int j, U, V, Y;							\
+	const type * r, * g, * b;					\
+	type * dst_2;							\
+	DITHER(const uint8_t * const pd = dither + 2 * dithpos;)	\
+									\
+	dst_2 = (type *)((char *)dst_1 + id->base.rgb_stride);		\
+	py_2 = py_1 + id->base.y_stride;				\
+	j = id->base.width;						\
+	do {								\
+	    RGB (type, 0)						\
+	    DST (py_1, dst_1, 0, 0)					\
+	    DST (py_1, dst_1, 1, 0)					\
+	    DST (py_2, dst_2, 0, 1)					\
+	    DST (py_2, dst_2, 1, 1)					\
+									\
+	    RGB (type, 1)						\
+	    DST (py_2, dst_2, 2, 1)					\
+	    DST (py_2, dst_2, 3, 1)					\
+	    DST (py_1, dst_1, 2, 0)					\
+	    DST (py_1, dst_1, 3, 0)					\
+									\
+	    RGB (type, 2)						\
+	    DST (py_1, dst_1, 4, 0)					\
+	    DST (py_1, dst_1, 5, 0)					\
+	    DST (py_2, dst_2, 4, 1)					\
+	    DST (py_2, dst_2, 5, 1)					\
+									\
+	    RGB (type, 3)						\
+	    DST (py_2, dst_2, 6, 1)					\
+	    DST (py_2, dst_2, 7, 1)					\
+	    DST (py_1, dst_1, 6, 0)					\
+	    DST (py_1, dst_1, 7, 0)					\
+									\
+	    pu += 4;							\
+	    pv += 4;							\
+	    py_1 += 8;							\
+	    py_2 += 8;							\
+	    dst_1 += 8 * num;						\
+	    dst_2 += 8 * num;						\
+	} while (--j);							\
+	if (--i == id->base.field) {					\
+	    dst_1 = (type *)(id->base.rgb_ptr +				\
+			     id->base.rgb_slice * (v_offset + 1));	\
+	    py_1 = src[0] + id->base.y_stride_frame;			\
+	    pu = src[1] + id->base.uv_stride_frame;			\
+	    pv = src[2] + id->base.uv_stride_frame;			\
+	} else {							\
+	    py_1 += id->base.y_increm;					\
+	    pu += id->base.uv_increm;					\
+	    pv += id->base.uv_increm;					\
+	    dst_1 = (type *)((char *)dst_1 + id->base.rgb_increm);	\
+	    DITHER(dithpos += id->base.dither_stride;)			\
+	}								\
+    } while (i);							\
+}
+
+DECLARE_420 (rgb_c_32_420, uint32_t, 1, DST, SKIP)
+DECLARE_420 (rgb_c_24_rgb_420, uint8_t, 3, DSTRGB, SKIP)
+DECLARE_420 (rgb_c_24_bgr_420, uint8_t, 3, DSTBGR, SKIP)
+DECLARE_420 (rgb_c_16_420, uint16_t, 1, DST, SKIP)
+DECLARE_420 (rgb_c_8_420, uint8_t, 1, DSTDITHER, DO)
+
+#define DECLARE_422(func,type,num,DST,DITHER)				\
+static void func (void * _id, uint8_t * const * src,			\
+		  unsigned int v_offset)				\
+{									\
+    const convert_rgb_c_t * const id = (convert_rgb_c_t *) _id;		\
+    type * dst;								\
+    const uint8_t * py, * pu, * pv;					\
+    int i;								\
+    DITHER(uint8_t dithpos = id->base.dither_offset;)			\
+									\
+    dst = (type *)(id->base.rgb_ptr + id->base.rgb_stride * v_offset);	\
+    py = src[0];	pu = src[1];	pv = src[2];			\
+									\
+    i = 16;								\
+    do {								\
+	int j, U, V, Y;							\
+	const type * r, * g, * b;					\
+	DITHER(const uint8_t * const pd = dither + 2 * dithpos;)	\
+									\
+	j = id->base.width;						\
+	do {								\
+	    RGB (type, 0)						\
+	    DST (py, dst, 0, 0)						\
+	    DST (py, dst, 1, 0)						\
+									\
+	    RGB (type, 1)						\
+	    DST (py, dst, 2, 0)						\
+	    DST (py, dst, 3, 0)						\
+									\
+	    RGB (type, 2)						\
+	    DST (py, dst, 4, 0)						\
+	    DST (py, dst, 5, 0)						\
+									\
+	    RGB (type, 3)						\
+	    DST (py, dst, 6, 0)						\
+	    DST (py, dst, 7, 0)						\
+									\
+	    pu += 4;							\
+	    pv += 4;							\
+	    py += 8;							\
+	    dst += 8 * num;						\
+	} while (--j);							\
+	py += id->base.y_increm;					\
+	pu += id->base.uv_increm;					\
+	pv += id->base.uv_increm;					\
+	dst = (type *)((char *)dst + id->base.rgb_increm);		\
+	DITHER(dithpos += id->base.dither_stride;)			\
+    } while (--i);							\
+}
+
+DECLARE_422 (rgb_c_32_422, uint32_t, 1, DST, SKIP)
+DECLARE_422 (rgb_c_24_rgb_422, uint8_t, 3, DSTRGB, SKIP)
+DECLARE_422 (rgb_c_24_bgr_422, uint8_t, 3, DSTBGR, SKIP)
+DECLARE_422 (rgb_c_16_422, uint16_t, 1, DST, SKIP)
+DECLARE_422 (rgb_c_8_422, uint8_t, 1, DSTDITHER, DO)
+
+#define DECLARE_444(func,type,num,DST,DITHER)				\
+static void func (void * _id, uint8_t * const * src,			\
+		  unsigned int v_offset)				\
+{									\
+    const convert_rgb_c_t * const id = (convert_rgb_c_t *) _id;		\
+    type * dst;								\
+    const uint8_t * py, * pu, * pv;					\
+    int i;								\
+    DITHER(uint8_t dithpos = id->base.dither_offset;)			\
+									\
+    dst = (type *)(id->base.rgb_ptr + id->base.rgb_stride * v_offset);	\
+    py = src[0];	pu = src[1];	pv = src[2];			\
+									\
+    i = 16;								\
+    do {								\
+	int j, U, V, Y;							\
+	const type * r, * g, * b;					\
+	DITHER(const uint8_t * const pd = dither + 2 * dithpos;)	\
+									\
+	j = id->base.width;						\
+	do {								\
+	    RGB (type, 0)						\
+	    DST (py, dst, 0, 0)						\
+	    RGB (type, 1)						\
+	    DST (py, dst, 1, 0)						\
+	    RGB (type, 2)						\
+	    DST (py, dst, 2, 0)						\
+	    RGB (type, 3)						\
+	    DST (py, dst, 3, 0)						\
+	    RGB (type, 4)						\
+	    DST (py, dst, 4, 0)						\
+	    RGB (type, 5)						\
+	    DST (py, dst, 5, 0)						\
+	    RGB (type, 6)						\
+	    DST (py, dst, 6, 0)						\
+	    RGB (type, 7)						\
+	    DST (py, dst, 7, 0)						\
+									\
+	    pu += 8;							\
+	    pv += 8;							\
+	    py += 8;							\
+	    dst += 8 * num;						\
+	} while (--j);							\
+	py += id->base.y_increm;				   	\
+	pu += id->base.y_increm;				   	\
+	pv += id->base.y_increm;				   	\
+	dst = (type *)((char *)dst + id->base.rgb_increm);		\
+	DITHER(dithpos += id->base.dither_stride;)			\
+    } while (--i);							\
+}
+
+DECLARE_444 (rgb_c_32_444, uint32_t, 1, DST, SKIP)
+DECLARE_444 (rgb_c_24_rgb_444, uint8_t, 3, DSTRGB, SKIP)
+DECLARE_444 (rgb_c_24_bgr_444, uint8_t, 3, DSTBGR, SKIP)
+DECLARE_444 (rgb_c_16_444, uint16_t, 1, DST, SKIP)
+DECLARE_444 (rgb_c_8_444, uint8_t, 1, DSTDITHER, DO)
+
+static void rgb_start (void * _id, const mpeg2_fbuf_t * fbuf,
+		       const mpeg2_picture_t * picture,
+		       const mpeg2_gop_t * gop)
+{
+    convert_rgb_t * id = (convert_rgb_t *) _id;
+    int uv_stride = id->uv_stride_frame;
+    id->y_stride = id->y_stride_frame;
+    id->rgb_ptr = fbuf->buf[0];
+    id->rgb_slice = id->rgb_stride = id->rgb_stride_frame;
+    id->dither_stride = 32;
+    id->dither_offset = dither_temporal[picture->temporal_reference & 63];
+    id->field = 0;
+    if ((picture->nb_fields == 1) ||
+	(id->chroma420 && !(picture->flags & PIC_FLAG_PROGRESSIVE_FRAME))) {
+	uv_stride <<= 1;
+	id->y_stride <<= 1;
+	id->rgb_stride <<= 1;
+	id->dither_stride <<= 1;
+	id->dither_offset += 16;
+	if (picture->nb_fields == 1) {
+	    id->rgb_slice <<= 1;
+	    if (!(picture->flags & PIC_FLAG_TOP_FIELD_FIRST)) {
+		id->rgb_ptr += id->rgb_stride_frame;
+		id->dither_offset += 32;
+	    }
+	} else
+	    id->field = 8 >> id->convert420;
+    }
+    id->y_increm = (id->y_stride << id->convert420) - id->y_stride_frame;
+    id->uv_increm = uv_stride - id->uv_stride_frame;
+    id->rgb_increm = (id->rgb_stride << id->convert420) - id->rgb_stride_min;
+    id->dither_stride <<= id->convert420;
+}
+
+static inline int div_round (int dividend, int divisor)
+{
+    if (dividend > 0)
+	return (dividend + (divisor>>1)) / divisor;
+    else
+	return -((-dividend + (divisor>>1)) / divisor);
+}
+
+static unsigned int rgb_c_init (convert_rgb_c_t * id,
+				mpeg2convert_rgb_order_t order,
+				unsigned int bpp)
+{
+    int i;
+    uint8_t table_Y[1024];
+    uint32_t * table_32 = 0;
+    uint16_t * table_16 = 0;
+    uint8_t * table_8 = 0;
+    uint8_t * table_332 = 0;
+    int entry_size = 0;
+    void * table_r = 0;
+    void * table_g = 0;
+    void * table_b = 0;
+
+    int crv = Inverse_Table_6_9[matrix_coefficients][0];
+    int cbu = Inverse_Table_6_9[matrix_coefficients][1];
+    int cgu = -Inverse_Table_6_9[matrix_coefficients][2];
+    int cgv = -Inverse_Table_6_9[matrix_coefficients][3];
+
+    for (i = 0; i < 1024; i++) {
+	int j;
+
+	j = (76309 * (i - 384 - 16) + 32768) >> 16;
+	table_Y[i] = (j < 0) ? 0 : ((j > 255) ? 255 : j);
+    }
+
+    switch (bpp) {
+    case 32:
+	if (!id)
+	    return (197 + 2*682 + 256 + 132) * sizeof (uint32_t);
+	table_32 = (uint32_t *) (id + 1);
+	entry_size = sizeof (uint32_t);
+	table_r = table_32 + 197;
+	table_b = table_32 + 197 + 685;
+	table_g = table_32 + 197 + 2*682;
+
+	for (i = -197; i < 256+197; i++)
+	    ((uint32_t *) table_r)[i] =
+		table_Y[i+384] << ((order == MPEG2CONVERT_RGB) ? 16 : 0);
+	for (i = -132; i < 256+132; i++)
+	    ((uint32_t *) table_g)[i] = table_Y[i+384] << 8;
+	for (i = -232; i < 256+232; i++)
+	    ((uint32_t *) table_b)[i] =
+		table_Y[i+384] << ((order == MPEG2CONVERT_RGB) ? 0 : 16);
+	break;
+
+    case 24:
+	if (!id)
+	    return (256 + 2*232) * sizeof (uint8_t);
+	table_8 = (uint8_t *) (id + 1);
+	entry_size = sizeof (uint8_t);
+	table_r = table_g = table_b = table_8 + 232;
+
+	for (i = -232; i < 256+232; i++)
+	    ((uint8_t * )table_b)[i] = table_Y[i+384];
+	break;
+
+    case 15:
+    case 16:
+	if (!id)
+	    return (197 + 2*682 + 256 + 132) * sizeof (uint16_t);
+	table_16 = (uint16_t *) (id + 1);
+	entry_size = sizeof (uint16_t);
+	table_r = table_16 + 197;
+	table_b = table_16 + 197 + 685;
+	table_g = table_16 + 197 + 2*682;
+
+	for (i = -197; i < 256+197; i++) {
+	    int j = table_Y[i+384] >> 3;
+
+	    if (order == MPEG2CONVERT_RGB)
+		j <<= ((bpp==16) ? 11 : 10);
+
+	    ((uint16_t *)table_r)[i] = j;
+	}
+	for (i = -132; i < 256+132; i++) {
+	    int j = table_Y[i+384] >> ((bpp==16) ? 2 : 3);
+
+	    ((uint16_t *)table_g)[i] = j << 5;
+	}
+	for (i = -232; i < 256+232; i++) {
+	    int j = table_Y[i+384] >> 3;
+
+	    if (order == MPEG2CONVERT_BGR)
+		j <<= ((bpp==16) ? 11 : 10);
+
+	    ((uint16_t *)table_b)[i] = j;
+	}
+	break;
+
+    case 8:
+	if (!id)
+	    return (197 + 2*682 + 256 + 232 + 71) * sizeof (uint8_t);
+	table_332 = (uint8_t *) (id + 1);
+	entry_size = sizeof (uint8_t);
+	table_r = table_332 + 197;
+	table_g = table_332 + 197 + 682 + 30;
+	table_b = table_332 + 197 + 2*682;
+
+	for (i = -197; i < 256+197+30; i++)
+	    ((uint8_t *)table_r)[i] = ((table_Y[i+384] * 7 / 255) <<
+				       (order == MPEG2CONVERT_RGB ? 5 : 0));
+	for (i = -132; i < 256+132+30; i++)
+	    ((uint8_t *)table_g)[i-30] = ((table_Y[i+384] * 7 / 255) <<
+					  (order == MPEG2CONVERT_RGB ? 2 : 3));
+	for (i = -232; i < 256+232+71; i++)
+	    ((uint8_t *)table_b)[i] = ((table_Y[i+384] / 85) <<
+				       (order == MPEG2CONVERT_RGB ? 0 : 6));
+	break;
+    }
+
+    for (i = 0; i < 256; i++) {
+	id->table_rV[i] = (((uint8_t *)table_r) +
+			   entry_size * div_round (crv * (i-128), 76309));
+	id->table_gU[i] = (((uint8_t *)table_g) +
+			   entry_size * div_round (cgu * (i-128), 76309));
+	id->table_gV[i] = entry_size * div_round (cgv * (i-128), 76309);
+	id->table_bU[i] = (((uint8_t *)table_b) +
+			   entry_size * div_round (cbu * (i-128), 76309));
+    }
+
+    return 0;
+}
+
+static int rgb_internal (mpeg2convert_rgb_order_t order, unsigned int bpp,
+			 int stage, void * _id, const mpeg2_sequence_t * seq,
+			 int stride, uint32_t accel, void * arg,
+			 mpeg2_convert_init_t * result)
+{
+    convert_rgb_t * id = (convert_rgb_t *) _id;
+    mpeg2convert_copy_t * copy = (mpeg2convert_copy_t *) 0;
+    unsigned int id_size = sizeof (convert_rgb_t);
+    int chroma420 = (seq->chroma_height < seq->height);
+    int convert420 = 0;
+    int rgb_stride_min = ((bpp + 7) >> 3) * seq->width;
+
+#ifdef ARCH_X86
+    if (!copy && (accel & MPEG2_ACCEL_X86_MMXEXT)) {
+	convert420 = 0;
+	copy = mpeg2convert_rgb_mmxext (order, bpp, seq);
+    }
+    if (!copy && (accel & MPEG2_ACCEL_X86_MMX)) {
+	convert420 = 0;
+	copy = mpeg2convert_rgb_mmx (order, bpp, seq);
+    }
+#endif
+#ifdef ARCH_SPARC
+    if (!copy && (accel & MPEG2_ACCEL_SPARC_VIS)) {
+	convert420 = chroma420;
+	copy = mpeg2convert_rgb_vis (order, bpp, seq);
+    }
+#endif
+    if (!copy) {
+	int src, dest;
+	static void (* rgb_c[3][5]) (void *, uint8_t * const *,
+				     unsigned int) =
+	    {{rgb_c_24_bgr_420, rgb_c_8_420, rgb_c_16_420,
+	      rgb_c_24_rgb_420, rgb_c_32_420},
+	     {rgb_c_24_bgr_422, rgb_c_8_422, rgb_c_16_422,
+	      rgb_c_24_rgb_422, rgb_c_32_422},
+	     {rgb_c_24_bgr_444, rgb_c_8_444, rgb_c_16_444,
+	      rgb_c_24_rgb_444, rgb_c_32_444}};
+
+	convert420 = chroma420;
+	id_size = (sizeof (convert_rgb_c_t) +
+		   rgb_c_init ((convert_rgb_c_t *) id, order, bpp));
+	src = ((seq->chroma_width == seq->width) +
+	       (seq->chroma_height == seq->height));
+	dest = ((bpp == 24 && order == MPEG2CONVERT_BGR) ? 0 : (bpp + 7) >> 3);
+	copy = rgb_c[src][dest];
+    }
+
+    result->id_size = id_size;
+
+    if (stride < rgb_stride_min)
+	stride = rgb_stride_min;
+
+    if (stage == MPEG2_CONVERT_STRIDE)
+	return stride;
+    else if (stage == MPEG2_CONVERT_START) {
+	id->width = seq->width >> 3;
+	id->y_stride_frame = seq->width;
+	id->uv_stride_frame = seq->chroma_width;
+	id->rgb_stride_frame = stride;
+	id->rgb_stride_min = rgb_stride_min;
+	id->chroma420 = chroma420;
+	id->convert420 = convert420;
+	result->buf_size[0] = stride * seq->height;
+	result->buf_size[1] = result->buf_size[2] = 0;
+	result->start = rgb_start;
+	result->copy = copy;
+    }
+    return 0;
+}
+
+#define DECLARE(func,order,bpp)						\
+int func (int stage, void * id,						\
+	  const mpeg2_sequence_t * sequence, int stride,		\
+	  uint32_t accel, void * arg, mpeg2_convert_init_t * result)	\
+{									\
+    return rgb_internal (order, bpp, stage, id, sequence, stride,	\
+			 accel, arg, result);				\
+}
+
+DECLARE (mpeg2convert_rgb32, MPEG2CONVERT_RGB, 32)
+DECLARE (mpeg2convert_rgb24, MPEG2CONVERT_RGB, 24)
+DECLARE (mpeg2convert_rgb16, MPEG2CONVERT_RGB, 16)
+DECLARE (mpeg2convert_rgb15, MPEG2CONVERT_RGB, 15)
+DECLARE (mpeg2convert_rgb8, MPEG2CONVERT_RGB, 8)
+DECLARE (mpeg2convert_bgr32, MPEG2CONVERT_BGR, 32)
+DECLARE (mpeg2convert_bgr24, MPEG2CONVERT_BGR, 24)
+DECLARE (mpeg2convert_bgr16, MPEG2CONVERT_BGR, 16)
+DECLARE (mpeg2convert_bgr15, MPEG2CONVERT_BGR, 15)
+DECLARE (mpeg2convert_bgr8, MPEG2CONVERT_BGR, 8)
+
+mpeg2_convert_t * mpeg2convert_rgb (mpeg2convert_rgb_order_t order,
+				    unsigned int bpp)
+{
+    static mpeg2_convert_t * table[5][2] =
+	{{mpeg2convert_rgb15, mpeg2convert_bgr15},
+	 {mpeg2convert_rgb8, mpeg2convert_bgr8},
+	 {mpeg2convert_rgb16, mpeg2convert_bgr16},
+	 {mpeg2convert_rgb24, mpeg2convert_bgr24},
+	 {mpeg2convert_rgb32, mpeg2convert_bgr32}};
+
+    if (order == MPEG2CONVERT_RGB || order == MPEG2CONVERT_BGR) {
+	if (bpp == 15)
+	    return table[0][order == MPEG2CONVERT_BGR];
+	else if (bpp >= 8 && bpp <= 32 && (bpp & 7) == 0)
+	    return table[bpp >> 3][order == MPEG2CONVERT_BGR];
+    }
+    return (mpeg2_convert_t *) 0;
+}
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/rgb_mmx.c xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/rgb_mmx.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/rgb_mmx.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/rgb_mmx.c	2022-01-15 22:03:19.587547183 +0100
@@ -0,0 +1,321 @@
+/*
+ * rgb_mmx.c
+ * Copyright (C) 2000-2003 Silicon Integrated System Corp.
+ * All Rights Reserved.
+ *
+ * Author: Olie Lho <ollie@sis.com.tw>
+ *
+ * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+ * See http://libmpeg2.sourceforge.net/ for updates.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+
+#ifdef ARCH_X86
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <inttypes.h>
+
+#include "mpeg2.h"
+#include "mpeg2convert.h"
+#include "convert_internal.h"
+#include <xine/attributes.h>
+#include "mmx.h"
+
+#define CPU_MMXEXT 0
+#define CPU_MMX 1
+
+/* CPU_MMXEXT/CPU_MMX adaptation layer */
+
+#define movntq(src,dest)	\
+do {				\
+    if (cpu == CPU_MMXEXT)	\
+	movntq_r2m (src, dest);	\
+    else			\
+	movq_r2m (src, dest);	\
+} while (0)
+
+static inline void mmx_yuv2rgb (uint8_t * py, uint8_t * pu, uint8_t * pv)
+{
+    static mmx_t mmx_80w = {0x0080008000800080LL};
+    static mmx_t mmx_U_green = {0xf37df37df37df37dLL};
+    static mmx_t mmx_U_blue = {0x4093409340934093LL};
+    static mmx_t mmx_V_red = {0x3312331233123312LL};
+    static mmx_t mmx_V_green = {0xe5fce5fce5fce5fcLL};
+    static mmx_t mmx_10w = {0x1010101010101010LL};
+    static mmx_t mmx_00ffw = {0x00ff00ff00ff00ffLL};
+    static mmx_t mmx_Y_coeff = {0x253f253f253f253fLL};
+
+    movd_m2r (*pu, mm0);		/* mm0 = 00 00 00 00 u3 u2 u1 u0 */
+    movd_m2r (*pv, mm1);		/* mm1 = 00 00 00 00 v3 v2 v1 v0 */
+    movq_m2r (*py, mm6);		/* mm6 = Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */
+    pxor_r2r (mm4, mm4);		/* mm4 = 0 */
+    /* XXX might do cache preload for image here */
+
+    /*
+     * Do the multiply part of the conversion for even and odd pixels
+     * register usage:
+     * mm0 -> Cblue, mm1 -> Cred, mm2 -> Cgreen even pixels
+     * mm3 -> Cblue, mm4 -> Cred, mm5 -> Cgreen odd  pixels
+     * mm6 -> Y even, mm7 -> Y odd
+     */
+
+    punpcklbw_r2r (mm4, mm0);		/* mm0 = u3 u2 u1 u0 */
+    punpcklbw_r2r (mm4, mm1);		/* mm1 = v3 v2 v1 v0 */
+    psubsw_m2r (mmx_80w, mm0);		/* u -= 128 */
+    psubsw_m2r (mmx_80w, mm1);		/* v -= 128 */
+    psllw_i2r (3, mm0);			/* promote precision */
+    psllw_i2r (3, mm1);			/* promote precision */
+    movq_r2r (mm0, mm2);		/* mm2 = u3 u2 u1 u0 */
+    movq_r2r (mm1, mm3);		/* mm3 = v3 v2 v1 v0 */
+    pmulhw_m2r (mmx_U_green, mm2);	/* mm2 = u * u_green */
+    pmulhw_m2r (mmx_V_green, mm3);	/* mm3 = v * v_green */
+    pmulhw_m2r (mmx_U_blue, mm0);	/* mm0 = chroma_b */
+    pmulhw_m2r (mmx_V_red, mm1);	/* mm1 = chroma_r */
+    paddsw_r2r (mm3, mm2);		/* mm2 = chroma_g */
+
+    psubusb_m2r (mmx_10w, mm6);		/* Y -= 16 */
+    movq_r2r (mm6, mm7);		/* mm7 = Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */
+    pand_m2r (mmx_00ffw, mm6);		/* mm6 =    Y6    Y4    Y2    Y0 */
+    psrlw_i2r (8, mm7);			/* mm7 =    Y7    Y5    Y3    Y1 */
+    psllw_i2r (3, mm6);			/* promote precision */
+    psllw_i2r (3, mm7);			/* promote precision */
+    pmulhw_m2r (mmx_Y_coeff, mm6);	/* mm6 = luma_rgb even */
+    pmulhw_m2r (mmx_Y_coeff, mm7);	/* mm7 = luma_rgb odd */
+
+    /*
+     * Do the addition part of the conversion for even and odd pixels
+     * register usage:
+     * mm0 -> Cblue, mm1 -> Cred, mm2 -> Cgreen even pixels
+     * mm3 -> Cblue, mm4 -> Cred, mm5 -> Cgreen odd  pixels
+     * mm6 -> Y even, mm7 -> Y odd
+     */
+
+    movq_r2r (mm0, mm3);		/* mm3 = chroma_b */
+    movq_r2r (mm1, mm4);		/* mm4 = chroma_r */
+    movq_r2r (mm2, mm5);		/* mm5 = chroma_g */
+    paddsw_r2r (mm6, mm0);		/* mm0 = B6 B4 B2 B0 */
+    paddsw_r2r (mm7, mm3);		/* mm3 = B7 B5 B3 B1 */
+    paddsw_r2r (mm6, mm1);		/* mm1 = R6 R4 R2 R0 */
+    paddsw_r2r (mm7, mm4);		/* mm4 = R7 R5 R3 R1 */
+    paddsw_r2r (mm6, mm2);		/* mm2 = G6 G4 G2 G0 */
+    paddsw_r2r (mm7, mm5);		/* mm5 = G7 G5 G3 G1 */
+    packuswb_r2r (mm0, mm0);		/* saturate to 0-255 */
+    packuswb_r2r (mm1, mm1);		/* saturate to 0-255 */
+    packuswb_r2r (mm2, mm2);		/* saturate to 0-255 */
+    packuswb_r2r (mm3, mm3);		/* saturate to 0-255 */
+    packuswb_r2r (mm4, mm4);		/* saturate to 0-255 */
+    packuswb_r2r (mm5, mm5);		/* saturate to 0-255 */
+    punpcklbw_r2r (mm3, mm0);		/* mm0 = B7 B6 B5 B4 B3 B2 B1 B0 */
+    punpcklbw_r2r (mm4, mm1);		/* mm1 = R7 R6 R5 R4 R3 R2 R1 R0 */
+    punpcklbw_r2r (mm5, mm2);		/* mm2 = G7 G6 G5 G4 G3 G2 G1 G0 */
+}
+
+static inline void mmx_unpack_16rgb (uint8_t * image, const int cpu)
+{
+    static mmx_t mmx_bluemask = {0xf8f8f8f8f8f8f8f8LL};
+    static mmx_t mmx_greenmask = {0xfcfcfcfcfcfcfcfcLL};
+    static mmx_t mmx_redmask = {0xf8f8f8f8f8f8f8f8LL};
+
+    /*
+     * convert RGB plane to RGB 16 bits
+     * mm0 -> B, mm1 -> R, mm2 -> G
+     * mm4 -> GB, mm5 -> AR pixel 4-7
+     * mm6 -> GB, mm7 -> AR pixel 0-3
+     */
+
+    pand_m2r (mmx_bluemask, mm0);	/* mm0 = b7b6b5b4b3______ */
+    pand_m2r (mmx_greenmask, mm2);	/* mm2 = g7g6g5g4g3g2____ */
+    pand_m2r (mmx_redmask, mm1);	/* mm1 = r7r6r5r4r3______ */
+    psrlq_i2r (3, mm0);			/* mm0 = ______b7b6b5b4b3 */
+    pxor_r2r (mm4, mm4);		/* mm4 = 0 */
+    movq_r2r (mm0, mm5);		/* mm5 = ______b7b6b5b4b3 */
+    movq_r2r (mm2, mm7);		/* mm7 = g7g6g5g4g3g2____ */
+
+    punpcklbw_r2r (mm4, mm2);
+    punpcklbw_r2r (mm1, mm0);
+    psllq_i2r (3, mm2);
+    por_r2r (mm2, mm0);
+    movntq (mm0, *image);
+
+    punpckhbw_r2r (mm4, mm7);
+    punpckhbw_r2r (mm1, mm5);
+    psllq_i2r (3, mm7);
+    por_r2r (mm7, mm5);
+    movntq (mm5, *(image+8));
+}
+
+static inline void mmx_unpack_32rgb (uint8_t * image, const int cpu)
+{
+    /*
+     * convert RGB plane to RGB packed format,
+     * mm0 -> B, mm1 -> R, mm2 -> G, mm3 -> 0,
+     * mm4 -> GB, mm5 -> AR pixel 4-7,
+     * mm6 -> GB, mm7 -> AR pixel 0-3
+     */
+
+    pxor_r2r (mm3, mm3);
+    movq_r2r (mm0, mm6);
+    movq_r2r (mm1, mm7);
+    movq_r2r (mm0, mm4);
+    movq_r2r (mm1, mm5);
+    punpcklbw_r2r (mm2, mm6);
+    punpcklbw_r2r (mm3, mm7);
+    punpcklwd_r2r (mm7, mm6);
+    movntq (mm6, *image);
+    movq_r2r (mm0, mm6);
+    punpcklbw_r2r (mm2, mm6);
+    punpckhwd_r2r (mm7, mm6);
+    movntq (mm6, *(image+8));
+    punpckhbw_r2r (mm2, mm4);
+    punpckhbw_r2r (mm3, mm5);
+    punpcklwd_r2r (mm5, mm4);
+    movntq (mm4, *(image+16));
+    movq_r2r (mm0, mm4);
+    punpckhbw_r2r (mm2, mm4);
+    punpckhwd_r2r (mm5, mm4);
+    movntq (mm4, *(image+24));
+}
+
+static inline void rgb16 (void * const _id, uint8_t * const * src,
+			  const unsigned int v_offset, const int cpu)
+{
+    convert_rgb_t * const id = (convert_rgb_t *) _id;
+    uint8_t * dst;
+    uint8_t * py, * pu, * pv;
+    int i, j;
+
+    dst = id->rgb_ptr + id->rgb_slice * v_offset;
+    py = src[0];	pu = src[1];	pv = src[2];
+
+    i = 16;
+    do {
+	j = id->width;
+	do {
+	    mmx_yuv2rgb (py, pu, pv);
+	    mmx_unpack_16rgb (dst, cpu);
+	    py += 8;
+	    pu += 4;
+	    pv += 4;
+	    dst += 16;
+	} while (--j);
+
+	dst += id->rgb_increm;
+	py += id->y_increm;
+	if (--i == id->field) {
+	    dst = id->rgb_ptr + id->rgb_slice * (v_offset + 1);
+	    py = src[0] + id->y_stride_frame;
+	    pu = src[1] + id->uv_stride_frame;
+	    pv = src[2] + id->uv_stride_frame;
+	} else if (! (i & id->chroma420)) {
+	    pu += id->uv_increm;
+	    pv += id->uv_increm;
+	} else {
+	    pu -= id->uv_stride_frame;
+	    pv -= id->uv_stride_frame;
+	}
+    } while (i);
+}
+
+static inline void argb32 (void * const _id, uint8_t * const * src,
+			   const unsigned int v_offset, const int cpu)
+{
+    convert_rgb_t * const id = (convert_rgb_t *) _id;
+    uint8_t * dst;
+    uint8_t * py, * pu, * pv;
+    int i, j;
+
+    dst = id->rgb_ptr + id->rgb_slice * v_offset;
+    py = src[0];	pu = src[1];	pv = src[2];
+
+    i = 16;
+    do {
+	j = id->width;
+	do {
+	    mmx_yuv2rgb (py, pu, pv);
+	    mmx_unpack_32rgb (dst, cpu);
+	    py += 8;
+	    pu += 4;
+	    pv += 4;
+	    dst += 32;
+	} while (--j);
+
+	dst += id->rgb_increm;
+	py += id->y_increm;
+	if (--i == id->field) {
+	    dst = id->rgb_ptr + id->rgb_slice * (v_offset + 1);
+	    py = src[0] + id->y_stride_frame;
+	    pu = src[1] + id->uv_stride_frame;
+	    pv = src[2] + id->uv_stride_frame;
+	} else if (! (i & id->chroma420)) {
+	    pu += id->uv_increm;
+	    pv += id->uv_increm;
+	} else {
+	    pu -= id->uv_stride_frame;
+	    pv -= id->uv_stride_frame;
+	}
+    } while (i);
+}
+
+static void mmxext_rgb16 (void * id, uint8_t * const * src,
+			  unsigned int v_offset)
+{
+    rgb16 (id, src, v_offset, CPU_MMXEXT);
+}
+
+static void mmxext_argb32 (void * id, uint8_t * const * src,
+			   unsigned int v_offset)
+{
+    argb32 (id, src, v_offset, CPU_MMXEXT);
+}
+
+static void mmx_rgb16 (void * id, uint8_t * const * src, unsigned int v_offset)
+{
+    rgb16 (id, src, v_offset, CPU_MMX);
+}
+
+static void mmx_argb32 (void * id, uint8_t * const * src,
+			unsigned int v_offset)
+{
+    argb32 (id, src, v_offset, CPU_MMX);
+}
+
+mpeg2convert_copy_t * mpeg2convert_rgb_mmxext (int order, int bpp,
+					       const mpeg2_sequence_t * seq)
+{
+    if (order == MPEG2CONVERT_RGB && seq->chroma_width < seq->width) {
+	if (bpp == 16)
+	    return mmxext_rgb16;
+	else if (bpp == 32)
+	    return mmxext_argb32;
+    }
+    return NULL;	/* Fallback to C */
+}
+
+mpeg2convert_copy_t * mpeg2convert_rgb_mmx (int order, int bpp,
+					    const mpeg2_sequence_t * seq)
+{
+    if (order == MPEG2CONVERT_RGB && seq->chroma_width < seq->width) {
+	if (bpp == 16)
+	    return mmx_rgb16;
+	else if (bpp == 32)
+	    return mmx_argb32;
+    }
+    return NULL;	/* Fallback to C */
+}
+#endif
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/rgb_vis.c xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/rgb_vis.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/rgb_vis.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/rgb_vis.c	2022-01-15 22:03:19.590547196 +0100
@@ -0,0 +1,384 @@
+/*
+ * rgb_vis.c
+ * Copyright (C) 2003 David S. Miller <davem@redhat.com>
+ *
+ * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+ * See http://libmpeg2.sourceforge.net/ for updates.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+
+#ifdef ARCH_SPARC
+
+#include <stddef.h>
+#include <inttypes.h>
+
+#include "mpeg2.h"
+#include "mpeg2convert.h"
+#include "convert_internal.h"
+#include <xine/attributes.h>
+#include "vis.h"
+
+/* Based partially upon the MMX yuv2rgb code, see there for credits.
+ *
+ * The difference here is that since we have enough registers we
+ * process both even and odd scanlines in one pass.
+ */
+
+static const uint16_t const_2048[] ATTR_ALIGN(8) = {2048, 2048, 2048, 2048};
+static const uint16_t const_1024[] ATTR_ALIGN(8) = {1024, 1024, 1024, 1024};
+static const uint16_t const_128[] ATTR_ALIGN(8) = {128, 128, 128, 128};
+static const uint8_t const_Ugreen[] ATTR_ALIGN(8) =
+	{0xf3, 0x00, 0xf3, 0x00, 0xf3, 0x00, 0xf3, 0x00};
+static const uint8_t const_Vgreen[] ATTR_ALIGN(8) =
+	{0xe6, 0x00, 0xe6, 0x00, 0xe6, 0x00, 0xe6, 0x00};
+static const uint8_t const_Ublue_Vred[] ATTR_ALIGN(8) =
+	{0x41, 0x41, 0x41, 0x41, 0x33, 0x33, 0x33, 0x33};
+static const uint8_t const_Ycoeff[] ATTR_ALIGN(4) = {0x25, 0x25, 0x25, 0x25};
+
+#define TMP0		0
+#define TMP1		1
+#define TMP2		2
+#define TMP3		3
+#define TMP4		4
+#define TMP5		5
+#define TMP6		6
+#define TMP7		7
+#define TMP8		8
+#define TMP9		9
+#define TMP10		10
+#define TMP11		11
+#define TMP12		12
+#define TMP13		13
+
+#define CONST_UBLUE	14
+#define CONST_VRED	15
+#define CONST_2048	16
+
+#define BLUE8_EVEN	18
+#define BLUE8_ODD	19
+#define RED8_EVEN	20
+#define RED8_ODD	21
+#define GREEN8_EVEN	22
+#define GREEN8_ODD	23
+
+#define BLUE8_2_EVEN	24
+#define BLUE8_2_ODD	25
+#define RED8_2_EVEN	26
+#define RED8_2_ODD	27
+#define GREEN8_2_EVEN	28
+#define GREEN8_2_ODD	29
+
+#define CONST_YCOEFF	30
+#define ZEROS		31
+
+#define PU_0		32
+#define PU_2		34
+#define PV_0		36
+#define PV_2		38
+#define PY_0		40
+#define PY_2		42
+#define PY_4		44
+#define PY_6		46
+
+#define CONST_128	56
+#define CONST_1024	58
+#define CONST_VGREEN	60
+#define CONST_UGREEN	62
+
+static inline void vis_init_consts(void)
+{
+	vis_set_gsr(7 << VIS_GSR_SCALEFACT_SHIFT);
+
+	vis_ld64(const_2048[0], CONST_2048);
+	vis_ld64(const_1024[0], CONST_1024);
+	vis_ld64(const_Ugreen[0], CONST_UGREEN);
+	vis_ld64(const_Vgreen[0], CONST_VGREEN);
+	vis_fzeros(ZEROS);
+	vis_ld64(const_Ublue_Vred[0], CONST_UBLUE);
+	vis_ld32(const_Ycoeff[0], CONST_YCOEFF);
+	vis_ld64(const_128[0],  CONST_128);
+}
+
+static inline void vis_yuv2rgb(uint8_t *py, uint8_t *pu, uint8_t *pv,
+			       int y_stride)
+{
+	vis_ld32(pu[0], TMP0);
+
+	vis_ld32(pv[0], TMP2);
+
+	vis_ld64(py[0], TMP4);
+	vis_mul8x16au(TMP0, CONST_2048, PU_0);
+
+	vis_ld64_2(py, y_stride, TMP8);
+	vis_mul8x16au(TMP2, CONST_2048, PV_0);
+
+	vis_pmerge(TMP4, TMP5, TMP6);
+
+	vis_pmerge(TMP6, TMP7, TMP4);
+
+	vis_pmerge(TMP8, TMP9, TMP10);
+
+	vis_pmerge(TMP10, TMP11, TMP8);
+	vis_mul8x16au(TMP4, CONST_2048, PY_0);
+
+	vis_psub16(PU_0, CONST_1024, PU_0);
+	vis_mul8x16au(TMP5, CONST_2048, PY_2);
+
+	vis_psub16(PV_0, CONST_1024, PV_0);
+	vis_mul8x16au(TMP8, CONST_2048, PY_4);
+
+	vis_psub16(PY_0, CONST_128, PY_0);
+	vis_mul8x16au(TMP9, CONST_2048, PY_6);
+
+	vis_psub16(PY_2, CONST_128, PY_2);
+	vis_mul8x16(CONST_YCOEFF, PY_0, PY_0);
+
+	vis_psub16(PY_4, CONST_128, PY_4);
+	vis_mul8x16(CONST_YCOEFF, PY_2, PY_2);
+
+	vis_psub16(PY_6, CONST_128, PY_6);
+	vis_mul8x16(CONST_YCOEFF, PY_4, PY_4);
+
+	vis_mul8x16(CONST_YCOEFF, PY_6, PY_6);
+
+	vis_mul8sux16(CONST_UGREEN, PU_0, TMP0);
+
+	vis_mul8sux16(CONST_VGREEN, PV_0, TMP2);
+
+	vis_mul8x16(CONST_UBLUE, PU_0, TMP4);
+
+	vis_mul8x16(CONST_VRED, PV_0, TMP6);
+	vis_padd16(TMP0, TMP2, TMP10);
+
+	vis_padd16(PY_0, TMP4, TMP0);
+
+	vis_padd16(PY_2, TMP4, TMP2);
+	vis_pack16(TMP0, BLUE8_EVEN);
+
+	vis_padd16(PY_4, TMP4, TMP0);
+	vis_pack16(TMP2, BLUE8_ODD);
+
+	vis_padd16(PY_6, TMP4, TMP2);
+	vis_pack16(TMP0, BLUE8_2_EVEN);
+
+	vis_padd16(PY_0, TMP6, TMP0);
+	vis_pack16(TMP2, BLUE8_2_ODD);
+
+	vis_padd16(PY_2, TMP6, TMP2);
+	vis_pack16(TMP0, RED8_EVEN);
+
+	vis_padd16(PY_4, TMP6, TMP0);
+	vis_pack16(TMP2, RED8_ODD);
+
+	vis_padd16(PY_6, TMP6, TMP2);
+	vis_pack16(TMP0, RED8_2_EVEN);
+
+	vis_padd16(PY_0, TMP10, TMP0);
+	vis_pack16(TMP2, RED8_2_ODD);
+
+	vis_padd16(PY_2, TMP10, TMP2);
+	vis_pack16(TMP0, GREEN8_EVEN);
+
+	vis_padd16(PY_4, TMP10, TMP0);
+	vis_pack16(TMP2, GREEN8_ODD);
+
+	vis_padd16(PY_6, TMP10, TMP2);
+	vis_pack16(TMP0, GREEN8_2_EVEN);
+
+	vis_pack16(TMP2, GREEN8_2_ODD);
+	vis_pmerge(BLUE8_EVEN, BLUE8_ODD, BLUE8_EVEN);
+
+	vis_pmerge(BLUE8_2_EVEN, BLUE8_2_ODD, BLUE8_2_EVEN);
+
+	vis_pmerge(RED8_EVEN, RED8_ODD, RED8_EVEN);
+
+	vis_pmerge(RED8_2_EVEN, RED8_2_ODD, RED8_2_EVEN);
+
+	vis_pmerge(GREEN8_EVEN, GREEN8_ODD, GREEN8_EVEN);
+
+	vis_pmerge(GREEN8_2_EVEN, GREEN8_2_ODD, GREEN8_2_EVEN);
+}
+
+static inline void vis_unpack_32rgb(uint8_t *image, int stride)
+{
+	vis_pmerge(ZEROS, GREEN8_EVEN, TMP0);
+	vis_pmerge(RED8_EVEN, BLUE8_EVEN, TMP2);
+
+	vis_pmerge(TMP0, TMP2, TMP4);
+	vis_st64(TMP4, image[0]);
+
+	vis_pmerge(TMP1, TMP3, TMP6);
+	vis_st64_2(TMP6, image, 8);
+
+	vis_pmerge(ZEROS, GREEN8_ODD, TMP8);
+	vis_pmerge(RED8_ODD, BLUE8_ODD, TMP10);
+
+	vis_pmerge(TMP8, TMP10, TMP0);
+	vis_st64_2(TMP0, image, 16);
+
+	vis_pmerge(TMP9, TMP11, TMP2);
+	vis_st64_2(TMP2, image, 24);
+
+	image += stride;
+
+	vis_pmerge(ZEROS, GREEN8_2_EVEN, TMP0);
+	vis_pmerge(RED8_2_EVEN, BLUE8_2_EVEN, TMP2);
+
+	vis_pmerge(TMP0, TMP2, TMP4);
+	vis_st64(TMP4, image[0]);
+
+	vis_pmerge(TMP1, TMP3, TMP6);
+	vis_st64_2(TMP6, image, 8);
+
+	vis_pmerge(ZEROS, GREEN8_2_ODD, TMP8);
+	vis_pmerge(RED8_2_ODD, BLUE8_2_ODD, TMP10);
+
+	vis_pmerge(TMP8, TMP10, TMP0);
+	vis_st64_2(TMP0, image, 16);
+
+	vis_pmerge(TMP9, TMP11, TMP2);
+	vis_st64_2(TMP2, image, 24);
+}
+
+static inline void vis_unpack_32bgr(uint8_t *image, int stride)
+{
+	vis_pmerge(ZEROS, GREEN8_EVEN, TMP0);
+	vis_pmerge(BLUE8_EVEN, RED8_EVEN, TMP2);
+
+	vis_pmerge(TMP0, TMP2, TMP4);
+	vis_st64(TMP4, image[0]);
+
+	vis_pmerge(TMP1, TMP3, TMP6);
+	vis_st64_2(TMP6, image, 8);
+
+	vis_pmerge(ZEROS, GREEN8_ODD, TMP8);
+	vis_pmerge(BLUE8_ODD, RED8_ODD, TMP10);
+
+	vis_pmerge(TMP8, TMP10, TMP0);
+	vis_st64_2(TMP0, image, 16);
+
+	vis_pmerge(TMP9, TMP11, TMP2);
+	vis_st64_2(TMP2, image, 24);
+
+	image += stride;
+
+	vis_pmerge(ZEROS, GREEN8_2_EVEN, TMP0);
+	vis_pmerge(BLUE8_2_EVEN, RED8_2_EVEN, TMP2);
+
+	vis_pmerge(TMP0, TMP2, TMP4);
+	vis_st64(TMP4, image[0]);
+
+	vis_pmerge(TMP1, TMP3, TMP6);
+	vis_st64_2(TMP6, image, 8);
+
+	vis_pmerge(ZEROS, GREEN8_2_ODD, TMP8);
+	vis_pmerge(BLUE8_2_ODD, RED8_2_ODD, TMP10);
+
+	vis_pmerge(TMP8, TMP10, TMP0);
+	vis_st64_2(TMP0, image, 16);
+
+	vis_pmerge(TMP9, TMP11, TMP2);
+	vis_st64_2(TMP2, image, 24);
+}
+
+static inline void vis_yuv420_argb32(uint8_t *image,
+				     uint8_t *py, uint8_t *pu, uint8_t *pv,
+				     int width, int height, int rgb_stride,
+				     int y_stride, int uv_stride)
+{
+	height >>= 1;
+	uv_stride -= width >> 1;
+	do {
+		int i = width >> 3;
+		do {
+			vis_yuv2rgb(py, pu, pv, y_stride);
+			vis_unpack_32rgb(image, rgb_stride);
+			py += 8;
+			pu += 4;
+			pv += 4;
+			image += 32;
+		} while (--i);
+
+		py    += (y_stride << 1) - width;
+		image += (rgb_stride << 1) - 4 * width;
+		pu    += uv_stride;
+		pv    += uv_stride;
+	} while (--height);
+}
+
+static inline void vis_yuv420_abgr32(uint8_t *image,
+				     uint8_t *py, uint8_t *pu, uint8_t *pv,
+				     int width, int height, int rgb_stride,
+				     int y_stride, int uv_stride)
+{
+	height >>= 1;
+	uv_stride -= width >> 1;
+	do {
+		int i = width >> 3;
+		do {
+			vis_yuv2rgb(py, pu, pv, y_stride);
+			vis_unpack_32bgr(image, rgb_stride);
+			py += 8;
+			pu += 4;
+			pv += 4;
+			image += 32;
+		} while (--i);
+
+		py    += (y_stride << 1) - width;
+		image += (rgb_stride << 1) - 4 * width;
+		pu    += uv_stride;
+		pv    += uv_stride;
+	} while (--height);
+}
+
+static void vis_argb32(void *_id, uint8_t * const *src,
+		       unsigned int v_offset)
+{
+	convert_rgb_t *id = (convert_rgb_t *) _id;
+
+	vis_init_consts();
+	vis_yuv420_argb32(id->rgb_ptr + id->rgb_stride * v_offset,
+			  src[0], src[1], src[2], id->width, 16,
+			  id->rgb_stride, id->y_stride, id->y_stride >> 1);
+}
+
+static void vis_abgr32(void *_id, uint8_t * const *src,
+		       unsigned int v_offset)
+{
+	convert_rgb_t *id = (convert_rgb_t *) _id;
+
+	vis_init_consts();
+	vis_yuv420_abgr32(id->rgb_ptr + id->rgb_stride * v_offset,
+			  src[0], src[1], src[2], id->width, 16,
+			  id->rgb_stride, id->y_stride, id->y_stride >> 1);
+}
+
+mpeg2convert_copy_t *mpeg2convert_rgb_vis(int order, int bpp,
+					  const mpeg2_sequence_t * seq)
+{
+	if (bpp == 32 && seq->chroma_height < seq->height) {
+		if (order == MPEG2CONVERT_RGB)
+			return vis_argb32;
+		if (order == MPEG2CONVERT_BGR)
+			return vis_abgr32;
+	}
+
+	return NULL;	/* Fallback to C */
+}
+
+#endif /* ARCH_SPARC */
diff -urN xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/uyvy.c xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/uyvy.c
--- xine-lib-1.2.11/src/video_dec/libmpeg2new/libmpeg2/uyvy.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/uyvy.c	2022-01-15 22:03:19.621547327 +0100
@@ -0,0 +1,123 @@
+/*
+ * uyvy.c
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2003      Regis Duchesne <hpreg@zoy.org>
+ * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ *
+ * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+ * See http://libmpeg2.sourceforge.net/ for updates.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+
+#include <inttypes.h>
+
+#include "mpeg2.h"
+#include "mpeg2convert.h"
+
+typedef struct {
+    int width;
+    int stride;
+    int chroma420;
+    uint8_t * out;
+} convert_uyvy_t;
+
+static void uyvy_start (void * _id, const mpeg2_fbuf_t * fbuf,
+			const mpeg2_picture_t * picture,
+			const mpeg2_gop_t * gop)
+{
+    convert_uyvy_t * instance = (convert_uyvy_t *) _id;
+
+    instance->out = fbuf->buf[0];
+    instance->stride = instance->width;
+    if (picture->nb_fields == 1) {
+	if (! (picture->flags & PIC_FLAG_TOP_FIELD_FIRST))
+	    instance->out += 2 * instance->stride;
+	instance->stride <<= 1;
+    }
+}
+
+#ifdef WORDS_BIGENDIAN
+#define PACK(a,b,c,d) (((a) << 24) | ((b) << 16) | ((c) << 8) | (d))
+#else
+#define PACK(a,b,c,d) (((d) << 24) | ((c) << 16) | ((b) << 8) | (a))
+#endif
+
+static void uyvy_copy (void * const _id, uint8_t * const * src,
+		       const unsigned int v_offset)
+{
+    const convert_uyvy_t * const id = (convert_uyvy_t *) _id;
+    uint8_t * _dst;
+    uint8_t * py, * pu, * pv;
+    int i, j;
+
+    _dst = id->out + 2 * id->stride * v_offset;
+    py = src[0]; pu = src[1]; pv = src[2];
+
+    i = 16;
+    do {
+	uint32_t * dst = (uint32_t *) _dst;
+
+	j = id->width >> 4;
+	do {
+	    dst[0] = PACK (pu[0],  py[0], pv[0],  py[1]);
+	    dst[1] = PACK (pu[1],  py[2], pv[1],  py[3]);
+	    dst[2] = PACK (pu[2],  py[4], pv[2],  py[5]);
+	    dst[3] = PACK (pu[3],  py[6], pv[3],  py[7]);
+	    dst[4] = PACK (pu[4],  py[8], pv[4],  py[9]);
+	    dst[5] = PACK (pu[5], py[10], pv[5], py[11]);
+	    dst[6] = PACK (pu[6], py[12], pv[6], py[13]);
+	    dst[7] = PACK (pu[7], py[14], pv[7], py[15]);
+	    py += 16;
+	    pu += 8;
+	    pv += 8;
+	    dst += 8;
+	} while (--j);
+	py -= id->width;
+	pu -= id->width >> 1;
+	pv -= id->width >> 1;
+	_dst += 2 * id->stride;
+	py += id->stride;
+	if (! (--i & id->chroma420)) {
+	    pu += id->stride >> 1;
+	    pv += id->stride >> 1;
+	}
+    } while (i);
+}
+
+int mpeg2convert_uyvy (int stage, void * _id, const mpeg2_sequence_t * seq,
+		       int stride, uint32_t accel, void * arg,
+		       mpeg2_convert_init_t * result)
+{
+    convert_uyvy_t * instance = (convert_uyvy_t *) _id;
+
+    if (seq->chroma_width == seq->width)
+	return 1;
+
+    if (instance) {
+	instance->width = seq->width;
+	instance->chroma420 = (seq->chroma_height < seq->height);
+	result->buf_size[0] = seq->width * seq->height * 2;
+	result->buf_size[1] = result->buf_size[2] = 0;
+	result->start = uyvy_start;
+	result->copy = uyvy_copy;
+    } else {
+	result->id_size = sizeof (convert_uyvy_t);
+    }
+
+    return 0;
+}
diff -urN xine-lib-1.2.11/src/video_dec/libpng.c xine-lib-1.2/src/video_dec/libpng.c
--- xine-lib-1.2.11/src/video_dec/libpng.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libpng.c	2022-01-15 22:03:19.606547263 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2003-2020 the xine project
+ * Copyright (C) 2003-2021 the xine project
  * Copyright (C) 2018-2019 Petri Hintukainen <phintuka@users.sourceforge.net>
  *
  * This file is part of xine, a free video player.
@@ -176,6 +176,7 @@
 
     _x_stream_info_set(this->stream, XINE_STREAM_INFO_VIDEO_WIDTH,  width);
     _x_stream_info_set(this->stream, XINE_STREAM_INFO_VIDEO_HEIGHT, height);
+    _x_meta_info_set_utf8(this->stream, XINE_META_INFO_VIDEOCODEC, "PNG");
 
 
     /* set up libpng csc */
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/alterh264_bits_reader.h xine-lib-1.2/src/video_dec/libvdpau/alterh264_bits_reader.h
--- xine-lib-1.2.11/src/video_dec/libvdpau/alterh264_bits_reader.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/alterh264_bits_reader.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,148 +0,0 @@
-/* kate: tab-indent on; indent-width 4; mixedindent off; indent-mode cstyle; remove-trailing-space on; */
-/*
- * Copyright (C) 2008-2013 the xine project
- *
- * This file is part of xine, a free video player.
- *
- * xine is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * xine is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- */
-
-#ifndef ALTERH264_BITS_READER_H
-#define ALTERH264_BITS_READER_H
-#include <sys/types.h>
-#include <inttypes.h>
-#include <stdio.h>
-
-
-
-typedef struct {
-  const uint8_t *buffer, *start;
-  int offbits, length, oflow;
-} bits_reader_t;
-
-
-
-static void
-bits_reader_set (bits_reader_t * br, const uint8_t * buf, int len)
-{
-  br->buffer = br->start = buf;
-  br->offbits = 0;
-  br->length = len;
-  br->oflow = 0;
-}
-
-
-
-static inline uint32_t
-more_rbsp_data (bits_reader_t * br)
-{
-  uint8_t val[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
-  const uint8_t *buf = br->start + br->length;
-  int bit;
-
-  while (--buf >= br->buffer)
-  {
-    for (bit = 7; bit > -1; bit--)
-      if (*buf & val[bit])
-	return ((buf - br->buffer) * 8) - br->offbits + bit;
-  }
-  return 0;
-}
-
-
-
-static inline uint8_t
-bits_reader_shift (bits_reader_t * br)
-{
-  br->offbits = 0;
-  if ((br->buffer + 1) > (br->start + br->length - 1))
-  {
-    br->oflow = 1;
-    //printf("!!!!! buffer overflow !!!!!\n");
-    return 0;
-  }
-  ++br->buffer;
-  if ((*(br->buffer) == 3) && ((br->buffer - br->start) > 2)
-      && (*(br->buffer - 2) == 0) && (*(br->buffer - 1) == 0))
-  {
-    if ((br->buffer + 1) > (br->start + br->length - 1))
-    {
-      br->oflow = 1;
-      //printf("!!!!! buffer overflow !!!!!\n");
-      return 0;
-    }
-    ++br->buffer;
-  }
-  return 1;
-}
-
-
-
-static inline uint32_t
-read_bits (bits_reader_t * br, int nbits)
-{
-  uint8_t val[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
-  uint32_t res = 0;
-
-  while (nbits)
-  {
-    res = (res << 1) + ((*br->buffer & val[br->offbits]) ? 1 : 0);
-    --nbits;
-    ++br->offbits;
-    if (br->offbits > 7)
-      if (!bits_reader_shift (br))
-	return 1;
-  }
-  return res;
-}
-
-
-
-static inline void
-skip_bits (bits_reader_t * br, int nbits)
-{
-  while (nbits)
-  {
-    --nbits;
-    ++br->offbits;
-    if (br->offbits > 7)
-      bits_reader_shift (br);
-  }
-}
-
-
-
-static inline uint32_t
-read_exp_ue (bits_reader_t * br)
-{
-  int leading = -1;
-  uint8_t b;
-
-  for (b = 0; !b; leading++)
-    b = read_bits (br, 1);
-
-  return (1 << leading) - 1 + read_bits (br, leading);
-}
-
-
-
-static inline int32_t
-read_exp_se (bits_reader_t * br)
-{
-  uint32_t res = read_exp_ue (br);
-  return (res & 0x01) ? (res + 1) / 2 : -(res / 2);
-}
-#endif /* ALTERH264_BITS_READER_H */
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/alterh264_decode.c xine-lib-1.2/src/video_dec/libvdpau/alterh264_decode.c
--- xine-lib-1.2.11/src/video_dec/libvdpau/alterh264_decode.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/alterh264_decode.c	2022-01-15 22:03:19.616547306 +0100
@@ -1,5 +1,5 @@
 /* kate: space-indent on; indent-width 2; mixedindent off; indent-mode cstyle; remove-trailing-space on;
- * Copyright (C) 2008-2020 the xine project
+ * Copyright (C) 2008-2021 the xine project
  * Copyright (C) 2008 Christophe Thommeret <hftom@free.fr>
  *
  * This file is part of xine, a free video player.
@@ -26,2168 +26,338 @@
 #include "config.h"
 #endif
 
-#include "alterh264_decode.h"
-#include "group_vdpau.h"
-
-
-#define MAX_DPB_SIZE 16
-#define MIN_BUFFER_SIZE 10000
-#define MAX_BUFFER_SIZE 3145728
-
-#define NAL_UNSPECIFIED 0
-#define NAL_SLICE_NO_IDR 1
-#define NAL_SLICE_IDR 5
-#define NAL_SEI 6
-#define NAL_SEQUENCE 7
-#define NAL_PICTURE 8
-#define NAL_ACCES 9
-#define NAL_END_SEQUENCE 10
-#define NAL_END_STREAM 11
-#define NAL_SEQUENCE_EXT 13
-
-#define SLICE_TYPE_P 0
-#define SLICE_TYPE_B 1
-#define SLICE_TYPE_I 2
-#define SLICE_TYPE_SP 3
-#define SLICE_TYPE_SI 4
-
-#define START_IDR_FLAG 1000
-
-#define MAX_POC 2147483647
-
-#define DPB_DRAW_CLEAR   1
-#define DPB_DRAW_REFS   2
-#define DPB_DRAW_CURRENT 3
-
-//#define MAKE_DAT /*do NOT define this, unless you know what you do */
-#ifdef MAKE_DAT
-static int nframes;
-static FILE *outfile;
-#endif
-
-static const uint8_t zigzag_4x4[16] = {
-  0, 1, 4, 8,
-  5, 2, 3, 6,
-  9, 12, 13, 10,
-  7, 11, 14, 15
-};
-
-static const uint8_t zigzag_8x8[64] = {
-  0, 1, 8, 16, 9, 2, 3, 10,
-  17, 24, 32, 25, 18, 11, 4, 5,
-  12, 19, 26, 33, 40, 48, 41, 34,
-  27, 20, 13, 6, 7, 14, 21, 28,
-  35, 42, 49, 56, 57, 50, 43, 36,
-  29, 22, 15, 23, 30, 37, 44, 51,
-  58, 59, 52, 45, 38, 31, 39, 46,
-  53, 60, 61, 54, 47, 55, 62, 63
-};
-
-static const uint8_t default_4x4_intra[16] = {
-  6, 13, 13, 20,
-  20, 20, 28, 28,
-  28, 28, 32, 32,
-  32, 37, 37, 42
-};
-
-static const uint8_t default_4x4_inter[16] = {
-  10, 14, 14, 20,
-  20, 20, 24, 24,
-  24, 24, 27, 27,
-  27, 30, 30, 34
-};
-
-static const uint8_t default_8x8_intra[64] = {
-  6, 10, 10, 13, 11, 13, 16, 16,
-  16, 16, 18, 18, 18, 18, 18, 23,
-  23, 23, 23, 23, 23, 25, 25, 25,
-  25, 25, 25, 25, 27, 27, 27, 27,
-  27, 27, 27, 27, 29, 29, 29, 29,
-  29, 29, 29, 31, 31, 31, 31, 31,
-  31, 33, 33, 33, 33, 33, 36, 36,
-  36, 36, 38, 38, 38, 40, 40, 42
-};
-
-static const uint8_t default_8x8_inter[64] = {
-  9, 13, 13, 15, 13, 15, 17, 17,
-  17, 17, 19, 19, 19, 19, 19, 21,
-  21, 21, 21, 21, 21, 22, 22, 22,
-  22, 22, 22, 22, 24, 24, 24, 24,
-  24, 24, 24, 24, 25, 25, 25, 25,
-  25, 25, 25, 27, 27, 27, 27, 27,
-  27, 28, 28, 28, 28, 28, 30, 30,
-  30, 30, 32, 32, 32, 33, 33, 35
-};
-
-
-
-/*-------- DPB -------------------------------------------*/
-static void
-dpb_print (sequence_t * sequence)
-{
-  int i;
-  dpb_frame_t *frame;
-  uint32_t sf;
-
-  for (i = 0; i < MAX_DPB_SIZE; i++)
-  {
-    frame = sequence->dpb[i];
-    if (!frame->used)
-      break;
-    vo_frame_t *vo = (vo_frame_t *) frame->videoSurface;
-    vdpau_accel_t *accel;
-    if (vo)
-      accel = (vdpau_accel_t *) vo->accel_data;
-    sf = (vo) ? accel->surface : (uint32_t)-1;
-    fprintf (stderr,
-	     "{ i:%d u:%d c:%d pn:%d-%d ir:%d-%d tpoc:%d bpoc:%d sf:%u }\n",
-	     i, frame->used, frame->completed, frame->PicNum[0],
-	     frame->PicNum[1], frame->is_reference[0], frame->is_reference[1],
-	     frame->TopFieldOrderCnt, frame->BottomFieldOrderCnt, sf);
-  }
-}
-
-
-
-static void
-dpb_clear_all_pts (sequence_t * sequence)
-{
-  int i;
-
-  for (i = 0; i < MAX_DPB_SIZE; i++)
-  {
-    if (!sequence->dpb[i]->used)
-      break;
-    sequence->dpb[i]->pts = 0;
-  }
-  sequence->cur_pic.pts = 0;
-  sequence->cur_pic.drop_pts = 1;
-}
-
-
-static void
-dpb_reset (sequence_t * sequence)
-{
-  int i;
-
-  for (i = 0; i < MAX_DPB_SIZE; i++)
-  {
-    if (sequence->dpb[i]->videoSurface)
-      sequence->dpb[i]->videoSurface->free (sequence->dpb[i]->videoSurface);
-    memset (sequence->dpb[i], 0, sizeof (dpb_frame_t));
-  }
-  if (sequence->cur_pic.videoSurface && !sequence->cur_pic.is_reference[0]
-      && !sequence->cur_pic.is_reference[1])
-  {
-    //fprintf(stderr, "freeing cur_pic\n");
-    sequence->cur_pic.videoSurface->free (sequence->cur_pic.videoSurface);
-  }
-}
-
-
-
-static void
-dpb_remove (sequence_t * sequence, int index)
-{
-  lprintf ("|||||||||||||||||||||||||||||||||||||||| dbp_remove\n");
-  int i;
-
-  dpb_frame_t *frame = sequence->dpb[index];
-  if (frame->videoSurface)
-    frame->videoSurface->free (frame->videoSurface);
-  memset (frame, 0, sizeof (dpb_frame_t));
-  for (i = index; i < (MAX_DPB_SIZE - 1); i++)
-  {
-    sequence->dpb[i] = sequence->dpb[i + 1];
-    if (!sequence->dpb[i]->used)
-    {
-      sequence->dpb[i + 1] = frame;
-      break;
-    }
-  }
-  if (i == (MAX_DPB_SIZE - 1))
-    sequence->dpb[i] = frame;
-}
-
-
+//#define LOG
+#define LOG_MODULE "vdpau_h264"
 
-static dpb_frame_t *
-dpb_get_prev_ref (sequence_t * sequence)
-{
-  int i = MAX_DPB_SIZE - 1;
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <xine/xine_internal.h>
+#include <xine/video_out.h>
+#include <xine/buffer.h>
+#include <xine/xineutils.h>
+#include "accel_vdpau.h"
+#include <vdpau/vdpau.h>
 
-  while (i > -1)
-  {
-    if (sequence->dpb[i]->used)
-      return sequence->dpb[i];
-    --i;
-  }
+#include "group_vdpau.h"
+#include "vdec_hw_h264.h"
 
-  return NULL;
-}
+typedef struct {
+  video_decoder_t video_decoder;        /* parent video decoder structure */
 
+  xine_stream_t *stream;
 
+  vdec_hw_h264_t *vdec;
 
-static void
-dpb_draw_frames (vdpau_h264_alter_decoder_t * this_gen, int32_t curpoc,
-		 int draw_mode)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  int i, index = 0;
-  int32_t poc, tpoc;
-  dpb_frame_t *frame;
-
-  while (index > -1)
-  {
-    index = -1;
-    poc = curpoc;
-    for (i = 0; i < MAX_DPB_SIZE; i++)
-    {
-      frame = seq->dpb[i];
-      if (!frame->used)
-	break;
-      tpoc =
-	(frame->TopFieldOrderCnt >
-	 frame->BottomFieldOrderCnt) ? frame->TopFieldOrderCnt : frame->
-	BottomFieldOrderCnt;
-      if (!frame->videoSurface->drawn && (tpoc <= poc))
-      {
-	poc = tpoc;
-	index = i;
-      }
-    }
-    if ((index > -1) && (poc <= curpoc))
-    {
-      //fprintf(stderr,"|||||||||||||||||||||||||||||||||||||||| dpb_draw_frame = %d\n", poc);
-      frame = seq->dpb[index];
-      frame->videoSurface->pts = frame->pts;
-      //fprintf(stderr,"H264 PTS = %llu\n", frame->pts);
-      frame->videoSurface->top_field_first = frame->top_field_first;
-      frame->videoSurface->draw (frame->videoSurface, this_gen->stream);
-      frame->videoSurface->drawn++;
-      if ((draw_mode != DPB_DRAW_CLEAR) && !frame->is_reference[0]
-	  && !frame->is_reference[1])
-	dpb_remove (seq, index);
-    }
-    else
-      index = -1;
-  }
-
-  if (draw_mode == DPB_DRAW_CURRENT)
-  {
-    //fprintf(stderr,"|||||||||||||||||||||||||||||||||||||||| dpb_draw_frame = %d\n", curpoc);
-    frame = &seq->cur_pic;
-    frame->videoSurface->pts = frame->pts;
-    //fprintf(stderr,"H264 PTS = %llu\n", frame->pts);
-    frame->videoSurface->top_field_first = frame->top_field_first;
-    frame->videoSurface->draw (frame->videoSurface, this_gen->stream);
-    frame->videoSurface->free (frame->videoSurface);
-  }
-  else if (draw_mode == DPB_DRAW_CLEAR)
-    dpb_reset (seq);
-}
+  vdpau_accel_t *accel;
 
+  VdpDecoderProfile profile;
+  vdpau_accel_t *accel_vdpau;
+  VdpDecoder decoder;
+  VdpDecoderProfile decoder_profile;
+  int vdp_runtime_nr;
 
+  int decoder_width;
+  int decoder_height;
 
-static dpb_frame_t *
-dpb_get_PicNum (sequence_t * sequence, int32_t pic_num, int *index)
-{
-  dpb_frame_t *frame;
-  int i = 0;
+  int seek;
 
-  for (i = 0; i < MAX_DPB_SIZE; i++)
-  {
-    frame = sequence->dpb[i];
-    if (!frame->used)
-      break;
-    if ((frame->PicNum[0] == pic_num) || (frame->PicNum[1] == pic_num))
-    {
-      *index = i;
-      return frame;
-    }
+  double reported_ratio;
+  int reported_video_step;
+  int reported_width;
+  int reported_height;
+
+  int used;
+} vdpau_h264_alter_decoder_t;
+
+static VdpDecoderProfile vdpau_h264_map_profile (int profile_idc) {
+  /* nvidia's vdpau doesn't suppot baseline (66), force main (77) */
+  return profile_idc >= 100 ? VDP_DECODER_PROFILE_H264_HIGH : VDP_DECODER_PROFILE_H264_MAIN;
+}
+
+static __attribute__((format (printf, 3, 4))) int vdpau_h264_alter_logg (void *user_data,
+  vdec_hw_h264_logg_t level, const char *fmt, ...) {
+  char b[2048];
+  vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *)user_data;
+  int l2 = level == VDEC_HW_H264_LOGG_ERR ? XINE_VERBOSITY_LOG
+         : level == VDEC_HW_H264_LOGG_INFO ? XINE_VERBOSITY_DEBUG
+         : /* VDEC_HW_H264_LOGG_DEBUG */ XINE_VERBOSITY_DEBUG + 1;
+
+  if (l2 >= this->stream->xine->verbosity) {
+    va_list va;
+
+    va_start (va, fmt);
+    vsnprintf (b, sizeof (b), fmt, va);
+    va_end (va);
+    xprintf (this->stream->xine, l2, LOG_MODULE ": %s", b);
+    return 1;
   }
   return 0;
 }
 
+static int vdpau_h264_alter_frame_new (void *user_data, vdec_hw_h264_frame_t *frame) {
+  vdpau_h264_alter_decoder_t * this = (vdpau_h264_alter_decoder_t *)user_data;
+  int flags = ((frame->flags & VDEC_HW_H264_FRAME_TOP_FIELD) ? VO_TOP_FIELD : 0)
+            | ((frame->flags & VDEC_HW_H264_FRAME_BOTTOM_FIELD) ? VO_BOTTOM_FIELD : 0)
+            | ((frame->flags & VDEC_HW_H264_FRAME_NEW_SEQ) ? VO_NEW_SEQUENCE_FLAG : 0);
+  vo_frame_t *img;
 
-
-static void
-dpb_mmc1 (vdpau_h264_alter_decoder_t * this_gen, int32_t picnum)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  int index;
-
-  lprintf ("dpb_mmc1\n");
-
-  dpb_frame_t *frame = dpb_get_PicNum (seq, picnum, &index);
-
-  if (frame)
-  {
-    frame->is_reference[0] = frame->is_reference[1] = 0;
-    if (frame->videoSurface->drawn)
-      dpb_remove (seq, index);
-    else
-      dpb_draw_frames (this_gen,
-		       (frame->TopFieldOrderCnt >
-			frame->BottomFieldOrderCnt) ? frame->
-		       TopFieldOrderCnt : frame->BottomFieldOrderCnt,
-		       DPB_DRAW_REFS);
-  }
-}
-
-
-
-static void
-dbp_append (vdpau_h264_alter_decoder_t * this_gen, int second_field)
-{
-  sequence_t *sequence = (sequence_t *) & this_gen->sequence;
-  int i, index = 0, refs = 0;
-  int32_t fnw = MAX_POC;
-  slice_param_t *sl = &sequence->slice_param;
-  pic_param_t *pic = sequence->pic_param[sl->pic_parameter_set_id];
-  seq_param_t *sp = sequence->seq_param[pic->seq_parameter_set_id];
-  dpb_frame_t *tmp = 0, *cur_pic = &sequence->cur_pic;
-  int max = sp->num_ref_frames ? sp->num_ref_frames : 1;
-  max = (max > MAX_DPB_SIZE) ? MAX_DPB_SIZE : max;
-
-#ifdef LOG
-  vo_frame_t *vo = (vo_frame_t *) cur_pic->videoSurface;
-  vdpau_accel_t *accel = (vdpau_accel_t *) vo->accel_data;
-  lprintf
-    ("|||||||||||||||||||||||||||||||||||||||| dbp_append surface = %d\n",
-     accel->surface);
-#endif
-
-  if (second_field)
-  {
-    tmp = dpb_get_prev_ref (sequence);
-    if (tmp)
-    {
-      memcpy (tmp, cur_pic, sizeof (dpb_frame_t));
-      cur_pic->videoSurface = NULL;
-    }
-    else
-      fprintf (stderr, "OOPS, no frame to store the second field ?!\n");
-    return;
-  }
-
-  for (i = 0; i < MAX_DPB_SIZE; i++)
-  {
-    if (!sequence->dpb[i]->used)
-      break;
-    if (sequence->dpb[i]->FrameNumWrap < fnw)
-    {
-      fnw = sequence->dpb[i]->FrameNumWrap;
-      index = i;
-    }
-    refs++;
-  }
-
-  if (refs >= max)
-  {
-    lprintf ("sliding window\n");
-    tmp = sequence->dpb[index],
-      tmp->is_reference[0] = tmp->is_reference[1] = 0;
-    if (tmp->videoSurface->drawn)
-      dpb_remove (sequence, index);
-    else
-      dpb_draw_frames (this_gen,
-		       (tmp->TopFieldOrderCnt >
-			tmp->BottomFieldOrderCnt) ? tmp->
-		       TopFieldOrderCnt : tmp->BottomFieldOrderCnt,
-		       DPB_DRAW_REFS);
-
-    for (i = 0; i < MAX_DPB_SIZE; i++)
-    {
-      if (!sequence->dpb[i]->used)
-	break;
-    }
-  }
-
-  if (i < MAX_DPB_SIZE)
-  {
-    memcpy (sequence->dpb[i], cur_pic, sizeof (dpb_frame_t));
-    if (!cur_pic->field_pic_flag)
-      cur_pic->videoSurface = NULL;
-  }
-}
-
-/*--------------------------------------------------------*/
-
-
-
-static void
-reset_slices (sequence_t * sequence)
-{
-  sequence->slices_count = 0;
-  sequence->slice_mode = 0;
-}
-
-
-
-static void
-reset_sequence (sequence_t * sequence)
-{
-  sequence->prevFrameNum = 0;
-  sequence->prevFrameNumOffset = 0;
-  sequence->prevMMC5 = 0;
-
-  sequence->startup_frame = 0;
-  sequence->reset = 0;
-  sequence->chroma = 0;
-  sequence->pic_pts = 0;
-  sequence->bufpos = 0;
-  sequence->bufseek = 0;
-  sequence->start = -1;
-  reset_slices (sequence);
-  dpb_reset (sequence);
-  memset (&sequence->cur_pic, 0, sizeof (dpb_frame_t));
-  sequence->reset = VO_NEW_SEQUENCE_FLAG;
-}
-
-
-
-static void
-set_ratio (sequence_t * seq, seq_param_t * sp)
-{
-  if (seq->mode_frame && seq->ratio)
-    return;
-  if (!seq->coded_height)
-    seq->coded_height = 1;
-  seq->ratio = (double) seq->coded_width / (double) seq->coded_height;
-  if (sp->vui.aspect_ratio_info)
-  {
-    switch (sp->vui.aspect_ratio_idc)
-    {
-    case ASPECT_1_1:
-      seq->ratio = 1 * seq->ratio;
-      break;
-    case ASPECT_12_11:
-      seq->ratio *= 12.0 / 11.0;
-      break;
-    case ASPECT_10_11:
-      seq->ratio *= 10.0 / 11.0;
-      break;
-    case ASPECT_16_11:
-      seq->ratio *= 16.0 / 11.0;
-      break;
-    case ASPECT_40_33:
-      seq->ratio *= 40.0 / 33.0;
-      break;
-    case ASPECT_24_11:
-      seq->ratio *= 24.0 / 11.0;
-      break;
-    case ASPECT_20_11:
-      seq->ratio *= 20.0 / 11.0;
-      break;
-    case ASPECT_32_11:
-      seq->ratio *= 32.0 / 11.0;
-      break;
-    case ASPECT_80_33:
-      seq->ratio *= 80.0 / 33.0;
-      break;
-    case ASPECT_18_11:
-      seq->ratio *= 18.0 / 11.0;
-      break;
-    case ASPECT_15_11:
-      seq->ratio *= 15.0 / 11.0;
-      break;
-    case ASPECT_64_33:
-      seq->ratio *= 64.0 / 33.0;
-      break;
-    case ASPECT_160_99:
-      seq->ratio *= 160.0 / 99.0;
-      break;
-    case ASPECT_4_3:
-      seq->ratio *= 4.0 / 3.0;
-      break;
-    case ASPECT_3_2:
-      seq->ratio *= 3.0 / 2.0;
-      break;
-    case ASPECT_2_1:
-      seq->ratio *= 2.0 / 1.0;
-      break;
-    case ASPECT_EXTENDED_SAR:
-      if (sp->vui.sar_height)
-	seq->ratio *= (double) sp->vui.sar_width / sp->vui.sar_height;
-      break;
-    }
-  }
-}
-
-
-
-static void
-parse_scaling_list (bits_reader_t * br, uint8_t * scaling_list, int len,
-		    int index)
-{
-  int last_scale = 8;
-  int next_scale = 8;
-  int32_t delta_scale;
-  uint8_t use_default_scaling_matrix_flag = 0;
-  int i;
-  uint32_t u;
-
-  const uint8_t *zigzag = (len == 64) ? zigzag_8x8 : zigzag_4x4;
-
-  for (i = 0; i < len; i++)
-  {
-    if (next_scale != 0)
-    {
-      delta_scale = read_exp_se (br);
-      next_scale = (last_scale + delta_scale + 256) % 256;
-      if (i == 0 && next_scale == 0)
-      {
-	use_default_scaling_matrix_flag = 1;
-	break;
-      }
-    }
-    scaling_list[zigzag[i]] = last_scale =
-      (next_scale == 0) ? last_scale : next_scale;
-  }
-
-  if (use_default_scaling_matrix_flag)
-  {
-    switch (index)
-    {
-    case 0:
-    case 1:
-    case 2:
-      {
-	for (u = 0; u < sizeof (default_4x4_intra); u++)
-	  scaling_list[zigzag_4x4[u]] = default_4x4_intra[u];
-	break;
-      }
-    case 3:
-    case 4:
-    case 5:
-      {
-	for (u = 0; u < sizeof (default_4x4_inter); u++)
-	  scaling_list[zigzag_4x4[u]] = default_4x4_inter[u];
-	break;
-      }
-    case 6:
-      {
-	for (u = 0; u < sizeof (default_8x8_intra); u++)
-	  scaling_list[zigzag_8x8[u]] = default_8x8_intra[u];
-	break;
-      }
-    case 7:
-      {
-	for (u = 0; u < sizeof (default_8x8_inter); u++)
-	  scaling_list[zigzag_8x8[u]] = default_8x8_inter[u];
-	break;
-      }
-    }
-  }
-}
-
-
-
-static void
-scaling_list_fallback_A (uint8_t * scaling_lists_4x4,
-			 uint8_t * scaling_lists_8x8, int i)
-{
-  uint32_t j;
-  switch (i)
-  {
-  case 0:
-      for (j = 0; j < sizeof (default_4x4_intra); j++)
-	scaling_lists_4x4[(i * 16) + zigzag_4x4[j]] = default_4x4_intra[j];
-      break;
-  case 3:
-      for (j = 0; j < sizeof (default_4x4_inter); j++)
-	scaling_lists_4x4[(i * 16) + zigzag_4x4[j]] = default_4x4_inter[j];
-      break;
-  case 1:
-  case 2:
-  case 4:
-  case 5:
-    memcpy (&scaling_lists_4x4[i * 16], &scaling_lists_4x4[(i - 1) * 16],
-	    16);
-    break;
-  case 6:
-      for (j = 0; j < sizeof (default_8x8_intra); j++)
-	scaling_lists_8x8[(i - 6) * 64 + zigzag_8x8[j]] =
-	  default_8x8_intra[j];
-      break;
-  case 7:
-      for (j = 0; j < sizeof (default_8x8_inter); j++)
-	scaling_lists_8x8[(i - 6) * 64 + zigzag_8x8[j]] =
-	  default_8x8_inter[j];
-      break;
-  }
-}
-
-
-
-static void
-scaling_list_fallback_B (seq_param_t * sp, pic_param_t * pic, int i)
-{
-  switch (i)
-  {
-  case 0:
-  case 3:
-    memcpy (pic->scaling_lists_4x4[i], sp->scaling_lists_4x4[i],
-	    sizeof (pic->scaling_lists_4x4[i]));
-    break;
-  case 1:
-  case 2:
-  case 4:
-  case 5:
-    memcpy (pic->scaling_lists_4x4[i], pic->scaling_lists_4x4[i - 1],
-	    sizeof (pic->scaling_lists_4x4[i]));
-    break;
-  case 6:
-  case 7:
-    memcpy (pic->scaling_lists_8x8[i - 6], sp->scaling_lists_8x8[i - 6],
-	    sizeof (pic->scaling_lists_8x8[i - 6]));
-    break;
-  }
-}
-
-
-
-static void
-vui_parameters (sequence_t * seq, vui_param_t * vui)
-{
-  bits_reader_t *br = &seq->br;
-  int xine_color_matrix = 4; /* undefined, mpeg range */
-
-  vui->aspect_ratio_info = read_bits (br, 1);
-  lprintf ("aspect_ratio_info_present_flag = %d\n", vui->aspect_ratio_info);
-  if (vui->aspect_ratio_info)
-  {
-    vui->aspect_ratio_idc = read_bits (br, 8);
-    lprintf ("aspect_ratio_idc = %d\n", vui->aspect_ratio_idc);
-    if (vui->aspect_ratio_idc == 255)
-    {
-      vui->sar_width = read_bits (br, 16);
-      lprintf ("sar_width = %d\n", vui->sar_width);
-      vui->sar_height = read_bits (br, 16);
-      lprintf ("sar_height = %d\n", vui->sar_height);
-    }
-  }
-  if (read_bits (br, 1))	/* overscan_info_present_flag */
-    skip_bits (br, 1);		/* overscan_appropriate_falg */
-  if (read_bits (br, 1))
-  {				/* video_signal_type_present_flag */
-    skip_bits (br, 3);		/*video_format */
-    xine_color_matrix |= read_bits (br, 1);  /*video_full_range_flag */
-    vui->colour_desc = read_bits (br, 1);
-    lprintf ("colour_desc = %d\n", vui->colour_desc);
-    if (vui->colour_desc)
-    {
-      skip_bits (br, 8);        /* colour_primaries */
-      skip_bits (br, 8);	/* transfer_characteristics */
-      xine_color_matrix = (xine_color_matrix & 1) | (read_bits (br, 8) << 1);  /* matrix_coefficients */
-    }
-  }
-  VO_SET_FLAGS_CM (xine_color_matrix, seq->color_matrix);
-  if (read_bits (br, 1))
-  {				/* chroma_loc_info_present_flag */
-    read_exp_ue (br);		/* chroma_sample_loc_type_top_field */
-    read_exp_ue (br);		/* chroma_sample_loc_type_bottom_field */
-  }
-  vui->timing_info = read_bits (br, 1);
-  lprintf ("timing_info = %d\n", vui->timing_info);
-  if (vui->timing_info)
-  {
-    vui->num_units_in_tick = read_bits (br, 32);
-    lprintf ("num_units_in_tick = %u\n", vui->num_units_in_tick);
-    vui->time_scale = read_bits (br, 32);
-    lprintf ("time_scale = %u\n", vui->time_scale);
-    if (vui->time_scale > 0) {
-      /* good: 2 * 1001 / 48000. */
-      seq->video_step = (uint64_t)90000 * 2
-                      * vui->num_units_in_tick / vui->time_scale;
-      if (seq->video_step < 90) {
-        /* bad: 2 * 1 / 60000. seen this once from broken h.264 video usability info (VUI).
-         * VAAPI seems to apply a similar HACK.*/
-        seq->video_step = (uint64_t)90000000 * 2
-                        * vui->num_units_in_tick / vui->time_scale;
-      }
-    }
-  }
-}
-
-
-
-static void
-seq_parameter_set_data (vdpau_h264_alter_decoder_t * this_gen)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  seq_param_t *sp;
-  int i;
-
-  uint8_t profile_idc = read_bits (&seq->br, 8);
-  lprintf ("profile_idc = %d\n", profile_idc);
-  uint8_t constraint_set0_flag = read_bits (&seq->br, 1);
-  lprintf ("constraint_set0_flag = %d\n", constraint_set0_flag);
-  uint8_t constraint_set1_flag = read_bits (&seq->br, 1);
-  lprintf ("constraint_set1_flag = %d\n", constraint_set1_flag);
-  uint8_t constraint_set2_flag = read_bits (&seq->br, 1);
-  lprintf ("constraint_set2_flag = %d\n", constraint_set2_flag);
-  uint8_t constraint_set3_flag = read_bits (&seq->br, 1);
-  lprintf ("constraint_set3_flag = %d\n", constraint_set3_flag);
-  skip_bits (&seq->br, 4);
-  uint8_t level_idc = read_bits (&seq->br, 8);
-  lprintf ("level_idc = %d\n", level_idc);
-
-  uint8_t seq_parameter_set_id = read_exp_ue (&seq->br);
-  lprintf ("seq_parameter_set_id = %d\n", seq_parameter_set_id);
-  if (seq_parameter_set_id > 31)
-  {
-    lprintf ("OOPS : seq_parameter_set_id > 31 !!\n");
-    return;
-  }
-
-  if (!seq->seq_param[seq_parameter_set_id])
-    seq->seq_param[seq_parameter_set_id] =
-      (seq_param_t *) calloc (1, sizeof (seq_param_t));
-  if (!seq->seq_param[seq_parameter_set_id])
-  {
-    lprintf ("OOPS : can't allocate SPS %d !!\n", seq_parameter_set_id);
-    return;
-  }
-
-  sp = seq->seq_param[seq_parameter_set_id];
-  sp->profile_idc = profile_idc;
-  switch (profile_idc)
-  {
-  case 100:
-    seq->profile = VDP_DECODER_PROFILE_H264_HIGH;
-    break;
-  case 77:
-    seq->profile = VDP_DECODER_PROFILE_H264_MAIN;
-    break;
-  case 66:			/* nvidia's vdpau doesn't suppot baseline, force main */
-  default:
-    seq->profile = VDP_DECODER_PROFILE_H264_MAIN;
-  }
-  sp->constraint_set0_flag = constraint_set0_flag;
-  sp->constraint_set1_flag = constraint_set1_flag;
-  sp->constraint_set2_flag = constraint_set2_flag;
-  sp->constraint_set3_flag = constraint_set3_flag;
-  sp->level_idc = level_idc;
-
-  memset (&sp->scaling_lists_4x4, 16, sizeof (sp->scaling_lists_4x4));
-  memset (&sp->scaling_lists_8x8, 16, sizeof (sp->scaling_lists_8x8));
-
-  sp->chroma_format_idc = 1;
-  sp->separate_colour_plane_flag = 0;
-  if (sp->profile_idc == 100 || sp->profile_idc == 110
-      || sp->profile_idc == 122 || sp->profile_idc == 244
-      || sp->profile_idc == 44 || sp->profile_idc == 83
-      || sp->profile_idc == 86)
-  {
-    sp->chroma_format_idc = read_exp_ue (&seq->br);
-    lprintf ("chroma_format_idc = %u\n", sp->chroma_format_idc);
-    if (sp->chroma_format_idc == 3)
-    {
-      sp->separate_colour_plane_flag = read_bits (&seq->br, 1);
-      lprintf ("separate_colour_plane_flag = %d\n",
-	       sp->separate_colour_plane_flag);
-    }
-    sp->bit_depth_luma_minus8 = read_exp_ue (&seq->br);
-    lprintf ("bit_depth_luma_minus8 = %u\n", sp->bit_depth_luma_minus8);
-    sp->bit_depth_chroma_minus8 = read_exp_ue (&seq->br);
-    lprintf ("bit_depth_chroma_minus8 = %u\n", sp->bit_depth_chroma_minus8);
-    sp->qpprime_y_zero_transform_bypass_flag = read_bits (&seq->br, 1);
-    lprintf ("qpprime_y_zero_transform_bypass_flag = %u\n",
-	     sp->qpprime_y_zero_transform_bypass_flag);
-    sp->seq_scaling_matrix_present_flag = read_bits (&seq->br, 1);
-    lprintf ("seq_scaling_matrix_present_flag = %u\n",
-	     sp->seq_scaling_matrix_present_flag);
-    if (sp->seq_scaling_matrix_present_flag)
-    {
-      for (i = 0; i < 8; i++)
-      {
-	int scaling_flag = read_bits (&seq->br, 1);
-	if (scaling_flag)
-	{
-	  if (i < 6)
-	    parse_scaling_list (&seq->br, &sp->scaling_lists_4x4[i][0], 16,
-				i);
-	  else
-	    parse_scaling_list (&seq->br, &sp->scaling_lists_8x8[i - 6][0],
-				64, i);
-	}
-	else
-	  scaling_list_fallback_A ((uint8_t *) sp->scaling_lists_4x4,
-				   (uint8_t *) sp->scaling_lists_8x8, i);
-      }
-    }
-  }
-  sp->log2_max_frame_num_minus4 = read_exp_ue (&seq->br);
-  lprintf ("log2_max_frame_num_minus4 = %u\n", sp->log2_max_frame_num_minus4);
-  sp->pic_order_cnt_type = read_exp_ue (&seq->br);
-  lprintf ("pic_order_cnt_type = %u\n", sp->pic_order_cnt_type);
-  if (sp->pic_order_cnt_type == 0)
-  {
-    sp->log2_max_pic_order_cnt_lsb_minus4 = read_exp_ue (&seq->br);
-    lprintf ("log2_max_pic_order_cnt_lsb_minus4 = %u\n",
-	     sp->log2_max_pic_order_cnt_lsb_minus4);
-  }
-  else if (sp->pic_order_cnt_type == 1)
-  {
-    sp->delta_pic_order_always_zero_flag = read_bits (&seq->br, 1);
-    lprintf ("delta_pic_order_always_zero_flag = %u\n",
-	     sp->delta_pic_order_always_zero_flag);
-    sp->offset_for_non_ref_pic = read_exp_se (&seq->br);
-    lprintf ("offset_for_non_ref_pic = %d\n", sp->offset_for_non_ref_pic);
-    sp->offset_for_top_to_bottom_field = read_exp_se (&seq->br);
-    lprintf ("offset_for_top_to_bottom_field = %d\n",
-	     sp->offset_for_top_to_bottom_field);
-    sp->num_ref_frames_in_pic_order_cnt_cycle = read_exp_ue (&seq->br);
-    lprintf ("num_ref_frames_in_pic_order_cnt_cycle = %u\n",
-	     sp->num_ref_frames_in_pic_order_cnt_cycle);
-    for (i = 0; i < sp->num_ref_frames_in_pic_order_cnt_cycle; i++)
-    {
-      sp->offset_for_ref_frame[i] = read_exp_se (&seq->br);
-      lprintf ("offset_for_ref_frame[%d] = %d\n", i,
-	       sp->offset_for_ref_frame[i]);
-    }
-  }
-  sp->num_ref_frames = read_exp_ue (&seq->br);
-  if (sp->num_ref_frames > 16)
-    sp->num_ref_frames = 16;
-  lprintf ("num_ref_frames = %u\n", sp->num_ref_frames);
-  sp->gaps_in_frame_num_value_allowed_flag = read_bits (&seq->br, 1);
-  lprintf ("gaps_in_frame_num_value_allowed_flag = %u\n",
-	   sp->gaps_in_frame_num_value_allowed_flag);
-  sp->pic_width_in_mbs_minus1 = read_exp_ue (&seq->br);
-  lprintf ("pic_width_in_mbs_minus1 = %u\n", sp->pic_width_in_mbs_minus1);
-  sp->pic_height_in_map_units_minus1 = read_exp_ue (&seq->br);
-  lprintf ("pic_height_in_map_units_minus1 = %u\n",
-	   sp->pic_height_in_map_units_minus1);
-  sp->frame_mbs_only_flag = read_bits (&seq->br, 1);
-  lprintf ("frame_mbs_only_flag = %u\n", sp->frame_mbs_only_flag);
-
-  seq->coded_width = (sp->pic_width_in_mbs_minus1 + 1) * 16;
-  seq->coded_height =
-    (2 - sp->frame_mbs_only_flag) * (sp->pic_height_in_map_units_minus1 +
-				     1) * 16;
-
-  if (!sp->frame_mbs_only_flag)
-  {
-    sp->mb_adaptive_frame_field_flag = read_bits (&seq->br, 1);
-    lprintf ("mb_adaptive_frame_field_flag = %u\n",
-	     sp->mb_adaptive_frame_field_flag);
-  }
-  else
-    sp->mb_adaptive_frame_field_flag = 0;
-  sp->direct_8x8_inference_flag = read_bits (&seq->br, 1);
-  lprintf ("direct_8x8_inference_flag = %u\n", sp->direct_8x8_inference_flag);
-  sp->frame_cropping_flag = read_bits (&seq->br, 1);
-  lprintf ("frame_cropping_flag = %u\n", sp->frame_cropping_flag);
-  if (sp->frame_cropping_flag)
-  {
-    sp->frame_crop_left_offset = read_exp_ue (&seq->br);
-    lprintf ("frame_crop_left_offset = %u\n", sp->frame_crop_left_offset);
-    sp->frame_crop_right_offset = read_exp_ue (&seq->br);
-    lprintf ("frame_crop_right_offset = %u\n", sp->frame_crop_right_offset);
-    sp->frame_crop_top_offset = read_exp_ue (&seq->br);
-    lprintf ("frame_crop_top_offset = %u\n", sp->frame_crop_top_offset);
-    sp->frame_crop_bottom_offset = read_exp_ue (&seq->br);
-    lprintf ("frame_crop_bottom_offset = %u\n", sp->frame_crop_bottom_offset);
-    seq->coded_height -=
-      (2 - sp->frame_mbs_only_flag) * 2 * sp->frame_crop_bottom_offset;
-  }
-  if (seq->coded_height == 1088)
-    seq->coded_height = 1080;
-  sp->vui_parameters_present_flag = read_bits (&seq->br, 1);
-  lprintf ("vui_parameters_present_flag = %u\n",
-	   sp->vui_parameters_present_flag);
-  if (sp->vui_parameters_present_flag)
-    vui_parameters (seq, &sp->vui);
-  set_ratio (seq, sp);
-}
-
-
-
-static void
-pic_parameter_set (vdpau_h264_alter_decoder_t * this_gen)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  pic_param_t *pic;
-  seq_param_t *sp;
-  int i;
-
-  uint8_t pic_parameter_set_id = read_exp_ue (&seq->br);
-  lprintf ("pic_parameter_set_id = %u\n", pic_parameter_set_id);
-  if (!seq->pic_param[pic_parameter_set_id])
-    seq->pic_param[pic_parameter_set_id] =
-      (pic_param_t *) calloc (1, sizeof (pic_param_t));
-  if (!seq->pic_param[pic_parameter_set_id])
-  {
-    lprintf ("OOPS : can't allocate PPS %d !!\n", pic_parameter_set_id);
-    return;
-  }
-  pic = seq->pic_param[pic_parameter_set_id];
-
-  uint8_t seq_parameter_set_id = read_exp_ue (&seq->br);
-  lprintf ("seq_parameter_set_id = %u\n", seq_parameter_set_id);
-  if (seq_parameter_set_id > 31)
-  {
-    lprintf ("OOPS : referenced SPS (%d) does not exist !!\n",
-	     seq_parameter_set_id);
-    return;
-  }
-  if (!seq->seq_param[seq_parameter_set_id])
-  {
-    lprintf ("OOPS : referenced SPS (%d) does not exist !!\n",
-	     seq_parameter_set_id);
-    return;
-  }
-
-  pic->seq_parameter_set_id = seq_parameter_set_id;
-  sp = seq->seq_param[pic->seq_parameter_set_id];
-  pic->entropy_coding_mode_flag = read_bits (&seq->br, 1);
-  lprintf ("entropy_coding_mode_flag = %u\n", pic->entropy_coding_mode_flag);
-  pic->pic_order_present_flag = read_bits (&seq->br, 1);
-  lprintf ("pic_order_present_flag = %u\n", pic->pic_order_present_flag);
-  uint8_t num_slice_groups_minus1 = read_exp_ue (&seq->br);
-  lprintf ("num_slice_groups_minus1 = %u\n", num_slice_groups_minus1);
-  if (num_slice_groups_minus1 > 0)
-  {
-    uint8_t slice_group_map_type = read_exp_ue (&seq->br);
-    lprintf ("slice_group_map_type = %u\n", slice_group_map_type);
-    if (!slice_group_map_type)
-    {
-      for (i = 0; i < num_slice_groups_minus1; i++)
-	read_exp_ue (&seq->br);
-    }
-    else if (slice_group_map_type == 2)
-    {
-      for (i = 0; i < num_slice_groups_minus1; i++)
-      {
-	read_exp_ue (&seq->br);
-	read_exp_ue (&seq->br);
-      }
-    }
-    else if (slice_group_map_type == 3 || slice_group_map_type == 4
-	     || slice_group_map_type == 5)
-    {
-      read_bits (&seq->br, 1);
-      read_exp_ue (&seq->br);
-    }
-    else if (slice_group_map_type == 6)
-    {
-      read_exp_ue (&seq->br);
-    }
-  }
-  pic->num_ref_idx_l0_active_minus1 = read_exp_ue (&seq->br);
-  lprintf ("num_ref_idx_l0_active_minus1 = %u\n",
-	   pic->num_ref_idx_l0_active_minus1);
-  pic->num_ref_idx_l1_active_minus1 = read_exp_ue (&seq->br);
-  lprintf ("num_ref_idx_l1_active_minus1 = %u\n",
-	   pic->num_ref_idx_l1_active_minus1);
-  pic->weighted_pred_flag = read_bits (&seq->br, 1);
-  lprintf ("weighted_pred_flag = %u\n", pic->weighted_pred_flag);
-  pic->weighted_bipred_idc = read_bits (&seq->br, 2);
-  lprintf ("weighted_bipred_idc = %u\n", pic->weighted_bipred_idc);
-  pic->pic_init_qp_minus26 = read_exp_se (&seq->br);
-  lprintf ("pic_init_qp_minus26 = %d\n", pic->pic_init_qp_minus26);
-  pic->pic_init_qs_minus26 = read_exp_se (&seq->br);
-  lprintf ("pic_init_qs_minus26 = %d\n", pic->pic_init_qs_minus26);
-  pic->chroma_qp_index_offset = read_exp_se (&seq->br);
-  lprintf ("chroma_qp_index_offset = %d\n", pic->chroma_qp_index_offset);
-  pic->deblocking_filter_control_present_flag = read_bits (&seq->br, 1);
-  lprintf ("deblocking_filter_control_present_flag = %u\n",
-	   pic->deblocking_filter_control_present_flag);
-  pic->constrained_intra_pred_flag = read_bits (&seq->br, 1);
-  lprintf ("constrained_intra_pred_flag = %u\n",
-	   pic->constrained_intra_pred_flag);
-  pic->redundant_pic_cnt_present_flag = read_bits (&seq->br, 1);
-  lprintf ("redundant_pic_cnt_present_flag = %u\n",
-	   pic->redundant_pic_cnt_present_flag);
-
-  uint32_t more = more_rbsp_data (&seq->br);
-  lprintf ("more bits = %u (buflen = %d) (still = %zd)\n", more,
-           seq->br.length, (ssize_t)(seq->br.start + seq->br.length - seq->br.buffer));
-  if (more)
-  {
-    pic->transform_8x8_mode_flag = read_bits (&seq->br, 1);
-    lprintf ("transform_8x8_mode_flag = %u\n", pic->transform_8x8_mode_flag);
-    pic->pic_scaling_matrix_present_flag = read_bits (&seq->br, 1);
-    lprintf ("pic_scaling_matrix_present_flag = %u\n",
-	     pic->pic_scaling_matrix_present_flag);
-    if (pic->pic_scaling_matrix_present_flag)
-    {
-      for (i = 0; i < 8; i++)
-      {
-	if (i < 6 || pic->transform_8x8_mode_flag)
-	  pic->pic_scaling_list_present_flag[i] = read_bits (&seq->br, 1);
-	else
-	  pic->pic_scaling_list_present_flag[i] = 0;
-
-	if (pic->pic_scaling_list_present_flag[i])
-	{
-	  if (i < 6)
-	    parse_scaling_list (&seq->br, &pic->scaling_lists_4x4[i][0], 16,
-				i);
-	  else
-	    parse_scaling_list (&seq->br, &pic->scaling_lists_8x8[i - 6][0],
-				64, i);
-	}
-	else
-	{
-	  if (!sp->seq_scaling_matrix_present_flag)
-	    scaling_list_fallback_A ((uint8_t *) pic->scaling_lists_4x4,
-				     (uint8_t *) pic->scaling_lists_8x8, i);
-	  else
-	    scaling_list_fallback_B (sp, pic, i);
-	}
-      }
-    }
-    pic->second_chroma_qp_index_offset = read_exp_se (&seq->br);
-    lprintf ("second_chroma_qp_index_offset = %d\n",
-	     pic->second_chroma_qp_index_offset);
-  }
-  else
-  {
-    pic->transform_8x8_mode_flag = 0;
-    pic->pic_scaling_matrix_present_flag = 0;
-    pic->second_chroma_qp_index_offset = pic->chroma_qp_index_offset;
-  }
-}
-
-
-
-static void
-pred_weight_table (vdpau_h264_alter_decoder_t * this_gen, uint8_t slice_type,
-		   uint8_t ChromaArrayType, uint8_t l0, uint8_t l1)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  int i;
-
-  read_exp_ue (&seq->br);
-  if (ChromaArrayType)
-    read_exp_ue (&seq->br);
-  for (i = 0; i <= l0; i++)
-  {
-    if (read_bits (&seq->br, 1))
-    {
-      read_exp_se (&seq->br);
-      read_exp_se (&seq->br);
-    }
-    if (ChromaArrayType && read_bits (&seq->br, 1))
-    {
-      read_exp_se (&seq->br);
-      read_exp_se (&seq->br);
-      read_exp_se (&seq->br);
-      read_exp_se (&seq->br);
-    }
-  }
-  if (slice_type == SLICE_TYPE_B)
-  {
-    for (i = 0; i <= l1; i++)
-    {
-      if (read_bits (&seq->br, 1))
-      {
-	read_exp_se (&seq->br);
-	read_exp_se (&seq->br);
-      }
-      if (ChromaArrayType)
-      {
-	if (read_bits (&seq->br, 1))
-	{
-	  read_exp_se (&seq->br);
-	  read_exp_se (&seq->br);
-	  read_exp_se (&seq->br);
-	  read_exp_se (&seq->br);
-	}
-      }
-    }
-  }
-}
-
-
-
-static void
-ref_pic_list_reordering (vdpau_h264_alter_decoder_t * this_gen)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  slice_param_t *sl = &seq->slice_param;
-
-  if ((sl->slice_type != SLICE_TYPE_I) && (sl->slice_type != SLICE_TYPE_SI))
-  {
-    if (read_bits (&seq->br, 1))
-    {
-      uint32_t tmp/*, diff*/;
-      do
-      {
-	tmp = read_exp_ue (&seq->br);
-	if (tmp == 0 || tmp == 1)
-	  /*diff =*/ read_exp_ue (&seq->br);
-	else if (tmp == 2)
-          /*diff =*/ read_exp_ue (&seq->br);
-      }
-      while (tmp != 3 && !seq->br.oflow);
-    }
-  }
-  if (sl->slice_type == SLICE_TYPE_B)
-  {
-    if (read_bits (&seq->br, 1))
-    {
-      uint32_t tmp2/*, diff2*/;
-      do
-      {
-	tmp2 = read_exp_ue (&seq->br);
-	if (tmp2 == 0 || tmp2 == 1)
-	  /*diff2 =*/ read_exp_ue (&seq->br);
-	else if (tmp2 == 2)
-	  /*diff2 =*/ read_exp_ue (&seq->br);
-      }
-      while (tmp2 != 3 && !seq->br.oflow);
-    }
-  }
-}
-
-
-
-static void
-dec_ref_pic_marking (vdpau_h264_alter_decoder_t * this_gen, uint8_t idr)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  int32_t pic_num;
-
-  if (idr)
-  {
-#ifdef LOG
-    uint8_t no_output_of_prior_pics_flag = read_bits (&seq->br, 1);
-    lprintf ("no_output_of_prior_pics_flag = %u\n",
-	     no_output_of_prior_pics_flag);
-    uint8_t long_term_reference_flag = read_bits (&seq->br, 1);
-    lprintf ("long_term_reference_flag = %u\n", long_term_reference_flag);
-#else
-    skip_bits (&seq->br, 2);
-#endif
-  }
-  else
-  {
-    uint8_t adaptive_ref_pic_marking_mode_flag = read_bits (&seq->br, 1);
-    lprintf ("adaptive_ref_pic_marking_mode_flag = %u\n",
-	     adaptive_ref_pic_marking_mode_flag);
-    if (!adaptive_ref_pic_marking_mode_flag)
-    {
-      if (seq->cur_pic.field_pic_flag
-	  && (seq->cur_pic.completed == PICTURE_DONE)
-	  && (seq->cur_pic.is_reference[0] || seq->cur_pic.is_reference[1]))
-      {
-	seq->cur_pic.is_reference[0] = seq->cur_pic.is_reference[1] =
-	  SHORT_TERM_REF;
-	lprintf ("short_ref marking\n");
-      }
-      // sliding window is always performed in dpb_append()
-    }
-    else
-    {
-      uint8_t memory_management_control_operation;
-      do
-      {
-	memory_management_control_operation = read_exp_ue (&seq->br);
-	lprintf ("memory_management_control_operation = %u\n",
-		 memory_management_control_operation);
-	if (memory_management_control_operation == 1
-	    || memory_management_control_operation == 3)
-	{
-	  uint32_t difference_of_pic_nums_minus1 = read_exp_ue (&seq->br);
-	  lprintf ("difference_of_pic_nums_minus1 = %u\n",
-		   difference_of_pic_nums_minus1);
-	  pic_num =
-	    seq->cur_pic.PicNum[0] - (difference_of_pic_nums_minus1 + 1);
-	  dpb_mmc1 (this_gen, pic_num);
-	}
-	if (memory_management_control_operation == 2)
-	{
-#ifdef LOG
-	  uint32_t long_term_pic_num = read_exp_ue (&seq->br);
-	  lprintf ("long_term_pic_num = %u\n", long_term_pic_num);
-#else
-          read_exp_ue (&seq->br);
-#endif
-	}
-	if (memory_management_control_operation == 3
-	    || memory_management_control_operation == 6)
-	{
-#ifdef LOG
-	  uint32_t long_term_frame_idx = read_exp_ue (&seq->br);
-	  lprintf ("long_term_frame_idx = %u\n", long_term_frame_idx);
-#else
-          read_exp_ue (&seq->br);
-#endif
-	}
-	if (memory_management_control_operation == 4)
-	{
-#ifdef LOG
-	  uint32_t max_long_term_frame_idx_plus1 = read_exp_ue (&seq->br);
-	  lprintf ("max_long_term_frame_idx_plus1 = %u\n",
-		   max_long_term_frame_idx_plus1);
-#else
-          read_exp_ue (&seq->br);
-#endif
-	}
-      }
-      while (memory_management_control_operation && !seq->br.oflow);
-    }
-  }
-}
-
-
-
-static void
-slice_header (vdpau_h264_alter_decoder_t * this_gen, uint8_t nal_ref_idc,
-	      uint8_t nal_unit_type)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  slice_param_t *sl = &seq->slice_param;
-  pic_param_t *pic;
-  seq_param_t *sp;
-
-  sl->nal_ref_idc = nal_ref_idc;
-  sl->nal_unit_type = nal_unit_type;
-
-  read_exp_ue (&seq->br);	/* first_mb_in_slice */
-  sl->slice_type = read_exp_ue (&seq->br) % 5;
-  lprintf ("slice_type = %u\n", sl->slice_type);
-  sl->pic_parameter_set_id = read_exp_ue (&seq->br);
-  lprintf ("pic_parameter_set_id = %u\n", sl->pic_parameter_set_id);
-  if (!seq->pic_param[sl->pic_parameter_set_id])
-  {
-    lprintf ("OOPS : referenced PPS (%d) does not exist !!\n",
-	     sl->pic_parameter_set_id);
-    seq->cur_pic.missing_header = 1;
-    return;
-  }
-  pic = seq->pic_param[sl->pic_parameter_set_id];
-  if (!seq->seq_param[pic->seq_parameter_set_id])
-  {
-    lprintf ("OOPS : referenced SPS (%d) does not exist !!\n",
-	     pic->seq_parameter_set_id);
-    seq->cur_pic.missing_header = 1;
-    return;
-  }
-
-  if (!seq->startup_frame && (sl->slice_type == SLICE_TYPE_I)
-      && !seq->cur_pic.completed)
-    seq->startup_frame = 1;
-
-  lprintf ("seq_parameter_set_id = %u\n", pic->seq_parameter_set_id);
-  sp = seq->seq_param[pic->seq_parameter_set_id];
-  if (sp->separate_colour_plane_flag)
-    read_bits (&seq->br, 2);	/* colour_plane_id */
-  sl->frame_num = read_bits (&seq->br, sp->log2_max_frame_num_minus4 + 4);
-  lprintf ("frame_num = %u\n", sl->frame_num);
-  sl->MaxFrameNum = 1 << (sp->log2_max_frame_num_minus4 + 4);
-
-  sl->field_pic_flag = sl->bottom_field_flag =
-    sl->delta_pic_order_cnt_bottom = 0;
-  sl->delta_pic_order_cnt[0] = sl->delta_pic_order_cnt[1] = 0;
-
-  if (!sp->frame_mbs_only_flag)
-  {
-    sl->field_pic_flag = read_bits (&seq->br, 1);
-    lprintf ("field_pic_flag = %u\n", sl->field_pic_flag);
-    if (sl->field_pic_flag)
-    {
-      sl->bottom_field_flag = read_bits (&seq->br, 1);
-      lprintf ("bottom_field_flag = %u\n", sl->bottom_field_flag);
-    }
-  }
-  if (nal_unit_type == NAL_SLICE_IDR)
-  {
-    sl->idr_pic_id = read_exp_ue (&seq->br);
-    lprintf ("idr_pic_id = %u\n", sl->idr_pic_id);
-  }
-  if (sp->pic_order_cnt_type == 0)
-  {
-    sl->pic_order_cnt_lsb =
-      read_bits (&seq->br, sp->log2_max_pic_order_cnt_lsb_minus4 + 4);
-    lprintf ("pic_order_cnt_lsb = %u\n", sl->pic_order_cnt_lsb);
-    if (pic->pic_order_present_flag && !sl->field_pic_flag)
-    {
-      sl->delta_pic_order_cnt_bottom = read_exp_se (&seq->br);
-      lprintf ("delta_pic_order_cnt_bottom = %d\n",
-	       sl->delta_pic_order_cnt_bottom);
-    }
-  }
-  if (sp->pic_order_cnt_type == 1 && !sp->delta_pic_order_always_zero_flag)
-  {
-    sl->delta_pic_order_cnt[0] = read_exp_se (&seq->br);
-    lprintf ("delta_pic_order_cnt[0] = %d\n", sl->delta_pic_order_cnt[0]);
-    if (pic->pic_order_present_flag && !sl->field_pic_flag)
-    {
-      sl->delta_pic_order_cnt[1] = read_exp_se (&seq->br);
-      lprintf ("delta_pic_order_cnt[1] = %d\n", sl->delta_pic_order_cnt[1]);
-    }
-  }
-  if (pic->redundant_pic_cnt_present_flag)
-  {
-    sl->redundant_pic_cnt = read_exp_ue (&seq->br);
-    lprintf ("redundant_pic_cnt = %u\n", sl->redundant_pic_cnt);
-  }
-  if (sl->slice_type == SLICE_TYPE_B)
-    skip_bits (&seq->br, 1);	/* direct_spatial_mv_pred_flag */
-
-  sl->num_ref_idx_l0_active_minus1 = pic->num_ref_idx_l0_active_minus1;
-  sl->num_ref_idx_l1_active_minus1 = pic->num_ref_idx_l1_active_minus1;
-
-  if (sl->slice_type == SLICE_TYPE_P || sl->slice_type == SLICE_TYPE_SP
-      || sl->slice_type == SLICE_TYPE_B)
-  {
-    if (read_bits (&seq->br, 1))
-    {
-      lprintf ("num_ref_idx_active_override_flag = 1\n");
-      sl->num_ref_idx_l0_active_minus1 = read_exp_ue (&seq->br);
-      if (sl->slice_type == SLICE_TYPE_B)
-	sl->num_ref_idx_l1_active_minus1 = read_exp_ue (&seq->br);
-      lprintf ("num_ref_idx_l0_active_minus1 = %u\n",
-	       sl->num_ref_idx_l0_active_minus1);
-      lprintf ("num_ref_idx_l1_active_minus1 = %u\n",
-	       sl->num_ref_idx_l1_active_minus1);
-    }
-  }
-}
-
-
-
-static void
-slice_header_post (vdpau_h264_alter_decoder_t * this_gen)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  slice_param_t *sl = &seq->slice_param;
-
-  if (!sl->nal_ref_idc)
-    return;
-
-  pic_param_t *pic = seq->pic_param[sl->pic_parameter_set_id];
-  seq_param_t *sp = seq->seq_param[pic->seq_parameter_set_id];
-
-  if ((pic->weighted_pred_flag
-       && ((sl->slice_type == SLICE_TYPE_P)
-	   || (sl->slice_type == SLICE_TYPE_SP)))
-      || ((pic->weighted_bipred_idc == 1)
-	  && (sl->slice_type == SLICE_TYPE_B)))
-  {
-    uint8_t chroma =
-      (sp->separate_colour_plane_flag) ? 0 : sp->chroma_format_idc;
-    pred_weight_table (this_gen, sl->slice_type, chroma,
-		       sl->num_ref_idx_l0_active_minus1,
-		       sl->num_ref_idx_l1_active_minus1);
-  }
-
-  dec_ref_pic_marking (this_gen, (sl->nal_unit_type == 5) ? 1 : 0);
-}
-
-
-
-static void
-decode_poc (vdpau_h264_alter_decoder_t * this_gen)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  slice_param_t *sl = &seq->slice_param;
-  pic_param_t *pic = seq->pic_param[sl->pic_parameter_set_id];
-  seq_param_t *sp = seq->seq_param[pic->seq_parameter_set_id];
-  int parity = sl->bottom_field_flag ? 1 : 0;
-
-  seq->cur_pic.used = 1;
-  seq->cur_pic.FrameNum = sl->frame_num;
-  seq->cur_pic.is_reference[parity] = sl->nal_ref_idc;
-  seq->cur_pic.field_pic_flag = sl->field_pic_flag;
-
-  if (sl->field_pic_flag)
-  {
-    if (!seq->cur_pic.completed)
-      seq->cur_pic.top_field_first = !parity;
-    seq->cur_pic.completed |=
-      (parity ? PICTURE_BOTTOM_DONE : PICTURE_TOP_DONE);
-  }
-  else
-  {
-    seq->cur_pic.is_reference[!parity] = seq->cur_pic.is_reference[parity];
-    seq->cur_pic.completed = PICTURE_DONE;
-  }
-
-  if (sp->pic_order_cnt_type == 0)
-  {
-    dpb_frame_t *prev_pic = dpb_get_prev_ref (seq);
-    int32_t prevPicOrderCntMsb, prevPicOrderCntLsb;
-    uint32_t MaxPicOrderCntLsb =
-      1 << (sp->log2_max_pic_order_cnt_lsb_minus4 + 4);
-
-    seq->cur_pic.pic_order_cnt_lsb = sl->pic_order_cnt_lsb;
-    seq->cur_pic.top_field_first =
-      (sl->delta_pic_order_cnt_bottom < 0) ? 0 : 1;
-
-    if (!prev_pic)
-    {
-      seq->cur_pic.PicOrderCntMsb = seq->cur_pic.TopFieldOrderCnt =
-	seq->cur_pic.BottomFieldOrderCnt = 0;
-      return;
-    }
-    if (sl->nal_unit_type == NAL_SLICE_IDR)
-      prevPicOrderCntMsb = prevPicOrderCntLsb = 0;
-    else if (prev_pic->mmc5)
-    {
-      if (!sl->bottom_field_flag)
-      {
-	prevPicOrderCntMsb = 0;
-	prevPicOrderCntLsb = prev_pic->TopFieldOrderCnt;
-      }
-      else
-	prevPicOrderCntMsb = prevPicOrderCntLsb = 0;
-    }
-    else
-    {
-      prevPicOrderCntMsb = prev_pic->PicOrderCntMsb;
-      prevPicOrderCntLsb = prev_pic->pic_order_cnt_lsb;
-    }
-
-    if ((sl->pic_order_cnt_lsb < prevPicOrderCntLsb)
-	&& ((prevPicOrderCntLsb - sl->pic_order_cnt_lsb) >=
-	    (int32_t)(MaxPicOrderCntLsb / 2)))
-      seq->cur_pic.PicOrderCntMsb = prevPicOrderCntMsb + MaxPicOrderCntLsb;
-    else if ((sl->pic_order_cnt_lsb > prevPicOrderCntLsb)
-	     && ((sl->pic_order_cnt_lsb - prevPicOrderCntLsb) >
-		 (int32_t)(MaxPicOrderCntLsb / 2)))
-      seq->cur_pic.PicOrderCntMsb = prevPicOrderCntMsb - MaxPicOrderCntLsb;
-    else
-      seq->cur_pic.PicOrderCntMsb = prevPicOrderCntMsb;
-
-    if (!sl->field_pic_flag)
-    {
-      seq->cur_pic.TopFieldOrderCnt =
-	seq->cur_pic.PicOrderCntMsb + sl->pic_order_cnt_lsb;
-      seq->cur_pic.BottomFieldOrderCnt =
-	seq->cur_pic.TopFieldOrderCnt + sl->delta_pic_order_cnt_bottom;
-    }
-    else
-    {
-      if (sl->bottom_field_flag)
-	seq->cur_pic.BottomFieldOrderCnt =
-	  seq->cur_pic.PicOrderCntMsb + sl->pic_order_cnt_lsb;
-      else
-	seq->cur_pic.TopFieldOrderCnt =
-	  seq->cur_pic.PicOrderCntMsb + sl->pic_order_cnt_lsb;
-    }
-  }
-  else
-  {
-    int16_t FrameNumOffset, prevFrameNumOffset;
-    uint16_t MaxFrameNum = 1 << (sp->log2_max_frame_num_minus4 + 4);
-
-    if (sl->nal_unit_type == NAL_SLICE_IDR)
-    {
-      FrameNumOffset = 0;
-    }
-    else
-    {
-      if (seq->prevMMC5)
-	prevFrameNumOffset = 0;
-      else
-	prevFrameNumOffset = seq->prevFrameNumOffset;
-
-      if (seq->prevFrameNum > sl->frame_num)
-	FrameNumOffset = prevFrameNumOffset + MaxFrameNum;
-      else
-	FrameNumOffset = prevFrameNumOffset;
-    }
-
-    if (sp->pic_order_cnt_type == 1)
-    {
-      int16_t absFrameNum = 0, picOrderCntCycleCnt =
-	0, frameNumInPicOrderCntCycle = 0, expectedDeltaPerPicOrderCntCycle =
-	0, expectedPicOrderCnt = 0;
-      int i;
-      if (sp->num_ref_frames_in_pic_order_cnt_cycle)
-	absFrameNum = FrameNumOffset + sl->frame_num;
-      if (!sl->nal_ref_idc && (absFrameNum > 0))
-	--absFrameNum;
-
-      for (i = 0; i < sp->num_ref_frames_in_pic_order_cnt_cycle; i++)
-	expectedDeltaPerPicOrderCntCycle += sp->offset_for_ref_frame[i];
-
-      if (absFrameNum > 0)
-      {
-	picOrderCntCycleCnt =
-	  (absFrameNum - 1) / sp->num_ref_frames_in_pic_order_cnt_cycle;
-	frameNumInPicOrderCntCycle =
-	  (absFrameNum - 1) % sp->num_ref_frames_in_pic_order_cnt_cycle;
-	expectedPicOrderCnt =
-	  picOrderCntCycleCnt * expectedDeltaPerPicOrderCntCycle;
-	for (i = 0; i < frameNumInPicOrderCntCycle; i++)
-	  expectedPicOrderCnt += sp->offset_for_ref_frame[i];
-      }
-      if (!sl->nal_ref_idc)
-	expectedPicOrderCnt += sp->offset_for_non_ref_pic;
-
-      if (!sl->field_pic_flag)
-      {
-	seq->cur_pic.TopFieldOrderCnt =
-	  expectedPicOrderCnt + sl->delta_pic_order_cnt[0];
-	seq->cur_pic.BottomFieldOrderCnt =
-	  seq->cur_pic.TopFieldOrderCnt + sp->offset_for_top_to_bottom_field +
-	  sl->delta_pic_order_cnt[1];
-      }
-      else if (!sl->bottom_field_flag)
-	seq->cur_pic.TopFieldOrderCnt =
-	  expectedPicOrderCnt + sl->delta_pic_order_cnt[0];
-      else
-	seq->cur_pic.BottomFieldOrderCnt =
-	  expectedPicOrderCnt + sp->offset_for_top_to_bottom_field +
-	  sl->delta_pic_order_cnt[1];
-    }
-    else
-    {
-      int32_t tmpPicOrderCnt;
-      if (sl->nal_unit_type == NAL_SLICE_IDR)
-	tmpPicOrderCnt = 0;
-      else if (!sl->nal_ref_idc)
-	tmpPicOrderCnt = 2 * (FrameNumOffset + sl->frame_num) - 1;
-      else
-	tmpPicOrderCnt = 2 * (FrameNumOffset + sl->frame_num);
-
-      if (!sl->field_pic_flag)
-	seq->cur_pic.TopFieldOrderCnt = seq->cur_pic.BottomFieldOrderCnt =
-	  tmpPicOrderCnt;
-      else if (sl->bottom_field_flag)
-	seq->cur_pic.BottomFieldOrderCnt = tmpPicOrderCnt;
-      else
-	seq->cur_pic.TopFieldOrderCnt = tmpPicOrderCnt;
-    }
-    seq->prevFrameNum = seq->cur_pic.FrameNum;
-    seq->prevFrameNumOffset = FrameNumOffset;
-  }
-
-  if (seq->cur_pic.completed < PICTURE_DONE)
-  {
-    if (sl->bottom_field_flag)
-      seq->cur_pic.TopFieldOrderCnt = seq->cur_pic.BottomFieldOrderCnt;
-    else
-      seq->cur_pic.BottomFieldOrderCnt = seq->cur_pic.TopFieldOrderCnt;
-  }
-}
-
-
-
-static void
-decode_picnum (vdpau_h264_alter_decoder_t * this_gen)
-{
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  slice_param_t *sl = &seq->slice_param;
-  dpb_frame_t *frame;
-  int i = 0;
-
-  int parity = sl->bottom_field_flag ? 1 : 0;
-
-  if (!seq->cur_pic.field_pic_flag)
-    seq->cur_pic.PicNum[0] = seq->cur_pic.FrameNum;
-  else
-    seq->cur_pic.PicNum[parity] = 2 * seq->cur_pic.FrameNum + 1;
-
-  while (i < MAX_DPB_SIZE)
-  {
-    frame = seq->dpb[i];
-    if (!frame->used)
-      break;
-    if (frame->FrameNum > seq->cur_pic.FrameNum)
-      frame->FrameNumWrap = frame->FrameNum - sl->MaxFrameNum;
-    else
-      frame->FrameNumWrap = frame->FrameNum;
-
-    if (!sl->field_pic_flag)
-    {
-      frame->PicNum[0] = frame->PicNum[1] = frame->FrameNumWrap;
-    }
-    else
-    {
-      frame->PicNum[0] = 2 * frame->FrameNumWrap + (parity ? 0 : 1);
-      frame->PicNum[1] = 2 * frame->FrameNumWrap + (parity ? 1 : 0);
-    }
-    ++i;
-  }
-}
-
-
-
-static int
-check_ref_list (vdpau_h264_alter_decoder_t * this_gen)
-{
-  int i, j, bad_frame = 0;
-  dpb_frame_t *frame;
-  sequence_t *seq = (sequence_t *) & this_gen->sequence;
-  slice_param_t *sl = &seq->slice_param;
-  pic_param_t *pic = seq->pic_param[sl->pic_parameter_set_id];
-  seq_param_t *sp = seq->seq_param[pic->seq_parameter_set_id];
-  int prefs = 0;
-  int brefs = 0;
-  int poc, curpoc;
-
-  //int fps = (double)sp->vui.time_scale / (double)sp->vui.num_units_in_tick / ( 2 - sl->field_pic_flag );
-  int fps = (1 + sl->field_pic_flag) * 2 * sp->num_ref_frames;
-
-  if (seq->startup_frame >= fps)
+  if (frame->user_data) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_LOG,
+      LOG_MODULE ": ERROR: user frame set already.\n");
     return 0;
-
-  curpoc =
-    (seq->cur_pic.TopFieldOrderCnt >
-     seq->cur_pic.BottomFieldOrderCnt) ? seq->cur_pic.TopFieldOrderCnt : seq->
-    cur_pic.BottomFieldOrderCnt;
-
-  for (i = 15; i > -1; i--)
-  {
-    frame = seq->dpb[i];
-    if (!frame->used)
-      continue;
-    poc =
-      (frame->TopFieldOrderCnt >
-       frame->BottomFieldOrderCnt) ? frame->TopFieldOrderCnt : frame->
-      BottomFieldOrderCnt;
-    if (seq->cur_pic.field_pic_flag)
-    {
-      if (!frame->videoSurface->bad_frame)
-      {
-	for (j = 0; j < 2; j++)
-	{
-	  if (frame->is_reference[j])
-	  {
-	    if (poc <= curpoc)
-	      ++prefs;
-	    else
-	      ++brefs;
-	  }
-	}
-      }
-    }
-    else
-    {
-      if (!frame->videoSurface->bad_frame)
-      {
-	if (poc <= curpoc)
-	  ++prefs;
-	else
-	  ++brefs;
-      }
-    }
   }
-
-  if (sl->slice_type != SLICE_TYPE_I)
-  {
-    if (prefs < (sl->num_ref_idx_l0_active_minus1 + 1))
-      bad_frame = 1;
-    if (sl->slice_type == SLICE_TYPE_B)
-    {
-      if (brefs < (sl->num_ref_idx_l1_active_minus1 + 1))
-	bad_frame = 1;
-    }
-  }
-
-  if (bad_frame)
-    fprintf (stderr,
-	     "******** Missing refframes, dropping. nrf=%d lo=%d prefs=%d l1=%d brefs=%d type=%d (%d fps)\n",
-	     sp->num_ref_frames, sl->num_ref_idx_l0_active_minus1 + 1, prefs,
-	     sl->num_ref_idx_l1_active_minus1 + 1, brefs, sl->slice_type,
-	     fps);
-  //else
-  //fprintf(stderr,"******** GOOD ! nrf=%d lo=%d prefs=%d l1=%d brefs=%d type=%d (%d fps)\n", sp->num_ref_frames, sl->num_ref_idx_l0_active_minus1 + 1, prefs, sl->num_ref_idx_l1_active_minus1 + 1, brefs, sl->slice_type, fps );
-
-  if (seq->cur_pic.is_reference[0] || seq->cur_pic.is_reference[1])
-    ++seq->startup_frame;
-
-  return bad_frame;
-}
-
-
-
-static void
-decode_render (vdpau_h264_alter_decoder_t * vd, int bad_frame)
-{
-  int i, j;
+  VO_SET_FLAGS_CM (frame->color_matrix, flags);
+  frame->user_data = img = this->stream->video_out->get_frame (this->stream->video_out,
+    frame->width, frame->height, frame->ratio, XINE_IMGFMT_VDPAU, flags);
+    img->progressive_frame = -1;
+  img->pts = frame->pts;
+  img->duration = frame->duration;
+  img->progressive_frame = frame->progressive_frame;
+  img->bad_frame = frame->bad_frame;
+  this->used += 1;
+  if (this->used > 19) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_LOG,
+      LOG_MODULE ": WARNING: too many frames (%d).\n", this->used);
+  }
+  return 1;
+}
+
+static int vdpau_h264_alter_frame_render (void *user_data, vdec_hw_h264_frame_t *frame) {
+  vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *)user_data;
+  vo_frame_t *img = (vo_frame_t *)frame->user_data;
+  vdpau_accel_t *accel;
   VdpPictureInfoH264 info;
-  seq_param_t *sp;
-  pic_param_t *pic;
-  slice_param_t *sl;
-  sequence_t *seq = (sequence_t *) & vd->sequence;
-  vo_frame_t *img;
-
-  if (!seq->cur_pic.field_pic_flag || (seq->cur_pic.completed < PICTURE_DONE))
-  {
-    img =
-      vd->stream->video_out->get_frame (vd->stream->video_out,
-					seq->coded_width, seq->coded_height,
-					seq->ratio, XINE_IMGFMT_VDPAU,
-					VO_BOTH_FIELDS | seq->chroma | seq->
-					reset | seq->color_matrix);
-    seq->reset = 0;
-    img->drawn = 0;
-  }
-  else
-    img = seq->cur_pic.videoSurface;
+  VdpDecoderProfile profile;
+  VdpStatus st;
 
   if (!img)
-  {				/* should not happen */
-    fprintf (stderr,
-	     "vdpau_h264_alter : !!!!!!!!!!!!!!!!!!!!!! No vo_frame_t !!!!!!!!!!!!!!!!!!!!!!!\n");
-    return;
-  }
+    return 0;
+  accel = (vdpau_accel_t *)img->accel_data;
 
-  vdpau_accel_t *accel = (vdpau_accel_t *) img->accel_data;
-  if (!seq->accel_vdpau)
-    seq->accel_vdpau = accel;
-
-  if (seq->vdp_runtime_nr != *(seq->accel_vdpau->current_vdp_runtime_nr))
-    vd->decoder = VDP_INVALID_HANDLE;
-
-  sl = &vd->sequence.slice_param;
-  pic = vd->sequence.pic_param[sl->pic_parameter_set_id];
-  sp = vd->sequence.seq_param[pic->seq_parameter_set_id];
+  if (!this->accel_vdpau)
+    this->accel_vdpau = accel;
 
-  VdpStatus st;
-  if (vd->decoder == VDP_INVALID_HANDLE || vd->decoder_profile != seq->profile
-      || vd->decoder_width != seq->coded_width
-      || vd->decoder_height != seq->coded_height)
-  {
+  if (this->vdp_runtime_nr != *(this->accel_vdpau->current_vdp_runtime_nr))
+    this->decoder = VDP_INVALID_HANDLE;
+
+  profile = vdpau_h264_map_profile (frame->profile);
+
+  if ((this->decoder == VDP_INVALID_HANDLE) || (this->decoder_profile != profile)
+    || (this->decoder_width != frame->width) || (this->decoder_height != frame->height)) {
     if (accel->lock)
       accel->lock (accel->vo_frame);
-    if (vd->decoder != VDP_INVALID_HANDLE)
-    {
-      accel->vdp_decoder_destroy (vd->decoder);
-      vd->decoder = VDP_INVALID_HANDLE;
+    if (this->decoder != VDP_INVALID_HANDLE) {
+      accel->vdp_decoder_destroy (this->decoder);
+      this->decoder = VDP_INVALID_HANDLE;
     }
-    st =
-      accel->vdp_decoder_create (accel->vdp_device, seq->profile,
-				 seq->coded_width, seq->coded_height,
-				 sp->num_ref_frames, &vd->decoder);
+    st = accel->vdp_decoder_create (accel->vdp_device, profile,
+        frame->width, frame->height, frame->num_ref_frames, &this->decoder);
     if (accel->unlock)
       accel->unlock (accel->vo_frame);
-    if (st != VDP_STATUS_OK)
-      fprintf (stderr, "vdpau_h264_alter : failed to create decoder !! %s\n",
-	       accel->vdp_get_error_string (st));
-    else
-    {
-      vd->decoder_profile = seq->profile;
-      vd->decoder_width = seq->coded_width;
-      vd->decoder_height = seq->coded_height;
-      seq->vdp_runtime_nr = seq->accel_vdpau->vdp_runtime_nr;
+    if (st != VDP_STATUS_OK) {
+      xprintf (this->stream->xine, XINE_VERBOSITY_LOG,
+        LOG_MODULE ": failed to create decoder !! %s\n", accel->vdp_get_error_string (st));
+    } else {
+      this->decoder_profile = profile;
+      this->decoder_width = frame->width;
+      this->decoder_height = frame->height;
+      this->vdp_runtime_nr = accel->vdp_runtime_nr;
+      xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+        LOG_MODULE ": created decoder for %dx%d %s @#%d.\n",
+        this->decoder_width, this->decoder_height,
+        this->decoder_profile == VDP_DECODER_PROFILE_H264_HIGH ? "high" : "main",
+        this->vdp_runtime_nr);
+    }
+  }
+
+  info.slice_count                            = frame->info->slice_count;
+  info.field_order_cnt[0]                     = frame->info->field_order_cnt[0];
+  info.field_order_cnt[1]                     = frame->info->field_order_cnt[1];
+  info.is_reference                           = frame->info->is_reference ? VDP_TRUE : VDP_FALSE;
+  info.frame_num                              = frame->info->frame_num;
+  info.field_pic_flag                         = frame->info->field_pic_flag;
+  info.bottom_field_flag                      = frame->info->bottom_field_flag;
+  info.num_ref_frames                         = frame->info->num_ref_frames;
+  info.mb_adaptive_frame_field_flag           = frame->info->mb_adaptive_frame_field_flag;
+  info.constrained_intra_pred_flag            = frame->info->constrained_intra_pred_flag;
+  info.weighted_pred_flag                     = frame->info->weighted_pred_flag;
+  info.weighted_bipred_idc                    = frame->info->weighted_bipred_idc;
+  info.frame_mbs_only_flag                    = frame->info->frame_mbs_only_flag;
+  info.transform_8x8_mode_flag                = frame->info->transform_8x8_mode_flag;
+  info.chroma_qp_index_offset                 = frame->info->chroma_qp_index_offset;
+  info.second_chroma_qp_index_offset          = frame->info->second_chroma_qp_index_offset;
+  info.pic_init_qp_minus26                    = frame->info->pic_init_qp_minus26;
+  info.num_ref_idx_l0_active_minus1           = frame->info->num_ref_idx_l0_active_minus1;
+  info.num_ref_idx_l1_active_minus1           = frame->info->num_ref_idx_l1_active_minus1;
+  info.log2_max_frame_num_minus4              = frame->info->log2_max_frame_num_minus4;
+  info.pic_order_cnt_type                     = frame->info->pic_order_cnt_type;
+  info.log2_max_pic_order_cnt_lsb_minus4      = frame->info->log2_max_pic_order_cnt_lsb_minus4;
+  info.delta_pic_order_always_zero_flag       = frame->info->delta_pic_order_always_zero_flag;
+  info.direct_8x8_inference_flag              = frame->info->direct_8x8_inference_flag;
+  info.entropy_coding_mode_flag               = frame->info->entropy_coding_mode_flag;
+  info.pic_order_present_flag                 = frame->info->pic_order_present_flag;
+  info.deblocking_filter_control_present_flag = frame->info->deblocking_filter_control_present_flag;
+  info.redundant_pic_cnt_present_flag         = frame->info->redundant_pic_cnt_present_flag;
+
+  xine_fast_memcpy (info.scaling_lists_4x4, frame->info->scaling_lists_4x4, sizeof (info.scaling_lists_4x4));
+  xine_fast_memcpy (info.scaling_lists_8x8, frame->info->scaling_lists_8x8, sizeof (info.scaling_lists_8x8));
+
+  {
+    uint32_t u;
+
+    for (u = 0; u < sizeof (info.referenceFrames) / sizeof (info.referenceFrames[0]); u++) {
+      if (frame->info->referenceFrames[u].frame) {
+        vo_frame_t *rimg = (vo_frame_t *)frame->info->referenceFrames[u].frame->user_data;
+        vdpau_accel_t *accel = (vdpau_accel_t *)rimg->accel_data;
+
+        info.referenceFrames[u].surface = accel->surface;
+      } else {
+        info.referenceFrames[u].surface = VDP_INVALID_HANDLE;
+      }
+      info.referenceFrames[u].is_long_term = 0;
+      info.referenceFrames[u].frame_idx = frame->info->referenceFrames[u].frame_idx;
+      info.referenceFrames[u].top_is_reference = frame->info->referenceFrames[u].top_is_reference ? VDP_TRUE : VDP_FALSE;
+      info.referenceFrames[u].bottom_is_reference = frame->info->referenceFrames[u].bottom_is_reference ? VDP_TRUE : VDP_FALSE;
+      info.referenceFrames[u].field_order_cnt[0] = frame->info->referenceFrames[u].field_order_cnt[0];
+      info.referenceFrames[u].field_order_cnt[1] = frame->info->referenceFrames[u].field_order_cnt[1];
+    }
+  }
+
+  {
+    const uint8_t sc[3] = { 0, 0, 1 };
+    VdpBitstreamBuffer vbits[80 * 2];
+    uint32_t u, m = frame->info->slice_count < 80 ? frame->info->slice_count : 80;
+
+    for (u = 0; u < m; u++) {
+      vbits[u * 2].struct_version = VDP_BITSTREAM_BUFFER_VERSION;
+      vbits[u * 2].bitstream = sc;
+      vbits[u * 2].bitstream_bytes = 3;
+      vbits[u * 2 + 1].struct_version = VDP_BITSTREAM_BUFFER_VERSION;
+      vbits[u * 2 + 1].bitstream = frame->info->slices_bitstream[u];
+      vbits[u * 2 + 1].bitstream_bytes = frame->info->slices_bytes[u];
     }
+    if (accel->lock)
+      accel->lock (accel->vo_frame);
+    st = accel->vdp_decoder_render (this->decoder, accel->surface,
+      CAST_VdpPictureInfo_PTR &info, m * 2, vbits);
+    if (accel->unlock)
+      accel->unlock (accel->vo_frame);
   }
-
-  info.slice_count = seq->slices_count;
-  info.field_order_cnt[0] = seq->cur_pic.TopFieldOrderCnt;
-  info.field_order_cnt[1] = seq->cur_pic.BottomFieldOrderCnt;
-  info.is_reference = sl->nal_ref_idc ? VDP_TRUE : VDP_FALSE;
-  info.frame_num = sl->frame_num;
-  info.field_pic_flag = sl->field_pic_flag;
-  info.bottom_field_flag = sl->bottom_field_flag;
-  info.num_ref_frames = sp->num_ref_frames;
-  info.mb_adaptive_frame_field_flag = sp->mb_adaptive_frame_field_flag
-    && !sl->field_pic_flag;
-  info.constrained_intra_pred_flag = pic->constrained_intra_pred_flag;
-  info.weighted_pred_flag = pic->weighted_pred_flag;
-  info.weighted_bipred_idc = pic->weighted_bipred_idc;
-  info.frame_mbs_only_flag = sp->frame_mbs_only_flag;
-  info.transform_8x8_mode_flag = pic->transform_8x8_mode_flag;
-  info.chroma_qp_index_offset = pic->chroma_qp_index_offset;
-  info.second_chroma_qp_index_offset = pic->second_chroma_qp_index_offset;
-  info.pic_init_qp_minus26 = pic->pic_init_qp_minus26;
-  info.num_ref_idx_l0_active_minus1 = pic->num_ref_idx_l0_active_minus1;
-  info.num_ref_idx_l1_active_minus1 = pic->num_ref_idx_l1_active_minus1;
-  info.log2_max_frame_num_minus4 = sp->log2_max_frame_num_minus4;
-  info.pic_order_cnt_type = sp->pic_order_cnt_type;
-  info.log2_max_pic_order_cnt_lsb_minus4 =
-    sp->log2_max_pic_order_cnt_lsb_minus4;
-  info.delta_pic_order_always_zero_flag =
-    sp->delta_pic_order_always_zero_flag;
-  info.direct_8x8_inference_flag = sp->direct_8x8_inference_flag;
-  info.entropy_coding_mode_flag = pic->entropy_coding_mode_flag;
-  info.pic_order_present_flag = pic->pic_order_present_flag;
-  info.deblocking_filter_control_present_flag =
-    pic->deblocking_filter_control_present_flag;
-  info.redundant_pic_cnt_present_flag = pic->redundant_pic_cnt_present_flag;
-
-  if (!pic->pic_scaling_matrix_present_flag)
-  {
-    xine_fast_memcpy (info.scaling_lists_4x4, sp->scaling_lists_4x4,
-		      sizeof (info.scaling_lists_4x4));
-    xine_fast_memcpy (info.scaling_lists_8x8, sp->scaling_lists_8x8,
-		      sizeof (info.scaling_lists_8x8));
-  }
-  else
-  {
-    xine_fast_memcpy (info.scaling_lists_4x4, pic->scaling_lists_4x4,
-		      sizeof (info.scaling_lists_4x4));
-    xine_fast_memcpy (info.scaling_lists_8x8, pic->scaling_lists_8x8,
-		      sizeof (info.scaling_lists_8x8));
-  }
-
-  j = 0;
-  for (i = (MAX_DPB_SIZE - 1); i > -1; i--)
-  {
-    if (!seq->dpb[i]->used)
-      continue;
-    vdpau_accel_t *accel =
-      (vdpau_accel_t *) seq->dpb[i]->videoSurface->accel_data;
-    info.referenceFrames[j].surface = accel->surface;
-    info.referenceFrames[j].is_long_term = 0;
-    info.referenceFrames[j].frame_idx = seq->dpb[i]->FrameNum;
-    info.referenceFrames[j].top_is_reference =
-      seq->dpb[i]->is_reference[0] ? VDP_TRUE : VDP_FALSE;
-    info.referenceFrames[j].bottom_is_reference =
-      seq->dpb[i]->is_reference[1] ? VDP_TRUE : VDP_FALSE;
-    info.referenceFrames[j].field_order_cnt[0] =
-      seq->dpb[i]->TopFieldOrderCnt;
-    info.referenceFrames[j].field_order_cnt[1] =
-      seq->dpb[i]->BottomFieldOrderCnt;
-    ++j;
-  }
-  for (; j < MAX_DPB_SIZE; j++)
-  {
-    info.referenceFrames[j].surface = VDP_INVALID_HANDLE;
-    info.referenceFrames[j].is_long_term = 0;
-    info.referenceFrames[j].frame_idx = 0;
-    info.referenceFrames[j].top_is_reference = 0;
-    info.referenceFrames[j].bottom_is_reference = 0;
-    info.referenceFrames[j].field_order_cnt[0] = 0;
-    info.referenceFrames[j].field_order_cnt[1] = 0;
-  }
-
-  uint8_t sc[3] = { 0, 0, 1 };
-  VdpBitstreamBuffer vbits[seq->slices_count * 2];
-  for (i = 0; i < seq->slices_count; i++)
-  {
-    vbits[i * 2].struct_version = VDP_BITSTREAM_BUFFER_VERSION;
-    vbits[i * 2].bitstream = sc;
-    vbits[i * 2].bitstream_bytes = 3;
-    vbits[(i * 2) + 1].struct_version = VDP_BITSTREAM_BUFFER_VERSION;
-    vbits[(i * 2) + 1].bitstream = seq->buf + seq->slices[i].buf_offset;
-    vbits[(i * 2) + 1].bitstream_bytes = seq->slices[i].len;
-  }
-  if (accel->lock)
-    accel->lock (accel->vo_frame);
-  st =
-    accel->vdp_decoder_render (vd->decoder, accel->surface,
-			       CAST_VdpPictureInfo_PTR &info,
-			       seq->slices_count * 2, vbits);
-  if (accel->unlock)
-    accel->unlock (accel->vo_frame);
   if (st != VDP_STATUS_OK)
     lprintf ("**********************DECODING failed! - surface = %d - %s\n",
-	     accel->surface, accel->vdp_get_error_string (st));
+             accel->surface, accel->vdp_get_error_string (st));
   else
     lprintf ("**********************DECODING success! - surface = %d\n",
-	     accel->surface);
+             accel->surface);
 
-  if ((seq->ratio != seq->reported_ratio)
-      || (seq->coded_width != seq->reported_coded_width)
-      || (seq->coded_height != seq->reported_coded_height)
-      || (seq->video_step != seq->reported_video_step))
-  {
-    seq->reported_ratio = seq->ratio;
-    seq->reported_coded_width = seq->coded_width;
-    seq->reported_coded_height = seq->coded_height;
-    seq->reported_video_step = seq->video_step;
-    _x_stream_info_set (vd->stream, XINE_STREAM_INFO_VIDEO_WIDTH,
-			seq->coded_width);
-    _x_stream_info_set (vd->stream, XINE_STREAM_INFO_VIDEO_HEIGHT,
-			seq->coded_height);
-    _x_stream_info_set (vd->stream, XINE_STREAM_INFO_VIDEO_RATIO,
-			((double) 10000 * seq->ratio));
-    _x_stream_info_set (vd->stream, XINE_STREAM_INFO_FRAME_DURATION,
-			seq->video_step);
-    _x_meta_info_set_utf8 (vd->stream, XINE_META_INFO_VIDEOCODEC,
-			   "H264/AVC (vdpau_alter)");
+  if ((frame->ratio != this->reported_ratio)
+    || (frame->width != this->reported_width)
+    || (frame->height != this->reported_height)
+    || (frame->duration != this->reported_video_step)) {
     xine_event_t event;
     xine_format_change_data_t data;
+
+    this->reported_ratio = frame->ratio;
+    this->reported_width = frame->width;
+    this->reported_height = frame->height;
+    this->reported_video_step = frame->duration;
+    _x_stream_info_set (this->stream, XINE_STREAM_INFO_VIDEO_WIDTH, frame->width);
+    _x_stream_info_set (this->stream, XINE_STREAM_INFO_VIDEO_HEIGHT, frame->height);
+    _x_stream_info_set (this->stream, XINE_STREAM_INFO_VIDEO_RATIO, ((double) 10000 * frame->ratio));
+    _x_stream_info_set (this->stream, XINE_STREAM_INFO_FRAME_DURATION, frame->duration);
+    _x_meta_info_set_utf8 (this->stream, XINE_META_INFO_VIDEOCODEC, "H264/AVC (vdpau_alter)");
+
     event.type = XINE_EVENT_FRAME_FORMAT_CHANGE;
-    event.stream = vd->stream;
+    event.stream = this->stream;
     event.data = &data;
     event.data_length = sizeof (data);
-    data.width = seq->coded_width;
-    data.height = seq->coded_height;
-    data.aspect = seq->ratio;
-    xine_event_send (vd->stream, &event);
+    data.width = frame->width;
+    data.height = frame->height;
+    data.aspect = frame->ratio;
+    xine_event_send (this->stream, &event);
   }
-
-  if (seq->cur_pic.completed == PICTURE_DONE)
-  {
-    seq->cur_pic.pts = seq->pic_pts;
-    seq->pic_pts = 0;
-  }
-  if (seq->cur_pic.drop_pts)
-    seq->cur_pic.pts = 0;
-  if (sp->frame_mbs_only_flag)
-    img->progressive_frame = -1;
-  img->bad_frame = bad_frame;
-  img->duration = seq->video_step;
-  seq->cur_pic.videoSurface = img;
+  return 1;
 }
 
+static int vdpau_h264_alter_frame_ready (void *user_data, vdec_hw_h264_frame_t *frame) {
+  vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *)user_data;
+  vo_frame_t *img = (vo_frame_t *)frame->user_data;
 
+  if (!img)
+    return 0;
 
-static void
-decode_picture (vdpau_h264_alter_decoder_t * decoder)
-{
-  if (decoder->sequence.cur_pic.missing_header
-      || !decoder->sequence.startup_frame)
-  {
-    memset (&decoder->sequence.cur_pic, 0, sizeof (dpb_frame_t));
-    lprintf ("MISSING_HEADER or !startup_frame\n\n");
-    return;
-  }
-
-  slice_param_t *sl = &decoder->sequence.slice_param;
-  dpb_frame_t *cur_pic = &decoder->sequence.cur_pic;
-
-  if (cur_pic->completed && cur_pic->field_pic_flag)
-  {
-    int wrong_field = 0;
-    if ((sl->frame_num != cur_pic->FrameNum)
-	|| (sl->bottom_field_flag
-	    && (cur_pic->completed == PICTURE_BOTTOM_DONE))
-	|| (!sl->bottom_field_flag
-	    && (cur_pic->completed == PICTURE_TOP_DONE))
-	|| !sl->field_pic_flag)
-    {
-      wrong_field = 1;
-    }
-    if (wrong_field)
-    {
-      fprintf (stderr, "vdpau_h264_alter : Wrong field, skipping.\n");
-      memset (cur_pic, 0, sizeof (dpb_frame_t));
-      dpb_reset (&decoder->sequence);
-      cur_pic->missing_header = 1;
-      decoder->sequence.startup_frame = 0;
-      return;
-    }
-  }
-
-  /* picture decoding */
-  decode_poc (decoder);
-  lprintf ("TopFieldOrderCnt = %d - BottomFieldOrderCnt = %d\n",
-	   cur_pic->TopFieldOrderCnt, cur_pic->BottomFieldOrderCnt);
-  if (sl->nal_unit_type == 5)
-  {
-    dpb_draw_frames (decoder, MAX_POC, DPB_DRAW_CLEAR);
-    decoder->sequence.startup_frame = START_IDR_FLAG;
-  }
-  decode_picnum (decoder);
-  ref_pic_list_reordering (decoder);
-  lprintf ("............................. slices_count = %d\n",
-	   decoder->sequence.slices_count);
-
-  decode_render (decoder, check_ref_list (decoder));
-
-  /* dec_ref_pic_marking */
-  slice_header_post (decoder);
-
-  if (!cur_pic->is_reference[0] && !cur_pic->is_reference[1])
-  {
-    if (cur_pic->completed == PICTURE_DONE)
-    {
-      dpb_draw_frames (decoder,
-		       (cur_pic->TopFieldOrderCnt >
-			cur_pic->BottomFieldOrderCnt) ? cur_pic->
-		       TopFieldOrderCnt : cur_pic->BottomFieldOrderCnt,
-		       DPB_DRAW_CURRENT);
+  /* the render call above is asynchroneous. it uploads frame info, and returns.
+   * this is OK with most frames as they show "much" later.
+   * however, first frame after seek is an exception. xine engine wants to show
+   * the user where the seek has landed early. we dont know when that frame is
+   * really done, so wait a fixed amount instead. */
+  if (this->seek) {
+    this->seek = 0;
+    xine_usec_sleep (10000);
+  }
+
+  img->pts = frame->pts;
+  img->top_field_first = frame->top_field_first;
+  img->draw (img, this->stream);
+  return 1;
+}
+
+static void vdpau_h264_alter_frame_delete (void *user_data, vdec_hw_h264_frame_t *frame) {
+  vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *)user_data;
+  vo_frame_t *img = (vo_frame_t *)frame->user_data;
+
+  (void)this;
+  if (img) {
+    img->free (img);
+    frame->user_data = NULL;
+    this->used -= 1;
+    if (this->used < 0) {
+      xprintf (this->stream->xine, XINE_VERBOSITY_LOG,
+        LOG_MODULE ": WARNING: too few frames (%d).\n", this->used);
     }
   }
-  else
-  {
-    if (decoder->sequence.
-	seq_param[decoder->sequence.pic_param[sl->pic_parameter_set_id]->
-		  seq_parameter_set_id]->pic_order_cnt_type == 2)
-      dpb_draw_frames (decoder,
-		       (cur_pic->TopFieldOrderCnt >
-			cur_pic->BottomFieldOrderCnt) ? cur_pic->
-		       TopFieldOrderCnt : cur_pic->BottomFieldOrderCnt,
-		       DPB_DRAW_REFS);
-
-    if (!sl->field_pic_flag || cur_pic->completed < PICTURE_DONE)
-      dbp_append (decoder, 0);
-    else
-      dbp_append (decoder, 1);
-  }
-
-  if (cur_pic->completed == PICTURE_DONE)
-    memset (cur_pic, 0, sizeof (dpb_frame_t));
-
-
-  lprintf
-    ("\n___________________________________________________________________________________________\n\n");
-}
-
-
-
-static int
-parse_startcodes (vdpau_h264_alter_decoder_t * this_gen, uint8_t * buf,
-		  uint32_t len)
-{
-  sequence_t *sequence = (sequence_t *) & this_gen->sequence;
-  bits_reader_set (&sequence->br, buf, len);
-  int ret = 0;
-
-  skip_bits (&sequence->br, 1);	/* forbidden_zero_bit */
-  uint8_t nal_ref_idc = read_bits (&sequence->br, 2);
-  uint8_t nal_unit_type = read_bits (&sequence->br, 5);
-  lprintf ("NAL size = %d, nal_ref_idc = %d, nal_unit_type = %d\n", len,
-	   nal_ref_idc, nal_unit_type);
-
-  switch (nal_unit_type)
-  {
-  case NAL_END_SEQUENCE:
-    break;
-  case NAL_SEQUENCE:
-    seq_parameter_set_data (this_gen);
-    break;
-  case NAL_PICTURE:
-    pic_parameter_set (this_gen);
-    break;
-  case NAL_SLICE_IDR:
-    slice_header (this_gen, nal_ref_idc, nal_unit_type);
-    sequence->slices[sequence->slices_count].buf_offset = buf - sequence->buf;
-    sequence->slices[sequence->slices_count].len = len;
-    ++sequence->slices_count;
-    sequence->slice_mode = NAL_SLICE_IDR;
-    break;
-  case NAL_SLICE_NO_IDR:
-    slice_header (this_gen, nal_ref_idc, nal_unit_type);
-    sequence->slices[sequence->slices_count].buf_offset = buf - sequence->buf;
-    sequence->slices[sequence->slices_count].len = len;
-    ++sequence->slices_count;
-    sequence->slice_mode = NAL_SLICE_NO_IDR;
-    break;
-  }
-
-  return ret;
 }
 
-
-
-static void
-parse_codec_private (vdpau_h264_alter_decoder_t * this_gen, const uint8_t * buf,
-		     uint32_t len)
-{
-  sequence_t *sequence = (sequence_t *) & this_gen->sequence;
-  bits_reader_set (&sequence->br, buf, len);
-  const uint8_t *buffer = buf;
-  int i;
-
-  lprintf ("parse_codec_private\n");
-
-  sequence->mode_frame = 1;
-
-  // reserved 
-  skip_bits (&sequence->br, 8);
-  skip_bits (&sequence->br, 8);	/* profile_idc */
-  skip_bits (&sequence->br, 8);
-  skip_bits (&sequence->br, 8);	/* level_idc */
-  skip_bits (&sequence->br, 6);
-
-  sequence->frame_header_size = read_bits (&sequence->br, 2) + 1;
-  //sequence->frame_header_size = 3;
-  skip_bits (&sequence->br, 3);
-  uint8_t count = read_bits (&sequence->br, 5);
-  buffer += 6;
-  for (i = 0; i < count; i++)
-  {
-    bits_reader_set (&sequence->br, buffer, len - (buffer - buf));
-    uint16_t sps_size = read_bits (&sequence->br, 16);
-    skip_bits (&sequence->br, 8);
-    seq_parameter_set_data (this_gen);
-    buffer += sps_size + 2;
-  }
-  count = buffer[0];
-  ++buffer;
-  for (i = 0; i < count; i++)
-  {
-    bits_reader_set (&sequence->br, buffer, len - (buffer - buf));
-    uint16_t pps_size = read_bits (&sequence->br, 16);
-    skip_bits (&sequence->br, 8);
-    pic_parameter_set (this_gen);
-    buffer += pps_size + 2;
-  }
-}
-
-
-
-static void
-flush_buffer (sequence_t * seq)
-{
-  if (((int)seq->bufpos - seq->bufseek) >= seq->bufseek)
-  {
-    seq->bufsize = (seq->bufpos - seq->bufseek) + MIN_BUFFER_SIZE;
-    lprintf ("buffer too short, have to allocate a new one.\n");
-    uint8_t *tmp = (uint8_t *) malloc (seq->bufsize);
-    xine_fast_memcpy (tmp, seq->buf + seq->bufseek,
-		      seq->bufpos - seq->bufseek);
-    free (seq->buf);
-    seq->buf = tmp;
-  }
-  else
-    xine_fast_memcpy (seq->buf, seq->buf + seq->bufseek,
-		      seq->bufpos - seq->bufseek);
-
-  seq->bufpos -= seq->bufseek;
-  seq->start = -1;
-  seq->bufseek = 0;
-  reset_slices (seq);
-}
-
-
-
 /*
  * This function receives a buffer of data from the demuxer layer and
  * figures out how to handle it based on its header flags.
  */
-static void
-vdpau_h264_alter_decode_data (video_decoder_t * this_gen, buf_element_t * buf)
-{
-  vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *) this_gen;
-  sequence_t *seq = (sequence_t *) & this->sequence;
-
-#ifdef MAKE_DAT
-  fwrite (buf->content, 1, buf->size, outfile);
-#endif
+static void vdpau_h264_alter_decode_data (video_decoder_t *this_gen, buf_element_t *buf) {
+  vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *)this_gen;
 
-  if (buf->decoder_flags & BUF_FLAG_FRAMERATE)
-  {
+  if (buf->decoder_flags & BUF_FLAG_FRAMERATE) {
     lprintf ("BUF_FLAG_FRAMERATE\n");
-    seq->video_step = buf->decoder_info[0];
+    vdec_hw_h264_put_container_info (this->vdec, 0, 0, buf->decoder_info[0], 0);
   }
 
-  if (buf->decoder_flags & BUF_FLAG_ASPECT)
-  {
+  if (buf->decoder_flags & BUF_FLAG_ASPECT) {
     lprintf ("BUF_FLAG_ASPECT\n");
-    seq->ratio =
-      (double) buf->decoder_info[1] / (double) buf->decoder_info[2];
+    vdec_hw_h264_put_container_info (this->vdec, 0, 0, 0, (double)buf->decoder_info[1] / (double) buf->decoder_info[2]);
   }
 
-  if (buf->decoder_flags & BUF_FLAG_STDHEADER)
-  {
-    lprintf ("BUF_FLAG_STDHEADER\n");
-    seq->flag_header = 1;
+  if (buf->decoder_flags & BUF_FLAG_STDHEADER) {
     xine_bmiheader *bih = (xine_bmiheader *) buf->content;
-    seq->coded_width = bih->biWidth;
-    seq->coded_height = bih->biHeight;
     uint8_t *codec_private = buf->content + sizeof (xine_bmiheader);
     uint32_t codec_private_len = bih->biSize - sizeof (xine_bmiheader);
-    if (codec_private_len > 0)
-      parse_codec_private (this, codec_private, codec_private_len);
+
+    lprintf ("BUF_FLAG_STDHEADER\n");
+    vdec_hw_h264_put_container_info (this->vdec, bih->biWidth, bih->biHeight, 0, 0);
+    vdec_hw_h264_put_config (this->vdec, codec_private, codec_private_len);
     return;
   }
 
-  if (buf->decoder_flags & BUF_FLAG_SPECIAL)
-  {
-    if (buf->decoder_info[1] == BUF_SPECIAL_DECODER_CONFIG)
-    {
-      lprintf ("BUF_SPECIAL_DECODER_CONFIG\n");
-      seq->flag_header = 1;
+  if (buf->decoder_flags & BUF_FLAG_SPECIAL) {
+    if (buf->decoder_info[1] == BUF_SPECIAL_DECODER_CONFIG) {
       const uint8_t *codec_private = buf->decoder_info_ptr[2];
       uint32_t codec_private_len = buf->decoder_info[2];
-      if (codec_private_len > 0)
-	parse_codec_private (this, codec_private, codec_private_len);
+
+      lprintf ("BUF_SPECIAL_DECODER_CONFIG\n");
+      vdec_hw_h264_put_config (this->vdec, codec_private, codec_private_len);
     }
     return;
   }
@@ -2195,189 +365,66 @@
   if (!buf->size)
     return;
 
-  int size = seq->bufpos + buf->size;
-  if ((int)seq->bufsize < size)
-  {
-    if (seq->bufsize > MAX_BUFFER_SIZE)
-    {
-      fprintf (stderr,
-	       "vdpau_h264_alter : sorry, can't accumulate so much data, broken stream?\n");
-      reset_sequence (seq);
-      return;
-    }
-    seq->bufsize = size + MIN_BUFFER_SIZE;
-    seq->buf = (uint8_t *) realloc (seq->buf, seq->bufsize);
-    lprintf ("realloc new size = %d\n", seq->bufsize);
-  }
-  xine_fast_memcpy (seq->buf + seq->bufpos, buf->content, buf->size);
-  seq->bufpos += buf->size;
-
-  if (buf->decoder_flags & BUF_FLAG_FRAME_START)
-    seq->pic_pts = buf->pts;
-
-  int frame_end = buf->decoder_flags & BUF_FLAG_FRAME_END;
-
-  if (seq->mode_frame)
-  {
-    if (!seq->pic_pts)
-      seq->pic_pts = buf->pts;
-    if (frame_end)
-    {
-      if (buf->pts)
-	seq->pic_pts = buf->pts;
-      lprintf ("frame_end && seq->mode_frame\n");
-      uint32_t fhs;
-      uint8_t tb;
-      uint32_t j = 0;
-      while (j < seq->bufpos)
-      {
-	uint32_t s = 0;
-	for (fhs = 0; fhs < seq->frame_header_size; fhs++)
-	  s |= seq->buf[j + fhs] << (8 * (seq->frame_header_size - 1 - fhs));
-	tb = *(seq->buf + j + seq->frame_header_size) & 0x1F;
-	if (seq->slice_mode && (tb != seq->slice_mode))
-	{
-	  decode_picture (this);
-	  reset_slices (seq);
-	}
-	parse_startcodes (this, seq->buf + j + seq->frame_header_size, s);
-	j += seq->frame_header_size + s;
-      }
-      if (seq->slice_mode)
-      {
-	decode_picture (this);
-	reset_slices (seq);
-      }
-      seq->bufpos = 0;
-    }
-    return;
-  }
-
-  while (seq->bufseek <= (int)seq->bufpos - 4)
-  {
-    uint8_t *buffer = seq->buf + seq->bufseek;
-    if (buffer[0] == 0 && buffer[1] == 0 && buffer[2] == 1)
-    {
-      if (seq->start < 0)
-      {
-	seq->start = seq->bufseek;
-	uint8_t tb = buffer[3] & 0x1F;
-	if (((tb == NAL_SLICE_NO_IDR) || (tb == NAL_SLICE_IDR))
-	    && !seq->pic_pts)
-	  seq->pic_pts = buf->pts;
-	if (seq->slice_mode && (tb != seq->slice_mode))
-	{
-	  decode_picture (this);
-	  flush_buffer (seq);
-	}
-	if ((tb & 0x1F) == NAL_END_SEQUENCE)
-	{
-	  dpb_print (seq);
-	  dpb_draw_frames (this, MAX_POC, DPB_DRAW_CLEAR);
-	  lprintf ("NAL_END_SEQUENCE\n");
-	  dpb_print (seq);
-	}
-      }
-      else
-      {
-	parse_startcodes (this, seq->buf + seq->start + 3,
-			  seq->bufseek - seq->start - 3);
-	seq->start = -1;
-	--seq->bufseek;
-      }
-    }
-    ++seq->bufseek;
-  }
-
-  if (frame_end && seq->flag_header && (seq->start > -1)
-      && (seq->bufseek > seq->start))
-  {
-    lprintf ("frame_end && seq->start\n");
-    seq->bufseek = seq->bufpos;
-    parse_startcodes (this, seq->buf + seq->start + 3,
-		      seq->bufseek - seq->start - 3);
-    if (seq->slice_mode)
-      decode_picture (this);
-    flush_buffer (seq);
-  }
+  vdec_hw_h264_put_frame (this->vdec, buf->pts, (const uint8_t *)buf->content, buf->size,
+    !!(buf->decoder_flags & BUF_FLAG_FRAME_END));
 }
 
 
 /*
  * This function is called when xine needs to flush the system.
  */
-static void
-vdpau_h264_alter_flush (video_decoder_t * this_gen)
-{
+static void vdpau_h264_alter_flush (video_decoder_t *this_gen) {
   vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *) this_gen;
 
   lprintf ("vdpau_h264_alter_flush\n");
-  dpb_draw_frames (this, MAX_POC, DPB_DRAW_REFS);
-}
 
+  vdec_hw_h264_flush (this->vdec);
+}
 
 /*
  * This function resets the video decoder.
  */
-static void
-vdpau_h264_alter_reset (video_decoder_t * this_gen)
-{
+static void vdpau_h264_alter_reset (video_decoder_t *this_gen) {
   vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *) this_gen;
 
   lprintf ("vdpau_h264_alter_reset\n");
-  reset_sequence (&this->sequence);
-}
 
+  vdec_hw_h264_reset (this->vdec);
+  this->seek = 1;
+}
 
 /*
  * The decoder should forget any stored pts values here.
  */
-static void
-vdpau_h264_alter_discontinuity (video_decoder_t * this_gen)
-{
+static void vdpau_h264_alter_discontinuity (video_decoder_t *this_gen) {
   vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *) this_gen;
+
   lprintf ("vdpau_h264_alter_discontinuity\n");
 
-  dpb_clear_all_pts (&this->sequence);
-  this->sequence.reset = VO_NEW_SEQUENCE_FLAG;
+  vdec_hw_h264_zero_pts (this->vdec);
 }
 
-
 /*
  * This function frees the video decoder instance allocated to the decoder.
  */
-static void
-vdpau_h264_alter_dispose (video_decoder_t * this_gen)
-{
-
+static void vdpau_h264_alter_dispose (video_decoder_t *this_gen) {
   vdpau_h264_alter_decoder_t *this = (vdpau_h264_alter_decoder_t *) this_gen;
 
   lprintf ("vdpau_h264_alter_dispose\n");
 
-  if ((this->decoder != VDP_INVALID_HANDLE) && this->sequence.accel_vdpau)
-  {
-    if (this->sequence.accel_vdpau->lock)
-      this->sequence.accel_vdpau->lock (this->sequence.accel_vdpau->vo_frame);
-    this->sequence.accel_vdpau->vdp_decoder_destroy (this->decoder);
+  vdec_hw_h264_delete (&this->vdec);
+
+  if ((this->decoder != VDP_INVALID_HANDLE) && this->accel_vdpau) {
+    if (this->accel_vdpau->lock)
+      this->accel_vdpau->lock (this->accel_vdpau->vo_frame);
+    this->accel_vdpau->vdp_decoder_destroy (this->decoder);
     this->decoder = VDP_INVALID_HANDLE;
-    if (this->sequence.accel_vdpau->unlock)
-      this->sequence.accel_vdpau->unlock (this->sequence.accel_vdpau->vo_frame);
+    if (this->accel_vdpau->unlock)
+      this->accel_vdpau->unlock (this->accel_vdpau->vo_frame);
   }
-  reset_sequence (&this->sequence);
-
-  int i;
-  for (i = 0; i < MAX_DPB_SIZE; i++)
-    free (this->sequence.dpb[i]);
-  for (i = 0; i < 32; i++)
-    if (this->sequence.seq_param[i])
-      free (this->sequence.seq_param[i]);
-  for (i = 0; i < 255; i++)
-    if (this->sequence.pic_param[i])
-      free (this->sequence.pic_param[i]);
 
   this->stream->video_out->close (this->stream->video_out, this->stream);
 
-  free (this->sequence.buf);
   free (this_gen);
 }
 
@@ -2386,55 +433,53 @@
  * This function allocates, initializes, and returns a private video
  * decoder structure.
  */
-static video_decoder_t *
-open_plugin (video_decoder_class_t * class_gen, xine_stream_t * stream)
-{
-
+static video_decoder_t *open_plugin (video_decoder_class_t *class_gen, xine_stream_t *stream) {
   vdpau_h264_alter_decoder_t *this;
+  vo_frame_t *img;
+  vdpau_accel_t *accel;
+  int runtime_nr;
+  VdpDecoder decoder;
+  VdpStatus st;
+  vdec_hw_h264_t *vdec;
 
   (void)class_gen;
-
   /* the videoout must be vdpau-capable to support this decoder */
-  if (!
-      (stream->video_out->
-       get_capabilities (stream->video_out) & VO_CAP_VDPAU_H264))
+  if (!(stream->video_out->get_capabilities (stream->video_out) & VO_CAP_VDPAU_H264))
     return NULL;
 
   /* now check if vdpau has free decoder resource */
-  vo_frame_t *img =
-    stream->video_out->get_frame (stream->video_out, 1920, 1080, 1, XINE_IMGFMT_VDPAU,
-                                  VO_BOTH_FIELDS | VO_GET_FRAME_MAY_FAIL);
-  if (!img) {
+  img = stream->video_out->get_frame (stream->video_out, 1920, 1080, 1, XINE_IMGFMT_VDPAU, VO_BOTH_FIELDS | VO_GET_FRAME_MAY_FAIL);
+  if (!img)
     return NULL;
-  }
-  vdpau_accel_t *accel = (vdpau_accel_t *) img->accel_data;
-  int runtime_nr = accel->vdp_runtime_nr;
+
+  accel = (vdpau_accel_t *)img->accel_data;
+  runtime_nr = accel->vdp_runtime_nr;
   img->free (img);
-  VdpDecoder decoder;
-  VdpStatus st;
+
   if (accel->lock)
     accel->lock (accel->vo_frame);
-  st =accel->vdp_decoder_create (accel->vdp_device,
-			       VDP_DECODER_PROFILE_H264_MAIN, 1920, 1080, 16,
-			       &decoder);
-  if (accel->unlock)
-    accel->unlock (accel->vo_frame);
-  if (st != VDP_STATUS_OK)
-  {
-    fprintf (stderr, "can't create vdpau decoder!\n");
+  st = accel->vdp_decoder_create (accel->vdp_device, VDP_DECODER_PROFILE_H264_MAIN, 1920, 1080, 16, &decoder);
+  if (st != VDP_STATUS_OK) {
+    if (accel->unlock)
+      accel->unlock (accel->vo_frame);
+    xprintf (stream->xine, XINE_VERBOSITY_LOG, "can't create vdpau decoder!\n");
     return NULL;
   }
-
-  if (accel->lock)
-    accel->lock (accel->vo_frame);
   accel->vdp_decoder_destroy (decoder);
   if (accel->unlock)
     accel->unlock (accel->vo_frame);
 
-  this =
-    (vdpau_h264_alter_decoder_t *) calloc (1,
-					   sizeof
-					   (vdpau_h264_alter_decoder_t));
+  this = (vdpau_h264_alter_decoder_t *)calloc (1, sizeof (*this));
+  if (!this)
+    return NULL;
+
+  vdec = vdec_hw_h264_new (vdpau_h264_alter_logg, this, vdpau_h264_alter_frame_new,
+    vdpau_h264_alter_frame_render, vdpau_h264_alter_frame_ready, vdpau_h264_alter_frame_delete,
+    stream->video_out->get_property (stream->video_out, VO_PROP_BUFS_TOTAL));
+  if (!vdec) {
+    free (this);
+    return NULL;
+  }
 
   this->video_decoder.decode_data = vdpau_h264_alter_decode_data;
   this->video_decoder.flush = vdpau_h264_alter_flush;
@@ -2443,37 +488,21 @@
   this->video_decoder.dispose = vdpau_h264_alter_dispose;
 
   this->stream = stream;
+  this->vdec = vdec;
 
-  int i;
-  for (i = 0; i < 16; i++)
-    this->sequence.dpb[i] = (dpb_frame_t *) calloc (1, sizeof (dpb_frame_t));
-  this->sequence.bufsize = MIN_BUFFER_SIZE;
-  this->sequence.buf = (uint8_t *) malloc (this->sequence.bufsize);
-  this->sequence.vdp_runtime_nr = runtime_nr;
-  this->sequence.reset = VO_NEW_SEQUENCE_FLAG;
-  this->sequence.reset = VO_NEW_SEQUENCE_FLAG;
-  this->sequence.ratio = 0.0;
-  this->sequence.video_step = 3600;
-  this->sequence.coded_width = 1280;
-  this->sequence.coded_height = 720;
-  this->sequence.reported_ratio = 0.0;
-  this->sequence.reported_video_step = 0;
-  this->sequence.reported_coded_width = 0;
-  this->sequence.reported_coded_height = 0;
-  this->sequence.frame_header_size = 4;
-  this->sequence.flag_header = 0;
-  this->sequence.mode_frame = 0;
-  reset_sequence (&this->sequence);
+  this->vdp_runtime_nr = runtime_nr;
+  this->reported_ratio = 0.0;
+  this->reported_video_step = 0;
+  this->reported_width = 0;
+  this->reported_height = 0;
 
-  this->decoder = VDP_INVALID_HANDLE;
-  this->sequence.accel_vdpau = NULL;
+  this->used = 0;
 
-  (stream->video_out->open) (stream->video_out, stream);
+  this->decoder = VDP_INVALID_HANDLE;
+  this->accel_vdpau = NULL;
 
-#ifdef MAKE_DAT
-  outfile = fopen ("/tmp/h264.dat", "w");
-  nframes = 0;
-#endif
+  stream->video_out->open (stream->video_out, stream);
+  this->seek = 1;
 
   return &this->video_decoder;
 }
@@ -2483,12 +512,7 @@
  * This function allocates a private video decoder class and initializes
  * the class's member functions.
  */
-void *
-h264_alter_init_plugin (xine_t * xine, const void *data)
-{
-  (void)xine;
-  (void)data;
-
+void *h264_alter_init_plugin (xine_t * xine, const void *data) {
   static const video_decoder_class_t decode_video_vdpau_h264_alter_class = {
     .open_plugin = open_plugin,
     .identifier  = "vdpau_h264_alter",
@@ -2499,6 +523,8 @@
     .dispose = NULL,
   };
 
+  (void)xine;
+  (void)data;
   return (void *)&decode_video_vdpau_h264_alter_class;
 }
 
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/alterh264_decode.h xine-lib-1.2/src/video_dec/libvdpau/alterh264_decode.h
--- xine-lib-1.2.11/src/video_dec/libvdpau/alterh264_decode.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/alterh264_decode.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,293 +0,0 @@
-/* kate: tab-indent on; indent-width 4; mixedindent off; indent-mode cstyle; remove-trailing-space on; */
-/*
- * Copyright (C) 2008-2018 the xine project
- *
- * This file is part of xine, a free video player.
- *
- * xine is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * xine is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- */
-
-#ifndef ALTERH264_DECODE_H
-#define ALTERH264_DECODE_H
-
-//#define LOG
-#define LOG_MODULE "vdpau_h264"
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include <xine/xine_internal.h>
-#include <xine/video_out.h>
-#include <xine/buffer.h>
-#include <xine/xineutils.h>
-#include "accel_vdpau.h"
-#include <vdpau/vdpau.h>
-
-#include "alterh264_bits_reader.h"
-
-
-
-enum aspect_ratio
-{
-  ASPECT_UNSPECIFIED = 0,
-  ASPECT_1_1,
-  ASPECT_12_11,
-  ASPECT_10_11,
-  ASPECT_16_11,
-  ASPECT_40_33,
-  ASPECT_24_11,
-  ASPECT_20_11,
-  ASPECT_32_11,
-  ASPECT_80_33,
-  ASPECT_18_11,
-  ASPECT_15_11,
-  ASPECT_64_33,
-  ASPECT_160_99,
-  ASPECT_4_3,
-  ASPECT_3_2,
-  ASPECT_2_1,
-  ASPECT_RESERVED,
-  ASPECT_EXTENDED_SAR = 255
-};
-
-
-
-typedef struct
-{
-  uint8_t aspect_ratio_info;
-  uint8_t aspect_ratio_idc;
-  uint16_t sar_width;
-  uint16_t sar_height;
-  uint8_t colour_desc;
-  uint8_t colour_primaries;
-  uint8_t timing_info;
-  uint32_t num_units_in_tick;
-  uint32_t time_scale;
-} vui_param_t;
-
-
-
-typedef struct
-{
-  uint8_t profile_idc;
-  uint8_t level_idc;
-  uint8_t seq_parameter_set_id;
-  uint8_t constraint_set0_flag;
-  uint8_t constraint_set1_flag;
-  uint8_t constraint_set2_flag;
-  uint8_t constraint_set3_flag;
-  uint8_t chroma_format_idc;
-  uint8_t separate_colour_plane_flag;
-  uint8_t bit_depth_luma_minus8;
-  uint8_t bit_depth_chroma_minus8;
-  uint8_t qpprime_y_zero_transform_bypass_flag;
-  uint8_t seq_scaling_matrix_present_flag;
-  uint8_t scaling_lists_4x4[6][16];
-  uint8_t scaling_lists_8x8[2][64];
-  uint8_t log2_max_frame_num_minus4;
-  uint8_t pic_order_cnt_type;
-  uint8_t log2_max_pic_order_cnt_lsb_minus4;
-  uint8_t delta_pic_order_always_zero_flag;
-  int32_t offset_for_non_ref_pic;
-  int32_t offset_for_top_to_bottom_field;
-  uint8_t num_ref_frames_in_pic_order_cnt_cycle;
-  int32_t offset_for_ref_frame[256];
-  uint8_t num_ref_frames;
-  uint8_t gaps_in_frame_num_value_allowed_flag;
-  uint8_t pic_width_in_mbs_minus1;
-  uint8_t pic_height_in_map_units_minus1;
-  uint8_t frame_mbs_only_flag;
-  uint8_t mb_adaptive_frame_field_flag;
-  uint8_t direct_8x8_inference_flag;
-  uint8_t frame_cropping_flag;
-  uint16_t frame_crop_left_offset;
-  uint16_t frame_crop_right_offset;
-  uint16_t frame_crop_top_offset;
-  uint16_t frame_crop_bottom_offset;
-  uint8_t vui_parameters_present_flag;
-  vui_param_t vui;
-} seq_param_t;
-
-
-
-typedef struct
-{
-  uint8_t pic_parameter_set_id;
-  uint8_t seq_parameter_set_id;
-  uint8_t entropy_coding_mode_flag;
-  uint8_t pic_order_present_flag;
-  /*uint8_t num_slice_groups_minus1;
-     uint8_t slice_group_map_type;
-     uint16_t run_length_minus1[64];
-     uint16_t top_left[64];
-     uint16_t bottom_right[64];
-     uint8_t slice_group_change_direction_flag;
-     uint16_t slice_group_change_rate_minus1;
-     uint16_t pic_size_in_map_units_minus1;
-     uint8_t slice_group_id[64]; */
-  uint8_t num_ref_idx_l0_active_minus1;
-  uint8_t num_ref_idx_l1_active_minus1;
-  uint8_t weighted_pred_flag;
-  uint8_t weighted_bipred_idc;
-  int8_t pic_init_qp_minus26;
-  int8_t pic_init_qs_minus26;
-  int8_t chroma_qp_index_offset;
-  uint8_t deblocking_filter_control_present_flag;
-  uint8_t constrained_intra_pred_flag;
-  uint8_t redundant_pic_cnt_present_flag;
-  uint8_t transform_8x8_mode_flag;
-  uint8_t pic_scaling_matrix_present_flag;
-  uint8_t pic_scaling_list_present_flag[8];
-  uint8_t scaling_lists_4x4[6][16];
-  uint8_t scaling_lists_8x8[2][64];
-  int8_t second_chroma_qp_index_offset;
-} pic_param_t;
-
-
-
-typedef struct
-{
-  uint8_t nal_ref_idc;
-  uint8_t nal_unit_type;
-  uint8_t slice_type;
-  uint8_t pic_parameter_set_id;
-  uint16_t frame_num;
-  uint32_t MaxFrameNum;
-  uint8_t field_pic_flag;
-  uint8_t bottom_field_flag;
-  uint16_t idr_pic_id;
-  uint16_t pic_order_cnt_lsb;
-  int32_t delta_pic_order_cnt_bottom;
-  int32_t delta_pic_order_cnt[2];
-  uint8_t redundant_pic_cnt;
-  uint8_t num_ref_idx_l0_active_minus1;
-  uint8_t num_ref_idx_l1_active_minus1;
-} slice_param_t;
-
-
-#define PICTURE_TOP_DONE    1
-#define PICTURE_BOTTOM_DONE 2
-#define PICTURE_DONE        3
-
-#define SHORT_TERM_REF 1
-#define LONG_TERM_REF  2
-
-typedef struct
-{
-  uint8_t used;
-  uint8_t missing_header;
-  int64_t pts;
-  uint8_t drop_pts;
-  uint8_t completed;
-  uint8_t top_field_first;
-  uint16_t FrameNum;
-  int32_t FrameNumWrap;
-  int32_t PicNum[2];		/* 0:top, 1:bottom */
-  uint8_t is_reference[2];	/* 0:top, 1:bottom, short or long term */
-  uint8_t field_pic_flag;
-  int32_t PicOrderCntMsb;
-  int32_t TopFieldOrderCnt;
-  int32_t BottomFieldOrderCnt;
-  uint16_t pic_order_cnt_lsb;
-  uint8_t mmc5;
-
-  vo_frame_t *videoSurface;
-} dpb_frame_t;
-
-
-
-typedef struct
-{
-  uint32_t buf_offset;
-  uint32_t len;
-} slice_t;
-
-
-
-typedef struct
-{
-  uint32_t coded_width;
-  uint32_t reported_coded_width;
-  uint32_t coded_height;
-  uint32_t reported_coded_height;
-  uint64_t video_step;		/* frame duration in pts units */
-  uint64_t reported_video_step;	/* frame duration in pts units */
-  double ratio;
-  double reported_ratio;
-
-  slice_t slices[68];
-  int slices_count;
-  int slice_mode;
-
-  seq_param_t *seq_param[32];
-  pic_param_t *pic_param[256];
-  slice_param_t slice_param;
-
-  dpb_frame_t *dpb[16];
-  dpb_frame_t cur_pic;
-  uint16_t prevFrameNum;
-  uint16_t prevFrameNumOffset;
-  uint8_t prevMMC5;
-
-  int chroma;
-  int top_field_first;
-  VdpDecoderProfile profile;
-
-  uint8_t *buf;			/* accumulate data */
-  int bufseek;
-  uint32_t bufsize;
-  uint32_t bufpos;
-  int start;
-
-  int64_t pic_pts;
-
-  bits_reader_t br;
-
-  int vdp_runtime_nr;
-  vdpau_accel_t *accel_vdpau;
-
-  int reset;
-  int startup_frame;
-
-  uint8_t mode_frame;
-  uint8_t flag_header;
-  uint32_t frame_header_size;
-
-  int color_matrix;
-
-} sequence_t;
-
-
-typedef struct vdpau_mpeg12_decoder_s
-{
-  video_decoder_t video_decoder;	/* parent video decoder structure */
-
-  xine_stream_t *stream;
-
-  sequence_t sequence;
-
-  VdpDecoder decoder;
-  VdpDecoderProfile decoder_profile;
-  uint32_t decoder_width;
-  uint32_t decoder_height;
-
-} vdpau_h264_alter_decoder_t;
-
-#endif /* ALTERH264_DECODE_H */
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/vdec_hw_bits_reader.h xine-lib-1.2/src/video_dec/libvdpau/vdec_hw_bits_reader.h
--- xine-lib-1.2.11/src/video_dec/libvdpau/vdec_hw_bits_reader.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/vdec_hw_bits_reader.h	2022-01-15 22:03:19.605547259 +0100
@@ -0,0 +1,312 @@
+/* kate: tab-indent on; indent-width 4; mixedindent off; indent-mode cstyle; remove-trailing-space on; */
+/*
+ * Copyright (C) 2008-2013 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ */
+
+#ifndef ALTERH264_BITS_READER_H
+#define ALTERH264_BITS_READER_H
+#include <sys/types.h>
+#include <inttypes.h>
+#include <stdio.h>
+
+typedef struct {
+  const uint32_t *read;
+  const uint8_t *start, *end;
+  uint32_t val, bits, oflow;
+} bits_reader_t;
+
+static void bits_set_buf (bits_reader_t *br, const uint8_t *buf, uint32_t len) {
+  const union {
+    uint32_t word;
+    uint8_t  little;
+  } endian_is = {1};
+  uint32_t v;
+
+  br->start = buf;
+  br->end = buf + len;
+  br->read = (const uint32_t *)((uintptr_t)buf & ~(uintptr_t)3);
+  br->bits = 32 - (buf - (const uint8_t *)br->read) * 8;
+  v = *br->read++;
+  if (endian_is.little)
+    v = (v >> 24) | ((v >> 8) & 0x0000ff00) | ((v << 8) & 0x00ff0000) | (v << 24);
+  br->val = v << (32 - br->bits);
+  br->oflow = 0;
+}
+
+static inline uint32_t bits_tell (bits_reader_t *br) {
+  return ((const uint8_t *)br->read - br->start) * 8 - br->bits;
+}
+
+/* NOTE: mathematically, uint32_t << 32 yields 0.
+ * however, real life truncates the shift width to 5 bits (32 == 0),
+ * and thus has no effect. lets use some paranoia that gcc will
+ * optimize away in most cases where width is constant. */
+
+/** NOTE: old code bailed out when end of bitstream was reached exactly. */
+static uint32_t _bits_read_slow (bits_reader_t *br, uint32_t bits) {
+  const union {
+    uint32_t word;
+    uint8_t  little;
+  } endian_is = {1};
+  uint32_t v1, v2;
+  int left = (br->end - (const uint8_t *)br->read) * 8;
+
+  if (br->bits) {
+    v1 = br->val >> (32 - br->bits);
+    bits -= br->bits;
+    v1 <<= bits;
+  } else {
+    v1 = 0;
+  }
+  if (left < 32) {
+    if (left < (int)bits) {
+      br->read = (const uint32_t *)(((uintptr_t)br->end + 3) & ~(uintptr_t)3);
+      br->bits = 0;
+      br->oflow = 1;
+      return 0;
+    }
+  } else {
+    left = 32;
+  }
+  v2 = *br->read++;
+  if (endian_is.little)
+    v2 = (v2 >> 24) | ((v2 >> 8) & 0x0000ff00) | ((v2 << 8) & 0x00ff0000) | (v2 << 24);
+  /* bits > 0 is sure here. */
+  v1 |= v2 >> (32 - bits);
+  br->val = v2 << bits;
+  br->bits = left - bits;
+  return v1;
+}
+
+/** bits <= 32 */
+static inline uint32_t bits_read (bits_reader_t *br, const uint32_t bits) {
+  uint32_t v;
+
+  if (!bits)
+    return 0;
+  if (br->bits >= bits) {
+    v = br->val >> (32 - bits);
+    br->val <<= bits;
+    br->bits -= bits;
+    return v;
+  }
+  return _bits_read_slow (br, bits);
+}
+
+static void _bits_skip_slow (bits_reader_t *br, uint32_t bits) {
+  const union {
+    uint32_t word;
+    uint8_t  little;
+  } endian_is = {1};
+  uint32_t v2;
+  int left = (br->end - (const uint8_t *)br->read) * 8;
+
+  bits -= br->bits;
+  left -= bits;
+  if (left < 0) {
+    br->read = (const uint32_t *)(((uintptr_t)br->end + 3) & ~(uintptr_t)3);
+    br->bits = 0;
+    br->oflow = 1;
+    return;
+  }
+  br->read += bits >> 5;
+  v2 = *br->read++;
+  if (endian_is.little)
+    v2 = (v2 >> 24) | ((v2 >> 8) & 0x0000ff00) | ((v2 << 8) & 0x00ff0000) | (v2 << 24);
+  bits &= 31;
+  br->val = v2 << bits;
+  br->bits = (left >= 32 ? 32 : left) - bits;
+}
+
+/** bits unlimited */
+static inline void bits_skip (bits_reader_t *br, const uint32_t bits) {
+  if (!bits)
+    return;
+  if (br->bits >= bits) {
+    br->val <<= bits;
+    br->bits -= bits;
+  } else {
+    _bits_skip_slow (br, bits);
+  }
+}
+
+/* needing this func at all is a nasty kludge.
+ * h.264 PPS has an optional extension that has been added without defining
+ * a presence flag earlier... */
+/** how many bits are left from here to the last "1"? NOTE: old code was off by -1. */
+static uint32_t bits_valid_left (bits_reader_t *br) {
+  static const uint32_t mask[4] = {0x00000000, 0xff000000, 0xffff0000, 0xffffff00};
+  const union {
+    uint32_t word;
+    uint8_t  little;
+  } endian_is = {1};
+  uint32_t v;
+  int n;
+
+  do {
+    /* search yet unread bits for last "1". */
+    if ((const uint8_t *)br->read < br->end) {
+      const uint32_t *p = (const uint32_t *)((uintptr_t)br->end & ~(uintptr_t)3);
+
+      n = br->end - (const uint8_t *)p;
+      if (n > 0) {
+        v = *p;
+        if (endian_is.little)
+          v = (v >> 24) | ((v >> 8) & 0x0000ff00) | ((v << 8) & 0x00ff0000) | (v << 24);
+        v &= mask[n];
+      } else {
+        v = 0;
+      }
+
+      while (!v && (p > br->read)) {
+        v = *--p;
+        if (endian_is.little)
+          v = (v >> 24) | ((v >> 8) & 0x0000ff00) | ((v << 8) & 0x00ff0000) | (v << 24);
+      }
+      n = (p - br->read) * 32 + br->bits;
+      if (v)
+        break;
+    }
+    /* well, only value cache is left to test. */
+    if (!br->bits)
+      return 0;
+    /* for performance, we dont end mask br->val generally. */
+    n = 32 - br->bits;
+    v = br->val >> n << n;
+    n = 0;
+  } while (0);
+
+  while (v)
+    n++, v <<= 1;
+  return n;
+}
+
+static uint32_t bits_exp_ue (bits_reader_t * br) {
+  const union {
+    uint32_t word;
+    uint8_t  little;
+  } endian_is = {1};
+  uint32_t size;
+  /* count leading 0 bits */
+  if (br->bits && br->val) {
+    uint32_t v1 = br->val;
+
+    size = 0;
+    while (!(v1 & 0x80000000))
+      v1 <<= 1, size++;
+    br->val = v1;
+    br->bits -= size;
+  } else {
+    int left = (br->end - (const uint8_t *)br->read) * 8;
+    uint32_t v2, rest;
+
+    if (left <= 0) {
+      br->read = (const uint32_t *)(((uintptr_t)br->end + 3) & ~(uintptr_t)3);
+      br->bits = 0;
+      br->oflow = 1;
+      return 0;
+    }
+    size = br->bits;
+    rest = 32 - size;
+    if (rest > (uint32_t)left)
+      rest = left;
+    v2 = *br->read++;
+    if (endian_is.little)
+      v2 = (v2 >> 24) | ((v2 >> 8) & 0x0000ff00) | ((v2 << 8) & 0x00ff0000) | (v2 << 24);
+    if (v2 & (0xffffffff << (32 - rest))) {
+      while (!(v2 & 0x80000000))
+        v2 <<= 1, size++;
+    } else {
+      v2 <<= rest;
+      size += rest;
+    }
+    br->val = v2;
+    br->bits = (left > 32 ? 32 : left) + br->bits - size;
+  }
+  /* get sized value */
+  size++;
+  if (br->bits >= size) {
+    uint32_t res = br->val >> (32 - size);
+
+    br->val <<= size;
+    br->bits -= size;
+    return res - 1;
+  } else {
+    uint32_t v2, res;
+    int left = (br->end - (const uint8_t *)br->read) * 8;
+
+    size -= br->bits;
+    if (left < (int)size) {
+      br->read = (const uint32_t *)(((uintptr_t)br->end + 3) & ~(uintptr_t)3);
+      br->bits = 0;
+      br->oflow = 1;
+      return 0;
+    }
+    res = br->bits ? br->val >> (32 - br->bits) : 0;
+    v2 = *br->read++;
+    if (endian_is.little)
+      v2 = (v2 >> 24) | ((v2 >> 8) & 0x0000ff00) | ((v2 << 8) & 0x00ff0000) | (v2 << 24);
+    res = (res << size) + (v2 >> (32 - size));
+    br->val = v2 << size;
+    br->bits = (left > 32 ? 32 : left) - size;
+    return res - 1;
+  }
+}
+
+static inline int32_t bits_exp_se (bits_reader_t * br) {
+  uint32_t res = bits_exp_ue (br);
+
+  return (res & 1) ? (int32_t)((res + 1) >> 1) : -(int32_t)(res >> 1);
+}
+
+#ifdef TEST_THIS_FILE
+#  include <stdio.h>
+
+int main (int argc, char **argv) {
+  static const uint8_t test[] = "\x75\x99\xfb\x07\x55\xd8\xff\x23\x11\xab\xa8";
+  bits_reader_t br;
+  unsigned int v1, v2, v3, v4, v5, v6, v7, v8, v9, m;
+
+  (void)argc;
+  (void)argv;
+  bits_set_buf (&br, test + 1, sizeof (test) - 1);
+  bits_skip (&br, 1);
+  v1 = bits_read (&br, 3);
+  v2 = bits_read (&br, 7);
+  v3 = bits_read (&br, 5);
+  bits_skip (&br, 8);
+  v4 = bits_read (&br, 8);
+  bits_skip (&br, 7);
+  v5 = bits_read (&br, 1);
+  m = bits_valid_left (&br);
+  v6 = bits_read (&br, 12);
+  v7 = bits_read (&br, 4);
+  v8 = bits_read (&br, 23);
+  v9 = bits_read (&br, 9);
+  printf ("%s\n", __FILE__);
+  printf ("(1)        3        7        5 (8)        8 (7)        1       12        4       23        9\n");
+  printf ("--- %08x %08x %08x --- %08x --- %08x %08x %08x %08x %08x\n", v1, v2, v3, v4, v5, v6, v7, v8, v9);
+  printf ("more: %08x\n", m);
+  return 0;
+}
+
+#endif
+#endif /* ALTERH264_BITS_READER_H */
+
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/vdec_hw_h264.c xine-lib-1.2/src/video_dec/libvdpau/vdec_hw_h264.c
--- xine-lib-1.2.11/src/video_dec/libvdpau/vdec_hw_h264.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/vdec_hw_h264.c	2022-01-15 22:03:19.623547335 +0100
@@ -0,0 +1,2409 @@
+/* kate: space-indent on; indent-width 2; mixedindent off; indent-mode cstyle; remove-trailing-space on;
+ * Copyright (C) 2008-2021 the xine project
+ * Copyright (C) 2008 Christophe Thommeret <hftom@free.fr>
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * h264.c, a generic H264 video stream parser for VDPAU and VAAPI hardware decoders
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#undef LOG
+#define LOG_MODULE "vdec_hw_h264"
+
+#ifdef LOG
+#  define lprintf(_fmt, ...) fprintf (stderr, LOG_MODULE _fmt, ...)
+#else
+#  define lprintf(_fmt, ...) /* nothing */
+#endif
+
+#include <stdio.h>
+#include <stdarg.h>
+#include "vdec_hw_h264.h"
+#include "vdec_hw_bits_reader.h"
+
+#define PICTURE_TOP_DONE    1
+#define PICTURE_BOTTOM_DONE 2
+#define PICTURE_DONE        3
+
+#define SHORT_TERM_REF 1
+#define LONG_TERM_REF  2
+
+#define MAX_SPS 32
+#define MAX_PPS 256
+#define MAX_SLICES 80 /* 68? */
+#define MAX_REF_FRAMES 16
+#define MIN_BUFFER_SIZE 10000
+#define MAX_BUFFER_SIZE 3145728
+#define BUF_PAD 8
+
+#define NAL_UNSPECIFIED 0
+#define NAL_SLICE_NO_IDR 1
+#define NAL_SLICE_IDR 5
+#define NAL_SEI 6
+#define NAL_SEQUENCE 7
+#define NAL_PICTURE 8
+#define NAL_SEEK_POINT 9
+#define NAL_END_SEQUENCE 10
+#define NAL_END_STREAM 11
+#define NAL_FILLER 12
+#define NAL_SEQUENCE_EXT 13
+
+#define SLICE_TYPE_P 0
+#define SLICE_TYPE_B 1
+#define SLICE_TYPE_I 2
+#define SLICE_TYPE_SP 3
+#define SLICE_TYPE_SI 4
+
+#define START_IDR_FLAG 1000
+
+#define MAX_POC 2147483647
+
+#define DPB_DRAW_CLEAR   1
+#define DPB_DRAW_REFS   2
+#define DPB_DRAW_CURRENT 3
+
+/* SPS: sequence parameter set
+ * PPS: picture parameter set
+ * LPS: slice parameter set */
+
+typedef struct{
+  uint8_t aspect_ratio_info;
+  uint8_t aspect_ratio_idc;
+  uint16_t sar_width;
+  uint16_t sar_height;
+  uint8_t colour_desc;
+  uint8_t colour_primaries;
+  uint8_t timing_info;
+  uint32_t num_units_in_tick;
+  uint32_t time_scale;
+} vdec_hw_h264_vui_t;
+
+typedef struct {
+  uint8_t reused;
+  uint8_t profile_idc;
+  uint8_t level_idc;
+  uint8_t sps_id;
+  uint8_t constraint_set0_flag;
+  uint8_t constraint_set1_flag;
+  uint8_t constraint_set2_flag;
+  uint8_t constraint_set3_flag;
+  uint8_t chroma_format_idc;
+  uint8_t separate_colour_plane_flag;
+  uint8_t bit_depth_luma_minus8;
+  uint8_t bit_depth_chroma_minus8;
+  uint8_t qpprime_y_zero_transform_bypass_flag;
+  uint8_t seq_scaling_matrix_present_flag;
+  uint8_t scaling_lists_4x4[6][16];
+  uint8_t scaling_lists_8x8[2][64];
+  uint8_t log2_max_frame_num_minus4;
+  uint8_t pic_order_cnt_type;
+  uint8_t log2_max_pic_order_cnt_lsb_minus4;
+  uint8_t delta_pic_order_always_zero_flag;
+  int32_t offset_for_non_ref_pic;
+  int32_t offset_for_top_to_bottom_field;
+  uint8_t ref_frames_used_in_pic_order_cnt_cycle;
+  int32_t offset_for_ref_frame[256];
+  uint8_t ref_frames_used;
+  uint8_t gaps_in_frame_num_value_allowed_flag;
+  uint8_t pic_width_in_mbs_minus1;
+  uint8_t pic_height_in_map_units_minus1;
+  uint8_t frame_mbs_only_flag;
+  uint8_t mb_adaptive_frame_field_flag;
+  uint8_t direct_8x8_inference_flag;
+  uint8_t frame_cropping_flag;
+  uint16_t frame_crop_left_offset;
+  uint16_t frame_crop_right_offset;
+  uint16_t frame_crop_top_offset;
+  uint16_t frame_crop_bottom_offset;
+  uint8_t vui_parameters_present_flag;
+  vdec_hw_h264_vui_t vui;
+} vdec_hw_h264_sps_t;
+
+#define VDEC_HW_H264_MAX_SLICE_GROUPS 80
+
+typedef struct{
+  uint8_t pps_id;
+  uint8_t sps_id;
+  uint8_t entropy_coding_mode_flag;
+  uint8_t pic_order_present_flag;
+  uint8_t num_ref_idx_l0_active_minus1;
+  uint8_t num_ref_idx_l1_active_minus1;
+  uint8_t weighted_pred_flag;
+  uint8_t weighted_bipred_idc;
+  int8_t pic_init_qp_minus26;
+  int8_t pic_init_qs_minus26;
+  int8_t chroma_qp_index_offset;
+  int8_t second_chroma_qp_index_offset;
+  uint8_t deblocking_filter_control_present_flag;
+  uint8_t constrained_intra_pred_flag;
+  uint8_t redundant_pic_cnt_present_flag;
+  uint8_t transform_8x8_mode_flag;
+  uint8_t pic_scaling_matrix_present_flag;
+  uint8_t pic_scaling_list_present_flag[8];
+  uint8_t scaling_lists_4x4[6][16];
+  uint8_t scaling_lists_8x8[2][64];
+  uint8_t num_slice_groups_minus1;
+  uint8_t slice_group_map_type;
+  uint8_t slice_group_change_direction_flag;
+  uint16_t slice_group_change_rate_minus1;
+  uint16_t pic_size_in_map_units_minus1;
+  struct {
+    uint16_t id;
+    uint16_t run_length_minus1;
+    uint16_t top_left;
+    uint16_t bottom_right;
+  } slice_groups[VDEC_HW_H264_MAX_SLICE_GROUPS];
+} vdec_hw_h264_pps_t;
+
+typedef struct {
+  uint8_t nal_ref_idc;
+  uint8_t nal_unit_type;
+  uint8_t slice_type;
+  uint8_t pps_id;
+  uint16_t frame_num;
+  uint32_t MaxFrameNum;
+  uint8_t field_pic_flag;
+  uint8_t bottom_field_flag;
+  uint16_t idr_pic_id;
+  uint16_t pic_order_cnt_lsb;
+  int32_t delta_pic_order_cnt_bottom;
+  int32_t delta_pic_order_cnt[2];
+  uint8_t redundant_pic_cnt;
+  /* slice_type B */
+  uint8_t direct_spatial_mv_pred_flag;
+  /* slice_type P, SP, B */
+  uint8_t num_ref_idx_active_override_flag;
+  uint8_t num_ref_idx_l0_active_minus1;
+  /* slice type B */
+  uint8_t num_ref_idx_l1_active_minus1;
+  /* pred_weight_table */
+  struct {
+    uint32_t luma_log2_weight_denom;
+    /* chroma_format_idc != 0 */
+    uint32_t chroma_log2_weight_denom;
+    int32_t luma_weight_l0[32];
+    int32_t luma_offset_l0[32];
+    int32_t chroma_weight_l0[32][2];
+    int32_t chroma_offset_l0[32][2];
+    int32_t luma_weight_l1[32];
+    int32_t luma_offset_l1[32];
+    int32_t chroma_weight_l1[32][2];
+    int32_t chroma_offset_l1[32][2];
+  } pred_weight_table;
+} vdec_hw_h264_lps_t;
+
+typedef struct vdec_hw_h264_frame_int_s {
+  vdec_hw_h264_frame_t f;
+
+  struct vdec_hw_h264_frame_int_s *link;
+  int drawn;
+  uint8_t used;
+  uint8_t missing_header;
+  uint8_t drop_pts;
+  uint8_t completed;
+  uint16_t FrameNum;
+  int32_t FrameNumWrap;
+  int32_t PicNum[2];            /* 0:top, 1:bottom */
+  uint8_t is_reference[2];      /* 0:top, 1:bottom, short or long term */
+  uint8_t field_pic_flag;
+  int32_t PicOrderCntMsb;
+  int32_t TopFieldOrderCnt;
+  int32_t BottomFieldOrderCnt;
+  uint16_t pic_order_cnt_lsb;
+  uint8_t mmc5;
+} vdec_hw_h264_frame_int_t;
+
+static __attribute__((format (printf, 3, 4))) int _vdec_hw_h264_dummy_logg (void *user_data,
+  vdec_hw_h264_logg_t level, const char *fmt, ...) {
+  (void)user_data;
+  if (level == VDEC_HW_H264_LOGG_ERR) {
+    va_list args;
+    int n;
+
+    va_start (args, fmt);
+    n = vfprintf (stderr, fmt, args);
+    va_end (args);
+    return n;
+  }
+  return 0;
+}
+
+typedef struct {
+  uint32_t coded_width;
+  uint32_t coded_height;
+  uint64_t video_step; /** << frame duration in pts units */
+  double ratio;
+  double user_ratio;
+  int color_matrix;
+
+  int slices_count;
+  uint32_t slice_mode;
+  const uint8_t *slices_bitstream[MAX_SLICES];
+  uint32_t slices_bytes[MAX_SLICES];
+
+  vdec_hw_h264_sps_t *sps[MAX_SPS];
+  vdec_hw_h264_pps_t *pps[MAX_PPS];
+  vdec_hw_h264_lps_t lps;
+
+  vdec_hw_h264_frame_int_t *dpb[MAX_REF_FRAMES + 1];
+  uint16_t prevFrameNum;
+  uint16_t prevFrameNumOffset;
+  uint8_t prevMMC5;
+
+  int chroma;
+
+  vdec_hw_h264_frame_info_t info;
+
+  struct {                /** << bytestream buf */
+    uint8_t *mem;         /** << memory */
+    uint32_t max;         /** << allocated size, minus a pad reserve */
+    int32_t  nal_unit;    /** << offs of a yet unprocessed nal unit, or -1 */
+    uint32_t read;        /** << parse here */
+    uint32_t write;       /** << append here */
+  } buf;
+
+  int64_t pic_pts;
+
+  bits_reader_t br;
+
+  int reset;
+  int startup_frame;
+
+  /* 0: standard 00 00 01
+   * 1..4: a big endian int of that many bytes telling the unit size */
+  uint8_t nal_unit_prefix;
+} vdec_hw_h264_sequence_t;
+
+struct vdec_hw_h264_s {
+  /* user supolied */
+  __attribute__((format (printf, 3, 4))) int (*logg) (void *user_data, vdec_hw_h264_logg_t level, const char *fmt, ...);
+  void *user_data;
+  int  (*frame_new)    (void *user_data, vdec_hw_h264_frame_t *frame);
+  int  (*frame_render) (void *user_data, vdec_hw_h264_frame_t *frame);
+  int  (*frame_ready)  (void *user_data, vdec_hw_h264_frame_t *frame);
+  void (*frame_delete) (void *user_data, vdec_hw_h264_frame_t *frame);
+
+  vdec_hw_h264_sequence_t seq;
+
+  struct {
+    int sps;
+    int pps;
+    int slices;
+    int frame_ready;
+  } stats;
+
+  int32_t user_frames;
+  uint32_t ref_frames_max;
+  uint32_t ref_frames_used;
+  vdec_hw_h264_frame_int_t frames[MAX_REF_FRAMES + 1];
+
+  uint8_t tempbuf[1 << 16];
+};
+
+static const uint8_t zigzag_4x4[16] = {
+  0, 1, 4, 8,
+  5, 2, 3, 6,
+  9, 12, 13, 10,
+  7, 11, 14, 15
+};
+
+static const uint8_t zigzag_8x8[64] = {
+  0, 1, 8, 16, 9, 2, 3, 10,
+  17, 24, 32, 25, 18, 11, 4, 5,
+  12, 19, 26, 33, 40, 48, 41, 34,
+  27, 20, 13, 6, 7, 14, 21, 28,
+  35, 42, 49, 56, 57, 50, 43, 36,
+  29, 22, 15, 23, 30, 37, 44, 51,
+  58, 59, 52, 45, 38, 31, 39, 46,
+  53, 60, 61, 54, 47, 55, 62, 63
+};
+
+static const uint8_t default_4x4_intra[16] = {
+  6, 13, 13, 20,
+  20, 20, 28, 28,
+  28, 28, 32, 32,
+  32, 37, 37, 42
+};
+
+static const uint8_t default_4x4_inter[16] = {
+  10, 14, 14, 20,
+  20, 20, 24, 24,
+  24, 24, 27, 27,
+  27, 30, 30, 34
+};
+
+static const uint8_t default_8x8_intra[64] = {
+  6, 10, 10, 13, 11, 13, 16, 16,
+  16, 16, 18, 18, 18, 18, 18, 23,
+  23, 23, 23, 23, 23, 25, 25, 25,
+  25, 25, 25, 25, 27, 27, 27, 27,
+  27, 27, 27, 27, 29, 29, 29, 29,
+  29, 29, 29, 31, 31, 31, 31, 31,
+  31, 33, 33, 33, 33, 33, 36, 36,
+  36, 36, 38, 38, 38, 40, 40, 42
+};
+
+static const uint8_t default_8x8_inter[64] = {
+  9, 13, 13, 15, 13, 15, 17, 17,
+  17, 17, 19, 19, 19, 19, 19, 21,
+  21, 21, 21, 21, 21, 22, 22, 22,
+  22, 22, 22, 22, 24, 24, 24, 24,
+  24, 24, 24, 24, 25, 25, 25, 25,
+  25, 25, 25, 27, 27, 27, 27, 27,
+  27, 28, 28, 28, 28, 28, 30, 30,
+  30, 30, 32, 32, 32, 33, 33, 35
+};
+
+/** 00 00 03 foo -> 00 00 foo */
+static uint32_t _vdec_hw_h264_unescape (uint8_t *b, uint32_t len) {
+  uint8_t *p = b, *e = b + len, *q, *a;
+  uint32_t v = 0xffffff00;
+
+  while (p < e) {
+    v = (v + *p) << 8;
+    if (v == 0x00000300)
+      break;
+    p++;
+  }
+  if (p >= e)
+    return p - b;
+
+  q = p;
+  do {
+    int32_t d;
+
+    a = ++p;
+    while (p < e) {
+      v = (v + *p) << 8;
+      if (v == 0x00000300)
+        break;
+      p++;
+    }
+    d = p - a;
+    if (d > 0) {
+      memmove (q, a, d);
+      q += d;
+    }
+  } while (p < e);
+  return q - b;
+}
+
+static void _vdec_hw_h264_frame_free (vdec_hw_h264_t *vdec, vdec_hw_h264_frame_int_t *frame, int zero) {
+  if (frame->link) {
+    if (frame->link->link == frame) {
+      frame->link->link = NULL;
+      frame->f.user_data = NULL;
+    }
+    frame->link = NULL;
+  }
+  if (frame->f.user_data && vdec->frame_delete) {
+    vdec->frame_delete (vdec->user_data, &frame->f);
+    frame->f.user_data = NULL;
+    vdec->user_frames--;
+    if (vdec->user_frames < 0)
+      vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+        LOG_MODULE ": ERROR: too few user frames (%d).\n", (int)vdec->user_frames);
+  }
+  if (zero) {
+    memset (frame, 0, sizeof (*frame));
+    frame->f.vdec = vdec;
+  }
+}
+
+static void _vdec_hw_h264_frame_new (vdec_hw_h264_t *vdec, vdec_hw_h264_frame_int_t *frame) {
+  if (frame->link) {
+    if (frame->link->link == frame)
+      return;
+    frame->link = NULL;
+  }
+  _vdec_hw_h264_frame_free (vdec, frame, 0);
+  if (!frame->f.user_data && vdec->frame_new) {
+    vdec->frame_new (vdec->user_data, &frame->f);
+    frame->drawn = 0;
+    vdec->user_frames++;
+    if (vdec->user_frames > (int32_t)vdec->ref_frames_max + 1)
+      vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+        LOG_MODULE ": ERROR: too many user frames (%d).\n", (int)vdec->user_frames);
+  }
+}
+
+static void _vdec_hw_h264_frame_link (vdec_hw_h264_t *vdec, vdec_hw_h264_frame_int_t *frame, vdec_hw_h264_frame_int_t *to) {
+  (void)vdec;
+  if ((to->link && (to->link != frame))
+    || (to->f.user_data && (to->f.user_data != frame->f.user_data)))
+    _vdec_hw_h264_frame_free (vdec, to, 0);
+  if (frame->link && (frame->link != to))
+    _vdec_hw_h264_frame_free (vdec, frame, 0);
+  *to = *frame;
+  frame->link = to;
+  to->link = frame;
+}
+
+static void _vdec_hw_h264_frame_draw (vdec_hw_h264_t *vdec, vdec_hw_h264_frame_int_t *frame) {
+  if (!frame->drawn && vdec->frame_ready) {
+    vdec->stats.frame_ready++;
+    vdec->frame_ready (vdec->user_data, &frame->f);
+    frame->drawn = 1;
+    if (frame->link)
+      frame->link->drawn = 1;
+  }
+}
+
+/*-------- DPB -------------------------------------------*/
+#if 0
+static void
+dpb_print (vdec_hw_h264_sequence_t * sequence)
+{
+  int i;
+  vdec_hw_h264_frame_int_t *frame;
+  uint32_t sf;
+
+  for (i = 0; i < MAX_REF_FRAMES; i++)
+  {
+    frame = vdec->seq.dpb[i];
+    if (!frame->used)
+      break;
+    vo_frame_t *vo = (vo_frame_t *) frame->videoSurface;
+    vdpau_accel_t *accel;
+    if (vo)
+      accel = (vdpau_accel_t *) vo->accel_data;
+    sf = (vo) ? accel->surface : (uint32_t)-1;
+    fprintf (stderr,
+             "{ i:%d u:%d c:%d pn:%d-%d ir:%d-%d tpoc:%d bpoc:%d sf:%u }\n",
+             i, frame->used, frame->completed, frame->PicNum[0],
+             frame->PicNum[1], frame->is_reference[0], frame->is_reference[1],
+             frame->TopFieldOrderCnt, frame->BottomFieldOrderCnt, sf);
+  }
+}
+#endif
+
+int vdec_hw_h264_zero_pts (vdec_hw_h264_t *vdec) {
+  uint32_t u, n = 0;
+
+  if (!vdec)
+    return 0;
+
+  vdec->seq.reset = VDEC_HW_H264_FRAME_NEW_SEQ;
+
+  for (u = 0; u < vdec->ref_frames_used; u++) {
+    vdec_hw_h264_frame_int_t *frame = vdec->seq.dpb[u];
+
+    if (frame->f.pts)
+      frame->f.pts = 0, frame->drop_pts = 1, n++;
+  }
+  {
+    vdec_hw_h264_frame_int_t *frame = vdec->frames + MAX_REF_FRAMES;
+
+    if (frame->f.pts)
+      frame->f.pts = 0, frame->drop_pts = 1, n++;
+  }
+  return n;
+}
+
+static void _vdec_hw_h264_dpb_reset (vdec_hw_h264_t *vdec) {
+  uint32_t u;
+
+  for (u = 0; u < vdec->ref_frames_used; u++)
+    _vdec_hw_h264_frame_free (vdec, vdec->seq.dpb[u], 1);
+  vdec->ref_frames_used = 0;
+  if (!vdec->frames[MAX_REF_FRAMES].is_reference[0] && !vdec->frames[MAX_REF_FRAMES].is_reference[1])
+    _vdec_hw_h264_frame_free (vdec, vdec->frames + MAX_REF_FRAMES, 0);
+}
+
+static void _vdec_hw_h264_dpb_remove (vdec_hw_h264_t *vdec, uint32_t index) {
+  vdec_hw_h264_frame_int_t *frame = vdec->seq.dpb[index];
+  uint32_t u;
+
+  lprintf ("|||||||||||||||||||||||||||||||||||||||| dbp_remove\n");
+  _vdec_hw_h264_frame_free (vdec, frame, 1);
+  for (u = index + 1; u < vdec->ref_frames_used; u++)
+    vdec->seq.dpb[u - 1] = vdec->seq.dpb[u];
+  vdec->seq.dpb[u - 1] = frame;
+  vdec->ref_frames_used = u - 1;
+}
+
+static vdec_hw_h264_frame_int_t *_vdec_hw_h264_dpb_get_prev_ref (vdec_hw_h264_t *vdec) {
+  return vdec->ref_frames_used > 0 ? vdec->seq.dpb[vdec->ref_frames_used - 1] : NULL;
+}
+
+static void _vdec_hw_h264_dpb_draw_frames (vdec_hw_h264_t *vdec, int32_t curpoc, int draw_mode) {
+  int i, index;
+  int32_t poc, tpoc;
+  vdec_hw_h264_frame_int_t *frame;
+
+  do {
+    index = -1;
+    poc = curpoc;
+    for (i = 0; i < (int)vdec->ref_frames_used; i++) {
+      frame = vdec->seq.dpb[i];
+      tpoc = (frame->TopFieldOrderCnt > frame->BottomFieldOrderCnt)
+           ? frame->TopFieldOrderCnt : frame->BottomFieldOrderCnt;
+      if (!frame->drawn && (tpoc <= poc)) {
+        poc = tpoc;
+        index = i;
+      }
+    }
+    if ((index < 0) || (poc > curpoc))
+      break;
+    //fprintf(stderr,"|||||||||||||||||||||||||||||||||||||||| dpb_draw_frame = %d\n", poc);
+    frame = vdec->seq.dpb[index];
+    //fprintf(stderr,"H264 PTS = %llu\n", frame->pts);
+    _vdec_hw_h264_frame_draw (vdec, frame);
+    if ((draw_mode != DPB_DRAW_CLEAR) && !frame->is_reference[0] && !frame->is_reference[1])
+      _vdec_hw_h264_dpb_remove (vdec, index);
+  } while (index >= 0);
+
+  if (draw_mode == DPB_DRAW_CURRENT) {
+    frame = &vdec->frames[MAX_REF_FRAMES];
+    //fprintf(stderr,"|||||||||||||||||||||||||||||||||||||||| dpb_draw_frame = %d\n", curpoc);
+    _vdec_hw_h264_frame_draw (vdec, frame);
+    _vdec_hw_h264_frame_free (vdec, frame, 1);
+  } else if (draw_mode == DPB_DRAW_CLEAR) {
+    _vdec_hw_h264_dpb_reset (vdec);
+  }
+}
+
+static vdec_hw_h264_frame_int_t *_vdec_hw_h264_dpb_get_PicNum (vdec_hw_h264_t *vdec, int32_t pic_num, int *index) {
+  vdec_hw_h264_frame_int_t *frame;
+  uint32_t i;
+
+  for (i = 0; i < vdec->ref_frames_used; i++) {
+    frame = vdec->seq.dpb[i];
+    if ((frame->PicNum[0] == pic_num) || (frame->PicNum[1] == pic_num)) {
+      *index = i;
+      return frame;
+    }
+  }
+  return NULL;
+}
+
+static void _vdec_hw_h264_dpb_mmc1 (vdec_hw_h264_t *vdec, int32_t picnum) {
+  int index;
+  vdec_hw_h264_frame_int_t *frame = _vdec_hw_h264_dpb_get_PicNum (vdec, picnum, &index);
+
+  lprintf ("_vdec_hw_h264_dpb_mmc1\n");
+
+  if (frame) {
+    frame->is_reference[0] = frame->is_reference[1] = 0;
+    if (frame->drawn)
+      _vdec_hw_h264_dpb_remove (vdec, index);
+    else
+      _vdec_hw_h264_dpb_draw_frames (vdec,
+        (frame->TopFieldOrderCnt > frame->BottomFieldOrderCnt)
+        ? frame->TopFieldOrderCnt : frame->BottomFieldOrderCnt,
+        DPB_DRAW_REFS);
+  }
+}
+
+static vdec_hw_h264_sps_t *_vdec_hw_h264_get_sps (vdec_hw_h264_t *vdec) {
+  vdec_hw_h264_lps_t *lps = &vdec->seq.lps;
+  vdec_hw_h264_pps_t *pps = vdec->seq.pps[lps->pps_id];
+
+  if (!pps)
+    return NULL;
+  return vdec->seq.sps[pps->sps_id];
+}
+
+static void _vdec_hw_h264_dbp_append (vdec_hw_h264_t *vdec, int second_field) {
+  uint32_t i, index = 0, max_refs = vdec->ref_frames_max;
+  int32_t fnw = MAX_POC;
+  vdec_hw_h264_frame_int_t *tmp = NULL, *cur_pic = &vdec->frames[MAX_REF_FRAMES];
+  vdec_hw_h264_sps_t *sps = _vdec_hw_h264_get_sps (vdec);
+
+  if (sps) {
+    max_refs = sps->ref_frames_used ? sps->ref_frames_used : 1;
+    if (max_refs > vdec->ref_frames_max)
+      max_refs = vdec->ref_frames_max;
+  }
+
+  if (second_field) {
+    tmp = _vdec_hw_h264_dpb_get_prev_ref (vdec);
+    if (tmp) {
+      _vdec_hw_h264_frame_link (vdec, cur_pic, tmp);
+    } else {
+      vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+        LOG_MODULE ": no frame to store the second field ?!\n");
+    }
+    return;
+  }
+
+  for (i = 0; i < vdec->ref_frames_used; i++) {
+    if (vdec->seq.dpb[i]->FrameNumWrap < fnw) {
+      fnw = vdec->seq.dpb[i]->FrameNumWrap;
+      index = i;
+    }
+  }
+
+  if (vdec->ref_frames_used >= max_refs) {
+    if (0 /* sps && sps->reused && (max_refs < vdec->ref_frames_max) */) {
+      vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_INFO,
+        LOG_MODULE ": SPS #%d is reused, raising ref frame count from %d to %d.\n",
+        (int)sps->sps_id, (int)max_refs, (int)max_refs + 1);
+      sps->ref_frames_used = ++max_refs;
+    } else {
+      lprintf ("sliding window\n");
+      tmp = vdec->seq.dpb[index];
+      tmp->is_reference[0] = tmp->is_reference[1] = 0;
+      if (tmp->drawn)
+        _vdec_hw_h264_dpb_remove (vdec, index);
+      else
+        _vdec_hw_h264_dpb_draw_frames (vdec,
+          (tmp->TopFieldOrderCnt > tmp->BottomFieldOrderCnt)
+          ? tmp->TopFieldOrderCnt : tmp->BottomFieldOrderCnt,
+          DPB_DRAW_REFS);
+      i = vdec->ref_frames_used;
+    }
+  }
+
+  if (i < max_refs) { /* should always be true */
+    if (cur_pic->field_pic_flag) {
+      _vdec_hw_h264_frame_link (vdec, cur_pic, vdec->seq.dpb[i]);
+    } else {
+      *vdec->seq.dpb[i] = *cur_pic;
+      cur_pic->f.user_data = NULL;
+    }
+    vdec->ref_frames_used = i + 1;
+  } else {
+    vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+      LOG_MODULE ": too many reference frames (%d).\n", i + 1);
+  }
+}
+
+/*--------------------------------------------------------*/
+
+static void _vdec_hw_h264_reset_slices (vdec_hw_h264_t *vdec) {
+  vdec->seq.slices_count = 0;
+  vdec->seq.slice_mode = 0;
+}
+
+static void _vdec_hw_h264_reset_sequence (vdec_hw_h264_t *vdec) {
+  vdec->seq.prevFrameNum = 0;
+  vdec->seq.prevFrameNumOffset = 0;
+  vdec->seq.prevMMC5 = 0;
+
+  vdec->seq.startup_frame = 0;
+  vdec->seq.reset = 0;
+  vdec->seq.chroma = 0;
+  vdec->seq.pic_pts = 0;
+  vdec->seq.buf.write = 0;
+  vdec->seq.buf.read = 0;
+  vdec->seq.buf.nal_unit = -1;
+  _vdec_hw_h264_reset_slices (vdec);
+  _vdec_hw_h264_dpb_reset (vdec);
+  _vdec_hw_h264_frame_free (vdec, vdec->frames + MAX_REF_FRAMES, 1);
+  vdec->seq.reset = VDEC_HW_H264_FRAME_NEW_SEQ;
+}
+
+static void _vdec_hw_h264_set_ratio (vdec_hw_h264_t *vdec, vdec_hw_h264_sps_t *sps) {
+  static const double fixed_ratios[] = {
+    (double)1, /* ASPECT_UNSPECIFIED */
+    (double)1, /* 1/1 */
+    (double)12 / (double)11,
+    (double)10 / (double)11,
+    (double)16 / (double)11,
+    (double)40 / (double)33,
+    (double)24 / (double)11,
+    (double)20 / (double)11,
+    (double)32 / (double)11,
+    (double)80 / (double)33,
+    (double)18 / (double)11,
+    (double)15 / (double)11,
+    (double)64 / (double)33,
+    (double)160 / (double)99,
+    (double)4 / (double)3,
+    (double)3 / (double)2,
+    (double)2 / (double)1,
+    (double)1 /* RESERVED */
+  };
+
+  if (!vdec->seq.coded_height)
+    vdec->seq.coded_height = 1;
+
+  vdec->seq.ratio = (double)vdec->seq.coded_width / (double)vdec->seq.coded_height;
+  if (sps->vui.aspect_ratio_info) {
+    if (sps->vui.aspect_ratio_idc < sizeof (fixed_ratios) / sizeof (fixed_ratios[0])) {
+      vdec->seq.ratio *= fixed_ratios[sps->vui.aspect_ratio_idc];
+    } else if (sps->vui.aspect_ratio_idc == 255) {
+      if (sps->vui.sar_height)
+        vdec->seq.ratio *= (double)sps->vui.sar_width / sps->vui.sar_height;
+    }
+  }
+}
+
+static void parse_scaling_list (bits_reader_t *br, uint8_t *scaling_list, int len, int index) {
+  int last_scale = 8;
+  int next_scale = 8;
+  int32_t delta_scale;
+  uint8_t use_default_scaling_matrix_flag = 0;
+  int i;
+  uint32_t u;
+
+  const uint8_t *zigzag = (len == 64) ? zigzag_8x8 : zigzag_4x4;
+
+  for (i = 0; i < len; i++)
+  {
+    if (next_scale != 0)
+    {
+      delta_scale = bits_exp_se (br);
+      next_scale = (last_scale + delta_scale + 256) % 256;
+      if (i == 0 && next_scale == 0)
+      {
+        use_default_scaling_matrix_flag = 1;
+        break;
+      }
+    }
+    scaling_list[zigzag[i]] = last_scale =
+      (next_scale == 0) ? last_scale : next_scale;
+  }
+
+  if (use_default_scaling_matrix_flag)
+  {
+    switch (index)
+    {
+    case 0:
+    case 1:
+    case 2:
+      {
+        for (u = 0; u < sizeof (default_4x4_intra); u++)
+          scaling_list[zigzag_4x4[u]] = default_4x4_intra[u];
+        break;
+      }
+    case 3:
+    case 4:
+    case 5:
+      {
+        for (u = 0; u < sizeof (default_4x4_inter); u++)
+          scaling_list[zigzag_4x4[u]] = default_4x4_inter[u];
+        break;
+      }
+    case 6:
+      {
+        for (u = 0; u < sizeof (default_8x8_intra); u++)
+          scaling_list[zigzag_8x8[u]] = default_8x8_intra[u];
+        break;
+      }
+    case 7:
+      {
+        for (u = 0; u < sizeof (default_8x8_inter); u++)
+          scaling_list[zigzag_8x8[u]] = default_8x8_inter[u];
+        break;
+      }
+    }
+  }
+}
+
+static void _vdec_hw_h264_scaling_list_fallback_A (uint8_t * scaling_lists_4x4, uint8_t * scaling_lists_8x8, int i) {
+  uint32_t j;
+
+  switch (i) {
+    case 0:
+      for (j = 0; j < sizeof (default_4x4_intra); j++)
+        scaling_lists_4x4[(i * 16) + zigzag_4x4[j]] = default_4x4_intra[j];
+      break;
+    case 3:
+      for (j = 0; j < sizeof (default_4x4_inter); j++)
+        scaling_lists_4x4[(i * 16) + zigzag_4x4[j]] = default_4x4_inter[j];
+      break;
+    case 1:
+    case 2:
+    case 4:
+    case 5:
+      memcpy (&scaling_lists_4x4[i * 16], &scaling_lists_4x4[(i - 1) * 16], 16);
+      break;
+    case 6:
+      for (j = 0; j < sizeof (default_8x8_intra); j++)
+        scaling_lists_8x8[(i - 6) * 64 + zigzag_8x8[j]] = default_8x8_intra[j];
+      break;
+    case 7:
+      for (j = 0; j < sizeof (default_8x8_inter); j++)
+        scaling_lists_8x8[(i - 6) * 64 + zigzag_8x8[j]] = default_8x8_inter[j];
+      break;
+  }
+}
+
+static void _vdec_hw_h264_scaling_list_fallback_B (vdec_hw_h264_sps_t *sps, vdec_hw_h264_pps_t *pps, int i) {
+  switch (i) {
+    case 0:
+    case 3:
+      memcpy (pps->scaling_lists_4x4[i], sps->scaling_lists_4x4[i], sizeof (pps->scaling_lists_4x4[i]));
+      break;
+    case 1:
+    case 2:
+    case 4:
+    case 5:
+      memcpy (pps->scaling_lists_4x4[i], pps->scaling_lists_4x4[i - 1], sizeof (pps->scaling_lists_4x4[i]));
+      break;
+    case 6:
+    case 7:
+      memcpy (pps->scaling_lists_8x8[i - 6], sps->scaling_lists_8x8[i - 6], sizeof (pps->scaling_lists_8x8[i - 6]));
+      break;
+  }
+}
+
+static void _vdec_hw_h264_read_vui (vdec_hw_h264_t *vdec, vdec_hw_h264_vui_t *vui) {
+  bits_reader_t *br = &vdec->seq.br;
+  vdec->seq.color_matrix = 4; /* undefined, mpeg range */
+
+  vui->aspect_ratio_info = bits_read (br, 1);
+  lprintf ("aspect_ratio_info_present_flag = %d\n", (int)vui->aspect_ratio_info);
+  if (vui->aspect_ratio_info) {
+    vui->aspect_ratio_idc = bits_read (br, 8);
+    lprintf ("aspect_ratio_idc = %d\n", (int)vui->aspect_ratio_idc);
+    if (vui->aspect_ratio_idc == 255) {
+      vui->sar_width = bits_read (br, 16);
+      lprintf ("sar_width = %d\n", (int)vui->sar_width);
+      vui->sar_height = bits_read (br, 16);
+      lprintf ("sar_height = %d\n", (int)vui->sar_height);
+    }
+  }
+
+  if (bits_read (br, 1))        /* overscan_info_present_flag */
+    bits_skip (br, 1);          /* overscan_appropriate_falg */
+
+  if (bits_read (br, 1)) {      /* video_signal_type_present_flag */
+    bits_skip (br, 3);          /* video_format */
+    vdec->seq.color_matrix = (vdec->seq.color_matrix & ~1) | bits_read (br, 1);  /*video_full_range_flag */
+    vui->colour_desc = bits_read (br, 1);
+    lprintf ("colour_desc = %d\n", (int)vui->colour_desc);
+    if (vui->colour_desc) {
+      bits_skip (br, 16);        /* colour_primaries, transfer_characteristics */
+      vdec->seq.color_matrix = (vdec->seq.color_matrix & 1) | (bits_read (br, 8) << 1);  /* matrix_coefficients */
+    }
+  }
+
+  if (bits_read (br, 1)) {      /* chroma_loc_info_present_flag */
+    bits_exp_ue (br);           /* chroma_sample_loc_type_top_field */
+    bits_exp_ue (br);           /* chroma_sample_loc_type_bottom_field */
+  }
+
+  vui->timing_info = bits_read (br, 1);
+  lprintf ("timing_info = %d\n", (int)vui->timing_info);
+  if (vui->timing_info) {
+    /* seen (500, (24000 + 0x80000000)) here... */
+    vui->num_units_in_tick = bits_read (br, 32) & 0x7fffffff;
+    lprintf ("num_units_in_tick = %d\n", (int)vui->num_units_in_tick);
+    vui->time_scale = bits_read (br, 32) & 0x7fffffff;
+    lprintf ("time_scale = %d\n", (int)vui->time_scale);
+    if (vui->time_scale > 0) {
+      /* good: 2 * 1001 / 48000. */
+      vdec->seq.video_step = (uint64_t)90000 * 2
+        * vui->num_units_in_tick / vui->time_scale;
+      if (vdec->seq.video_step < 90) {
+        /* bad: 2 * 1 / 60000. seen this once from broken h.264 video usability info (VUI).
+         * VAAPI seems to apply a similar HACK. */
+        vdec->seq.video_step = (uint64_t)90000000 * 2 * vui->num_units_in_tick / vui->time_scale;
+        /* seen 1 / 180000, ignore. */
+        if (vdec->seq.video_step < 1500)
+          vdec->seq.video_step = 0;
+      }
+    }
+  }
+}
+
+static vdec_hw_h264_sps_t *_vdec_hw_h264_read_sps (vdec_hw_h264_t *vdec) {
+  vdec_hw_h264_sps_t tsps, *sps;
+  uint8_t bits;
+  int i;
+
+  memset (&tsps, 0, sizeof (tsps));
+
+  tsps.profile_idc = bits_read (&vdec->seq.br, 8);
+  bits = bits_read (&vdec->seq.br, 8);
+  tsps.constraint_set0_flag = (bits >> 7) & 1;
+  tsps.constraint_set1_flag = (bits >> 6) & 1;
+  tsps.constraint_set2_flag = (bits >> 5) & 1;
+  tsps.constraint_set3_flag = (bits >> 4) & 1;
+  /* skip 4 */
+  tsps.level_idc = bits_read (&vdec->seq.br, 8);
+  tsps.sps_id = bits_exp_ue (&vdec->seq.br);
+  if (tsps.sps_id > 31) {
+    lprintf ("invalid SPS id %d!!\n", (int)tsps.sps_id);
+    return NULL;
+  }
+
+  /* this is read only for now. */
+  tsps.reused = 0;
+
+  memset (&tsps.scaling_lists_4x4, 16, sizeof (tsps.scaling_lists_4x4));
+  memset (&tsps.scaling_lists_8x8, 16, sizeof (tsps.scaling_lists_8x8));
+
+  tsps.chroma_format_idc = 1;
+  tsps.separate_colour_plane_flag = 0;
+  if  (tsps.profile_idc == 100 || tsps.profile_idc == 110
+    || tsps.profile_idc == 122 || tsps.profile_idc == 244
+    || tsps.profile_idc ==  44 || tsps.profile_idc ==  83
+    || tsps.profile_idc ==  86) {
+    tsps.chroma_format_idc = bits_exp_ue (&vdec->seq.br);
+    lprintf ("chroma_format_idc = %d\n", (int)tsps.chroma_format_idc);
+    if (tsps.chroma_format_idc == 3) {
+      tsps.separate_colour_plane_flag = bits_read (&vdec->seq.br, 1);
+      lprintf ("separate_colour_plane_flag = %d\n", (int)tsps.separate_colour_plane_flag);
+    }
+
+    tsps.bit_depth_luma_minus8 = bits_exp_ue (&vdec->seq.br);
+    lprintf ("bit_depth_luma_minus8 = %d\n", (int)tsps.bit_depth_luma_minus8);
+    tsps.bit_depth_chroma_minus8 = bits_exp_ue (&vdec->seq.br);
+    lprintf ("bit_depth_chroma_minus8 = %d\n", (int)tsps.bit_depth_chroma_minus8);
+
+    tsps.qpprime_y_zero_transform_bypass_flag = bits_read (&vdec->seq.br, 1);
+    lprintf ("qpprime_y_zero_transform_bypass_flag = %d\n", (int)tsps.qpprime_y_zero_transform_bypass_flag);
+
+    tsps.seq_scaling_matrix_present_flag = bits_read (&vdec->seq.br, 1);
+    lprintf ("seq_scaling_matrix_present_flag = %d\n", (int)tsps.seq_scaling_matrix_present_flag);
+    if (tsps.seq_scaling_matrix_present_flag) {
+      for (i = 0; i < 8; i++) {
+        int scaling_flag = bits_read (&vdec->seq.br, 1);
+        if (scaling_flag) {
+          if (i < 6)
+            parse_scaling_list (&vdec->seq.br, &tsps.scaling_lists_4x4[i][0], 16, i);
+          else
+            parse_scaling_list (&vdec->seq.br, &tsps.scaling_lists_8x8[i - 6][0], 64, i);
+        } else {
+          _vdec_hw_h264_scaling_list_fallback_A ((uint8_t *)tsps.scaling_lists_4x4, (uint8_t *)tsps.scaling_lists_8x8, i);
+        }
+      }
+    }
+  }
+
+  tsps.log2_max_frame_num_minus4 = bits_exp_ue (&vdec->seq.br);
+  lprintf ("log2_max_frame_num_minus4 = %d\n", (int)tsps.log2_max_frame_num_minus4);
+
+  tsps.pic_order_cnt_type = bits_exp_ue (&vdec->seq.br);
+  lprintf ("pic_order_cnt_type = %d\n", (int)tsps.pic_order_cnt_type);
+  if (tsps.pic_order_cnt_type == 0) {
+    tsps.log2_max_pic_order_cnt_lsb_minus4 = bits_exp_ue (&vdec->seq.br);
+    lprintf ("log2_max_pic_order_cnt_lsb_minus4 = %d\n", (int)tsps.log2_max_pic_order_cnt_lsb_minus4);
+  } else if (tsps.pic_order_cnt_type == 1) {
+    tsps.delta_pic_order_always_zero_flag = bits_read (&vdec->seq.br, 1);
+    lprintf ("delta_pic_order_always_zero_flag = %d\n", (int)tsps.delta_pic_order_always_zero_flag);
+    tsps.offset_for_non_ref_pic = bits_exp_se (&vdec->seq.br);
+    lprintf ("offset_for_non_ref_pic = %d\n", (int)tsps.offset_for_non_ref_pic);
+    tsps.offset_for_top_to_bottom_field = bits_exp_se (&vdec->seq.br);
+    lprintf ("offset_for_top_to_bottom_field = %d\n", (int)tsps.offset_for_top_to_bottom_field);
+    tsps.ref_frames_used_in_pic_order_cnt_cycle = bits_exp_ue (&vdec->seq.br);
+    lprintf ("ref_frames_used_in_pic_order_cnt_cycle = %d\n", (int)tsps.ref_frames_used_in_pic_order_cnt_cycle);
+    for (i = 0; i < (int)tsps.ref_frames_used_in_pic_order_cnt_cycle; i++) {
+      tsps.offset_for_ref_frame[i] = bits_exp_se (&vdec->seq.br);
+      lprintf ("offset_for_ref_frame[%d] = %d\n", i, (int)tsps.offset_for_ref_frame[i]);
+    }
+  }
+
+  tsps.ref_frames_used = bits_exp_ue (&vdec->seq.br);
+  if (tsps.ref_frames_used > 16)
+    tsps.ref_frames_used = 16;
+  lprintf ("ref_frames_used = %d\n", (int)tsps.ref_frames_used);
+
+  tsps.gaps_in_frame_num_value_allowed_flag = bits_read (&vdec->seq.br, 1);
+  lprintf ("gaps_in_frame_num_value_allowed_flag = %d\n", (int)tsps.gaps_in_frame_num_value_allowed_flag);
+
+  tsps.pic_width_in_mbs_minus1 = bits_exp_ue (&vdec->seq.br);
+  lprintf ("pic_width_in_mbs_minus1 = %d\n", (int)tsps.pic_width_in_mbs_minus1);
+  tsps.pic_height_in_map_units_minus1 = bits_exp_ue (&vdec->seq.br);
+  lprintf ("pic_height_in_map_units_minus1 = %d\n", (int)tsps.pic_height_in_map_units_minus1);
+
+  tsps.frame_mbs_only_flag = bits_read (&vdec->seq.br, 1);
+  lprintf ("frame_mbs_only_flag = %d\n", (int)tsps.frame_mbs_only_flag);
+
+  vdec->seq.coded_width = (tsps.pic_width_in_mbs_minus1 + 1) * 16;
+  vdec->seq.coded_height = (2 - tsps.frame_mbs_only_flag) * (tsps.pic_height_in_map_units_minus1 + 1) * 16;
+
+  if (!tsps.frame_mbs_only_flag) {
+    tsps.mb_adaptive_frame_field_flag = bits_read (&vdec->seq.br, 1);
+    lprintf ("mb_adaptive_frame_field_flag = %d\n", (int)tsps.mb_adaptive_frame_field_flag);
+  } else {
+    tsps.mb_adaptive_frame_field_flag = 0;
+  }
+
+  tsps.direct_8x8_inference_flag = bits_read (&vdec->seq.br, 1);
+  lprintf ("direct_8x8_inference_flag = %d\n", (int)tsps.direct_8x8_inference_flag);
+
+  tsps.frame_cropping_flag = bits_read (&vdec->seq.br, 1);
+  lprintf ("frame_cropping_flag = %d\n", (int)tsps.frame_cropping_flag);
+  if (tsps.frame_cropping_flag) {
+    tsps.frame_crop_left_offset = bits_exp_ue (&vdec->seq.br);
+    lprintf ("frame_crop_left_offset = %d\n", (int)tsps.frame_crop_left_offset);
+    tsps.frame_crop_right_offset = bits_exp_ue (&vdec->seq.br);
+    lprintf ("frame_crop_right_offset = %d\n", (int)tsps.frame_crop_right_offset);
+    tsps.frame_crop_top_offset = bits_exp_ue (&vdec->seq.br);
+    lprintf ("frame_crop_top_offset = %d\n", (int)tsps.frame_crop_top_offset);
+    tsps.frame_crop_bottom_offset = bits_exp_ue (&vdec->seq.br);
+    lprintf ("frame_crop_bottom_offset = %d\n", (int)tsps.frame_crop_bottom_offset);
+    vdec->seq.coded_height -= (2 - tsps.frame_mbs_only_flag) * 2 * tsps.frame_crop_bottom_offset;
+  }
+
+  /* XXX? */
+  if (vdec->seq.coded_height == 1088)
+    vdec->seq.coded_height = 1080;
+
+  tsps.vui_parameters_present_flag = bits_read (&vdec->seq.br, 1);
+  lprintf ("vui_parameters_present_flag = %d\n", (int)tsps.vui_parameters_present_flag);
+  if (tsps.vui_parameters_present_flag)
+    _vdec_hw_h264_read_vui (vdec, &tsps.vui);
+  _vdec_hw_h264_set_ratio (vdec, &tsps);
+
+  sps = vdec->seq.sps[tsps.sps_id];
+  if (!sps) {
+    vdec->seq.sps[tsps.sps_id] = sps = malloc  (sizeof (*sps));
+    if (!sps) {
+      vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR, LOG_MODULE ": no memory for SPS #%d.}n", (int)tsps.sps_id);
+      return NULL;
+    }
+    vdec->stats.sps++;
+  } else {
+    sps->reused = 0;
+    if (!memcmp (&tsps, sps, sizeof (tsps)))
+      return sps;
+  }
+  memcpy (sps, &tsps, sizeof (tsps));
+  vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_INFO, LOG_MODULE ": new SPS #%d.\n", (int)tsps.sps_id);
+  return sps;
+}
+
+static vdec_hw_h264_pps_t *_vdec_hw_h264_read_pps (vdec_hw_h264_t *vdec) {
+  vdec_hw_h264_pps_t *pps, tpps;
+  vdec_hw_h264_sps_t *sps;
+  uint32_t more;
+  uint8_t bits;
+
+  memset (&tpps, 0, sizeof (tpps));
+
+  tpps.pps_id = bits_exp_ue (&vdec->seq.br);
+  tpps.sps_id = bits_exp_ue (&vdec->seq.br);
+  if (tpps.sps_id > 31) {
+    lprintf ("referenced SPS #%d does not exist!!\n", (int)tpps.sps_id);
+    return NULL;
+  }
+  sps = vdec->seq.sps[tpps.sps_id];
+  if (!sps) {
+    lprintf ("referenced SPS #%d does not exist!!\n", (int)tpps.sps_id);
+    return NULL;
+  }
+
+  bits = bits_read (&vdec->seq.br, 2);
+  tpps.entropy_coding_mode_flag = (bits >> 1) & 1;
+  tpps.pic_order_present_flag   = (bits >> 0) & 1;
+
+  tpps.num_slice_groups_minus1 = bits_exp_ue (&vdec->seq.br);
+  lprintf ("num_slice_groups_minus1 = %d\n", (int)tpps.num_slice_groups_minus1);
+  if (tpps.num_slice_groups_minus1 > 0) {
+    uint32_t slice_group_id_bits, u, i;
+
+    for (slice_group_id_bits = 0, u = tpps.num_slice_groups_minus1; u; slice_group_id_bits++, u >>= 1) ;
+    u = 0;
+    
+    tpps.slice_group_map_type = bits_exp_ue (&vdec->seq.br);
+    lprintf ("slice_group_map_type = %d\n", (int)slice_group_map_type);
+    switch (tpps.slice_group_map_type) {
+      case 0:
+        for (i = 0; i <= tpps.num_slice_groups_minus1; i++) {
+          tpps.slice_groups[u].run_length_minus1 = bits_exp_ue (&vdec->seq.br);
+          if (u < VDEC_HW_H264_MAX_SLICE_GROUPS - 1)
+            u++;
+        }
+        break;
+      case 2:
+        for (i = 0; i <= tpps.num_slice_groups_minus1; i++) {
+          bits_exp_ue (&vdec->seq.br);
+          bits_exp_ue (&vdec->seq.br);
+        }
+        break;
+      case 3:
+      case 4:
+      case 5:
+        tpps.slice_group_change_direction_flag = bits_read (&vdec->seq.br, 1);
+        tpps.slice_group_change_rate_minus1 = bits_exp_ue (&vdec->seq.br);
+        break;
+      case 6:
+        tpps.pic_size_in_map_units_minus1 = bits_exp_ue (&vdec->seq.br);
+        for (i = 0; i <= tpps.num_slice_groups_minus1; i++) {
+          tpps.slice_groups[u].id = bits_read (&vdec->seq.br, slice_group_id_bits);
+          if (u < VDEC_HW_H264_MAX_SLICE_GROUPS - 1)
+            u++;
+        }
+        break;
+      default: ;
+    }
+  } else {
+    tpps.slice_group_map_type = 0;
+  }
+
+  tpps.num_ref_idx_l0_active_minus1 = bits_exp_ue (&vdec->seq.br) & 31;
+  tpps.num_ref_idx_l1_active_minus1 = bits_exp_ue (&vdec->seq.br) & 31;
+
+  bits = bits_read (&vdec->seq.br, 3);
+  tpps.weighted_pred_flag  = (bits >> 2) & 1;
+  tpps.weighted_bipred_idc = (bits >> 0) & 3;
+
+  tpps.pic_init_qp_minus26 = bits_exp_se (&vdec->seq.br);
+  tpps.pic_init_qs_minus26 = bits_exp_se (&vdec->seq.br);
+  tpps.chroma_qp_index_offset = bits_exp_se (&vdec->seq.br);
+
+  bits = bits_read (&vdec->seq.br, 3);
+  tpps.deblocking_filter_control_present_flag = (bits >> 2) & 1;
+  tpps.constrained_intra_pred_flag = (bits >> 1) & 1;
+  tpps.redundant_pic_cnt_present_flag = (bits >> 0) & 1;
+
+  more = bits_valid_left (&vdec->seq.br);
+  /* no typo, we want at least 2 "1" bits. */
+  if (more > 1) {
+    bits = bits_read (&vdec->seq.br, 2);
+    tpps.transform_8x8_mode_flag = (bits >> 1) & 1;
+    tpps.pic_scaling_matrix_present_flag = (bits >> 0) & 1;
+    if (tpps.pic_scaling_matrix_present_flag) {
+      int i;
+
+      for (i = 0; i < 8; i++) {
+        if ((i < 6) || tpps.transform_8x8_mode_flag)
+          tpps.pic_scaling_list_present_flag[i] = bits_read (&vdec->seq.br, 1);
+        else
+          tpps.pic_scaling_list_present_flag[i] = 0;
+        if (tpps.pic_scaling_list_present_flag[i]) {
+          if (i < 6)
+            parse_scaling_list (&vdec->seq.br, &tpps.scaling_lists_4x4[i][0], 16, i);
+          else
+            parse_scaling_list (&vdec->seq.br, &tpps.scaling_lists_8x8[i - 6][0], 64, i);
+        } else {
+          if (!sps->seq_scaling_matrix_present_flag)
+            _vdec_hw_h264_scaling_list_fallback_A ((uint8_t *)tpps.scaling_lists_4x4, (uint8_t *)tpps.scaling_lists_8x8, i);
+          else
+            _vdec_hw_h264_scaling_list_fallback_B (sps, &tpps, i);
+        }
+      }
+    }
+    tpps.second_chroma_qp_index_offset = bits_exp_se (&vdec->seq.br);
+    lprintf ("second_chroma_qp_index_offset = %d\n", (int)tpps.second_chroma_qp_index_offset);
+  } else {
+    tpps.transform_8x8_mode_flag = 0;
+    tpps.pic_scaling_matrix_present_flag = 0;
+    tpps.second_chroma_qp_index_offset = tpps.chroma_qp_index_offset;
+  }
+
+  pps = vdec->seq.pps[tpps.pps_id];
+  if (!pps) {
+    vdec->seq.pps[tpps.pps_id] = pps = malloc  (sizeof (*pps));
+    if (!pps) {
+      vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR, LOG_MODULE ": no memory for PPS #%d.}n", (int)tpps.pps_id);
+      return NULL;
+    }
+    vdec->stats.pps++;
+  } else {
+    if (!memcmp (&tpps, pps, sizeof (tpps)))
+      return pps;
+  }
+  memcpy (pps, &tpps, sizeof (tpps));
+  vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_INFO, LOG_MODULE ": new PPS #%d.\n", (int)tpps.pps_id);
+  return pps;
+}
+
+static void _vdec_hw_h264_pred_weight_table (vdec_hw_h264_t *vdec,
+  uint32_t slice_type, uint32_t ChromaArrayType, uint32_t l0, uint32_t l1) {
+  uint32_t i;
+
+  vdec->seq.lps.pred_weight_table.luma_log2_weight_denom = bits_exp_ue (&vdec->seq.br);
+  if (ChromaArrayType)
+    vdec->seq.lps.pred_weight_table.chroma_log2_weight_denom = bits_exp_ue (&vdec->seq.br);
+  for (i = 0; i <= l0; i++) {
+    if (bits_read (&vdec->seq.br, 1)) {
+      vdec->seq.lps.pred_weight_table.luma_weight_l0[i] = bits_exp_se (&vdec->seq.br);
+      vdec->seq.lps.pred_weight_table.luma_offset_l0[i] = bits_exp_se (&vdec->seq.br);
+    }
+    if (ChromaArrayType && bits_read (&vdec->seq.br, 1)) {
+      vdec->seq.lps.pred_weight_table.chroma_weight_l0[i][0] = bits_exp_se (&vdec->seq.br);
+      vdec->seq.lps.pred_weight_table.chroma_weight_l0[i][1] = bits_exp_se (&vdec->seq.br);
+      vdec->seq.lps.pred_weight_table.chroma_offset_l0[i][0] = bits_exp_se (&vdec->seq.br);
+      vdec->seq.lps.pred_weight_table.chroma_offset_l0[i][1] = bits_exp_se (&vdec->seq.br);
+    }
+  }
+  if (slice_type == SLICE_TYPE_B) {
+    for (i = 0; i <= l1; i++) {
+      if (bits_read (&vdec->seq.br, 1)) {
+        vdec->seq.lps.pred_weight_table.luma_weight_l1[i] = bits_exp_se (&vdec->seq.br);
+        vdec->seq.lps.pred_weight_table.luma_offset_l1[i] = bits_exp_se (&vdec->seq.br);
+      }
+      if (ChromaArrayType && bits_read (&vdec->seq.br, 1)) {
+        vdec->seq.lps.pred_weight_table.chroma_weight_l1[i][0] = bits_exp_se (&vdec->seq.br);
+        vdec->seq.lps.pred_weight_table.chroma_weight_l1[i][1] = bits_exp_se (&vdec->seq.br);
+        vdec->seq.lps.pred_weight_table.chroma_offset_l1[i][0] = bits_exp_se (&vdec->seq.br);
+        vdec->seq.lps.pred_weight_table.chroma_offset_l1[i][1] = bits_exp_se (&vdec->seq.br);
+      }
+    }
+  }
+}
+
+static void _vdec_hw_h264_ref_pic_list_reordering (vdec_hw_h264_t *vdec) {
+  vdec_hw_h264_lps_t *lps = &vdec->seq.lps;
+
+  if ((lps->slice_type != SLICE_TYPE_I) && (lps->slice_type != SLICE_TYPE_SI)) {
+    if (bits_read (&vdec->seq.br, 1)) {
+      uint32_t tmp /*, diff */;
+      do {
+        tmp = bits_exp_ue (&vdec->seq.br);
+        if (tmp == 0 || tmp == 1)
+          /*diff =*/ bits_exp_ue (&vdec->seq.br);
+        else if (tmp == 2)
+          /*diff =*/ bits_exp_ue (&vdec->seq.br);
+      }
+      while (tmp != 3 && !vdec->seq.br.oflow);
+    }
+  }
+  if (lps->slice_type == SLICE_TYPE_B) {
+    if (bits_read (&vdec->seq.br, 1)) {
+      uint32_t tmp2/*, diff2*/;
+      do {
+        tmp2 = bits_exp_ue (&vdec->seq.br);
+        if (tmp2 == 0 || tmp2 == 1)
+          /*diff2 =*/ bits_exp_ue (&vdec->seq.br);
+        else if (tmp2 == 2)
+          /*diff2 =*/ bits_exp_ue (&vdec->seq.br);
+      }
+      while (tmp2 != 3 && !vdec->seq.br.oflow);
+    }
+  }
+}
+
+static void _vdec_hw_h264_dec_ref_pic_marking (vdec_hw_h264_t *vdec, uint8_t idr) {
+  int32_t pic_num;
+
+  if (idr) {
+#ifdef LOG
+    uint8_t no_output_of_prior_pics_flag = bits_read (&vdec->seq.br, 1);
+    uint8_t long_term_reference_flag = bits_read (&vdec->seq.br, 1);
+    lprintf ("no_output_of_prior_pics_flag = %d\n", (int)no_output_of_prior_pics_flag);
+    lprintf ("long_term_reference_flag = %d\n", (int)long_term_reference_flag);
+#else
+    bits_skip (&vdec->seq.br, 2);
+#endif
+  } else {
+    uint8_t adaptive_ref_pic_marking_mode_flag = bits_read (&vdec->seq.br, 1);
+    lprintf ("adaptive_ref_pic_marking_mode_flag = %d\n", (int)adaptive_ref_pic_marking_mode_flag);
+    if (!adaptive_ref_pic_marking_mode_flag) {
+      if (vdec->frames[MAX_REF_FRAMES].field_pic_flag
+        && (vdec->frames[MAX_REF_FRAMES].completed == PICTURE_DONE)
+        && (vdec->frames[MAX_REF_FRAMES].is_reference[0] || vdec->frames[MAX_REF_FRAMES].is_reference[1])) {
+        vdec->frames[MAX_REF_FRAMES].is_reference[0] = vdec->frames[MAX_REF_FRAMES].is_reference[1] = SHORT_TERM_REF;
+        lprintf ("short_ref marking\n");
+      }
+      // sliding window is always performed in dpb_append()
+    } else {
+      uint8_t memory_management_control_operation;
+      do {
+        memory_management_control_operation = bits_exp_ue (&vdec->seq.br);
+        lprintf ("memory_management_control_operation = %d\n",
+          (int)memory_management_control_operation);
+        if ((memory_management_control_operation == 1)
+          || (memory_management_control_operation == 3)) {
+          uint32_t difference_of_pic_nums_minus1 = bits_exp_ue (&vdec->seq.br);
+          lprintf ("difference_of_pic_nums_minus1 = %d\n", difference_of_pic_nums_minus1);
+          pic_num = vdec->frames[MAX_REF_FRAMES].PicNum[0] - (difference_of_pic_nums_minus1 + 1);
+          _vdec_hw_h264_dpb_mmc1 (vdec, pic_num);
+        }
+        if (memory_management_control_operation == 2) {
+#ifdef LOG
+          uint32_t long_term_pic_num = bits_exp_ue (&vdec->seq.br);
+          lprintf ("long_term_pic_num = %d\n", (int)long_term_pic_num);
+#else
+          bits_exp_ue (&vdec->seq.br);
+#endif
+        }
+        if ((memory_management_control_operation == 3)
+          || (memory_management_control_operation == 6)) {
+#ifdef LOG
+          uint32_t long_term_frame_idx = bits_exp_ue (&vdec->seq.br);
+          lprintf ("long_term_frame_idx = %d\n", (int)long_term_frame_idx);
+#else
+          bits_exp_ue (&vdec->seq.br);
+#endif
+        }
+        if (memory_management_control_operation == 4) {
+#ifdef LOG
+          uint32_t max_long_term_frame_idx_plus1 = bits_exp_ue (&vdec->seq.br);
+          lprintf ("max_long_term_frame_idx_plus1 = %d\n", max_long_term_frame_idx_plus1);
+#else
+          bits_exp_ue (&vdec->seq.br);
+#endif
+        }
+      } while (memory_management_control_operation && !vdec->seq.br.oflow);
+    }
+  }
+}
+
+static void _vdec_hw_h264_slice_header (vdec_hw_h264_t *vdec, uint8_t nal_ref_idc, uint8_t nal_unit_type) {
+  vdec_hw_h264_lps_t *lps = &vdec->seq.lps;
+  vdec_hw_h264_pps_t *pps;
+  vdec_hw_h264_sps_t *sps;
+
+  lps->nal_ref_idc = nal_ref_idc;
+  lps->nal_unit_type = nal_unit_type;
+
+  bits_exp_ue (&vdec->seq.br);  /* first_mb_in_slice */
+  lps->slice_type = bits_exp_ue (&vdec->seq.br) % 5;
+  lprintf ("slice_type = %u\n", lps->slice_type);
+
+  lps->pps_id = bits_exp_ue (&vdec->seq.br);
+  lprintf ("_vdec_hw_h264_read_pps_id = %d\n", (int)lps->pps_id);
+  pps = vdec->seq.pps[lps->pps_id];
+  if (!pps) {
+    vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+      LOG_MODULE ": referenced PPS #%d does not exist!!\n", (int)lps->pps_id);
+    vdec->frames[MAX_REF_FRAMES].missing_header = 1;
+    return;
+  }
+
+  sps = vdec->seq.sps[pps->sps_id];
+  if (!sps) {
+    vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+      LOG_MODULE ": referenced SPS #%d does not exist!!\n", (int)pps->sps_id);
+    vdec->frames[MAX_REF_FRAMES].missing_header = 1;
+    return;
+  }
+
+  if (!vdec->seq.startup_frame && (lps->slice_type == SLICE_TYPE_I) && !vdec->frames[MAX_REF_FRAMES].completed)
+    vdec->seq.startup_frame = 1;
+
+  lprintf ("sps_id = %d\n", (int)pps->sps_id);
+  if (sps->separate_colour_plane_flag)
+    bits_read (&vdec->seq.br, 2);       /* colour_plane_id */
+
+  lps->frame_num = bits_read (&vdec->seq.br, sps->log2_max_frame_num_minus4 + 4);
+  lprintf ("frame_num = %d\n", (int)lps->frame_num);
+  lps->MaxFrameNum = 1 << (sps->log2_max_frame_num_minus4 + 4);
+
+  lps->field_pic_flag = lps->bottom_field_flag = lps->delta_pic_order_cnt_bottom = 0;
+  lps->delta_pic_order_cnt[0] = lps->delta_pic_order_cnt[1] = 0;
+
+  if (!sps->frame_mbs_only_flag) {
+    lps->field_pic_flag = bits_read (&vdec->seq.br, 1);
+    lprintf ("field_pic_flag = %d\n", (int)lps->field_pic_flag);
+    if (lps->field_pic_flag) {
+      lps->bottom_field_flag = bits_read (&vdec->seq.br, 1);
+      lprintf ("bottom_field_flag = %d\n", (int)lps->bottom_field_flag);
+    }
+  }
+  if (nal_unit_type == NAL_SLICE_IDR) {
+    lps->idr_pic_id = bits_exp_ue (&vdec->seq.br);
+    lprintf ("idr_pic_id = %d\n", (int)lps->idr_pic_id);
+  }
+  if (sps->pic_order_cnt_type == 0) {
+    lps->pic_order_cnt_lsb = bits_read (&vdec->seq.br, sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+    lprintf ("pic_order_cnt_lsb = %d\n", (int)lps->pic_order_cnt_lsb);
+    if (pps->pic_order_present_flag && !lps->field_pic_flag) {
+      lps->delta_pic_order_cnt_bottom = bits_exp_se (&vdec->seq.br);
+      lprintf ("delta_pic_order_cnt_bottom = %d\n", (int)lps->delta_pic_order_cnt_bottom);
+    }
+  }
+  if ((sps->pic_order_cnt_type == 1) && !sps->delta_pic_order_always_zero_flag) {
+    lps->delta_pic_order_cnt[0] = bits_exp_se (&vdec->seq.br);
+    lprintf ("delta_pic_order_cnt[0] = %d\n", (int)lps->delta_pic_order_cnt[0]);
+    if (pps->pic_order_present_flag && !lps->field_pic_flag) {
+      lps->delta_pic_order_cnt[1] = bits_exp_se (&vdec->seq.br);
+      lprintf ("delta_pic_order_cnt[1] = %d\n", (int)lps->delta_pic_order_cnt[1]);
+    }
+  }
+  if (pps->redundant_pic_cnt_present_flag) {
+    lps->redundant_pic_cnt = bits_exp_ue (&vdec->seq.br);
+    lprintf ("redundant_pic_cnt = %d\n", (int)lps->redundant_pic_cnt);
+  }
+  if (lps->slice_type == SLICE_TYPE_B)
+    bits_skip (&vdec->seq.br, 1);       /* direct_spatial_mv_pred_flag */
+
+  lps->num_ref_idx_l0_active_minus1 = pps->num_ref_idx_l0_active_minus1;
+  lps->num_ref_idx_l1_active_minus1 = pps->num_ref_idx_l1_active_minus1;
+
+  if ((lps->slice_type == SLICE_TYPE_P) || (lps->slice_type == SLICE_TYPE_SP) || (lps->slice_type == SLICE_TYPE_B)) {
+    if (bits_read (&vdec->seq.br, 1)) {
+      lprintf ("num_ref_idx_active_override_flag = 1\n");
+      lps->num_ref_idx_l0_active_minus1 = bits_exp_ue (&vdec->seq.br) & 31;
+      if (lps->slice_type == SLICE_TYPE_B)
+        lps->num_ref_idx_l1_active_minus1 = bits_exp_ue (&vdec->seq.br);
+      lprintf ("num_ref_idx_l0_active_minus1 = %d\n", (int)lps->num_ref_idx_l0_active_minus1);
+      lprintf ("num_ref_idx_l1_active_minus1 = %d\n", (int)lps->num_ref_idx_l1_active_minus1);
+    }
+  }
+}
+
+static void _vdec_hw_h264_slice_header_post (vdec_hw_h264_t *vdec) {
+  vdec_hw_h264_lps_t *lps = &vdec->seq.lps;
+  vdec_hw_h264_pps_t *pps;
+  vdec_hw_h264_sps_t *sps;
+
+  if (!lps->nal_ref_idc)
+    return;
+
+  pps = vdec->seq.pps[lps->pps_id];
+  sps = vdec->seq.sps[pps->sps_id];
+
+  if ((pps->weighted_pred_flag && ((lps->slice_type == SLICE_TYPE_P) || (lps->slice_type == SLICE_TYPE_SP)))
+    || ((pps->weighted_bipred_idc == 1) && (lps->slice_type == SLICE_TYPE_B))) {
+    uint8_t chroma = (sps->separate_colour_plane_flag) ? 0 : sps->chroma_format_idc;
+
+    _vdec_hw_h264_pred_weight_table (vdec, lps->slice_type, chroma,
+      lps->num_ref_idx_l0_active_minus1, lps->num_ref_idx_l1_active_minus1);
+  }
+
+  _vdec_hw_h264_dec_ref_pic_marking (vdec, (lps->nal_unit_type == 5) ? 1 : 0);
+}
+
+static void _vdec_hw_h264_decode_poc (vdec_hw_h264_t *vdec) {
+  vdec_hw_h264_lps_t *lps = &vdec->seq.lps;
+  vdec_hw_h264_pps_t *pps = vdec->seq.pps[lps->pps_id];
+  vdec_hw_h264_sps_t *sps = vdec->seq.sps[pps->sps_id];
+  int parity = lps->bottom_field_flag ? 1 : 0;
+
+  vdec->frames[MAX_REF_FRAMES].used = 1;
+  vdec->frames[MAX_REF_FRAMES].FrameNum = lps->frame_num;
+  vdec->frames[MAX_REF_FRAMES].is_reference[parity] = lps->nal_ref_idc;
+  vdec->frames[MAX_REF_FRAMES].field_pic_flag = lps->field_pic_flag;
+
+  if (lps->field_pic_flag) {
+    if (!vdec->frames[MAX_REF_FRAMES].completed)
+      vdec->frames[MAX_REF_FRAMES].f.top_field_first = !parity;
+    vdec->frames[MAX_REF_FRAMES].completed |= (parity ? PICTURE_BOTTOM_DONE : PICTURE_TOP_DONE);
+  } else {
+    vdec->frames[MAX_REF_FRAMES].is_reference[!parity] = vdec->frames[MAX_REF_FRAMES].is_reference[parity];
+    vdec->frames[MAX_REF_FRAMES].completed = PICTURE_DONE;
+  }
+
+  if (sps->pic_order_cnt_type == 0) {
+    vdec_hw_h264_frame_int_t *prev_frame = _vdec_hw_h264_dpb_get_prev_ref (vdec);
+    int32_t prevPicOrderCntMsb, prevPicOrderCntLsb;
+    uint32_t MaxPicOrderCntLsb = 1 << (sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+
+    vdec->frames[MAX_REF_FRAMES].pic_order_cnt_lsb = lps->pic_order_cnt_lsb;
+    vdec->frames[MAX_REF_FRAMES].f.top_field_first = (lps->delta_pic_order_cnt_bottom < 0) ? 0 : 1;
+
+    if (!prev_frame) {
+      vdec->frames[MAX_REF_FRAMES].PicOrderCntMsb = vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt =
+        vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt = 0;
+      return;
+    }
+    if (lps->nal_unit_type == NAL_SLICE_IDR) {
+      prevPicOrderCntMsb = prevPicOrderCntLsb = 0;
+    } else if (prev_frame->mmc5) {
+      if (!lps->bottom_field_flag) {
+        prevPicOrderCntMsb = 0;
+        prevPicOrderCntLsb = prev_frame->TopFieldOrderCnt;
+      } else {
+        prevPicOrderCntMsb = prevPicOrderCntLsb = 0;
+      }
+    } else {
+      prevPicOrderCntMsb = prev_frame->PicOrderCntMsb;
+      prevPicOrderCntLsb = prev_frame->pic_order_cnt_lsb;
+    }
+
+    if ((lps->pic_order_cnt_lsb < prevPicOrderCntLsb)
+      && ((prevPicOrderCntLsb - lps->pic_order_cnt_lsb) >= (int32_t)(MaxPicOrderCntLsb / 2)))
+      vdec->frames[MAX_REF_FRAMES].PicOrderCntMsb = prevPicOrderCntMsb + MaxPicOrderCntLsb;
+    else if ((lps->pic_order_cnt_lsb > prevPicOrderCntLsb)
+      && ((lps->pic_order_cnt_lsb - prevPicOrderCntLsb) > (int32_t)(MaxPicOrderCntLsb / 2)))
+      vdec->frames[MAX_REF_FRAMES].PicOrderCntMsb = prevPicOrderCntMsb - MaxPicOrderCntLsb;
+    else
+      vdec->frames[MAX_REF_FRAMES].PicOrderCntMsb = prevPicOrderCntMsb;
+
+    if (!lps->field_pic_flag) {
+      vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt =
+        vdec->frames[MAX_REF_FRAMES].PicOrderCntMsb + lps->pic_order_cnt_lsb;
+      vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt =
+        vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt + lps->delta_pic_order_cnt_bottom;
+    } else {
+      if (lps->bottom_field_flag)
+        vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt =
+          vdec->frames[MAX_REF_FRAMES].PicOrderCntMsb + lps->pic_order_cnt_lsb;
+      else
+        vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt =
+          vdec->frames[MAX_REF_FRAMES].PicOrderCntMsb + lps->pic_order_cnt_lsb;
+    }
+  } else {
+    int16_t FrameNumOffset, prevFrameNumOffset;
+    uint16_t MaxFrameNum = 1 << (sps->log2_max_frame_num_minus4 + 4);
+
+    if (lps->nal_unit_type == NAL_SLICE_IDR) {
+      FrameNumOffset = 0;
+    } else {
+      if (vdec->seq.prevMMC5)
+        prevFrameNumOffset = 0;
+      else
+        prevFrameNumOffset = vdec->seq.prevFrameNumOffset;
+
+      if (vdec->seq.prevFrameNum > lps->frame_num)
+        FrameNumOffset = prevFrameNumOffset + MaxFrameNum;
+      else
+        FrameNumOffset = prevFrameNumOffset;
+    }
+
+    if (sps->pic_order_cnt_type == 1) {
+      int16_t absFrameNum = 0, picOrderCntCycleCnt = 0,
+        frameNumInPicOrderCntCycle = 0, expectedDeltaPerPicOrderCntCycle = 0, expectedPicOrderCnt = 0;
+      int i;
+
+      if (sps->ref_frames_used_in_pic_order_cnt_cycle)
+        absFrameNum = FrameNumOffset + lps->frame_num;
+      if (!lps->nal_ref_idc && (absFrameNum > 0))
+        --absFrameNum;
+
+      for (i = 0; i < sps->ref_frames_used_in_pic_order_cnt_cycle; i++)
+        expectedDeltaPerPicOrderCntCycle += sps->offset_for_ref_frame[i];
+
+      if (absFrameNum > 0) {
+        picOrderCntCycleCnt = (absFrameNum - 1) / sps->ref_frames_used_in_pic_order_cnt_cycle;
+        frameNumInPicOrderCntCycle = (absFrameNum - 1) % sps->ref_frames_used_in_pic_order_cnt_cycle;
+        expectedPicOrderCnt = picOrderCntCycleCnt * expectedDeltaPerPicOrderCntCycle;
+        for (i = 0; i < frameNumInPicOrderCntCycle; i++)
+          expectedPicOrderCnt += sps->offset_for_ref_frame[i];
+      }
+      if (!lps->nal_ref_idc)
+        expectedPicOrderCnt += sps->offset_for_non_ref_pic;
+
+      if (!lps->field_pic_flag) {
+        vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt =
+          expectedPicOrderCnt + lps->delta_pic_order_cnt[0];
+        vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt =
+          vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt + sps->offset_for_top_to_bottom_field +
+          lps->delta_pic_order_cnt[1];
+      }
+      else if (!lps->bottom_field_flag)
+        vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt =
+          expectedPicOrderCnt + lps->delta_pic_order_cnt[0];
+      else
+        vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt =
+          expectedPicOrderCnt + sps->offset_for_top_to_bottom_field +
+          lps->delta_pic_order_cnt[1];
+    } else {
+      int32_t tmpPicOrderCnt;
+
+      if (lps->nal_unit_type == NAL_SLICE_IDR)
+        tmpPicOrderCnt = 0;
+      else if (!lps->nal_ref_idc)
+        tmpPicOrderCnt = 2 * (FrameNumOffset + lps->frame_num) - 1;
+      else
+        tmpPicOrderCnt = 2 * (FrameNumOffset + lps->frame_num);
+
+      if (!lps->field_pic_flag)
+        vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt = vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt = tmpPicOrderCnt;
+      else if (lps->bottom_field_flag)
+        vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt = tmpPicOrderCnt;
+      else
+        vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt = tmpPicOrderCnt;
+    }
+    vdec->seq.prevFrameNum = vdec->frames[MAX_REF_FRAMES].FrameNum;
+    vdec->seq.prevFrameNumOffset = FrameNumOffset;
+  }
+
+  if (vdec->frames[MAX_REF_FRAMES].completed < PICTURE_DONE) {
+    if (lps->bottom_field_flag)
+      vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt = vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt;
+    else
+      vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt = vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt;
+  }
+}
+
+static void _vdec_hw_h264_decode_picnum (vdec_hw_h264_t *vdec) {
+  vdec_hw_h264_lps_t *lps = &vdec->seq.lps;
+  vdec_hw_h264_frame_int_t *frame;
+  int parity = lps->bottom_field_flag ? 1 : 0;
+  uint32_t i;
+
+  frame = &vdec->frames[MAX_REF_FRAMES];
+  if (!frame->field_pic_flag)
+    frame->PicNum[0] = frame->FrameNum;
+  else
+    frame->PicNum[parity] = 2 * frame->FrameNum + 1;
+
+  for (i = 0; i < vdec->ref_frames_used; i++) {
+    frame = vdec->seq.dpb[i];
+    if (frame->FrameNum > vdec->frames[MAX_REF_FRAMES].FrameNum)
+      frame->FrameNumWrap = frame->FrameNum - lps->MaxFrameNum;
+    else
+      frame->FrameNumWrap = frame->FrameNum;
+
+    if (!lps->field_pic_flag) {
+      frame->PicNum[0] = frame->PicNum[1] = frame->FrameNumWrap;
+    } else {
+      frame->PicNum[0] = 2 * frame->FrameNumWrap + (parity ? 0 : 1);
+      frame->PicNum[1] = 2 * frame->FrameNumWrap + (parity ? 1 : 0);
+    }
+  }
+}
+
+static int _vdec_hw_h264_check_ref_list (vdec_hw_h264_t *vdec) {
+  int i, j, bad_frame = 0;
+  vdec_hw_h264_frame_int_t *frame;
+  vdec_hw_h264_lps_t *lps = &vdec->seq.lps;
+  vdec_hw_h264_pps_t *pps = vdec->seq.pps[lps->pps_id];
+  vdec_hw_h264_sps_t *sps = vdec->seq.sps[pps->sps_id];
+  int prefs = 0;
+  int brefs = 0;
+  int poc, curpoc;
+  int fps;
+
+  // int fps = (double)sps->vui.time_scale / (double)sps->vui.num_units_in_tick / ( 2 - lps->field_pic_flag );
+  fps = (1 + lps->field_pic_flag) * 2 * sps->ref_frames_used;
+
+  if (vdec->seq.startup_frame >= fps)
+    return 0;
+
+  curpoc =
+    (vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt > vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt)
+    ? vdec->frames[MAX_REF_FRAMES].TopFieldOrderCnt : vdec->frames[MAX_REF_FRAMES].BottomFieldOrderCnt;
+
+  for (i = vdec->ref_frames_used - 1; i >= 0; i--) {
+    frame = vdec->seq.dpb[i];
+    poc = (frame->TopFieldOrderCnt > frame->BottomFieldOrderCnt)
+        ? frame->TopFieldOrderCnt : frame->BottomFieldOrderCnt;
+    if (vdec->frames[MAX_REF_FRAMES].field_pic_flag) {
+      if (!frame->f.bad_frame) {
+        for (j = 0; j < 2; j++) {
+          if (frame->is_reference[j]) {
+            if (poc <= curpoc)
+              ++prefs;
+            else
+              ++brefs;
+          }
+        }
+      }
+    } else {
+      if (!frame->f.bad_frame) {
+        if (poc <= curpoc)
+          ++prefs;
+        else
+          ++brefs;
+      }
+    }
+  }
+
+  if (lps->slice_type != SLICE_TYPE_I) {
+    if (prefs < (int)(lps->num_ref_idx_l0_active_minus1 + 1))
+      bad_frame = 1;
+    if (lps->slice_type == SLICE_TYPE_B) {
+      if (brefs < (int)(lps->num_ref_idx_l1_active_minus1 + 1))
+        bad_frame = 1;
+    }
+  }
+
+  if (bad_frame) {
+    vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+      LOG_MODULE ": Missing refframes, dropping. nrf=%d lo=%d prefs=%d l1=%d brefs=%d type=%d (%d fps)\n",
+        (int)sps->ref_frames_used, (int)lps->num_ref_idx_l0_active_minus1 + 1, (int)prefs,
+        (int)lps->num_ref_idx_l1_active_minus1 + 1, (int)brefs, (int)lps->slice_type, fps);
+  }
+/*
+  else {
+    vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_DEBUG,
+        LOG_MODULE ": GOOD ! nrf=%d lo=%d prefs=%d l1=%d brefs=%d type=%d (%d fps)\n",
+        (int)sps->ref_frames_used, (int)lps->num_ref_idx_l0_active_minus1 + 1, (int)prefs,
+        (int)lps->num_ref_idx_l1_active_minus1 + 1, (int)brefs, lps->slice_type, fps );
+  ]
+*/
+  if (vdec->frames[MAX_REF_FRAMES].is_reference[0] || vdec->frames[MAX_REF_FRAMES].is_reference[1])
+    ++vdec->seq.startup_frame;
+
+  return bad_frame;
+}
+
+static void _vdec_hw_h264_render (vdec_hw_h264_t *vdec, int bad_frame) {
+  int i, j;
+  vdec_hw_h264_frame_int_t *frame;
+  vdec_hw_h264_sps_t *sps;
+  vdec_hw_h264_pps_t *pps;
+  vdec_hw_h264_lps_t *lps;
+
+  frame = vdec->frames + MAX_REF_FRAMES;
+
+  frame->f.width        = vdec->seq.coded_width;
+  frame->f.height       = vdec->seq.coded_height;
+  frame->f.duration     = vdec->seq.video_step;
+  frame->f.ratio        = vdec->seq.user_ratio > 0.001 ? vdec->seq.user_ratio : vdec->seq.ratio;
+  frame->f.color_matrix = vdec->seq.color_matrix;
+  frame->f.flags        = VDEC_HW_H264_FRAME_TOP_FIELD | VDEC_HW_H264_FRAME_BOTTOM_FIELD | vdec->seq.reset;
+  if (frame->completed == PICTURE_DONE) {
+    frame->f.pts = vdec->seq.pic_pts;
+    vdec->seq.pic_pts = 0;
+  }
+  if (frame->drop_pts)
+    frame->f.pts = 0;
+  frame->f.bad_frame = bad_frame;
+
+  lps = &vdec->seq.lps;
+  pps = vdec->seq.pps[lps->pps_id];
+  if (!pps)
+    return;
+  sps = vdec->seq.sps[pps->sps_id];
+  if (!sps)
+    return;
+
+  frame->f.profile = sps->profile_idc;
+  frame->f.level   = sps->level_idc;
+  frame->f.num_ref_frames = sps->ref_frames_used;
+  if (sps->frame_mbs_only_flag)
+    frame->f.progressive_frame = -1;
+
+  if (!frame->field_pic_flag || (frame->completed < PICTURE_DONE)) {
+    _vdec_hw_h264_frame_new (vdec, frame);
+    vdec->seq.reset = 0;
+  }
+
+  vdec->seq.info.field_order_cnt[0] = frame->TopFieldOrderCnt;
+  vdec->seq.info.field_order_cnt[1] = frame->BottomFieldOrderCnt;
+
+  vdec->seq.info.is_reference = lps->nal_ref_idc ? 1 : 0;
+  vdec->seq.info.frame_num = lps->frame_num;
+  vdec->seq.info.field_pic_flag = lps->field_pic_flag;
+  vdec->seq.info.bottom_field_flag = lps->bottom_field_flag;
+  vdec->seq.info.num_ref_frames = sps->ref_frames_used;
+  vdec->seq.info.gaps_in_frame_num_value_allowed_flag = sps->gaps_in_frame_num_value_allowed_flag;
+  vdec->seq.info.mb_adaptive_frame_field_flag = sps->mb_adaptive_frame_field_flag && !lps->field_pic_flag;
+  vdec->seq.info.constrained_intra_pred_flag = pps->constrained_intra_pred_flag;
+  vdec->seq.info.weighted_pred_flag = pps->weighted_pred_flag;
+  vdec->seq.info.weighted_bipred_idc = pps->weighted_bipred_idc;
+  vdec->seq.info.frame_mbs_only_flag = sps->frame_mbs_only_flag;
+  vdec->seq.info.transform_8x8_mode_flag = pps->transform_8x8_mode_flag;
+  vdec->seq.info.bit_depth_luma_minus8 = sps->bit_depth_luma_minus8;
+  vdec->seq.info.bit_depth_chroma_minus8 = sps->bit_depth_chroma_minus8;
+  vdec->seq.info.chroma_format_idc = sps->chroma_format_idc;
+  vdec->seq.info.separate_colour_plane_flag = sps->separate_colour_plane_flag;
+  vdec->seq.info.chroma_qp_index_offset = pps->chroma_qp_index_offset;
+  vdec->seq.info.second_chroma_qp_index_offset = pps->second_chroma_qp_index_offset;
+  vdec->seq.info.pic_init_qp_minus26 = pps->pic_init_qp_minus26;
+  vdec->seq.info.pic_init_qs_minus26 = pps->pic_init_qs_minus26;
+  vdec->seq.info.num_ref_idx_l0_active_minus1 = pps->num_ref_idx_l0_active_minus1;
+  vdec->seq.info.num_ref_idx_l1_active_minus1 = pps->num_ref_idx_l1_active_minus1;
+  vdec->seq.info.log2_max_frame_num_minus4 = sps->log2_max_frame_num_minus4;
+  vdec->seq.info.pic_order_cnt_type = sps->pic_order_cnt_type;
+  vdec->seq.info.log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_pic_order_cnt_lsb_minus4;
+  vdec->seq.info.delta_pic_order_always_zero_flag = sps->delta_pic_order_always_zero_flag;
+  vdec->seq.info.direct_8x8_inference_flag = sps->direct_8x8_inference_flag;
+  vdec->seq.info.entropy_coding_mode_flag = pps->entropy_coding_mode_flag;
+  vdec->seq.info.pic_order_present_flag = pps->pic_order_present_flag;
+  vdec->seq.info.deblocking_filter_control_present_flag = pps->deblocking_filter_control_present_flag;
+  vdec->seq.info.redundant_pic_cnt_present_flag = pps->redundant_pic_cnt_present_flag;
+
+  vdec->seq.info.num_slice_groups_minus1 = pps->num_slice_groups_minus1;
+  vdec->seq.info.slice_group_map_type = pps->slice_group_map_type;
+
+  vdec->seq.info.slice_count = vdec->seq.slices_count;
+  vdec->seq.info.slices_bitstream = (const uint8_t * const *)vdec->seq.slices_bitstream;
+  vdec->seq.info.slices_bytes = (const uint32_t *)vdec->seq.slices_bytes;
+
+  if (!pps->pic_scaling_matrix_present_flag) {
+    memcpy (vdec->seq.info.scaling_lists_4x4, sps->scaling_lists_4x4, sizeof (vdec->seq.info.scaling_lists_4x4));
+    memcpy (vdec->seq.info.scaling_lists_8x8, sps->scaling_lists_8x8, sizeof (vdec->seq.info.scaling_lists_8x8));
+  } else {
+    memcpy (vdec->seq.info.scaling_lists_4x4, pps->scaling_lists_4x4, sizeof (vdec->seq.info.scaling_lists_4x4));
+    memcpy (vdec->seq.info.scaling_lists_8x8, pps->scaling_lists_8x8, sizeof (vdec->seq.info.scaling_lists_8x8));
+  }
+
+  for (i = vdec->ref_frames_used - 1, j = 0; i >= 0; i--, j++) {
+    vdec_hw_h264_info_ref_frame_t *ref = vdec->seq.info.referenceFrames + j;
+    vdec_hw_h264_frame_int_t *rf = vdec->seq.dpb[i];
+
+    ref->frame = &rf->f;
+    ref->is_long_term = 0;
+    ref->frame_idx = rf->FrameNum;
+    ref->top_is_reference = rf->is_reference[0] ? 1 : 0;
+    ref->bottom_is_reference = rf->is_reference[1] ? 1 : 0;
+    ref->field_order_cnt[0] = rf->TopFieldOrderCnt;
+    ref->field_order_cnt[1] = rf->BottomFieldOrderCnt;
+  }
+  for (; j < MAX_REF_FRAMES; j++) {
+    vdec_hw_h264_info_ref_frame_t *ref = vdec->seq.info.referenceFrames + j;
+
+    ref->frame = NULL;
+    ref->is_long_term = 0;
+    ref->frame_idx = 0;
+    ref->top_is_reference = 0;
+    ref->bottom_is_reference = 0;
+    ref->field_order_cnt[0] = 0;
+    ref->field_order_cnt[1] = 0;
+  }
+
+  frame->f.info = &vdec->seq.info;
+  if (vdec->frame_render)
+    vdec->frame_render (vdec->user_data, &frame->f);
+  frame->f.info = NULL;
+}
+
+static void _vdec_hw_h264_decode_picture (vdec_hw_h264_t *vdec) {
+  vdec_hw_h264_frame_int_t *cur_frame = &vdec->frames[MAX_REF_FRAMES];
+  vdec_hw_h264_lps_t *lps = &vdec->seq.lps;
+
+  if (cur_frame->missing_header || !vdec->seq.startup_frame) {
+    _vdec_hw_h264_frame_free (vdec, cur_frame, 1);
+    lprintf ("MISSING_HEADER or !startup_frame\n\n");
+    return;
+  }
+
+  if (cur_frame->completed && cur_frame->field_pic_flag) {
+    int wrong_field = 0;
+    if ((lps->frame_num != cur_frame->FrameNum)
+      || (lps->bottom_field_flag && (cur_frame->completed == PICTURE_BOTTOM_DONE))
+      || (!lps->bottom_field_flag && (cur_frame->completed == PICTURE_TOP_DONE))
+      || !lps->field_pic_flag) {
+      wrong_field = 1;
+    }
+    if (wrong_field) {
+      fprintf (stderr, "vdpau_h264_alter : Wrong field, skipping.\n");
+      _vdec_hw_h264_frame_free (vdec, cur_frame, 1);
+      _vdec_hw_h264_dpb_reset (vdec);
+      cur_frame->missing_header = 1;
+      vdec->seq.startup_frame = 0;
+      return;
+    }
+  }
+
+  /* picture decoding */
+  _vdec_hw_h264_decode_poc (vdec);
+  lprintf ("TopFieldOrderCnt = %d - BottomFieldOrderCnt = %d\n",
+    cur_frame->TopFieldOrderCnt, cur_frame->BottomFieldOrderCnt);
+  if (lps->nal_unit_type == 5) {
+    _vdec_hw_h264_dpb_draw_frames (vdec, MAX_POC, DPB_DRAW_CLEAR);
+    vdec->seq.startup_frame = START_IDR_FLAG;
+  }
+  _vdec_hw_h264_decode_picnum (vdec);
+  _vdec_hw_h264_ref_pic_list_reordering (vdec);
+  lprintf ("............................. slices_count = %d\n", vdec->seq.slices_count);
+
+  _vdec_hw_h264_render (vdec, _vdec_hw_h264_check_ref_list (vdec));
+
+  /* _vdec_hw_h264_dec_ref_pic_marking */
+  _vdec_hw_h264_slice_header_post (vdec);
+
+  if (!cur_frame->is_reference[0] && !cur_frame->is_reference[1]) {
+    if (cur_frame->completed == PICTURE_DONE) {
+      _vdec_hw_h264_dpb_draw_frames (vdec,
+        (cur_frame->TopFieldOrderCnt > cur_frame->BottomFieldOrderCnt)
+        ? cur_frame->TopFieldOrderCnt : cur_frame->BottomFieldOrderCnt,
+        DPB_DRAW_CURRENT);
+    }
+  } else {
+    if (vdec->seq.sps[vdec->seq.pps[lps->pps_id]->sps_id]->pic_order_cnt_type == 2)
+      _vdec_hw_h264_dpb_draw_frames (vdec,
+        (cur_frame->TopFieldOrderCnt > cur_frame->BottomFieldOrderCnt)
+        ? cur_frame->TopFieldOrderCnt : cur_frame->BottomFieldOrderCnt,
+        DPB_DRAW_REFS);
+    _vdec_hw_h264_dbp_append (vdec,
+      (!lps->field_pic_flag || cur_frame->completed < PICTURE_DONE) ? 0 : 1);
+  }
+
+  if (cur_frame->completed == PICTURE_DONE)
+    _vdec_hw_h264_frame_free (vdec, cur_frame, 1);
+
+  lprintf ("\n___________________________________________________________________________________________\n\n");
+}
+
+static int _vdec_hw_h264_flush_slices (vdec_hw_h264_t *vdec, uint32_t new_type) {
+  if (vdec->seq.slices_count && ((new_type != vdec->seq.slice_mode) || (vdec->seq.slices_count >= MAX_SLICES))) {
+    _vdec_hw_h264_decode_picture (vdec);
+    vdec->seq.slices_count = 0;
+    vdec->seq.slice_mode = new_type;
+    return 1;
+  }
+  vdec->seq.slice_mode = new_type;
+  return 0;
+}
+
+static int _vdec_hw_h264_nal_unit (vdec_hw_h264_t *vdec, uint8_t *buf, uint32_t len) {
+  static const uint8_t flush[32] = {
+    [NAL_SLICE_IDR] = NAL_SLICE_IDR,
+    [NAL_SLICE_NO_IDR] = NAL_SLICE_NO_IDR
+  };
+  int ret;
+  uint8_t nal_ref_idc, nal_unit_type;
+  uint32_t ulen;
+  vdec_hw_h264_sps_t *sps;
+
+  /* forbidden_zero_bit 7 */
+  nal_ref_idc = (*buf >> 5) & 3;
+  nal_unit_type = *buf & 0x1f;
+  lprintf ("NAL size = %d, nal_ref_idc = %d, nal_unit_type = %d\n", (int)len, (int)nal_ref_idc, (int)nal_unit_type);
+
+  /* a lost reader looks for standard nal heads (0, 0, 1, type) to get back on track.
+   * unfortunately, such byte sequence may appear elsewhere - for example from sps.vui
+   * frame timing fields who are plain uint32, not exp_ue.
+   * encoders/muxers work around and insert 0x03 break bytes.
+   * remove them here (not generally in bits reader like before). */
+
+  ret = _vdec_hw_h264_flush_slices (vdec, flush[nal_unit_type]);
+
+  switch (nal_unit_type) {
+    case NAL_END_SEQUENCE:
+      _vdec_hw_h264_dpb_draw_frames (vdec, MAX_POC, DPB_DRAW_CLEAR);
+      vdec->seq.reset = VDEC_HW_H264_FRAME_NEW_SEQ;
+      vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_INFO,
+        LOG_MODULE ": sequence end.\n");
+      /* TJ. got some buggy .mp4 files there made from multiple sequences.
+       * the NAL_END_SEQUENCE's are still there, buf the NAL_SEQUENCE's have
+       * been dropped in favour of a single global config. */
+      sps = _vdec_hw_h264_get_sps (vdec);
+      if (sps)
+        sps->reused = 1;
+      break;
+    case NAL_SEQUENCE:
+      /* this is just for us, unescape and read in place. */
+      ulen = _vdec_hw_h264_unescape (buf + 1, len);
+      bits_set_buf (&vdec->seq.br, buf + 1, ulen);
+      sps = _vdec_hw_h264_read_sps (vdec);
+      if (!sps) {
+        vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+          LOG_MODULE ": ERROR: sequence start failed.\n");
+      }
+      break;
+    case NAL_PICTURE:
+      /* this is just for us, unescape and read in place. */
+      ulen = _vdec_hw_h264_unescape (buf + 1, len);
+      bits_set_buf (&vdec->seq.br, buf + 1, ulen);
+      _vdec_hw_h264_read_pps (vdec);
+      break;
+    case NAL_SLICE_IDR:
+    case NAL_SLICE_NO_IDR:
+      /* copy, unescape and read the small head here, and pass the whole original to hw later. */
+      ulen = len > 256 ? 256 : len;
+      memcpy (vdec->tempbuf, buf + 1, ulen);
+      ulen = _vdec_hw_h264_unescape (vdec->tempbuf, ulen);
+      bits_set_buf (&vdec->seq.br, vdec->tempbuf, ulen);
+      _vdec_hw_h264_slice_header (vdec, nal_ref_idc, nal_unit_type);
+      vdec->seq.slices_bitstream[vdec->seq.slices_count] = buf;
+      vdec->seq.slices_bytes[vdec->seq.slices_count] = len;
+      vdec->seq.slices_count++;
+      if ((int)vdec->seq.slices_count > vdec->stats.slices)
+        vdec->stats.slices = vdec->seq.slices_count;
+      break;
+    case NAL_SEI:
+    case NAL_SEEK_POINT:
+    case NAL_FILLER:
+      break;
+    default:
+      vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_INFO,
+        LOG_MODULE ": unhandled nal unit type %d.\n", (int)nal_unit_type);
+  }
+
+  return ret;
+}
+
+int vdec_hw_h264_put_config (vdec_hw_h264_t *vdec, const uint8_t *bitstream, uint32_t num_bytes) {
+  const uint8_t *buf, *e;
+  uint32_t count, i;
+
+  if (!vdec || !bitstream || (num_bytes < 7))
+    return 0;
+
+  lprintf ("vdec_hw_h264_put_config\n");
+
+  /* reserved:8, profile_idc:8, reserved:8, level_idc:8, reserved:6 frame_header_size_minus_1:2 */
+  vdec->seq.nal_unit_prefix = (bitstream[4] & 3) + 1;
+
+  buf = bitstream + 5;
+  e = bitstream + num_bytes;
+  /* reserved:3, sps_count:5 */
+  count = *buf++ & 31;
+  for (i = 0; i < count; i++) {
+    uint32_t sps_size, s2;
+
+    if (buf + 2 > e)
+      return 1;
+    sps_size = ((uint32_t)buf[0] << 8) + buf[1], buf += 2;
+    if (buf + sps_size > e)
+      sps_size = e - buf;
+    memcpy (vdec->tempbuf, buf, sps_size);
+    s2 = _vdec_hw_h264_unescape (vdec->tempbuf, sps_size);
+    /* reserved:8 */
+    bits_set_buf (&vdec->seq.br, vdec->tempbuf + 1, s2 ? s2 - 1 : 0);
+    _vdec_hw_h264_read_sps (vdec);
+    buf += sps_size;
+  }
+  if (buf + 1 > e)
+    return 1;
+  count = *buf++;
+  for (i = 0; i < count; i++) {
+    uint32_t pps_size, s2;
+
+    if (buf + 2 > e)
+      return 1;
+    pps_size = ((uint32_t)buf[0] << 8) + buf[1], buf += 2;
+    if (buf + pps_size > e)
+      pps_size = e - buf;
+    memcpy (vdec->tempbuf, buf, pps_size);
+    s2 = _vdec_hw_h264_unescape (vdec->tempbuf, pps_size);
+    /* reserved:8 */
+    bits_set_buf (&vdec->seq.br, vdec->tempbuf + 1, s2 ? s2 - 1 : 0);
+    _vdec_hw_h264_read_pps (vdec);
+    buf += pps_size;
+  }
+  return 1;
+}
+
+static void _vdec_hw_h264_flush_buffer (vdec_hw_h264_t *vdec) {
+  uint32_t drop, keep;
+
+  drop = vdec->seq.buf.nal_unit >= 0 ? (uint32_t)vdec->seq.buf.nal_unit : vdec->seq.buf.read;
+  if (vdec->seq.slices_count > 0) {
+    uint32_t d2 = vdec->seq.slices_bitstream[0] - vdec->seq.buf.mem;
+
+    if (d2 < drop)
+      drop = d2;
+  }
+  keep = vdec->seq.buf.write - drop;
+  /* printf ("--------[%d/%d]\n", (int)drop, (int)keep); */
+
+  if (drop) {
+    int i;
+
+    if (keep) {
+      if (keep > drop)
+        memmove (vdec->seq.buf.mem, vdec->seq.buf.mem + drop, keep);
+      else
+        memcpy (vdec->seq.buf.mem, vdec->seq.buf.mem + drop, keep);
+    }
+    for (i = 0; i < vdec->seq.slices_count; i++)
+      vdec->seq.slices_bitstream[i] -= drop;
+  }
+  vdec->seq.buf.write = keep;
+  vdec->seq.buf.read -= drop;
+  if (vdec->seq.buf.nal_unit >= 0) {
+    vdec->seq.buf.nal_unit -= drop;
+    if ((uint32_t)vdec->seq.buf.nal_unit > vdec->seq.buf.write)
+      vdec->seq.buf.nal_unit = -1;
+  }
+}
+
+int vdec_hw_h264_put_frame (vdec_hw_h264_t *vdec, int64_t pts, const uint8_t *bitstream, uint32_t num_bytes, int frame_end) {
+  uint32_t nal_unit_prefix = vdec->seq.nal_unit_prefix;
+  int flush;
+
+  if (!vdec)
+    return 1;
+
+  if (!bitstream || !num_bytes) {
+    if (!frame_end)
+      return 1;
+  } else {
+    uint32_t s;
+    /* if this really is the start of a new frame, flush the previous one
+     * before all that memcpy's. */
+    if ((vdec->seq.buf.nal_unit >= 0) && (num_bytes > 4) && !memcmp (bitstream, "\x00\x00\x00\x01", 4)) {
+      _vdec_hw_h264_nal_unit (vdec, vdec->seq.buf.mem + vdec->seq.buf.nal_unit + 3,
+        vdec->seq.buf.write - vdec->seq.buf.nal_unit - 3);
+      vdec->seq.buf.read = vdec->seq.buf.write;
+      vdec->seq.buf.nal_unit = -1;
+      _vdec_hw_h264_flush_slices (vdec, bitstream[4] & 0x1f);
+      _vdec_hw_h264_flush_buffer (vdec);
+    }
+
+    s = vdec->seq.buf.write + num_bytes;
+    if (s > vdec->seq.buf.max) {
+      if (s > MAX_BUFFER_SIZE)
+        vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+          LOG_MODULE ": frame too large, truncating.\n");
+      s = s * 3 / 2;
+      if (s > MAX_BUFFER_SIZE)
+        s = MAX_BUFFER_SIZE;
+      if (s > vdec->seq.buf.max) {
+        uint8_t *nb = realloc (vdec->seq.buf.mem, s + BUF_PAD);
+
+        if (nb) {
+          int i;
+
+          for (i = 0; i < vdec->seq.slices_count; i++)
+            vdec->seq.slices_bitstream[i] = nb + (vdec->seq.slices_bitstream[i] - vdec->seq.buf.mem);
+          vdec->seq.buf.mem = nb;
+          vdec->seq.buf.max = s;
+          vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_DEBUG,
+            LOG_MODULE ": enlarged bitstream buffer to %u bytes.\n", (unsigned int)vdec->seq.buf.max);
+        } else {
+          vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+            LOG_MODULE ": cannot enlarge bitstream buffer, truncating.\n");
+        }
+      }
+    }
+    s = vdec->seq.buf.max - vdec->seq.buf.write;
+    if (s > num_bytes)
+      s = num_bytes;
+    memcpy (vdec->seq.buf.mem + vdec->seq.buf.write, bitstream, s);
+    vdec->seq.buf.write += s;
+    memset (vdec->seq.buf.mem + vdec->seq.buf.write, 0, BUF_PAD);
+  }
+
+  /* always decode into cur_frame (vdec->frames[MAX_REF_FRAMES]).
+   * if this is a reference frame, move it to the dpb array.
+   * otherwise, draw and free immediately. */
+
+  /* TJ. I once made an .mp4 file with ffmpeg -vcodec copy. It has a global config (just fine),
+   * but then the frames have standard nal units... */
+  if (vdec->seq.buf.nal_unit >= 0)
+    nal_unit_prefix = 0;
+  if (nal_unit_prefix && (vdec->seq.buf.write - vdec->seq.buf.read > 4)) {
+    if (!memcmp (vdec->seq.buf.mem + vdec->seq.buf.read, "\x00\x00\x00\x01", 4)
+        && ((vdec->seq.buf.mem[vdec->seq.buf.read + 4] & 0x1f) != NAL_END_SEQUENCE))
+      nal_unit_prefix = 0;
+  }
+  if (nal_unit_prefix) {
+    if (!vdec->seq.pic_pts)
+      vdec->seq.pic_pts = pts;
+    if (frame_end) {
+      uint8_t *p = vdec->seq.buf.mem + vdec->seq.buf.read;
+      uint8_t *e = vdec->seq.buf.mem + vdec->seq.buf.write;
+
+      lprintf ("frame_end && vdec->seq.nal_unit_prefix\n");
+      while (p < e) {
+        uint32_t s = 0;
+
+        vdec->seq.buf.read = p - vdec->seq.buf.mem;
+        switch (vdec->seq.nal_unit_prefix) {
+          case 4:
+            s = *p++;
+            s <<= 8;
+            /* fall through */
+          case 3:
+            s += *p++;
+            s <<= 8;
+            /* fall through */
+          case 2:
+            s += *p++;
+            s <<= 8;
+            /* fall through */
+          default:
+            s += *p++;
+        }
+        if (p >= e)
+          break;
+        if ((s > 0x00ffffff) || (p + s > e))
+          s = e - p;
+        _vdec_hw_h264_nal_unit (vdec, p, s);
+        p += s;
+      }
+      _vdec_hw_h264_flush_slices (vdec, 0);
+      vdec->seq.buf.read =
+      vdec->seq.buf.write = 0;
+      vdec->seq.buf.nal_unit = -1;
+    }
+    return 0;
+  }
+
+  flush = 0;
+  while (1) {
+    uint8_t *b = vdec->seq.buf.mem + vdec->seq.buf.read;
+    uint8_t *e = vdec->seq.buf.mem + vdec->seq.buf.write;
+    uint32_t v;
+
+    memcpy (e, "\x00\x00\x01", 4);
+    v = 0xffffff00;
+    do {
+      v = (v + *b++) << 8;
+    } while (v != 0x00000100);
+    if (b >= e) {
+      /* we hit our fake stop mark. last unit may or may not be complete.
+       * rewind read pos a bit to amke sure that a possible begun standard unit
+       * prefix will be recognized next time. */
+      vdec->seq.buf.read = vdec->seq.buf.read + 3 > vdec->seq.buf.write ? vdec->seq.buf.read : vdec->seq.buf.write - 3;
+      break;
+    }
+    vdec->seq.buf.read = b - vdec->seq.buf.mem - 3;
+    if (vdec->seq.buf.nal_unit >= 0) {
+      flush += _vdec_hw_h264_nal_unit (vdec, vdec->seq.buf.mem + vdec->seq.buf.nal_unit + 3,
+        vdec->seq.buf.read - vdec->seq.buf.nal_unit - 3);
+      vdec->seq.buf.nal_unit = -1;
+    }
+    {
+      uint8_t tb = b[0] & 0x1f;
+
+      vdec->seq.buf.nal_unit = vdec->seq.buf.read;
+      if (((tb == NAL_SLICE_NO_IDR) || (tb == NAL_SLICE_IDR)) && !vdec->seq.pic_pts)
+        vdec->seq.pic_pts = pts;
+      if (tb == NAL_END_SEQUENCE) {
+        _vdec_hw_h264_dpb_draw_frames (vdec, MAX_POC, DPB_DRAW_CLEAR);
+        lprintf ("NAL_END_SEQUENCE\n");
+      }
+      vdec->seq.buf.read += 1;
+    }
+    if (vdec->seq.buf.read > vdec->seq.buf.write)
+      vdec->seq.buf.read = vdec->seq.buf.write;
+  }
+  if (vdec->seq.buf.nal_unit >= 0) {
+    uint8_t tb = vdec->seq.buf.mem[vdec->seq.buf.nal_unit + 3] & 0x1f;
+    /* in nal_unit_prefix workaround mode, assume this last nalu complete. */
+    if (vdec->seq.nal_unit_prefix) {
+      if (frame_end) {
+        _vdec_hw_h264_nal_unit (vdec, vdec->seq.buf.mem + vdec->seq.buf.nal_unit + 3,
+          vdec->seq.buf.write - vdec->seq.buf.nal_unit - 3);
+        if (((tb == NAL_SLICE_NO_IDR) || (tb == NAL_SLICE_IDR)) && !vdec->seq.pic_pts)
+          vdec->seq.pic_pts = pts;
+        _vdec_hw_h264_flush_slices (vdec, 0);
+        vdec->seq.buf.read =
+        vdec->seq.buf.write = 0;
+        vdec->seq.buf.nal_unit = -1;
+      }
+    }
+    /* sequence end just has the type byte. do it right now. */
+    else if (tb == NAL_END_SEQUENCE) {
+      _vdec_hw_h264_nal_unit (vdec, vdec->seq.buf.mem + vdec->seq.buf.nal_unit + 3, 1);
+      vdec->seq.buf.nal_unit = -1;
+    }
+    else if (((tb == NAL_SLICE_NO_IDR) || (tb == NAL_SLICE_IDR)) && !vdec->seq.pic_pts) {
+      vdec->seq.pic_pts = pts;
+    }
+  }
+  /* frame_end seems to be unreliable here. */
+  if (flush)
+    _vdec_hw_h264_flush_buffer (vdec);
+  return 0;
+}
+
+int vdec_hw_h264_flush (vdec_hw_h264_t *vdec) {
+  uint32_t n;
+
+  lprintf ("vdec_hw_h264_flush\n");
+  if (!vdec)
+    return 0;
+  if ((vdec->seq.buf.nal_unit >= 0) && ((uint32_t)vdec->seq.buf.nal_unit + 3 < vdec->seq.buf.write)) {
+    _vdec_hw_h264_nal_unit (vdec, vdec->seq.buf.mem + vdec->seq.buf.nal_unit + 3,
+      vdec->seq.buf.write - vdec->seq.buf.nal_unit - 3);
+  }
+  vdec->seq.buf.read =
+  vdec->seq.buf.write = 0;
+  vdec->seq.buf.nal_unit = -1;
+  _vdec_hw_h264_flush_slices (vdec, 0);
+  n = vdec->ref_frames_used;
+  _vdec_hw_h264_dpb_draw_frames (vdec, MAX_POC, DPB_DRAW_REFS);
+  return n;
+}
+
+vdec_hw_h264_t *vdec_hw_h264_new (
+  int (*logg) (void *user_data, vdec_hw_h264_logg_t level, const char *fmt, ...),
+  void *user_data,
+  int  (*frame_new)    (void *user_data, vdec_hw_h264_frame_t *frame),
+  int  (*frame_render) (void *user_data, vdec_hw_h264_frame_t *frame),
+  int  (*frame_ready)  (void *user_data, vdec_hw_h264_frame_t *frame),
+  void (*frame_delete) (void *user_data, vdec_hw_h264_frame_t *frame),
+  int num_frames
+) {
+  vdec_hw_h264_t *vdec;
+  uint32_t u;
+
+  vdec = calloc (1, sizeof (*vdec));
+  if (!vdec)
+    return NULL;
+
+  vdec->logg = logg ? logg : _vdec_hw_h264_dummy_logg;
+  vdec->user_data = user_data;
+
+  vdec->frame_new    = frame_new;
+  vdec->frame_render = frame_render;
+  vdec->frame_ready  = frame_ready;
+  vdec->frame_delete = frame_delete;
+
+  vdec->ref_frames_max = num_frames <= 1 ? 1 : num_frames > MAX_REF_FRAMES + 1 ? MAX_REF_FRAMES : num_frames - 1;
+
+  vdec->seq.buf.mem = malloc (MIN_BUFFER_SIZE + BUF_PAD);
+  if (!vdec->seq.buf.mem) {
+    free (vdec);
+    return NULL;
+  }
+  vdec->seq.buf.max = MIN_BUFFER_SIZE;
+  vdec->seq.buf.read = 0;
+  vdec->seq.buf.write = 0;
+  vdec->seq.buf.nal_unit = -1;
+
+  for (u = 0; u < MAX_REF_FRAMES + 1; u++)
+    vdec->seq.dpb[u] = vdec->frames + u;
+  vdec->ref_frames_used = 0;
+  vdec->user_frames = 0;
+
+  vdec->seq.reset = VDEC_HW_H264_FRAME_NEW_SEQ;
+  vdec->seq.ratio = 0.0;
+  vdec->seq.user_ratio = 0.0;
+  vdec->seq.video_step = 3600;
+  vdec->seq.coded_width = 1280;
+  vdec->seq.coded_height = 720;
+  vdec->seq.nal_unit_prefix = 0;
+  _vdec_hw_h264_reset_sequence (vdec);
+
+  for (u = 0; u < MAX_SPS; u++)
+    vdec->seq.sps[u] = NULL;
+  for (u = 0; u < MAX_PPS; u++)
+    vdec->seq.pps[u] = NULL;
+
+  vdec->stats.sps = 0;
+  vdec->stats.pps = 0;
+  vdec->stats.slices = 0;
+  vdec->stats.frame_ready = 0;
+
+  return vdec;
+}
+
+int vdec_hw_h264_reset (vdec_hw_h264_t *vdec) {
+  int n = 0;
+
+  if (!vdec)
+    return 0;
+
+  n = vdec->ref_frames_used;
+  _vdec_hw_h264_reset_sequence (vdec);
+  return n;
+}
+
+int vdec_hw_h264_put_container_info (vdec_hw_h264_t *vdec, int width, int height, int duration, double ratio) {
+  if (!vdec)
+    return 0;
+  if (width > 0)
+    vdec->seq.coded_width = width;
+  if (height > 0)
+    vdec->seq.coded_height = height;
+  if (duration > 0)
+    vdec->seq.video_step = duration;
+  if (ratio > 0.001)
+    vdec->seq.user_ratio = ratio;
+  return 1;
+}
+
+void vdec_hw_h264_delete (vdec_hw_h264_t **dec) {
+  vdec_hw_h264_t *vdec;
+  uint32_t u;
+
+  if (!dec)
+    return;
+  vdec = *dec;
+  if (!vdec)
+    return;
+  *dec = NULL;
+
+  for (u = 0; u < vdec->ref_frames_used; u++)
+    _vdec_hw_h264_frame_free (vdec, vdec->seq.dpb[u], 1);
+  vdec->ref_frames_used = 0;
+  _vdec_hw_h264_frame_free (vdec, vdec->frames + MAX_REF_FRAMES, 1);
+  vdec_hw_h264_reset (vdec);
+  _vdec_hw_h264_reset_sequence (vdec);
+  if (vdec->user_frames)
+    vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_ERR,
+      LOG_MODULE ": ERROR: %d user frames still in use.\n", (int)vdec->user_frames);
+  for (u = 0; u < MAX_SPS; u++)
+    if (vdec->seq.sps[u])
+      free (vdec->seq.sps[u]);
+  for (u = 0; u < MAX_PPS; u++)
+    if (vdec->seq.pps[u])
+      free (vdec->seq.pps[u]);
+  free (vdec->seq.buf.mem);
+
+  vdec->logg (vdec->user_data, VDEC_HW_H264_LOGG_INFO,
+    LOG_MODULE ": used %d SPS, %d PPS, %d slices per frame, %d stream bytes, %d render calls.\n",
+    vdec->stats.sps, vdec->stats.pps, vdec->stats.slices,
+    (int)vdec->seq.buf.max, (int)vdec->stats.frame_ready);
+
+  free (vdec);
+}
+
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/vdec_hw_h264.h xine-lib-1.2/src/video_dec/libvdpau/vdec_hw_h264.h
--- xine-lib-1.2.11/src/video_dec/libvdpau/vdec_hw_h264.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/vdec_hw_h264.h	2022-01-15 22:03:19.634547381 +0100
@@ -0,0 +1,148 @@
+/* kate: tab-indent on; indent-width 2; mixedindent off; indent-mode cstyle; remove-trailing-space on; */
+/*
+ * Copyright (C) 2008-2021 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * h264.h, a generic H264 video stream parser for VDPAU and VAAPI hardware decoders
+ */
+
+#ifndef VDEC_HW_H264_H
+#define VDEC_HW_H264_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+#include <sys/types.h>
+
+typedef struct vdec_hw_h264_s vdec_hw_h264_t;
+typedef struct vdec_hw_h264_frame_info_s vdec_hw_h264_frame_info_t;
+
+typedef struct {
+  void *user_data;
+  vdec_hw_h264_t *vdec;
+  int profile;
+  int level;
+  int width;
+  int height;
+  double ratio;
+  int64_t pts; /** << reordered from vdec_hw_info_h264_put_frame () */
+  int duration; /** << in pts */
+#define VDEC_HW_H264_FRAME_TOP_FIELD 1
+#define VDEC_HW_H264_FRAME_BOTTOM_FIELD 2
+#define VDEC_HW_H264_FRAME_NEW_SEQ 4
+  int flags;
+  int bad_frame; /** "here should have been a frame" */
+  int progressive_frame;
+  int top_field_first;
+  int color_matrix; /** << (MPEG matrix # << 1) | fullrange */
+  int num_ref_frames;
+  const vdec_hw_h264_frame_info_t *info;
+} vdec_hw_h264_frame_t;
+
+typedef struct {
+  vdec_hw_h264_frame_t *frame;
+
+  int is_long_term;
+  int top_is_reference;
+  int  bottom_is_reference;
+
+  int32_t field_order_cnt[2];
+  uint16_t frame_idx;
+} vdec_hw_h264_info_ref_frame_t;
+
+struct vdec_hw_h264_frame_info_s {
+  const uint8_t * const *slices_bitstream;
+  const uint32_t *slices_bytes;
+  uint32_t slice_count;
+
+  int32_t  field_order_cnt[2];
+  int      is_reference;
+
+  uint16_t frame_num;
+  uint8_t  field_pic_flag;
+  uint8_t  bottom_field_flag;
+  uint8_t  num_ref_frames;
+  uint8_t  gaps_in_frame_num_value_allowed_flag;
+  uint8_t  mb_adaptive_frame_field_flag;
+  uint8_t  constrained_intra_pred_flag;
+  uint8_t  weighted_pred_flag;
+  uint8_t  weighted_bipred_idc;
+  uint8_t  frame_mbs_only_flag;
+  uint8_t  transform_8x8_mode_flag;
+  uint8_t  chroma_format_idc;
+  uint8_t  separate_colour_plane_flag;
+  uint8_t  bit_depth_luma_minus8;
+  uint8_t  bit_depth_chroma_minus8;
+  int8_t   chroma_qp_index_offset;
+  int8_t   second_chroma_qp_index_offset;
+  int8_t   pic_init_qp_minus26;
+  int8_t   pic_init_qs_minus26;
+  uint8_t  num_ref_idx_l0_active_minus1;
+  uint8_t  num_ref_idx_l1_active_minus1;
+  uint8_t  log2_max_frame_num_minus4;
+  uint8_t  pic_order_cnt_type;
+  uint8_t  log2_max_pic_order_cnt_lsb_minus4;
+  uint8_t  delta_pic_order_always_zero_flag;
+  uint8_t  direct_8x8_inference_flag;
+  uint8_t  entropy_coding_mode_flag;
+  uint8_t  pic_order_present_flag;
+  uint8_t  deblocking_filter_control_present_flag;
+  uint8_t  redundant_pic_cnt_present_flag;
+  uint8_t  num_slice_groups_minus1;
+  uint8_t  slice_group_map_type;
+
+  uint8_t scaling_lists_4x4[6][16];
+  uint8_t scaling_lists_8x8[2][64];
+
+  vdec_hw_h264_info_ref_frame_t referenceFrames[16];
+};
+
+typedef enum {
+  VDEC_HW_H264_LOGG_ERR = 0,
+  VDEC_HW_H264_LOGG_INFO,
+  VDEC_HW_H264_LOGG_DEBUG
+} vdec_hw_h264_logg_t;
+
+vdec_hw_h264_t *vdec_hw_h264_new (
+  int __attribute__((format (printf, 3, 4))) (*logg) (void *user_data,
+    vdec_hw_h264_logg_t level, const char *fmt, ...), /** << can be NULL */
+  void *user_data, /** << passed to logg () and frame_* () verbatim */
+  int  (*frame_new)    (void *user_data, vdec_hw_h264_frame_t *frame), /** << get user part of this frame */
+  int  (*frame_render) (void *user_data, vdec_hw_h264_frame_t *frame), /** << perform hw decoding based on info */
+  int  (*frame_ready)  (void *user_data, vdec_hw_h264_frame_t *frame), /** << put this frame to output queue */
+  void (*frame_delete) (void *user_data, vdec_hw_h264_frame_t *frame), /** << unref/free user part */
+  int num_frames /** << max frames to use */
+);
+/** frame_delete () any held frames, set defaults */
+int vdec_hw_h264_reset (vdec_hw_h264_t *dec);
+/** zero all held frame pts */
+int vdec_hw_h264_zero_pts (vdec_hw_h264_t *dec);
+/** frame_ready () / frame_delete () any held frames now */
+int vdec_hw_h264_flush (vdec_hw_h264_t *dec);
+/** optional, 0 means "no change". */
+int vdec_hw_h264_put_container_info (vdec_hw_h264_t *dec, int width, int height, int duration, double ratio);
+/** optional global head from media container */
+int vdec_hw_h264_put_config (vdec_hw_h264_t *dec, const uint8_t *bitstream, uint32_t num_bytes);
+/** send what you have */
+int vdec_hw_h264_put_frame (vdec_hw_h264_t *dec, int64_t pts, const uint8_t *bitstream, uint32_t num_bytes, int frame_end);
+/** done */
+void vdec_hw_h264_delete (vdec_hw_h264_t **dec);
+
+#endif
+
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/vdpau_h264.c xine-lib-1.2/src/video_dec/libvdpau/vdpau_h264.c
--- xine-lib-1.2.11/src/video_dec/libvdpau/vdpau_h264.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/vdpau_h264.c	2022-01-15 22:03:19.608547272 +0100
@@ -486,6 +486,8 @@
 static struct nal_buffer* create_nal_buffer(uint8_t max_size)
 {
     struct nal_buffer *nal_buffer = calloc(1, sizeof(struct nal_buffer));
+    if (!nal_buffer)
+      return NULL;
     nal_buffer->max_size = max_size;
 
     return nal_buffer;
@@ -649,6 +651,8 @@
 static struct nal_unit* create_nal_unit()
 {
   struct nal_unit *nal = calloc(1, sizeof(struct nal_unit));
+  if (!nal)
+    return NULL;
   nal->lock_counter = 1;
 
   return nal;
@@ -860,6 +864,8 @@
 static struct decoded_picture* init_decoded_picture(struct coded_picture *cpic, vo_frame_t *img)
 {
   struct decoded_picture *pic = calloc(1, sizeof(struct decoded_picture));
+  if (!pic)
+    return NULL;
 
   pic->coded_pic[0] = cpic;
 
@@ -912,6 +918,8 @@
 static struct dpb* create_dpb(void)
 {
     struct dpb *dpb = calloc(1, sizeof(struct dpb));
+    if (!dpb)
+      return NULL;
 
     dpb->output_list = xine_list_new();
     dpb->reference_list = xine_list_new();
@@ -2947,20 +2955,6 @@
 
 /* ----------------- NAL parser ----------------- */
 
-static struct h264_parser* init_parser(xine_t *xine)
-{
-  struct h264_parser *parser = calloc(1, sizeof(struct h264_parser));
-  parser->pic = create_coded_picture();
-  parser->position = NON_VCL;
-  parser->last_vcl_nal = NULL;
-  parser->sps_buffer = create_nal_buffer(32);
-  parser->pps_buffer = create_nal_buffer(32);
-  parser->xine = xine;
-  parser->dpb = create_dpb();
-
-  return parser;
-}
-
 #if 0
 static void reset_parser(struct h264_parser *parser)
 {
@@ -3010,6 +3004,28 @@
   free(parser);
 }
 
+static struct h264_parser* init_parser(xine_t *xine)
+{
+  struct h264_parser *parser = calloc(1, sizeof(struct h264_parser));
+  if (!parser)
+    return NULL;
+
+  parser->pic = create_coded_picture();
+  parser->position = NON_VCL;
+  parser->last_vcl_nal = NULL;
+  parser->sps_buffer = create_nal_buffer(32);
+  parser->pps_buffer = create_nal_buffer(32);
+  parser->xine = xine;
+  parser->dpb = create_dpb();
+
+  if (!parser->dpb || !parser->pic || !parser->pps_buffer || !parser->sps_buffer) {
+    free_parser(parser);
+    return NULL;
+  }
+  return parser;
+}
+
+
 static void parse_codec_private(struct h264_parser *parser, const uint8_t *inbuf, int inbuf_len)
 {
   struct buf_reader bufr;
@@ -3021,7 +3037,8 @@
 
   // FIXME: Might be broken!
   struct nal_unit *nal = calloc(1, sizeof(struct nal_unit));
-
+  if (!nal)
+    return;
 
   /* reserved */
   read_bits(&bufr, 8);
@@ -4369,9 +4386,13 @@
     accel->unlock (accel->vo_frame);
 
   this = (vdpau_h264_decoder_t *) calloc(1, sizeof(vdpau_h264_decoder_t));
-
+  if (!this)
+    return NULL;
   this->nal_parser = init_parser(stream->xine);
-
+  if (!this->nal_parser) {
+    free(this);
+    return NULL;
+  }
   this->video_decoder.decode_data         = vdpau_h264_decode_data;
   this->video_decoder.flush               = vdpau_h264_flush;
   this->video_decoder.reset               = vdpau_h264_reset;
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/vdpau_mpeg12.c xine-lib-1.2/src/video_dec/libvdpau/vdpau_mpeg12.c
--- xine-lib-1.2.11/src/video_dec/libvdpau/vdpau_mpeg12.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/vdpau_mpeg12.c	2022-01-15 22:03:19.609547276 +0100
@@ -1,6 +1,6 @@
 /*
  * kate: space-indent on; indent-width 2; mixedindent off; indent-mode cstyle; remove-trailing-space on;
- * Copyright (C) 2008-2019 the xine project
+ * Copyright (C) 2008-2020 the xine project
  * Copyright (C) 2008 Christophe Thommeret <hftom@free.fr>
  *
  * This file is part of xine, a free video player.
@@ -1066,6 +1066,8 @@
     accel->unlock (accel->vo_frame);
 
   this = (vdpau_mpeg12_decoder_t *) calloc(1, sizeof(vdpau_mpeg12_decoder_t));
+  if (!this)
+    return NULL;
 
   this->video_decoder.decode_data         = vdpau_mpeg12_decode_data;
   this->video_decoder.flush               = vdpau_mpeg12_flush;
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/vdpau_mpeg4.c xine-lib-1.2/src/video_dec/libvdpau/vdpau_mpeg4.c
--- xine-lib-1.2.11/src/video_dec/libvdpau/vdpau_mpeg4.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/vdpau_mpeg4.c	2022-01-15 22:03:19.621547327 +0100
@@ -1,7 +1,7 @@
 /*
  * kate: space-indent on; indent-width 2; mixedindent off; indent-mode cstyle; remove-trailing-space on;
  *
- * Copyright (C) 2010-2019 the xine project
+ * Copyright (C) 2010-2021 the xine project
  * Copyright (C) 2010 Christophe Thommeret <hftom@free.fr>
  *
  * This file is part of xine, a free video player.
@@ -1121,6 +1121,8 @@
     accel->unlock (accel->vo_frame);
 
   this = (vdpau_mpeg4_decoder_t *) calloc(1, sizeof(vdpau_mpeg4_decoder_t));
+  if (!this)
+    return NULL;
 
   this->video_decoder.decode_data         = vdpau_mpeg4_decode_data;
   this->video_decoder.flush               = vdpau_mpeg4_flush;
diff -urN xine-lib-1.2.11/src/video_dec/libvdpau/vdpau_vc1.c xine-lib-1.2/src/video_dec/libvdpau/vdpau_vc1.c
--- xine-lib-1.2.11/src/video_dec/libvdpau/vdpau_vc1.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/libvdpau/vdpau_vc1.c	2022-01-15 22:03:19.617547310 +0100
@@ -1124,6 +1124,8 @@
     accel->unlock (accel->vo_frame);
 
   this = (vdpau_vc1_decoder_t *) calloc(1, sizeof(vdpau_vc1_decoder_t));
+  if (!this)
+    return NULL;
 
   this->video_decoder.decode_data         = vdpau_vc1_decode_data;
   this->video_decoder.flush               = vdpau_vc1_flush;
diff -urN xine-lib-1.2.11/src/video_dec/Makefile.am xine-lib-1.2/src/video_dec/Makefile.am
--- xine-lib-1.2.11/src/video_dec/Makefile.am	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/Makefile.am	2022-01-15 22:03:19.601547242 +0100
@@ -99,7 +99,9 @@
 xineplug_decode_vdpau_la_SOURCES = \
 	libvdpau/group_vdpau.c \
 	libvdpau/group_vdpau.h \
-	libvdpau/alterh264_bits_reader.h \
+	libvdpau/vdec_hw_bits_reader.h \
+	libvdpau/vdec_hw_h264.h \
+	libvdpau/vdec_hw_h264.c \
 	libvdpau/alterh264_decode.c \
 	libvdpau/alterh264_decode.h \
 	libvdpau/bits_reader.h \
diff -urN xine-lib-1.2.11/src/video_dec/mmal.c xine-lib-1.2/src/video_dec/mmal.c
--- xine-lib-1.2.11/src/video_dec/mmal.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_dec/mmal.c	2022-01-15 22:03:19.609547276 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2019 the xine project
+ * Copyright (C) 2014-2020 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/src/video_out/macosx/XineOpenGLView.m xine-lib-1.2/src/video_out/macosx/XineOpenGLView.m
--- xine-lib-1.2.11/src/video_out/macosx/XineOpenGLView.m	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/macosx/XineOpenGLView.m	2022-01-15 22:03:19.610547280 +0100
@@ -23,6 +23,10 @@
 #define LOG
 */
 
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
 #import <Cocoa/Cocoa.h>
 #import <OpenGL/OpenGL.h>
 #import <OpenGL/gl.h>
diff -urN xine-lib-1.2.11/src/video_out/Makefile.am xine-lib-1.2/src/video_out/Makefile.am
--- xine-lib-1.2.11/src/video_out/Makefile.am	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/Makefile.am	2022-01-15 22:03:19.622547331 +0100
@@ -153,7 +153,7 @@
 xineplug_vo_out_vdpau_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) $(X_LIBS) $(LTLIBINTL) $(VDPAU_LIBS) -lm
 xineplug_vo_out_vdpau_la_CFLAGS = $(AM_CFLAGS) $(X_CFLAGS) $(VDPAU_CFLAGS)
 
-xineplug_vo_out_vaapi_la_SOURCES = video_out_vaapi.c
+xineplug_vo_out_vaapi_la_SOURCES = video_out_vaapi.c vaapi/vaapi_util.h vaapi/vaapi_util.c vaapi/vaapi_frame.h
 xineplug_vo_out_vaapi_la_LIBADD = $(XINE_LIB) $(OPENGL_LIBS) $(X_LIBS) $(PTHREAD_LIBS) $(LTLIBINTL) $(DYNAMIC_LD_LIBS) $(GLU_LIBS) $(LIBVA_LIBS) $(LIBVA_GLX_LIBS) -lm
 xineplug_vo_out_vaapi_la_CFLAGS = $(AM_CFLAGS) $(X_CFLAGS) $(XV_CFLAGS) $(LIBVA_CFLAGS) $(LIBVA_GLX_CFLAGS)
 
@@ -187,7 +187,7 @@
 	$(GLUT_LIBS) $(GLU_LIBS) $(X_LIBS) $(PTHREAD_LIBS) $(DYNAMIC_LD_LIBS) $(LTLIBINTL) $(X11OSD_LIB) -lm
 xineplug_vo_out_opengl_la_CFLAGS = $(AM_CFLAGS) $(X_CFLAGS)
 
-xineplug_vo_out_opengl2_la_SOURCES = video_out_opengl2.c
+xineplug_vo_out_opengl2_la_SOURCES = video_out_opengl2.c mem_frame.h
 xineplug_vo_out_opengl2_la_LIBADD = $(XINE_LIB) $(OPENGL_LIBS) $(PTHREAD_LIBS) $(LTLIBINTL) $(XINE_GL_LIB) -lm
 xineplug_vo_out_opengl2_la_CFLAGS = $(AM_CFLAGS)
 
@@ -246,7 +246,7 @@
 xineplug_vo_out_directx_la_LIBADD = $(XINE_LIB) $(DIRECTX_VIDEO_LIBS) $(PTHREAD_LIBS) $(LTLIBINTL)
 xineplug_vo_out_directx_la_CPPFLAGS = $(AM_CPPFLAGS) $(DIRECTX_CPPFLAGS)
 
-xineplug_vo_out_none_la_SOURCES =  video_out_none.c
+xineplug_vo_out_none_la_SOURCES =  video_out_none.c mem_frame.h
 xineplug_vo_out_none_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) $(LTLIBINTL)
 
 xineplug_vo_out_raw_la_SOURCES = video_out_raw.c
diff -urN xine-lib-1.2.11/src/video_out/mem_frame.h xine-lib-1.2/src/video_out/mem_frame.h
--- xine-lib-1.2.11/src/video_out/mem_frame.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_out/mem_frame.h	2022-01-15 22:03:19.620547323 +0100
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2012-2022 the xine project
+ * Copyright (C) 2012 Christophe Thommeret <hftom@free.fr>
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ *
+ * mem_frame.h, generic memory backed frame
+ *
+ *
+ */
+
+typedef struct mem_frame_t {
+  vo_frame_t vo_frame;
+  int width, height, format, flags;
+  double ratio;
+} mem_frame_t;
+
+static void _mem_frame_proc_slice(vo_frame_t *vo_img, uint8_t **src)
+{
+  (void)src;
+  vo_img->proc_called = 1;
+}
+
+static void _mem_frame_field(vo_frame_t *vo_img, int which_field)
+{
+  (void)vo_img;
+  (void)which_field;
+}
+
+static void _mem_frame_dispose(vo_frame_t *vo_img)
+{
+  xine_free_aligned (vo_img->base[0]);
+  pthread_mutex_destroy (&vo_img->mutex);
+  free (vo_img);
+}
+
+static void _mem_frame_init(mem_frame_t *frame, vo_driver_t *driver)
+{
+  frame->vo_frame.base[0] = frame->vo_frame.base[1] = frame->vo_frame.base[2] = NULL;
+  frame->width = frame->height = frame->format = frame->flags = 0;
+  frame->ratio = 0.0;
+
+  pthread_mutex_init (&frame->vo_frame.mutex, NULL);
+
+  frame->vo_frame.proc_slice = _mem_frame_proc_slice;
+  frame->vo_frame.proc_frame = NULL;
+  frame->vo_frame.field      = _mem_frame_field;
+  frame->vo_frame.dispose    = _mem_frame_dispose;
+  frame->vo_frame.driver     = driver;
+}
+
+static vo_frame_t *_mem_frame_alloc_frame(vo_driver_t *this_gen, size_t frame_size)
+{
+  mem_frame_t *frame;
+
+  frame = calloc(1, frame_size);
+
+  if (!frame)
+    return NULL;
+
+  _mem_frame_init(frame, this_gen);
+
+  return &frame->vo_frame;
+}
+
+static inline vo_frame_t *mem_frame_alloc_frame(vo_driver_t *this_gen)
+{
+  return _mem_frame_alloc_frame(this_gen, sizeof(mem_frame_t));
+}
+
+static inline void mem_frame_update_frame_format(vo_driver_t *this_gen, vo_frame_t *frame_gen,
+      uint32_t width, uint32_t height, double ratio, int format, int flags)
+{
+  mem_frame_t *frame = xine_container_of(frame_gen, mem_frame_t, vo_frame);
+
+  (void)this_gen;
+
+  /* vo_none and vo_opengl2 need no buffer adjustment for these. */
+  frame->flags = flags;
+  frame->ratio = ratio;
+
+  /* Check frame size and format and reallocate if necessary (rare case). */
+  if (!((frame->width ^ width) | (frame->height ^ height) | (frame->format ^ format)))
+    return;
+
+  frame->width  = width;
+  frame->height = height;
+  frame->format = format;
+
+  /* (re-) allocate render space */
+  xine_freep_aligned (&frame->vo_frame.base[0]);
+  frame->vo_frame.base[1] = NULL;
+  frame->vo_frame.base[2] = NULL;
+
+  if (format == XINE_IMGFMT_YV12) {
+    uint32_t w = (width + 15) & ~15;
+    uint32_t ysize = w * height;
+    uint32_t uvsize = (w >> 1) * ((height + 1) >> 1);
+
+    frame->vo_frame.pitches[0] = w;
+    frame->vo_frame.pitches[1] = w >> 1;
+    frame->vo_frame.pitches[2] = w >> 1;
+    frame->vo_frame.base[0] = xine_malloc_aligned (ysize + 2 * uvsize);
+    if (frame->vo_frame.base[0]) {
+      memset (frame->vo_frame.base[0], 0, ysize);
+      frame->vo_frame.base[1] = frame->vo_frame.base[0] + ysize;
+      memset (frame->vo_frame.base[1], 128, 2 * uvsize);
+      frame->vo_frame.base[2] = frame->vo_frame.base[1] + uvsize;
+    }
+
+  } else if (format == XINE_IMGFMT_NV12) {
+    uint32_t w = (width + 15) & ~15;
+    uint32_t ysize = w * height;
+    uint32_t uvsize = w * ((height + 1) >> 1);
+
+    frame->vo_frame.pitches[0] =
+    frame->vo_frame.pitches[1] = w;
+    frame->vo_frame.base[0] = xine_malloc_aligned (ysize + uvsize);
+    if (frame->vo_frame.base[0]) {
+      memset (frame->vo_frame.base[0], 0, ysize);
+      frame->vo_frame.base[1] = frame->vo_frame.base[0] + ysize;
+      memset (frame->vo_frame.base[1], 128, uvsize);
+    }
+
+  } else if (format == XINE_IMGFMT_YUY2) {
+    frame->vo_frame.pitches[0] = ((width + 15) & ~15) << 1;
+    frame->vo_frame.base[0] = xine_malloc_aligned (frame->vo_frame.pitches[0] * height);
+    if (frame->vo_frame.base[0]) {
+      const union {uint8_t bytes[4]; uint32_t word;} black = {{0, 128, 0, 128}};
+      uint32_t *q = (uint32_t *)frame->vo_frame.base[0];
+      unsigned i;
+      for (i = frame->vo_frame.pitches[0] * height / 4; i > 0; i--)
+        *q++ = black.word;
+    }
+  }
+
+  if (!frame->vo_frame.base[0]) {
+    /* tell vo_get_frame () to retry later */
+    frame->width = 0;
+    frame->vo_frame.width = 0;
+  }
+}
diff -urN xine-lib-1.2.11/src/video_out/opengl/xine_egl.c xine-lib-1.2/src/video_out/opengl/xine_egl.c
--- xine-lib-1.2.11/src/video_out/opengl/xine_egl.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/opengl/xine_egl.c	2022-01-15 22:03:19.591547200 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (C) 2018-2019 the xine project
- * Copyright (C) 2018-2019 Petri Hintukainen <phintuka@users.sourceforge.net>
+ * Copyright (C) 2018-2021 the xine project
+ * Copyright (C) 2018-2021 Petri Hintukainen <phintuka@users.sourceforge.net>
  *
  * This file is part of xine, a free video player.
  *
@@ -43,6 +43,7 @@
 #endif
 
 #include <EGL/egl.h>
+#include <EGL/eglext.h>
 
 #define EGL(_gl) xine_container_of(_gl, xine_egl_t, p.gl)
 
@@ -59,6 +60,11 @@
   int width, height;
 #endif
 
+#ifdef EGL_KHR_image
+  PFNEGLCREATEIMAGEKHRPROC    eglCreateImageKHR;
+  PFNEGLDESTROYIMAGEKHRPROC   eglDestroyImageKHR;
+#endif
+
   /* DEBUG */
   int         is_current;
 } xine_egl_t;
@@ -161,7 +167,41 @@
 #endif
 }
 
-static int _egl_init(xine_egl_t *egl, EGLNativeDisplayType native_display)
+static const char *_egl_query_string(xine_gl_t *gl, int type)
+{
+  xine_egl_t *egl = EGL(gl);
+
+  return eglQueryString(egl->display, type);
+}
+
+static const char *_egl_query_extensions(xine_gl_t *gl)
+{
+  return _egl_query_string(gl, EGL_EXTENSIONS);
+}
+
+static void *_egl_get_proc_address(xine_gl_t *gl, const char *procname)
+{
+  (void)gl;
+  return (void *)eglGetProcAddress(procname);
+}
+
+#ifdef EGL_KHR_image
+static void *_egl_create_image_khr(xine_gl_t *gl, unsigned target, void *buffer, const int32_t *attrib_list)
+{
+  xine_egl_t *egl = EGL(gl);
+
+  return egl->eglCreateImageKHR(egl->display, egl->context, target, buffer, attrib_list);
+}
+
+static int _egl_destroy_image_khr(xine_gl_t *gl, void *image)
+{
+  xine_egl_t *egl = EGL(gl);
+
+  return egl->eglDestroyImageKHR(egl->display, image);
+}
+#endif /* EGL_KHR_image */
+
+static int _egl_init(xine_egl_t *egl, EGLNativeDisplayType native_display, int api)
 {
   static const EGLint attributes[] = {
     EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
@@ -190,7 +230,7 @@
 
   eglChooseConfig(egl->display, attributes, &egl->config, 1, &num_config);
 
-  if (!eglBindAPI (EGL_OPENGL_API)) {
+  if (!eglBindAPI (api)) {
     _egl_log_error(egl->p.xine, "OpenGL API unavailable");
     goto fail;
   }
@@ -257,7 +297,7 @@
 
   (void)class_gen;
 
-  if (!(params->flags & XINE_GL_API_OPENGL)) {
+  if (!(params->flags & (XINE_GL_API_OPENGL | XINE_GL_API_OPENGLES))) {
     return NULL;
   }
   _x_assert(params->visual);
@@ -277,12 +317,32 @@
   egl->p.gl.set_native_window = _egl_set_native_window;
   egl->p.gl.dispose           = NULL;
 
+  egl->p.gl.query_extensions  = _egl_query_extensions;
+  egl->p.gl.get_proc_address  = _egl_get_proc_address;
+
+#ifdef EGL_KHR_image
+  egl->eglCreateImageKHR  = (void *)eglGetProcAddress("eglCreateImageKHR");
+  egl->eglDestroyImageKHR = (void *)eglGetProcAddress("eglDestroyImageKHR");
+  if (egl->eglCreateImageKHR && egl->eglDestroyImageKHR) {
+    egl->p.gl.eglCreateImageKHR  = _egl_create_image_khr;
+    egl->p.gl.eglDestroyImageKHR = _egl_destroy_image_khr;
+  }
+#endif /* EGL_KHR_image */
+
   egl->p.xine = params->xine;
 
-  if (!_egl_init(egl, vis->display)) {
+  do {
+    if (params->flags & XINE_GL_API_OPENGL)
+      if (_egl_init(egl, vis->display, EGL_OPENGL_API))
+        break;
+
+    if (params->flags & XINE_GL_API_OPENGLES)
+      if (_egl_init(egl, vis->display, EGL_OPENGL_ES_API))
+        break;
+
     free(egl);
     return NULL;
-  }
+  } while (0);
 
 #if defined(XINE_EGL_USE_X11)
   native_window       = vis->d;
diff -urN xine-lib-1.2.11/src/video_out/opengl/xine_gl.h xine-lib-1.2/src/video_out/opengl/xine_gl.h
--- xine-lib-1.2.11/src/video_out/opengl/xine_gl.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/opengl/xine_gl.h	2022-01-15 22:03:19.622547331 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (C) 2018-2019 the xine project
- * Copyright (C) 2018-2019 Petri Hintukainen <phintuka@users.sourceforge.net>
+ * Copyright (C) 2018-2021 the xine project
+ * Copyright (C) 2018-2021 Petri Hintukainen <phintuka@users.sourceforge.net>
  *
  * This file is part of xine, a free video player.
  *
@@ -42,11 +42,22 @@
   void (*set_native_window)(xine_gl_t *, void *);
 
   void (*dispose)          (xine_gl_t **);
+
+  void *(*get_proc_address)(xine_gl_t *, const char *);
+  const char * (*query_extensions)(xine_gl_t *);
+
+  /* EGL */
+  void       * (*eglCreateImageKHR) (xine_gl_t *,
+                                     unsigned /* EGLenum target */,
+                                     void * /* EGLClientBuffer buffer */,
+                                     const int32_t * /*const EGLint * attrib_list */);
+  int          (*eglDestroyImageKHR) (xine_gl_t *, void *);
 };
 
 xine_gl_t *_x_load_gl(xine_t *xine, unsigned visual_type, const void *visual, unsigned flags);
 
 /* flags */
 #define XINE_GL_API_OPENGL     0x0001
+#define XINE_GL_API_OPENGLES   0x0002
 
 #endif /* XINE_GL_H_ */
diff -urN xine-lib-1.2.11/src/video_out/vaapi/vaapi_frame.h xine-lib-1.2/src/video_out/vaapi/vaapi_frame.h
--- xine-lib-1.2.11/src/video_out/vaapi/vaapi_frame.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_out/vaapi/vaapi_frame.h	2022-01-15 22:03:19.621547327 +0100
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2012 Edgar Hucek <gimli|@dark-green.com>
+ * Copyright (C) 2012-2022 xine developers
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * vaapi_frame.c, VAAPI video extension interface for xine
+ *
+ */
+
+#ifndef XINE_VAAPI_FRAME_H
+#define XINE_VAAPI_FRAME_H
+
+#include <xine/video_out.h>
+#include "accel_vaapi.h"
+
+#include "vaapi_util.h"
+#include "../mem_frame.h"
+
+typedef struct {
+  mem_frame_t           mem_frame;
+  vaapi_accel_t         vaapi_accel_data;
+  vaapi_context_impl_t *ctx_impl;
+} vaapi_frame_t;
+
+static inline
+vaapi_context_impl_t *_ctx_from_frame(vo_frame_t *vo_frame)
+{
+  vaapi_frame_t *frame = xine_container_of(vo_frame, vaapi_frame_t, mem_frame.vo_frame);
+  return frame->ctx_impl;
+}
+
+/*
+ * accel
+ */
+
+static inline
+int _x_va_accel_profile_from_imgfmt(vo_frame_t *vo_frame, unsigned format)
+{
+  vaapi_context_impl_t *va = _ctx_from_frame(vo_frame);
+  return _x_va_profile_from_imgfmt(va, format);
+}
+
+static inline
+ff_vaapi_context_t *_x_va_accel_get_context(vo_frame_t *vo_frame)
+{
+  vaapi_context_impl_t *va = _ctx_from_frame(vo_frame);
+  return &va->c;
+}
+
+static inline
+int _x_va_accel_init(vo_frame_t *vo_frame, int va_profile, int width, int height)
+{
+  vaapi_context_impl_t *va = _ctx_from_frame(vo_frame);
+  return _x_va_init(va, va_profile, width, height);
+}
+
+static inline
+int _x_va_accel_guarded_render(vo_frame_t *vo_frame)
+{
+  vaapi_accel_t *accel = vo_frame->accel_data;
+  return accel->f->render_vaapi_surface != NULL;
+}
+
+/*
+ * non-guarded mode
+ */
+
+static inline
+int _x_va_accel_lock_decode_dummy(vo_frame_t *vo_frame)
+{
+  (void)vo_frame;
+  return 0;
+}
+
+static inline
+ff_vaapi_surface_t *_x_va_accel_get_vaapi_surface(vo_frame_t *vo_frame)
+{
+  vaapi_context_impl_t *va = _ctx_from_frame(vo_frame);
+  vaapi_accel_t        *accel = vo_frame->accel_data;
+  _x_assert(accel->index < RENDER_SURFACES); /* index is constant in this mode */
+  return &va->c.va_render_surfaces[accel->index];
+}
+
+/*
+ * guarded mode
+ */
+
+static inline
+ff_vaapi_surface_t *_x_va_accel_alloc_vaapi_surface(vo_frame_t *vo_frame)
+{
+  vaapi_context_impl_t *va = _ctx_from_frame(vo_frame);
+  return _x_va_alloc_surface(va);
+}
+
+static inline
+void _x_va_accel_render_vaapi_surface(vo_frame_t *vo_frame, ff_vaapi_surface_t *va_surface)
+{
+  vaapi_context_impl_t *va = _ctx_from_frame(vo_frame);
+  vaapi_accel_t        *accel = vo_frame->accel_data;
+
+  accel->index = va_surface->index;
+  _x_va_render_surface(va, va_surface);
+}
+
+static inline
+void _x_va_accel_release_vaapi_surface(vo_frame_t *vo_frame, ff_vaapi_surface_t *va_surface)
+{
+  /* surface was not binded to this vo_frame */
+  vaapi_context_impl_t *va = _ctx_from_frame(vo_frame);
+  _x_va_release_surface(va, va_surface);
+}
+
+/*
+ * video out
+ */
+
+static inline
+void _x_va_frame_displayed(vo_frame_t *vo_frame)
+{
+  vaapi_context_impl_t *va_context = _ctx_from_frame(vo_frame);
+  vaapi_accel_t *accel = vo_frame->accel_data;
+
+  if (accel->index < RENDER_SURFACES) {
+    ff_vaapi_surface_t *va_surface = &va_context->c.va_render_surfaces[accel->index];
+    _x_va_surface_displayed(va_context, va_surface);
+    accel->index = RENDER_SURFACES; /* invalid */
+  }
+}
+
+#endif /* XINE_VAAPI_UTIL_H */
diff -urN xine-lib-1.2.11/src/video_out/vaapi/vaapi_util.c xine-lib-1.2/src/video_out/vaapi/vaapi_util.c
--- xine-lib-1.2.11/src/video_out/vaapi/vaapi_util.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_out/vaapi/vaapi_util.c	2022-01-15 22:03:19.607547268 +0100
@@ -0,0 +1,655 @@
+/*
+ * Copyright (C) 2012 Edgar Hucek <gimli|@dark-green.com>
+ * Copyright (C) 2012-2022 xine developers
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * vaapi_util.c, VAAPI video extension interface for xine
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "vaapi_util.h"
+
+#include <stdlib.h>
+#include <pthread.h>
+
+#include <xine/xine_internal.h>
+#include <xine/xineutils.h>
+
+#include <va/va.h>
+#include <va/va_x11.h>
+
+#if defined(HAVE_VA_VA_GLX_H)
+# include <va/va_glx.h>
+#endif
+
+#if defined(LOG) || defined(DEBUG)
+static const char *_x_va_string_of_VAImageFormat(VAImageFormat *imgfmt)
+{
+  static char str[5];
+  str[0] = imgfmt->fourcc;
+  str[1] = imgfmt->fourcc >> 8;
+  str[2] = imgfmt->fourcc >> 16;
+  str[3] = imgfmt->fourcc >> 24;
+  str[4] = '\0';
+  return str;
+}
+#endif
+
+const char *_x_va_profile_to_string(VAProfile profile)
+{
+  switch(profile) {
+#define PROFILE(profile) \
+    case VAProfile##profile: return "VAProfile" #profile
+      PROFILE(MPEG2Simple);
+      PROFILE(MPEG2Main);
+      PROFILE(MPEG4Simple);
+      PROFILE(MPEG4AdvancedSimple);
+      PROFILE(MPEG4Main);
+      PROFILE(H264Main);
+      PROFILE(H264High);
+      PROFILE(VC1Simple);
+      PROFILE(VC1Main);
+      PROFILE(VC1Advanced);
+#if VA_CHECK_VERSION(0, 37, 0)
+      PROFILE(HEVCMain);
+      PROFILE(HEVCMain10);
+#endif
+#undef PROFILE
+    default: break;
+  }
+  return "<unknown>";
+}
+
+const char *_x_va_entrypoint_to_string(VAEntrypoint entrypoint)
+{
+  switch(entrypoint)
+  {
+#define ENTRYPOINT(entrypoint) \
+    case VAEntrypoint##entrypoint: return "VAEntrypoint" #entrypoint
+      ENTRYPOINT(VLD);
+      ENTRYPOINT(IZZ);
+      ENTRYPOINT(IDCT);
+      ENTRYPOINT(MoComp);
+      ENTRYPOINT(Deblocking);
+#undef ENTRYPOINT
+    default: break;
+  }
+  return "<unknown>";
+}
+
+int _x_va_check_status(vaapi_context_impl_t *this, VAStatus vaStatus, const char *msg)
+{
+  if (vaStatus != VA_STATUS_SUCCESS) {
+    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " Error : %s: %s\n", msg, vaErrorStr(vaStatus));
+    return 0;
+  }
+  return 1;
+}
+
+void _x_va_reset_va_context(ff_vaapi_context_t *va_context)
+{
+  int i;
+
+  va_context->va_config_id              = VA_INVALID_ID;
+  va_context->va_context_id             = VA_INVALID_ID;
+  va_context->valid_context             = 0;
+  va_context->va_head                   = 0;
+
+  for(i = 0; i < RENDER_SURFACES; i++) {
+    ff_vaapi_surface_t *va_surface      = &va_context->va_render_surfaces[i];
+
+    va_surface->index                   = i;
+    va_surface->status                  = SURFACE_FREE;
+    va_surface->va_surface_id           = VA_INVALID_SURFACE;
+
+    va_context->va_surface_ids[i]       = VA_INVALID_SURFACE;
+  }
+}
+
+static VADisplay _get_display(int visual_type, const void *visual, int opengl_render)
+{
+  VADisplay ret;
+
+  if (visual_type == XINE_VISUAL_TYPE_X11) {
+    if (opengl_render) {
+#if defined(HAVE_VA_VA_GLX_H)
+      ret = vaGetDisplayGLX(((const x11_visual_t *)visual)->display);
+#else
+      return NULL;
+#endif
+    } else {
+#if defined(HAVE_VA_VA_X11_H)
+      ret = vaGetDisplay(((const x11_visual_t *)visual)->display);
+#else
+      return NULL;
+#endif
+    }
+  } else {
+    return NULL;
+  }
+
+  if (vaDisplayIsValid(ret))
+    return ret;
+
+  return NULL;
+}
+
+VAStatus _x_va_terminate(ff_vaapi_context_t *va_context)
+{
+  VAStatus vaStatus = VA_STATUS_SUCCESS;
+
+  _x_freep(&va_context->va_image_formats);
+  va_context->va_num_image_formats  = 0;
+
+  if (va_context->va_display) {
+    vaStatus = vaTerminate(va_context->va_display);
+    va_context->va_display = NULL;
+  }
+
+  return vaStatus;
+}
+
+void _x_va_free(vaapi_context_impl_t **p_va_context)
+{
+  if (*p_va_context) {
+    vaapi_context_impl_t *va_context = *p_va_context;
+    VAStatus vaStatus;
+
+    vaStatus = _x_va_terminate(&va_context->c);
+    _x_va_check_status(va_context, vaStatus, "vaTerminate()");
+
+    pthread_mutex_destroy(&va_context->surfaces_lock);
+
+    _x_freep(p_va_context);
+  }
+}
+
+VAStatus _x_va_initialize(ff_vaapi_context_t *va_context, int visual_type, const void *visual, int opengl_render)
+{
+  VAStatus vaStatus;
+  int      maj, min;
+  int      fmt_count = 0;
+
+  va_context->va_display = _get_display(visual_type, visual, opengl_render);
+  if (!va_context->va_display) {
+    return VA_STATUS_ERROR_INVALID_DISPLAY;
+  }
+
+  vaStatus = vaInitialize(va_context->va_display, &maj, &min);
+  if (vaStatus != VA_STATUS_SUCCESS) {
+    goto fail;
+  }
+
+  lprintf("libva: %d.%d\n", maj, min);
+
+  fmt_count = vaMaxNumImageFormats(va_context->va_display);
+  va_context->va_image_formats = calloc(fmt_count, sizeof(*va_context->va_image_formats));
+  if (!va_context->va_image_formats) {
+    goto fail;
+  }
+
+  vaStatus = vaQueryImageFormats(va_context->va_display, va_context->va_image_formats, &va_context->va_num_image_formats);
+  if (vaStatus != VA_STATUS_SUCCESS) {
+    goto fail;
+  }
+
+  return vaStatus;
+
+fail:
+  _x_va_terminate(va_context);
+  return vaStatus;
+}
+
+vaapi_context_impl_t *_x_va_new(xine_t *xine, int visual_type, const void *visual, int opengl_render)
+{
+  vaapi_context_impl_t *va_context;
+  const char *p, *vendor;
+  VAStatus vaStatus;
+  size_t   i;
+
+  va_context = calloc(1, sizeof(*va_context));
+  if (!va_context)
+    return NULL;
+
+  va_context->xine = xine;
+  va_context->c.va_render_surfaces  = va_context->va_render_surfaces_storage;
+  va_context->c.va_surface_ids      = va_context->va_surface_ids_storage;
+
+  _x_va_reset_va_context(&va_context->c);
+
+  pthread_mutex_init(&va_context->surfaces_lock, NULL);
+
+  vaStatus = _x_va_initialize(&va_context->c, visual_type, visual, opengl_render);
+
+  if (!_x_va_check_status(va_context, vaStatus, "vaInitialize()")) {
+    _x_va_free(&va_context);
+    return NULL;
+  }
+
+  va_context->query_va_status = 1;
+
+  vendor = vaQueryVendorString(va_context->c.va_display);
+  xprintf(va_context->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Vendor : %s\n", vendor);
+
+  for (p = vendor, i = strlen (vendor); i > 0; i--, p++) {
+    if (strncmp(p, "VDPAU", strlen("VDPAU")) == 0) {
+      xprintf(va_context->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Enable Splitted-Desktop Systems VDPAU-VIDEO workarounds.\n");
+      va_context->query_va_status = 0;
+      break;
+    }
+  }
+
+  return va_context;
+}
+
+
+void _x_va_destroy_image(vaapi_context_impl_t *va_context, VAImage *va_image)
+{
+  VAStatus              vaStatus;
+
+  if (va_image->image_id != VA_INVALID_ID) {
+    lprintf("vaapi_destroy_image 0x%08x\n", va_image->image_id);
+    vaStatus = vaDestroyImage(va_context->c.va_display, va_image->image_id);
+    _x_va_check_status(va_context, vaStatus, "vaDestroyImage()");
+  }
+  va_image->image_id      = VA_INVALID_ID;
+  va_image->width         = 0;
+  va_image->height        = 0;
+}
+
+VAStatus _x_va_create_image(vaapi_context_impl_t *va_context, VASurfaceID va_surface_id, VAImage *va_image, int width, int height, int clear, int *is_bound)
+{
+  int i = 0;
+  VAStatus vaStatus;
+
+  if (!va_context->c.valid_context || va_context->c.va_image_formats == NULL || va_context->c.va_num_image_formats == 0)
+    return VA_STATUS_ERROR_UNKNOWN;
+
+  *is_bound = 0;
+
+  vaStatus = vaDeriveImage(va_context->c.va_display, va_surface_id, va_image);
+  if (vaStatus == VA_STATUS_SUCCESS) {
+    if (va_image->image_id != VA_INVALID_ID && va_image->buf != VA_INVALID_ID) {
+      *is_bound = 1;
+    }
+  }
+
+  if (!*is_bound) {
+    for (i = 0; i < va_context->c.va_num_image_formats; i++) {
+      if (va_context->c.va_image_formats[i].fourcc == VA_FOURCC( 'Y', 'V', '1', '2' ) ||
+          va_context->c.va_image_formats[i].fourcc == VA_FOURCC( 'I', '4', '2', '0' ) /*||
+          va_context->c.va_image_formats[i].fourcc == VA_FOURCC( 'N', 'V', '1', '2' ) */) {
+        vaStatus = vaCreateImage( va_context->c.va_display, &va_context->c.va_image_formats[i], width, height, va_image );
+        if (!_x_va_check_status(va_context, vaStatus, "vaCreateImage()"))
+          goto error;
+        break;
+      }
+    }
+  }
+
+  void *p_base = NULL;
+
+  vaStatus = vaMapBuffer( va_context->c.va_display, va_image->buf, &p_base );
+  if (!_x_va_check_status(va_context, vaStatus, "vaMapBuffer()"))
+    goto error;
+
+  if (clear) {
+    if (va_image->format.fourcc == VA_FOURCC( 'Y', 'V', '1', '2' ) ||
+        va_image->format.fourcc == VA_FOURCC( 'I', '4', '2', '0' )) {
+      memset((uint8_t*)p_base + va_image->offsets[0],   0, va_image->pitches[0] * va_image->height);
+      memset((uint8_t*)p_base + va_image->offsets[1], 128, va_image->pitches[1] * (va_image->height/2));
+      memset((uint8_t*)p_base + va_image->offsets[2], 128, va_image->pitches[2] * (va_image->height/2));
+    } else if (va_image->format.fourcc == VA_FOURCC( 'N', 'V', '1', '2' ) ) {
+      memset((uint8_t*)p_base + va_image->offsets[0],   0, va_image->pitches[0] * va_image->height);
+      memset((uint8_t*)p_base + va_image->offsets[1], 128, va_image->pitches[1] * (va_image->height/2));
+    }
+  }
+
+  vaStatus = vaUnmapBuffer( va_context->c.va_display, va_image->buf );
+  _x_va_check_status(va_context, vaStatus, "vaUnmapBuffer()");
+
+  lprintf("_x_va_create_image 0x%08x width %d height %d format %s\n", va_image->image_id, va_image->width, va_image->height,
+      _x_va_string_of_VAImageFormat(&va_image->format));
+
+  return VA_STATUS_SUCCESS;
+
+error:
+  /* house keeping */
+  _x_va_destroy_image(va_context, va_image);
+  return VA_STATUS_ERROR_UNKNOWN;
+}
+
+static VAStatus _x_va_destroy_render_surfaces(vaapi_context_impl_t *va_context)
+{
+  int                 i;
+  VAStatus            vaStatus;
+
+  pthread_mutex_lock(&va_context->surfaces_lock);
+
+  for (i = 0; i < RENDER_SURFACES; i++) {
+    if (va_context->c.va_surface_ids[i] != VA_INVALID_SURFACE) {
+      vaStatus = vaSyncSurface(va_context->c.va_display, va_context->c.va_surface_ids[i]);
+      _x_va_check_status(va_context, vaStatus, "vaSyncSurface()");
+      vaStatus = vaDestroySurfaces(va_context->c.va_display, &va_context->c.va_surface_ids[i], 1);
+      _x_va_check_status(va_context, vaStatus, "vaDestroySurfaces()");
+      va_context->c.va_surface_ids[i] = VA_INVALID_SURFACE;
+
+      ff_vaapi_surface_t *va_surface  = &va_context->c.va_render_surfaces[i];
+      va_surface->index               = i;
+      va_surface->status              = SURFACE_FREE;
+      va_surface->va_surface_id       = va_context->c.va_surface_ids[i];
+    }
+  }
+
+  pthread_mutex_unlock(&va_context->surfaces_lock);
+
+  return VA_STATUS_SUCCESS;
+}
+
+void _x_va_close(vaapi_context_impl_t *va_context)
+{
+  VAStatus vaStatus;
+
+  if (va_context->c.va_context_id != VA_INVALID_ID) {
+    vaStatus = vaDestroyContext(va_context->c.va_display, va_context->c.va_context_id);
+    _x_va_check_status(va_context, vaStatus, "vaDestroyContext()");
+    va_context->c.va_context_id = VA_INVALID_ID;
+  }
+
+  _x_va_destroy_render_surfaces(va_context);
+
+  if (va_context->c.va_config_id != VA_INVALID_ID) {
+    vaStatus = vaDestroyConfig(va_context->c.va_display, va_context->c.va_config_id);
+    _x_va_check_status(va_context, vaStatus, "vaDestroyConfig()");
+    va_context->c.va_config_id = VA_INVALID_ID;
+  }
+
+  va_context->c.valid_context = 0;
+}
+
+VAStatus _x_va_init(vaapi_context_impl_t *va_context, int va_profile, int width, int height)
+{
+  VAConfigAttrib va_attrib;
+  VAStatus       vaStatus;
+  size_t         i;
+
+  _x_va_close(va_context);
+
+  va_context->c.width = width;
+  va_context->c.height = height;
+
+  xprintf(va_context->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : Context width %d height %d\n", va_context->c.width, va_context->c.height);
+
+  /* allocate decoding surfaces */
+  unsigned rt_format = VA_RT_FORMAT_YUV420;
+#if VA_CHECK_VERSION(0, 37, 0) && defined (VA_RT_FORMAT_YUV420_10BPP)
+  if (va_profile == VAProfileHEVCMain10) {
+    rt_format = VA_RT_FORMAT_YUV420_10BPP;
+  }
+#endif
+  vaStatus = vaCreateSurfaces(va_context->c.va_display, rt_format, va_context->c.width, va_context->c.height, va_context->c.va_surface_ids, RENDER_SURFACES, NULL, 0);
+  if (!_x_va_check_status(va_context, vaStatus, "vaCreateSurfaces()"))
+    goto error;
+
+  /* hardware decoding needs more setup */
+  if (va_profile >= 0) {
+    xprintf(va_context->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : Profile: %d (%s) Entrypoint %d (%s) Surfaces %d\n",
+            va_profile, _x_va_profile_to_string(va_profile), VAEntrypointVLD, _x_va_entrypoint_to_string(VAEntrypointVLD), RENDER_SURFACES);
+
+    memset (&va_attrib, 0, sizeof(va_attrib));
+    va_attrib.type = VAConfigAttribRTFormat;
+
+    vaStatus = vaGetConfigAttributes(va_context->c.va_display, va_profile, VAEntrypointVLD, &va_attrib, 1);
+    if (!_x_va_check_status(va_context, vaStatus, "vaGetConfigAttributes()"))
+      goto error;
+
+    if ((va_attrib.value & VA_RT_FORMAT_YUV420) == 0)
+      goto error;
+
+    vaStatus = vaCreateConfig(va_context->c.va_display, va_profile, VAEntrypointVLD, &va_attrib, 1, &va_context->c.va_config_id);
+    if (!_x_va_check_status(va_context, vaStatus, "vaCreateConfig()")) {
+      va_context->c.va_config_id = VA_INVALID_ID;
+      goto error;
+    }
+
+    vaStatus = vaCreateContext(va_context->c.va_display, va_context->c.va_config_id, va_context->c.width, va_context->c.height,
+                               VA_PROGRESSIVE, va_context->c.va_surface_ids, RENDER_SURFACES, &va_context->c.va_context_id);
+    if (!_x_va_check_status(va_context, vaStatus, "vaCreateContext()")) {
+      va_context->c.va_context_id = VA_INVALID_ID;
+      goto error;
+    }
+  }
+
+  pthread_mutex_lock(&va_context->surfaces_lock);
+
+  /* assign surfaces */
+  for (i = 0; i < RENDER_SURFACES; i++) {
+    ff_vaapi_surface_t *va_surface  = &va_context->c.va_render_surfaces[i];
+    va_surface->index               = i;
+    va_surface->status              = SURFACE_FREE;
+    va_surface->va_surface_id       = va_context->c.va_surface_ids[i];
+  }
+  va_context->c.va_head = 0;
+
+  pthread_mutex_unlock(&va_context->surfaces_lock);
+
+  va_context->c.valid_context = 1;
+  return VA_STATUS_SUCCESS;
+
+ error:
+  _x_va_close(va_context);
+  return VA_STATUS_ERROR_UNKNOWN;
+}
+
+static int _x_va_has_profile(VAProfile *va_profiles, int va_num_profiles, VAProfile profile)
+{
+  int i;
+  for (i = 0; i < va_num_profiles; i++) {
+    if (va_profiles[i] == profile)
+      return 1;
+  }
+  return 0;
+}
+
+int _x_va_profile_from_imgfmt(vaapi_context_impl_t *va_context, unsigned format)
+{
+  VAStatus            vaStatus;
+  int                 profile     = -1;
+  int                 i;
+  int                 va_num_profiles;
+  int                 max_profiles;
+  VAProfile           *va_profiles = NULL;
+
+  _x_assert(va_context->c.va_display);
+
+  max_profiles = vaMaxNumProfiles(va_context->c.va_display);
+  va_profiles = calloc(max_profiles, sizeof(*va_profiles));
+  if (!va_profiles)
+    goto out;
+
+  vaStatus = vaQueryConfigProfiles(va_context->c.va_display, va_profiles, &va_num_profiles);
+  if(!_x_va_check_status(va_context, vaStatus, "vaQueryConfigProfiles()"))
+    goto out;
+
+  xprintf(va_context->xine, XINE_VERBOSITY_LOG, LOG_MODULE " VAAPI Supported Profiles :\n");
+  for (i = 0; i < va_num_profiles; i++) {
+    xprintf(va_context->xine, XINE_VERBOSITY_LOG, LOG_MODULE "    %s\n", _x_va_profile_to_string(va_profiles[i]));
+  }
+
+  static const int mpeg2_profiles[] = { VAProfileMPEG2Main, VAProfileMPEG2Simple, -1 };
+  static const int mpeg4_profiles[] = { VAProfileMPEG4Main, VAProfileMPEG4AdvancedSimple, VAProfileMPEG4Simple, -1 };
+  static const int h264_profiles[]  = { VAProfileH264High, VAProfileH264Main, -1 };
+#if VA_CHECK_VERSION(0, 37, 0)
+  static const int hevc_profiles[]  = { VAProfileHEVCMain, VAProfileHEVCMain10, -1 };
+  static const int hevc_profiles10[]  = { VAProfileHEVCMain10, -1 };
+#endif
+  static const int wmv3_profiles[]  = { VAProfileVC1Main, VAProfileVC1Simple, -1 };
+  static const int vc1_profiles[]   = { VAProfileVC1Advanced, -1 };
+
+  const int *profiles = NULL;
+  switch (IMGFMT_VAAPI_CODEC(format)) 
+  {
+    case IMGFMT_VAAPI_CODEC_MPEG2:
+      profiles = mpeg2_profiles;
+      break;
+    case IMGFMT_VAAPI_CODEC_MPEG4:
+      profiles = mpeg4_profiles;
+      break;
+    case IMGFMT_VAAPI_CODEC_H264:
+      profiles = h264_profiles;
+      break;
+#if VA_CHECK_VERSION(0, 37, 0)
+    case IMGFMT_VAAPI_CODEC_HEVC:
+      switch (format) {
+        case IMGFMT_VAAPI_HEVC_MAIN10:
+          profiles = hevc_profiles10;
+          break;
+        case IMGFMT_VAAPI_HEVC:
+        default:
+          profiles = hevc_profiles;
+          break;
+      }
+      break;
+#endif
+    case IMGFMT_VAAPI_CODEC_VC1:
+      switch (format) {
+        case IMGFMT_VAAPI_WMV3:
+          profiles = wmv3_profiles;
+          break;
+        case IMGFMT_VAAPI_VC1:
+            profiles = vc1_profiles;
+            break;
+      }
+      break;
+  }
+
+  if (profiles) {
+    int i;
+    for (i = 0; profiles[i] != -1; i++) {
+      if (_x_va_has_profile(va_profiles, va_num_profiles, profiles[i])) {
+        profile = profiles[i];
+        xprintf(va_context->xine, XINE_VERBOSITY_LOG, LOG_MODULE " VAAPI Profile %s supported by your hardware\n", _x_va_profile_to_string(profiles[i]));
+        break;
+      }
+    }
+  }
+
+out:
+  free(va_profiles);
+  return profile;
+}
+
+#ifdef DEBUG_SURFACE
+# define DBG_SURFACE printf
+#else
+# define DBG_SURFACE(...) do { } while (0)
+#endif
+
+ff_vaapi_surface_t *_x_va_alloc_surface(vaapi_context_impl_t *va_context)
+{
+  ff_vaapi_surface_t   *va_surface = NULL;
+  VAStatus              vaStatus;
+
+  lprintf("get_vaapi_surface\n");
+
+  pthread_mutex_lock(&va_context->surfaces_lock);
+
+  /* Get next VAAPI surface marked as SURFACE_FREE */
+  while (1) {
+    va_surface = &va_context->c.va_render_surfaces[va_context->c.va_head];
+    va_context->c.va_head = (va_context->c.va_head + 1) % RENDER_SURFACES;
+
+    if (va_surface->status == SURFACE_FREE) {
+
+      VASurfaceStatus surf_status = 0;
+
+      if (va_context->query_va_status) {
+        vaStatus = vaQuerySurfaceStatus(va_context->c.va_display, va_surface->va_surface_id, &surf_status);
+        _x_va_check_status(va_context, vaStatus, "vaQuerySurfaceStatus()");
+      } else {
+        surf_status = VASurfaceReady;
+      }
+
+      if (surf_status == VASurfaceReady) {
+        va_surface->status = SURFACE_ALOC;
+        DBG_SURFACE("alloc_vaapi_surface 0x%08x\n", va_surface->va_surface_id);
+        break;
+      }
+      DBG_SURFACE("alloc_vaapi_surface busy\n");
+    }
+    DBG_SURFACE("alloc_vaapi_surface miss\n");
+  }
+
+  pthread_mutex_unlock(&va_context->surfaces_lock);
+
+  return va_surface;
+}
+
+void _x_va_render_surface(vaapi_context_impl_t *va_context, ff_vaapi_surface_t *va_surface)
+{
+  DBG_SURFACE("render_vaapi_surface 0x%08x\n", va_surface->va_surface_id);
+  _x_assert(va_surface->status == SURFACE_ALOC);
+
+  pthread_mutex_lock(&va_context->surfaces_lock);
+  va_surface->status = SURFACE_RENDER;
+  pthread_mutex_unlock(&va_context->surfaces_lock);
+}
+
+void _x_va_release_surface(vaapi_context_impl_t *va_context, ff_vaapi_surface_t *va_surface)
+{
+  _x_assert(va_surface->status == SURFACE_ALOC ||
+            va_surface->status == SURFACE_RENDER ||
+            va_surface->status == SURFACE_RENDER_RELEASE);
+
+  pthread_mutex_lock(&va_context->surfaces_lock);
+
+  if (va_surface->status == SURFACE_RENDER) {
+    va_surface->status = SURFACE_RENDER_RELEASE;
+    DBG_SURFACE("release_surface 0x%08x -> RENDER_RELEASE\n", va_surface->va_surface_id);
+  } else if (va_surface->status != SURFACE_RENDER_RELEASE) {
+    va_surface->status = SURFACE_FREE;
+    DBG_SURFACE("release_surface 0x%08x -> FREE\n", va_surface->va_surface_id);
+  }
+
+  pthread_mutex_unlock(&va_context->surfaces_lock);
+}
+
+void _x_va_surface_displayed(vaapi_context_impl_t *va_context, ff_vaapi_surface_t *va_surface)
+{
+  _x_assert(va_surface->status == SURFACE_RENDER ||
+            va_surface->status == SURFACE_RENDER_RELEASE);
+
+  pthread_mutex_lock(&va_context->surfaces_lock);
+
+  if (va_surface->status == SURFACE_RENDER_RELEASE) {
+    va_surface->status = SURFACE_FREE;
+    DBG_SURFACE("release_surface 0x%08x -> FREE\n", va_surface->va_surface_id, vo_frame);
+  } else if (va_surface->status == SURFACE_RENDER) {
+    va_surface->status = SURFACE_RELEASE;
+    DBG_SURFACE("release_surface 0x%08x -> RELEASE\n", va_surface->va_surface_id, vo_frame);
+  } else {
+    DBG_SURFACE("release_surface 0x%08x INVALID STATE %d\n",
+                va_surface->va_surface_id, vo_frame, va_surface->status);
+  }
+
+  pthread_mutex_unlock(&va_context->surfaces_lock);
+}
diff -urN xine-lib-1.2.11/src/video_out/vaapi/vaapi_util.h xine-lib-1.2/src/video_out/vaapi/vaapi_util.h
--- xine-lib-1.2.11/src/video_out/vaapi/vaapi_util.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/video_out/vaapi/vaapi_util.h	2022-01-15 22:03:19.617547310 +0100
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2012 Edgar Hucek <gimli|@dark-green.com>
+ * Copyright (C) 2012-2022 xine developers
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * vaapi_util.c, VAAPI video extension interface for xine
+ *
+ */
+
+#ifndef XINE_VAAPI_UTIL_H
+#define XINE_VAAPI_UTIL_H
+
+#include <xine/video_out.h>
+#include "accel_vaapi.h"
+
+#include <sys/types.h>
+
+#include <va/va.h>
+
+/*
+ *
+ */
+
+const char *_x_va_profile_to_string(VAProfile profile);
+const char *_x_va_entrypoint_to_string(VAEntrypoint entrypoint);
+
+void _x_va_reset_va_context(ff_vaapi_context_t *va_context);
+
+VAStatus _x_va_initialize(ff_vaapi_context_t *va_context, int visual_type, const void *visual, int opengl_render);
+VAStatus _x_va_terminate(ff_vaapi_context_t *va_context);
+
+/*
+ *
+ */
+
+typedef struct vaapi_context_impl vaapi_context_impl_t;
+
+#define  RENDER_SURFACES  50
+
+struct vaapi_context_impl {
+  ff_vaapi_context_t  c;
+
+  xine_t *xine;
+
+  int query_va_status;
+
+  pthread_mutex_t     surfaces_lock;
+  ff_vaapi_surface_t  va_render_surfaces_storage[RENDER_SURFACES + 1];
+  VASurfaceID         va_surface_ids_storage[RENDER_SURFACES + 1];
+};
+
+vaapi_context_impl_t *_x_va_new(xine_t *xine, int visual_type, const void *visual, int opengl_render);
+void _x_va_free(vaapi_context_impl_t **va_context);
+
+int _x_va_check_status(vaapi_context_impl_t *va_context, VAStatus vaStatus, const char *msg);
+
+void _x_va_destroy_image(vaapi_context_impl_t *va_context, VAImage *va_image);
+VAStatus _x_va_create_image(vaapi_context_impl_t *va_context, VASurfaceID va_surface_id, VAImage *va_image, int width, int height, int clear, int *is_bound);
+
+int _x_va_profile_from_imgfmt(vaapi_context_impl_t *va_context, unsigned format);
+
+/*
+ * surface pool
+ */
+
+void _x_va_close(vaapi_context_impl_t *va_context);
+VAStatus _x_va_init(vaapi_context_impl_t *va_context, int va_profile, int width, int height);
+
+ff_vaapi_surface_t *_x_va_alloc_surface(vaapi_context_impl_t *va_context);
+void _x_va_render_surface(vaapi_context_impl_t *va_context, ff_vaapi_surface_t *va_surface);
+void _x_va_release_surface(vaapi_context_impl_t *va_context, ff_vaapi_surface_t *va_surface);
+void _x_va_surface_displayed(vaapi_context_impl_t *va_context, ff_vaapi_surface_t *va_surface);
+
+#endif /* XINE_VAAPI_UTIL_H */
diff -urN xine-lib-1.2.11/src/video_out/video_out_caca.c xine-lib-1.2/src/video_out/video_out_caca.c
--- xine-lib-1.2.11/src/video_out/video_out_caca.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/video_out_caca.c	2022-01-15 22:03:19.597547225 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2003-2019 the xine project
+ * Copyright (C) 2003-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -35,13 +35,21 @@
 #include <sys/stat.h>
 #include <sys/mman.h>
 #include <sys/time.h>
+
 #ifdef HAVE_CUCUL
-#include <cucul.h>
+#  include <cucul.h>
+#  define caca_canvas_t cucul_canvas_t
+#  define caca_create_canvas cucul_create_canvas
+#  define caca_get_canvas_width cucul_get_canvas_width
+#  define caca_get_canvas_height cucul_get_canvas_height
+#  define caca_free_canvas cucul_free_canvas
+#  define caca_dither_t cucul_dither_t
+#  define caca_create_dither define cucul_create_dither
+#  define caca_dither_bitmap cucul_dither_bitmap
+#  define caca_free_dither cucul_free_dither
 #endif
 #include <caca.h>
 
-
-
 #include "xine.h"
 #include <xine/video_out.h>
 #include <xine/xine_internal.h>
@@ -56,7 +64,7 @@
 
   vo_frame_t         vo_frame;
 
-  cucul_dither_t *pixmap_s;  /* pixmap info structure */
+  caca_dither_t *pixmap_s;  /* pixmap info structure */
   uint8_t            *pixmap_d;  /* pixmap data */
   unsigned int       width, height;
 
@@ -74,7 +82,7 @@
 
   yuv2rgb_factory_t *yuv2rgb_factory;
 
-  cucul_canvas_t *cv;
+  caca_canvas_t *cv;
   caca_display_t *dp;
 
 } caca_driver_t;
@@ -104,7 +112,7 @@
 
   free (frame->pixmap_d);
   if (frame->pixmap_s)
-    cucul_free_dither (frame->pixmap_s);
+    caca_free_dither (frame->pixmap_s);
 
   frame->yuv2rgb->dispose (frame->yuv2rgb);
 
@@ -163,7 +171,7 @@
     _x_freep (&frame->pixmap_d);
 
     if (frame->pixmap_s) {
-      cucul_free_dither (frame->pixmap_s);
+      caca_free_dither (frame->pixmap_s);
       frame->pixmap_s = NULL;
     }
 
@@ -172,7 +180,7 @@
     frame->format = format;
 
     frame->pixmap_d = (uint8_t *) calloc (height, width * 4);
-    frame->pixmap_s = cucul_create_dither (32, width, height, width * 4,
+    frame->pixmap_s = caca_create_dither (32, width, height, width * 4,
       0xff0000, 0xff00, 0xff, 0);
 
     if (format == XINE_IMGFMT_YV12) {
@@ -214,7 +222,7 @@
 
   frame->vo_frame.free (&frame->vo_frame);
 
-  cucul_dither_bitmap(this->cv, 0, 0, cucul_get_canvas_width(this->cv)-1, cucul_get_canvas_height(this->cv)-1,
+  caca_dither_bitmap(this->cv, 0, 0, caca_get_canvas_width(this->cv)-1, caca_get_canvas_height(this->cv)-1,
     frame->pixmap_s, frame->pixmap_d);
   caca_refresh_display (this->dp);
 }
@@ -262,7 +270,7 @@
   caca_driver_t *this = (caca_driver_t*) this_gen;
   this->yuv2rgb_factory->dispose (this->yuv2rgb_factory);
   caca_free_display(this->dp);
-  cucul_free_canvas(this->cv);
+  caca_free_canvas(this->cv);
 
   free(this);
 }
@@ -309,7 +317,7 @@
     this->cv = caca_get_canvas(dp);
     this->dp = dp;
   } else {
-    this->cv = cucul_create_canvas(0, 0);
+    this->cv = caca_create_canvas(0, 0);
     this->dp = caca_create_display(this->cv);
   }
 
diff -urN xine-lib-1.2.11/src/video_out/video_out_fb.c xine-lib-1.2/src/video_out/video_out_fb.c
--- xine-lib-1.2.11/src/video_out/video_out_fb.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/video_out_fb.c	2022-01-15 22:03:19.626547348 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project and Fredrik Noring
+ * Copyright (C) 2000-2021 the xine project and Fredrik Noring
  *
  * This file is part of xine, a free video player.
  *
@@ -102,8 +102,6 @@
   uint8_t*           video_mem;            /* mmapped video memory */
   uint8_t*           data;
   int                yoffset;
-
-  struct fb_driver_s *this;
 } fb_frame_t;
 
 typedef struct fb_driver_s
@@ -205,10 +203,11 @@
 static void fb_frame_dispose(vo_frame_t *vo_img)
 {
   fb_frame_t *frame = xine_container_of(vo_img, fb_frame_t, vo_frame);
+  fb_driver_t *this = xine_container_of(vo_img->driver, fb_driver_t, vo_driver);
 
   frame->yuv2rgb->dispose (frame->yuv2rgb);
 
-  if(!frame->this->use_zero_copy)
+  if(!this->use_zero_copy)
      free(frame->data);
   free(frame);
 }
@@ -244,8 +243,6 @@
   frame->vo_frame.dispose    = fb_frame_dispose;
   frame->vo_frame.driver     = this_gen;
 
-  frame->this = this;
-
   if(this->use_zero_copy)
   {
     frame->yoffset = this->used_num_buffers * this->fb_var.yres;
diff -urN xine-lib-1.2.11/src/video_out/video_out_none.c xine-lib-1.2/src/video_out/video_out_none.c
--- xine-lib-1.2.11/src/video_out/video_out_none.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/video_out_none.c	2022-01-15 22:03:19.610547280 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2022 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -39,13 +39,9 @@
 #include <xine/xineutils.h>
 #include <xine/vo_scale.h>
 
-typedef struct {
-  vo_frame_t           vo_frame;
-  unsigned int         width;
-  unsigned int         height;
-  double               ratio;
-  int                  format;
-} vo_none_frame_t;
+#include "mem_frame.h"
+
+typedef mem_frame_t vo_none_frame_t;
 
 typedef struct {
   vo_driver_t          vo_driver;
@@ -59,28 +55,6 @@
 } vo_none_class_t;
 
 
-static void vo_none_free_framedata(vo_none_frame_t* frame) {
-  if(frame->vo_frame.base[0]) {
-    xine_free_aligned(frame->vo_frame.base[0]);
-    frame->vo_frame.base[0] = NULL;
-    frame->vo_frame.base[1] = NULL;
-    frame->vo_frame.base[2] = NULL;
-  }
-}
-
-static void vo_none_frame_dispose(vo_frame_t *vo_frame) {
-  vo_none_frame_t *frame = (vo_none_frame_t *)vo_frame;
-  vo_none_free_framedata(frame);
-  pthread_mutex_destroy (&frame->vo_frame.mutex);
-  free (frame);
-}
-
-static void vo_none_frame_field(vo_frame_t *vo_frame, int which_field) {
-  /* do nothing */
-  (void)vo_frame;
-  (void)which_field;
-}
-
 static uint32_t vo_none_get_capabilities(vo_driver_t *vo_driver) {
   /* No, we dont crop. Neither do we interpret color matrix or range. */
   /* But we also dont ask decoders to convert data just for the trash ;-) */
@@ -88,96 +62,6 @@
   return VO_CAP_YV12 | VO_CAP_YUY2 | VO_CAP_CROP | VO_CAP_COLOR_MATRIX | VO_CAP_FULLRANGE;
 }
 
-static vo_frame_t *vo_none_alloc_frame(vo_driver_t *vo_driver) {
-  /* none_driver_t *this = (none_driver_t *) vo_driver; */
-  vo_none_frame_t  *frame;
-
-  frame = calloc(1, sizeof(vo_none_frame_t));
-  if(!frame)
-    return NULL;
-
-  pthread_mutex_init(&frame->vo_frame.mutex, NULL);
-
-  frame->vo_frame.base[0] = NULL;
-  frame->vo_frame.base[1] = NULL;
-  frame->vo_frame.base[2] = NULL;
-
-  frame->vo_frame.proc_slice = NULL;
-  frame->vo_frame.proc_frame = NULL;
-  frame->vo_frame.field      = vo_none_frame_field;
-  frame->vo_frame.dispose    = vo_none_frame_dispose;
-  frame->vo_frame.driver     = vo_driver;
-
-  return (vo_frame_t *)frame;
-}
-
-static void vo_none_update_frame_format(vo_driver_t *vo_driver, vo_frame_t *vo_frame,
-				     uint32_t width, uint32_t height,
-				     double ratio, int format, int flags) {
-  vo_none_driver_t *this = (vo_none_driver_t *) vo_driver;
-  vo_none_frame_t  *frame = (vo_none_frame_t *) vo_frame;
-
-  (void)flags;
-  if((frame->width != width) || (frame->height != height) || (frame->format != format)) {
-
-    vo_none_free_framedata(frame);
-
-    frame->width  = width;
-    frame->height = height;
-    frame->format = format;
-
-    switch(format) {
-
-    case XINE_IMGFMT_YV12:
-      {
-	int y_size, uv_size;
-
-	frame->vo_frame.pitches[0] = 8*((width + 7) / 8);
-	frame->vo_frame.pitches[1] = 8*((width + 15) / 16);
-	frame->vo_frame.pitches[2] = 8*((width + 15) / 16);
-
-	y_size  = frame->vo_frame.pitches[0] * height;
-	uv_size = frame->vo_frame.pitches[1] * ((height+1)/2);
-
-	frame->vo_frame.base[0] = xine_malloc_aligned (y_size + 2*uv_size);
-        if (frame->vo_frame.base[0]) {
-          frame->vo_frame.base[1] = frame->vo_frame.base[0] + y_size;
-          frame->vo_frame.base[2] = frame->vo_frame.base[0] + y_size + uv_size;
-        } else {
-          frame->vo_frame.base[1] = NULL;
-          frame->vo_frame.base[2] = NULL;
-          xprintf (this->xine, XINE_VERBOSITY_DEBUG,
-            "video_out_none: error. (framedata allocation failed: out of memory)\n");
-          frame->width = 0;
-          frame->vo_frame.width = 0;
-        }
-      }
-      break;
-
-    case XINE_IMGFMT_YUY2:
-      frame->vo_frame.pitches[0] = 8*((width + 3) / 4);
-      frame->vo_frame.base[0] = xine_malloc_aligned(frame->vo_frame.pitches[0] * height);
-      frame->vo_frame.base[1] = NULL;
-      frame->vo_frame.base[2] = NULL;
-      if (!frame->vo_frame.base[0]) {
-        xprintf (this->xine, XINE_VERBOSITY_DEBUG,
-          "video_out_none: error. (framedata allocation failed: out of memory)\n");
-        frame->width = 0;
-        frame->vo_frame.width = 0;
-      }
-      break;
-
-    default:
-      xprintf (this->xine, XINE_VERBOSITY_DEBUG, "video_out_none: unknown frame format %04x)\n", format);
-      frame->width = 0;
-      frame->vo_frame.width = 0;
-      break;
-    }
-  }
-
-  frame->ratio = ratio;
-}
-
 static void vo_none_display_frame(vo_driver_t *vo_driver, vo_frame_t *vo_frame) {
   /* vo_none_driver_t  *driver = (vo_none_driver_t *)vo_driver; */
 
@@ -194,6 +78,9 @@
     return driver->ratio;
     break;
 
+  case VO_PROP_CAPS2:
+    return VO_CAP2_NV12;
+
   default:
     break;
   }
@@ -268,8 +155,8 @@
   driver->ratio  = XINE_VO_ASPECT_AUTO;
 
   driver->vo_driver.get_capabilities     = vo_none_get_capabilities;
-  driver->vo_driver.alloc_frame          = vo_none_alloc_frame ;
-  driver->vo_driver.update_frame_format  = vo_none_update_frame_format;
+  driver->vo_driver.alloc_frame          = mem_frame_alloc_frame;
+  driver->vo_driver.update_frame_format  = mem_frame_update_frame_format;
   driver->vo_driver.overlay_begin        = NULL;
   driver->vo_driver.overlay_blend        = NULL;
   driver->vo_driver.overlay_end          = NULL;
diff -urN xine-lib-1.2.11/src/video_out/video_out_opengl2.c xine-lib-1.2/src/video_out/video_out_opengl2.c
--- xine-lib-1.2.11/src/video_out/video_out_opengl2.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/video_out_opengl2.c	2022-01-15 22:03:19.619547318 +0100
@@ -1,6 +1,6 @@
 /*
  * kate: space-indent on; indent-width 2; mixedindent off; indent-mode cstyle; remove-trailing-space on;
- * Copyright (C) 2012-2020 the xine project
+ * Copyright (C) 2012-2022 the xine project
  * Copyright (C) 2012 Christophe Thommeret <hftom@free.fr>
  *
  * This file is part of xine, a free video player.
@@ -47,20 +47,14 @@
 #include <xine/xine_internal.h>
 #include <xine/xineutils.h>
 
-
-
 #define GL_GLEXT_PROTOTYPES
 #include <GL/gl.h>
 #include <GL/glext.h>
 
 #include "opengl/xine_gl.h"
 
-typedef struct {
-  vo_frame_t         vo_frame;
-  int                width, height, format, flags;
-  double             ratio;
-} opengl2_frame_t;
-
+#include "mem_frame.h"
+typedef mem_frame_t opengl2_frame_t;
 
 typedef struct {
   int       ovl_w, ovl_h;
@@ -76,27 +70,27 @@
   int       extent_height;
 } opengl2_overlay_t;
 
-
-
 typedef struct {
   int    compiled;
   GLuint shader;
   GLuint program;
 } opengl2_program_t;
 
-
+typedef enum {
+  OGL2_TEX_y = 0,
+  OGL2_TEX_u_v,
+  OGL2_TEX_yuv,
+  OGL2_TEX_uv,
+  OGL2_TEX_LAST
+} opengl2_tex_t;
 
 typedef struct {
-  GLuint y, u, v;
-  GLuint yuv;
+  GLuint tex[OGL2_TEX_LAST];
   int width;
   int height;
 } opengl2_yuvtex_t;
 
-
-
 typedef struct {
-
   vo_driver_t        vo_driver;
   vo_scale_t         sc;
 
@@ -104,12 +98,13 @@
 
   int                texture_float;
   opengl2_program_t  yuv420_program;
+  opengl2_program_t  nv12_program;
   opengl2_program_t  yuv422_program;
   opengl2_yuvtex_t   yuvtex;
   GLuint             videoPBO;
   GLuint             overlayPBO;
   GLuint             fbo;
-  GLuint             videoTex, videoTex2;
+  GLuint             videoTex[2];
   int                last_gui_width;
   int                last_gui_height;
 
@@ -119,7 +114,6 @@
   uint32_t           ovls_drawn;
   opengl2_overlay_t  overlays[XINE_VORAW_MAX_OVL];
 
-  opengl2_program_t  sharpness_program;
   float              csc_matrix[3 * 4];
   int                color_standard;
   int                update_csc;
@@ -127,8 +121,14 @@
   int                contrast;
   int                brightness;
   int                hue;
-  int                update_sharpness;
-  int                sharpness;
+  struct {
+    int              value, changed;
+    float            mid, side, corn;
+    opengl2_program_t program;
+  }                  sharp;
+  struct {
+    int              flags, changed;
+  }                  transform;
 
   opengl2_program_t  bicubic_pass1_program;
   opengl2_program_t  bicubic_pass2_program;
@@ -237,8 +237,6 @@
   unsigned             visual_type;
 } opengl2_class_t;
 
-
-
 static const char *bicubic_pass1_frag=
 "#extension GL_ARB_texture_rectangle : enable\n"
 "uniform sampler2DRect tex, lut;\n"
@@ -254,8 +252,6 @@
 "    gl_FragColor = sum;\n"
 "}\n";
 
-
-
 static const char *bicubic_pass2_frag=
 "#extension GL_ARB_texture_rectangle : enable\n"
 "uniform sampler2DRect tex, lut;\n"
@@ -271,8 +267,6 @@
 "    gl_FragColor = sum;\n"
 "}\n";
 
-
-
 #define LUTWIDTH 1000
 #define N_SPLINES 2
 #define CATMULLROM_SPLINE   0
@@ -342,46 +336,58 @@
   return 1;
 }
 
-
-
 static const char *blur_sharpen_frag=
 "#extension GL_ARB_texture_rectangle : enable\n"
 "uniform sampler2DRect tex;\n"
-"uniform float value;\n"
+"uniform float mid, side, corn;\n"
 "void main() {\n"
 "  vec2 pos = gl_TexCoord[0].xy;\n"
 "  vec4 c1;\n"
-"  float K;\n"
-"  if ( value < 0.0 )\n"
-"    K = value / 8.0;\n"
-"  else\n"
-"    K = value / 4.0;\n"
-"  c1 = texture2DRect( tex, pos ) * (1.0 + (8.0 * K));\n"
-"  c1 -= texture2DRect( tex, pos + vec2( 1.0, 0.0 ) ) * K;\n"
-"  c1 -= texture2DRect( tex, pos + vec2( -1.0, 0.0 ) ) * K;\n"
-"  c1 -= texture2DRect( tex, pos + vec2( 0.0, 1.0 ) ) * K;\n"
-"  c1 -= texture2DRect( tex, pos + vec2( 0.0, -1.0 ) ) * K;\n"
-"  c1 -= texture2DRect( tex, pos + vec2( 1.0, 1.0 ) ) * K;\n"
-"  c1 -= texture2DRect( tex, pos + vec2( -1.0, 1.0 ) ) * K;\n"
-"  c1 -= texture2DRect( tex, pos + vec2( -1.0, -1.0 ) ) * K;\n"
-"  c1 -= texture2DRect( tex, pos + vec2( 1.0, -1.0 ) ) * K;\n"
+"  c1 =   texture2DRect (tex, pos) * mid\n"
+"     +  (texture2DRect (tex, pos + vec2 (-1.0,  0.0))\n"
+"       + texture2DRect (tex, pos + vec2 ( 0.0, -1.0))\n"
+"       + texture2DRect (tex, pos + vec2 ( 1.0,  0.0))\n"
+"       + texture2DRect (tex, pos + vec2 ( 0.0,  1.0))) * side\n"
+"     +  (texture2DRect (tex, pos + vec2 (-1.0, -1.0))\n"
+"       + texture2DRect (tex, pos + vec2 ( 1.0, -1.0))\n"
+"       + texture2DRect (tex, pos + vec2 (-1.0,  1.0))\n"
+"       + texture2DRect (tex, pos + vec2 ( 1.0,  1.0))) * corn;\n"
 "  gl_FragColor = c1 ;\n"
 "}\n";
 
-
-
-static const char *yuv420_frag=
+static const char *yuv420_frag =
 "#extension GL_ARB_texture_rectangle : enable\n"
-"uniform sampler2DRect texY, texU, texV;\n"
+"uniform sampler2DRect texY, texU_V;\n"
+"uniform vec2 offsV;\n"
 "uniform vec4 r_coefs, g_coefs, b_coefs;\n"
 "void main(void) {\n"
 "    vec4 rgb;\n"
 "    vec4 yuv;\n"
 "    vec2 ycoord = gl_TexCoord[0].xy;\n"
 "    vec2 uvcoord = ycoord / 2.0;\n"
-"    yuv.r = texture2DRect( texY, ycoord ).r;\n"
-"    yuv.g = texture2DRect( texU, uvcoord ).r;\n"
-"    yuv.b = texture2DRect( texV, uvcoord ).r;\n"
+"    yuv.r = texture2DRect (texY, ycoord).r;\n"
+"    yuv.g = texture2DRect (texU_V, uvcoord).r;\n"
+"    yuv.b = texture2DRect (texU_V, uvcoord + offsV).r;\n"
+"    yuv.a = 1.0;\n"
+"    rgb.r = dot (yuv, r_coefs);\n"
+"    rgb.g = dot (yuv, g_coefs);\n"
+"    rgb.b = dot (yuv, b_coefs);\n"
+"    rgb.a = 1.0;\n"
+"    gl_FragColor = rgb;\n"
+"}\n";
+
+static const char *nv12_frag =
+"#extension GL_ARB_texture_rectangle : enable\n"
+"uniform sampler2DRect texY, texUV;\n"
+"uniform vec4 r_coefs, g_coefs, b_coefs;\n"
+"void main (void) {\n"
+"    vec4 rgb;\n"
+"    vec4 yuv;\n"
+"    vec2 ycoord = gl_TexCoord[0].xy;\n"
+"    vec2 uvcoord = vec2 (ycoord.x - step (1.0, mod (ycoord.x, 2.0)), ycoord.y / 2.0);\n"
+"    yuv.r = texture2DRect (texY, ycoord).r;\n"
+"    yuv.g = texture2DRect (texUV, uvcoord).r;\n"
+"    yuv.b = texture2DRect (texUV, uvcoord + vec2 (1.0, 0.0)).r;\n"
 "    yuv.a = 1.0;\n"
 "    rgb.r = dot( yuv, r_coefs );\n"
 "    rgb.g = dot( yuv, g_coefs );\n"
@@ -390,9 +396,7 @@
 "    gl_FragColor = rgb;\n"
 "}\n";
 
-
-
-static const char *yuv422_frag=
+static const char *yuv422_frag =
 "#extension GL_ARB_texture_rectangle : enable\n"
 "uniform sampler2DRect texYUV;\n"
 "uniform vec4 r_coefs, g_coefs, b_coefs;\n"
@@ -412,8 +416,6 @@
 "    gl_FragColor = vec4(rgb, 1.0);\n"
 "}\n";
 
-
-
 static void load_csc_matrix( GLuint prog, float *cf )
 {
     glUniform4f( glGetUniformLocationARB( prog, "r_coefs" ), cf[0], cf[1], cf[2], cf[3] );
@@ -421,11 +423,9 @@
     glUniform4f( glGetUniformLocationARB( prog, "b_coefs" ), cf[8], cf[9], cf[10], cf[11] );
 }
 
-
-
 static int opengl2_build_program( opengl2_driver_t *this, opengl2_program_t *prog, const char **source, const char *name )
 {
-  xprintf( this->xine, XINE_VERBOSITY_DEBUG, "video_out_opengl2: compiling shader %s\n", name );
+  xprintf( this->xine, XINE_VERBOSITY_DEBUG, LOG_MODULE ": compiling shader %s\n", name );
   if ( !(prog->shader = glCreateShader( GL_FRAGMENT_SHADER )) )
     return 0;
   if ( !(prog->program = glCreateProgram()) )
@@ -443,7 +443,7 @@
 
   glGetShaderInfoLog( prog->shader, length, &length, log );
   if ( length ) {
-    xprintf( this->xine, XINE_VERBOSITY_DEBUG, "video_out_opengl2: Shader %s Compilation Log:\n", name );
+    xprintf( this->xine, XINE_VERBOSITY_DEBUG, LOG_MODULE ": Shader %s Compilation Log:\n", name );
     if ( this->xine->verbosity >= XINE_VERBOSITY_DEBUG )
       fwrite( log, 1, length, stdout );
   }
@@ -458,7 +458,7 @@
 
   glGetProgramInfoLog( prog->program, length, &length, log );
   if ( length ) {
-    xprintf( this->xine, XINE_VERBOSITY_DEBUG, "video_out_opengl2: Shader %s Linking Log:\n", name );
+    xprintf( this->xine, XINE_VERBOSITY_DEBUG, LOG_MODULE ": Shader %s Linking Log:\n", name );
     if ( this->xine->verbosity >= XINE_VERBOSITY_DEBUG )
       fwrite( log, 1, length, stdout );
   }
@@ -469,37 +469,37 @@
   return 1;
 }
 
-
-
 static void opengl2_delete_program( opengl2_program_t *prog )
 {
   glDeleteProgram( prog->program );
   glDeleteShader( prog->shader );
 }
 
-
+static void _config_texture(GLuint texture, GLsizei width, GLsizei height,
+                            GLenum format, GLenum type, GLenum minmag_filter)
+{
+  if (texture) {
+    glBindTexture(GL_TEXTURE_RECTANGLE_ARB, texture);
+    glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, format, width, height, 0, format, type, NULL);
+    glTexParameterf(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameterf(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, minmag_filter);
+    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, minmag_filter);
+  }
+}
 
 static int opengl2_check_textures_size( opengl2_driver_t *this_gen, int w, int h )
 {
   opengl2_driver_t *this = this_gen;
   opengl2_yuvtex_t *ytex = &this->yuvtex;
+  int uvh;
 
   w = (w + 15) & ~15;
   if ( (w == ytex->width) && (h == ytex->height) )
     return 1;
 
-  if ( ytex->y )
-    glDeleteTextures( 1, &ytex->y );
-  if ( ytex->u )
-    glDeleteTextures( 1, &ytex->u );
-  if ( ytex->v )
-    glDeleteTextures( 1, &ytex->v );
-  if ( ytex->yuv )
-    glDeleteTextures( 1, &ytex->yuv );
-  if ( this->videoTex )
-    glDeleteTextures( 1, &this->videoTex );
-  if ( this->videoTex2 )
-    glDeleteTextures( 1, &this->videoTex2 );
+  glDeleteTextures (OGL2_TEX_LAST, ytex->tex);
+  glDeleteTextures (2, this->videoTex);
 
   if ( !this->videoPBO ) {
     glGenBuffers( 1, &this->videoPBO );
@@ -513,63 +513,23 @@
       return 0;
   }
 
-  glGenTextures( 1, &this->videoTex );
-  if ( !this->videoTex )
-    return 0;
-
-  glGenTextures( 1, &this->videoTex2 );
-  if ( !this->videoTex2 )
+  glGenTextures (2, this->videoTex);
+  if (!this->videoTex[0] || !this->videoTex[1])
     return 0;
 
-  glGenTextures( 1, &ytex->y );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, ytex->y );
-  glTexImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, GL_LUMINANCE, w, h, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, NULL );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-  glGenTextures( 1, &ytex->u );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, ytex->u );
-  glTexImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, GL_LUMINANCE, w/2, h/2, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, NULL );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-  glGenTextures( 1, &ytex->v );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, ytex->v );
-  glTexImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, GL_LUMINANCE, w/2, h/2, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, NULL );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-  glGenTextures( 1, &ytex->yuv );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, ytex->yuv );
-  glTexImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, GL_LUMINANCE_ALPHA, w, h, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, NULL );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, 0 );
+  glGenTextures (OGL2_TEX_LAST, ytex->tex);
+  uvh = (h + 1) >> 1;
+  _config_texture (ytex->tex[OGL2_TEX_y],   w,      h,       GL_LUMINANCE, GL_UNSIGNED_BYTE, GL_NEAREST);
+  _config_texture (ytex->tex[OGL2_TEX_u_v], w >> 1, uvh * 2, GL_LUMINANCE, GL_UNSIGNED_BYTE, GL_NEAREST);
+  _config_texture (ytex->tex[OGL2_TEX_yuv], w,      h,       GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, GL_NEAREST);
+  _config_texture (ytex->tex[OGL2_TEX_uv],  w,      uvh,     GL_LUMINANCE, GL_UNSIGNED_BYTE, GL_NEAREST);
 
   ytex->width = w;
   ytex->height = h;
 
-  glGenTextures( 1, &this->videoTex );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, this->videoTex );
-  glTexImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, 0 );
+  _config_texture (this->videoTex[0], w, h, GL_RGBA, GL_UNSIGNED_BYTE, GL_LINEAR);
+  _config_texture (this->videoTex[1], w, h, GL_RGBA, GL_UNSIGNED_BYTE, GL_LINEAR);
 
-  glGenTextures( 1, &this->videoTex2 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, this->videoTex2 );
-  glTexImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-  glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
   glBindTexture( GL_TEXTURE_RECTANGLE_ARB, 0 );
 
   glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, this->videoPBO );
@@ -577,8 +537,8 @@
   glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, 0 );
 
   glBindFramebuffer( GL_FRAMEBUFFER, this->fbo );
-  glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_RECTANGLE_ARB, this->videoTex, 0 );
-  glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_RECTANGLE_ARB, this->videoTex2, 0 );
+  glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_RECTANGLE_ARB, this->videoTex[0], 0 );
+  glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_RECTANGLE_ARB, this->videoTex[1], 0 );
   glBindFramebuffer( GL_FRAMEBUFFER, 0 );
 
   return 1;
@@ -601,7 +561,7 @@
   if ( overlay->rle && !this->overlayPBO ) {
     glGenBuffers( 1, &this->overlayPBO );
     if ( !this->overlayPBO ) {
-      xprintf( this->xine, XINE_VERBOSITY_LOG, "video_out_opengl2: overlay PBO failed\n" );
+      xprintf( this->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": overlay PBO failed\n" );
       return;
     }
   }
@@ -714,122 +674,6 @@
 }
 
 
-
-
-static void opengl2_frame_proc_slice( vo_frame_t *vo_img, uint8_t **src )
-{
-  (void)src;
-  vo_img->proc_called = 1;
-}
-
-
-
-static void opengl2_frame_field( vo_frame_t *vo_img, int which_field )
-{
-  (void)vo_img;
-  (void)which_field;
-}
-
-
-
-static void opengl2_frame_dispose( vo_frame_t *vo_img )
-{
-  opengl2_frame_t  *frame = (opengl2_frame_t *) vo_img ;
-
-  xine_free_aligned (frame->vo_frame.base[0]);
-  pthread_mutex_destroy (&frame->vo_frame.mutex);
-  free (frame);
-}
-
-
-
-static vo_frame_t *opengl2_alloc_frame( vo_driver_t *this_gen )
-{
-  opengl2_frame_t  *frame;
-
-  frame = (opengl2_frame_t *) calloc(1, sizeof(opengl2_frame_t));
-
-  if (!frame)
-    return NULL;
-
-  frame->vo_frame.base[0] = frame->vo_frame.base[1] = frame->vo_frame.base[2] = NULL;
-  frame->width = frame->height = frame->format = frame->flags = 0;
-
-  pthread_mutex_init (&frame->vo_frame.mutex, NULL);
-
-  /*
-   * supply required functions/fields
-   */
-  frame->vo_frame.proc_slice = opengl2_frame_proc_slice;
-  frame->vo_frame.proc_frame = NULL;
-  frame->vo_frame.field      = opengl2_frame_field;
-  frame->vo_frame.dispose    = opengl2_frame_dispose;
-  frame->vo_frame.driver     = this_gen;
-
-  return (vo_frame_t *) frame;
-}
-
-
-
-static void opengl2_update_frame_format( vo_driver_t *this_gen, vo_frame_t *frame_gen,
-      uint32_t width, uint32_t height, double ratio, int format, int flags )
-{
-  opengl2_frame_t *frame = (opengl2_frame_t *) frame_gen;
-
-  (void)this_gen;
-  /* Check frame size and format and reallocate if necessary */
-  if ( (frame->width != (int)width) || (frame->height != (int)height) || (frame->format != format) ) {
-
-    /* (re-) allocate render space */
-    xine_freep_aligned (&frame->vo_frame.base[0]);
-    frame->vo_frame.base[1] = NULL;
-    frame->vo_frame.base[2] = NULL;
-
-    if (format == XINE_IMGFMT_YV12) {
-      int w = (width + 15) & ~15;
-      int ysize = w * height;
-      int uvsize = (w >> 1) * ((height + 1) >> 1);
-      frame->vo_frame.pitches[0] = w;
-      frame->vo_frame.pitches[1] = w >> 1;
-      frame->vo_frame.pitches[2] = w >> 1;
-      frame->vo_frame.base[0] = xine_malloc_aligned (ysize + 2 * uvsize);
-      if (!frame->vo_frame.base[0]) {
-        frame->width = 0;
-        frame->vo_frame.width = 0; /* tell vo_get_frame () to retry later */
-        return;
-      }
-      memset (frame->vo_frame.base[0], 0, ysize);
-      frame->vo_frame.base[1] = frame->vo_frame.base[0] + ysize;
-      memset (frame->vo_frame.base[1], 128, 2 * uvsize);
-      frame->vo_frame.base[2] = frame->vo_frame.base[1] + uvsize;
-    } else if (format == XINE_IMGFMT_YUY2){
-      frame->vo_frame.pitches[0] = ((width + 15) & ~15) << 1;
-      frame->vo_frame.base[0] = xine_malloc_aligned (frame->vo_frame.pitches[0] * height);
-      if (frame->vo_frame.base[0]) {
-        const union {uint8_t bytes[4]; uint32_t word;} black = {{0, 128, 0, 128}};
-        uint32_t *q = (uint32_t *)frame->vo_frame.base[0];
-        int i;
-        for (i = frame->vo_frame.pitches[0] * height / 4; i > 0; i--)
-          *q++ = black.word;
-      } else {
-        frame->width = 0;
-        frame->vo_frame.width = 0; /* tell vo_get_frame () to retry later */
-        return;
-      }
-    }
-
-    frame->width = width;
-    frame->height = height;
-    frame->format = format;
-  }
-  /* flags dont matter for buffers yet, so just copy them */
-  frame->flags = flags;
-
-  frame->ratio = ratio;
-}
-
-
-
 static int opengl2_redraw_needed( vo_driver_t *this_gen )
 {
   opengl2_driver_t  *this = (opengl2_driver_t *) this_gen;
@@ -839,7 +683,7 @@
     _x_vo_scale_compute_output_size( &this->sc );
     return 1;
   }
-  return this->update_csc | this->update_sharpness;
+  return this->update_csc | this->sharp.changed | this->transform.changed;
 }
 
 
@@ -922,7 +766,7 @@
     that->color_standard = color_standard;
     that->update_csc = 0;
 
-    xprintf (that->xine, XINE_VERBOSITY_LOG,"video_out_opengl2: b %d c %d s %d h %d [%s]\n",
+    xprintf (that->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": b %d c %d s %d h %d [%s]\n",
       that->brightness, that->contrast, that->saturation, that->hue, cm_names[color_standard]);
   }
 }
@@ -1061,13 +905,13 @@
 
 static GLuint opengl2_swap_textures( opengl2_driver_t *that, GLuint current_dest )
 {
-  if ( current_dest == that->videoTex ) {
+  if (current_dest == that->videoTex[0]) {
     glDrawBuffer( GL_COLOR_ATTACHMENT1 );
-    return that->videoTex2;
+    return that->videoTex[1];
   }
 
   glDrawBuffer( GL_COLOR_ATTACHMENT0 );
-  return that->videoTex;
+  return that->videoTex[0];
 }
 
 
@@ -1076,8 +920,8 @@
 {
   GLuint ret = video_texture;
   
-  if ( !that->sharpness_program.compiled ) {
-    if ( !opengl2_build_program( that, &that->sharpness_program, &blur_sharpen_frag, "blur_sharpen_frag" ) )
+  if (!that->sharp.program.compiled) {
+    if (!opengl2_build_program (that, &that->sharp.program, &blur_sharpen_frag, "blur_sharpen_frag"))
       return ret;
   }
 
@@ -1085,12 +929,11 @@
   glActiveTexture( GL_TEXTURE0 );
   glBindTexture( GL_TEXTURE_RECTANGLE_ARB, video_texture );
 
-  float value = that->sharpness / 100.0 * frame->width / 1920.0;
-
-  glUseProgram( that->sharpness_program.program );
-  glUniform1i( glGetUniformLocationARB( that->sharpness_program.program, "tex" ), 0 );
-  glUniform1f( glGetUniformLocationARB( that->sharpness_program.program, "value" ), value );
-  //fprintf(stderr, "vo_opengl2 : sharpness = %f\n", value);
+  glUseProgram (that->sharp.program.program);
+  glUniform1i (glGetUniformLocationARB (that->sharp.program.program, "tex"), 0);
+  glUniform1f (glGetUniformLocationARB (that->sharp.program.program, "mid"), that->sharp.mid);
+  glUniform1f (glGetUniformLocationARB (that->sharp.program.program, "side"), that->sharp.side);
+  glUniform1f (glGetUniformLocationARB (that->sharp.program.program, "corn"), that->sharp.corn);
 
   glBegin( GL_QUADS );
     glTexCoord2f( 0, 0 );                           glVertex3f( 0, 0, 0.);
@@ -1105,253 +948,237 @@
 }
 
 
-
-static int opengl2_draw_video_bicubic( opengl2_driver_t *that, int guiw, int guih, GLfloat u, GLfloat v, GLfloat u1, GLfloat v1,
-    GLfloat x, GLfloat y, GLfloat x1, GLfloat y1, GLuint video_texture )
-{
-  if ( !that->bicubic_lut_texture ) {
-    if ( !create_lut_texture( that ) )
+typedef struct {
+  int guiw, guih;
+  int sx1, sx2, sy1, sy2, dx1, dx2, dy1, dy2, dw, dh;
+  GLuint video_texture;
+} opengl2_draw_info_t;
+
+static int opengl2_draw_video_bicubic (opengl2_driver_t *that, const opengl2_draw_info_t *info) {
+  if (!that->bicubic_lut_texture) {
+    if (!create_lut_texture (that))
       return 0;
   }
 
-  if ( !that->bicubic_pass1_program.compiled && !opengl2_build_program( that, &that->bicubic_pass1_program, &bicubic_pass1_frag, "bicubic_pass1_frag" ) )
+  if (!that->bicubic_pass1_program.compiled
+    && !opengl2_build_program (that, &that->bicubic_pass1_program, &bicubic_pass1_frag, "bicubic_pass1_frag"))
     return 0;
-  if ( !that->bicubic_pass2_program.compiled && !opengl2_build_program( that, &that->bicubic_pass2_program, &bicubic_pass2_frag, "bicubic_pass2_frag" ) )
+  if (!that->bicubic_pass2_program.compiled
+    && !opengl2_build_program (that, &that->bicubic_pass2_program, &bicubic_pass2_frag, "bicubic_pass2_frag"))
     return 0;
-  if ( !that->bicubic_fbo ) {
-    glGenFramebuffers( 1, &that->bicubic_fbo );
-    if ( !that->bicubic_fbo )
+  if (!that->bicubic_fbo) {
+    glGenFramebuffers (1, &that->bicubic_fbo);
+    if (!that->bicubic_fbo)
       return 0;
   }
-  if ( (that->bicubic_pass1_texture_width != (x1 - x)) || (that->bicubic_pass1_texture_height != (v1 - v) ) ) {
-    if ( that->bicubic_pass1_texture )
-      glDeleteTextures( 1, &that->bicubic_pass1_texture );
-    glGenTextures( 1, &that->bicubic_pass1_texture );
-    if ( !that->bicubic_pass1_texture )
+  if ((that->bicubic_pass1_texture_width != info->dw) || (that->bicubic_pass1_texture_height != info->dh)) {
+    if (that->bicubic_pass1_texture)
+      glDeleteTextures (1, &that->bicubic_pass1_texture);
+    glGenTextures (1, &that->bicubic_pass1_texture);
+    if (!that->bicubic_pass1_texture)
       return 0;
-    glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->bicubic_pass1_texture );
-    glTexImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, x1 - x, v1 - v, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL );
-    glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-    glTexParameterf( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
-    glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-    glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-    glBindTexture( GL_TEXTURE_RECTANGLE_ARB, 0 );
-    that->bicubic_pass1_texture_width = x1 - x;
-    that->bicubic_pass1_texture_height = v1 - v;
-  }
-  glBindFramebuffer( GL_FRAMEBUFFER, that->bicubic_fbo );
-  glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_RECTANGLE_ARB, that->bicubic_pass1_texture, 0 );
-
-  glViewport( 0, 0, x1 - x, v1 - v );
-  glMatrixMode( GL_PROJECTION );
-  glLoadIdentity();
-  glOrtho( 0.0, x1 - x, 0.0, v1 - v, -1.0, 1.0 );
-  glMatrixMode( GL_MODELVIEW );
-  glLoadIdentity();
-
-  glActiveTexture( GL_TEXTURE0 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, video_texture );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-  glActiveTexture( GL_TEXTURE1 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->bicubic_lut_texture );
-  glUseProgram( that->bicubic_pass1_program.program );
-  glUniform1i( glGetUniformLocationARB( that->bicubic_pass1_program.program, "tex" ), 0 );
-  glUniform1i( glGetUniformLocationARB( that->bicubic_pass1_program.program, "lut" ), 1 );
-  glUniform1f( glGetUniformLocationARB( that->bicubic_pass1_program.program, "spline" ), CATMULLROM_SPLINE );
-
-  glBegin( GL_QUADS );
-    glTexCoord2f( u, v );    glVertex3f( 0.0, 0.0, 0.);
-    glTexCoord2f( u, v1 );   glVertex3f( 0.0, v1 - v, 0.);
-    glTexCoord2f( u1, v1 );  glVertex3f( x1 - x, v1 - v, 0.);
-    glTexCoord2f( u1, v );   glVertex3f( x1 - x, 0.0, 0.);
-  glEnd();
-
-  glActiveTexture( GL_TEXTURE0 );
-  glBindFramebuffer( GL_FRAMEBUFFER, 0 );
-
-  glViewport( 0, 0, guiw, guih );
-  glMatrixMode( GL_PROJECTION );
-  glLoadIdentity();
-  glOrtho( 0.0, guiw, guih, 0.0, -1.0, 1.0 );
-  glMatrixMode( GL_MODELVIEW );
-  glLoadIdentity();
-
-  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
-
-  glActiveTexture( GL_TEXTURE0 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->bicubic_pass1_texture );
-  glActiveTexture( GL_TEXTURE1 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->bicubic_lut_texture );
-  glUseProgram( that->bicubic_pass2_program.program );
-  glUniform1i( glGetUniformLocationARB( that->bicubic_pass2_program.program, "tex" ), 0 );
-  glUniform1i( glGetUniformLocationARB( that->bicubic_pass2_program.program, "lut" ), 1 );
-  glUniform1f( glGetUniformLocationARB( that->bicubic_pass2_program.program, "spline" ), CATMULLROM_SPLINE );
-
-  glBegin( GL_QUADS );
-    glTexCoord2f( 0.0, 0.0 );        glVertex3f( x, y, 0.);
-    glTexCoord2f( 0.0, v1 - v );     glVertex3f( x, y1, 0.);
-    glTexCoord2f( x1 - x, v1 - v );  glVertex3f( x1, y1, 0.);
-    glTexCoord2f( x1 - x, 0.0 );     glVertex3f( x1, y, 0.);
-  glEnd();
+    _config_texture (that->bicubic_pass1_texture, info->dw, info->dh, GL_RGBA, GL_UNSIGNED_BYTE, GL_NEAREST);
+    glBindTexture (GL_TEXTURE_RECTANGLE_ARB, 0);
+    that->bicubic_pass1_texture_width  = info->dw;
+    that->bicubic_pass1_texture_height = info->dh;
+  }
+  glBindFramebuffer (GL_FRAMEBUFFER, that->bicubic_fbo);
+  glFramebufferTexture2D (GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_RECTANGLE_ARB, that->bicubic_pass1_texture, 0);
+
+  glViewport (0, 0, info->dw, info->dh);
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, info->dw, 0, info->dh, -1, 1);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+
+  glActiveTexture (GL_TEXTURE0);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, info->video_texture);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  glActiveTexture (GL_TEXTURE1);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->bicubic_lut_texture);
+  glUseProgram (that->bicubic_pass1_program.program);
+  glUniform1i (glGetUniformLocationARB (that->bicubic_pass1_program.program, "tex"), 0);
+  glUniform1i (glGetUniformLocationARB (that->bicubic_pass1_program.program, "lut"), 1);
+  glUniform1f (glGetUniformLocationARB (that->bicubic_pass1_program.program, "spline"), CATMULLROM_SPLINE);
+
+  glBegin (GL_QUADS);
+    glTexCoord2f (info->sx1, info->sy1); glVertex3f (       0,        0, 0);
+    glTexCoord2f (info->sx1, info->sy2); glVertex3f (       0, info->dh, 0);
+    glTexCoord2f (info->sx2, info->sy2); glVertex3f (info->dw, info->dh, 0);
+    glTexCoord2f (info->sx2, info->sy1); glVertex3f (info->dw,        0, 0);
+  glEnd ();
+
+  glActiveTexture (GL_TEXTURE0);
+  glBindFramebuffer (GL_FRAMEBUFFER, 0);
+
+  glViewport (0, 0, info->guiw, info->guih);
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, info->guiw, info->guih, 0, -1, 1);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+
+  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+  glActiveTexture (GL_TEXTURE0);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->bicubic_pass1_texture);
+  glActiveTexture (GL_TEXTURE1);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->bicubic_lut_texture);
+  glUseProgram (that->bicubic_pass2_program.program);
+  glUniform1i (glGetUniformLocationARB (that->bicubic_pass2_program.program, "tex"), 0);
+  glUniform1i (glGetUniformLocationARB (that->bicubic_pass2_program.program, "lut"), 1);
+  glUniform1f (glGetUniformLocationARB (that->bicubic_pass2_program.program, "spline"), CATMULLROM_SPLINE);
+
+  glBegin (GL_QUADS);
+    glTexCoord2f (       0,        0); glVertex3f (info->dx1, info->dy1, 0);
+    glTexCoord2f (       0, info->dh); glVertex3f (info->dx1, info->dy2, 0);
+    glTexCoord2f (info->dw, info->dh); glVertex3f (info->dx2, info->dy2, 0);
+    glTexCoord2f (info->dw,        0); glVertex3f (info->dx2, info->dy1, 0);
+  glEnd ();
 
-  glUseProgram( 0 );
+  glUseProgram (0);
 
   return 1;
 }
 
-
-
-static int opengl2_draw_video_cubic_x( opengl2_driver_t *that, int guiw, int guih, GLfloat u, GLfloat v, GLfloat u1, GLfloat v1,
-    GLfloat x, GLfloat y, GLfloat x1, GLfloat y1, GLuint video_texture )
-{
-  if ( !that->bicubic_lut_texture ) {
-    if ( !create_lut_texture( that ) )
+static int opengl2_draw_video_cubic_x (opengl2_driver_t *that, const opengl2_draw_info_t *info) {
+  if (!that->bicubic_lut_texture) {
+    if (!create_lut_texture (that))
       return 0;
   }
 
-  if ( !that->bicubic_pass1_program.compiled && !opengl2_build_program( that, &that->bicubic_pass1_program, &bicubic_pass1_frag, "bicubic_pass1_frag" ) )
+  if (!that->bicubic_pass1_program.compiled
+    && !opengl2_build_program (that, &that->bicubic_pass1_program, &bicubic_pass1_frag, "bicubic_pass1_frag"))
     return 0;
 
-  glViewport( 0, 0, guiw, guih );
-  glMatrixMode( GL_PROJECTION );
-  glLoadIdentity();
-  glOrtho( 0.0, guiw, guih, 0.0, -1.0, 1.0 );
-  glMatrixMode( GL_MODELVIEW );
-  glLoadIdentity();
-
-  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
-
-  glActiveTexture( GL_TEXTURE0 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, video_texture );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-  glActiveTexture( GL_TEXTURE1 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->bicubic_lut_texture );
-  glUseProgram( that->bicubic_pass1_program.program );
-  glUniform1i( glGetUniformLocationARB( that->bicubic_pass1_program.program, "tex" ), 0 );
-  glUniform1i( glGetUniformLocationARB( that->bicubic_pass1_program.program, "lut" ), 1 );
-  glUniform1f( glGetUniformLocationARB( that->bicubic_pass1_program.program, "spline" ), CATMULLROM_SPLINE );
-
-  glBegin( GL_QUADS );
-    glTexCoord2f( u, v );     glVertex3f( x, y, 0.);
-    glTexCoord2f( u, v1 );    glVertex3f( x, y1, 0.);
-    glTexCoord2f( u1, v1 );   glVertex3f( x1, y1, 0.);
-    glTexCoord2f( u1, v );    glVertex3f( x1, y, 0.);
-  glEnd();
+  glViewport (0, 0, info->guiw, info->guih);
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, info->guiw, info->guih, 0, -1, 1);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+
+  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+  glActiveTexture (GL_TEXTURE0);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, info->video_texture);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  glActiveTexture (GL_TEXTURE1);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->bicubic_lut_texture);
+  glUseProgram (that->bicubic_pass1_program.program);
+  glUniform1i (glGetUniformLocationARB (that->bicubic_pass1_program.program, "tex"), 0);
+  glUniform1i (glGetUniformLocationARB (that->bicubic_pass1_program.program, "lut"), 1);
+  glUniform1f (glGetUniformLocationARB (that->bicubic_pass1_program.program, "spline"), CATMULLROM_SPLINE);
+
+  glBegin (GL_QUADS);
+    glTexCoord2f (info->sx1, info->sy1); glVertex3f (info->dx1, info->dy1, 0);
+    glTexCoord2f (info->sx1, info->sy2); glVertex3f (info->dx1, info->dy2, 0);
+    glTexCoord2f (info->sx2, info->sy2); glVertex3f (info->dx2, info->dy2, 0);
+    glTexCoord2f (info->sx2, info->sy1); glVertex3f (info->dx2, info->dy1, 0);
+  glEnd ();
 
-  glUseProgram( 0 );
+  glUseProgram (0);
 
   return 1;
 }
 
-
-
-static int opengl2_draw_video_cubic_y( opengl2_driver_t *that, int guiw, int guih, GLfloat u, GLfloat v, GLfloat u1, GLfloat v1,
-    GLfloat x, GLfloat y, GLfloat x1, GLfloat y1, GLuint video_texture )
-{
-  if ( !that->bicubic_lut_texture ) {
-    if ( !create_lut_texture( that ) )
+static int opengl2_draw_video_cubic_y (opengl2_driver_t *that, const opengl2_draw_info_t *info) {
+  if (!that->bicubic_lut_texture) {
+    if (!create_lut_texture (that))
       return 0;
   }
 
-  if ( !that->bicubic_pass2_program.compiled && !opengl2_build_program( that, &that->bicubic_pass2_program, &bicubic_pass2_frag, "bicubic_pass2_frag" ) )
+  if (!that->bicubic_pass2_program.compiled
+    && !opengl2_build_program (that, &that->bicubic_pass2_program, &bicubic_pass2_frag, "bicubic_pass2_frag"))
     return 0;
 
-  glViewport( 0, 0, guiw, guih );
-  glMatrixMode( GL_PROJECTION );
-  glLoadIdentity();
-  glOrtho( 0.0, guiw, guih, 0.0, -1.0, 1.0 );
-  glMatrixMode( GL_MODELVIEW );
-  glLoadIdentity();
-
-  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
-
-  glActiveTexture( GL_TEXTURE0 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, video_texture );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-  glActiveTexture( GL_TEXTURE1 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->bicubic_lut_texture );
-  glUseProgram( that->bicubic_pass2_program.program );
-  glUniform1i( glGetUniformLocationARB( that->bicubic_pass2_program.program, "tex" ), 0 );
-  glUniform1i( glGetUniformLocationARB( that->bicubic_pass2_program.program, "lut" ), 1 );
-  glUniform1f( glGetUniformLocationARB( that->bicubic_pass2_program.program, "spline" ), CATMULLROM_SPLINE );
-
-  glBegin( GL_QUADS );
-    glTexCoord2f( u, v );     glVertex3f( x, y, 0.);
-    glTexCoord2f( u, v1 );    glVertex3f( x, y1, 0.);
-    glTexCoord2f( u1, v1 );   glVertex3f( x1, y1, 0.);
-    glTexCoord2f( u1, v );    glVertex3f( x1, y, 0.);
-  glEnd();
+  glViewport (0, 0, info->guiw, info->guih);
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, info->guiw, info->guih, 0, -1, 1);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+
+  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+  glActiveTexture (GL_TEXTURE0);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, info->video_texture);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  glActiveTexture (GL_TEXTURE1);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->bicubic_lut_texture);
+  glUseProgram (that->bicubic_pass2_program.program);
+  glUniform1i (glGetUniformLocationARB (that->bicubic_pass2_program.program, "tex"), 0);
+  glUniform1i (glGetUniformLocationARB (that->bicubic_pass2_program.program, "lut"), 1);
+  glUniform1f (glGetUniformLocationARB (that->bicubic_pass2_program.program, "spline"), CATMULLROM_SPLINE);
+
+  glBegin (GL_QUADS);
+    glTexCoord2f (info->sx1, info->sy1); glVertex3f (info->dx1, info->dy1, 0);
+    glTexCoord2f (info->sx1, info->sy2); glVertex3f (info->dx1, info->dy2, 0);
+    glTexCoord2f (info->sx2, info->sy2); glVertex3f (info->dx2, info->dy2, 0);
+    glTexCoord2f (info->sx2, info->sy1); glVertex3f (info->dx2, info->dy1, 0);
+  glEnd ();
 
-  glUseProgram( 0 );
+  glUseProgram (0);
 
   return 1;
 }
 
-
-
-static int opengl2_draw_video_simple( opengl2_driver_t *that, int guiw, int guih, GLfloat u, GLfloat v, GLfloat u1, GLfloat v1,
-    GLfloat x, GLfloat y, GLfloat x1, GLfloat y1, GLuint video_texture )
-{
+static int opengl2_draw_video_simple (opengl2_driver_t *that, const opengl2_draw_info_t *info) {
   (void)that;
 
-  glViewport( 0, 0, guiw, guih );
-  glMatrixMode( GL_PROJECTION );
-  glLoadIdentity();
-  glOrtho( 0.0, guiw, guih, 0.0, -1.0, 1.0 );
-  glMatrixMode( GL_MODELVIEW );
-  glLoadIdentity();
-
-  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
-
-  glActiveTexture( GL_TEXTURE0 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, video_texture );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-
-  glBegin( GL_QUADS );
-    glTexCoord2f( u, v );     glVertex3f( x, y, 0.);
-    glTexCoord2f( u, v1 );    glVertex3f( x, y1, 0.);
-    glTexCoord2f( u1, v1 );   glVertex3f( x1, y1, 0.);
-    glTexCoord2f( u1, v );    glVertex3f( x1, y, 0.);
-  glEnd();
+  glViewport (0, 0, info->guiw, info->guih);
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, info->guiw, info->guih, 0, -1, 1);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+
+  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+  glActiveTexture (GL_TEXTURE0);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, info->video_texture);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+  glBegin (GL_QUADS);
+    glTexCoord2f (info->sx1, info->sy1); glVertex3f (info->dx1, info->dy1, 0);
+    glTexCoord2f (info->sx1, info->sy2); glVertex3f (info->dx1, info->dy2, 0);
+    glTexCoord2f (info->sx2, info->sy2); glVertex3f (info->dx2, info->dy2, 0);
+    glTexCoord2f (info->sx2, info->sy1); glVertex3f (info->dx2, info->dy1, 0);
+  glEnd ();
 
   return 1;
 }
 
-
-
-static void opengl2_draw_video_bilinear( opengl2_driver_t *that, int guiw, int guih, GLfloat u, GLfloat v, GLfloat u1, GLfloat v1,
-    GLfloat x, GLfloat y, GLfloat x1, GLfloat y1, GLuint video_texture )
-{
+static void opengl2_draw_video_bilinear (opengl2_driver_t *that, const opengl2_draw_info_t *info) {
   (void)that;
 
-  glViewport( 0, 0, guiw, guih );
-  glMatrixMode( GL_PROJECTION );
-  glLoadIdentity();
-  glOrtho( 0.0, guiw, guih, 0.0, -1.0, 1.0 );
-  glMatrixMode( GL_MODELVIEW );
-  glLoadIdentity();
-
-  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
-
-  glActiveTexture( GL_TEXTURE0 );
-  glBindTexture( GL_TEXTURE_RECTANGLE_ARB, video_texture );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
-  glTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
-
-  glBegin( GL_QUADS );
-    glTexCoord2f( u, v );     glVertex3f( x, y, 0.);
-    glTexCoord2f( u, v1 );    glVertex3f( x, y1, 0.);
-    glTexCoord2f( u1, v1 );   glVertex3f( x1, y1, 0.);
-    glTexCoord2f( u1, v );    glVertex3f( x1, y, 0.);
-  glEnd();
+  glViewport (0, 0, info->guiw, info->guih);
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, info->guiw, info->guih, 0, -1, 1);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+
+  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+  glActiveTexture (GL_TEXTURE0);
+  glBindTexture (GL_TEXTURE_RECTANGLE_ARB, info->video_texture);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri (GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+  glBegin (GL_QUADS);
+    glTexCoord2f (info->sx1, info->sy1); glVertex3f (info->dx1, info->dy1, 0);
+    glTexCoord2f (info->sx1, info->sy2); glVertex3f (info->dx1, info->dy2, 0);
+    glTexCoord2f (info->sx2, info->sy2); glVertex3f (info->dx2, info->dy2, 0);
+    glTexCoord2f (info->sx2, info->sy1); glVertex3f (info->dx2, info->dy1, 0);
+  glEnd ();
 }
 
-
-
 static void opengl2_draw( opengl2_driver_t *that, opengl2_frame_t *frame )
 {
   if (!that->gl->make_current(that->gl)) {
@@ -1364,55 +1191,81 @@
   }
 
   opengl2_update_csc_matrix( that, frame );
-  that->update_sharpness = 0;
 
   glBindFramebuffer( GL_FRAMEBUFFER, that->fbo );
 
-  if ( frame->format == XINE_IMGFMT_YV12 ) {
-    glActiveTexture( GL_TEXTURE0 );
-    glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->yuvtex.y );
-    glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, that->videoPBO );
-    void *mem = glMapBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY );
+  if (frame->format == XINE_IMGFMT_YV12) {
+    void *mem;
+    int uvh = (frame->height + 1) >> 1;
+
+    glBindBuffer (GL_PIXEL_UNPACK_BUFFER_ARB, that->videoPBO);
+
+    glActiveTexture (GL_TEXTURE0);
+    glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->yuvtex.tex[OGL2_TEX_y]);
+    mem = glMapBuffer (GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY);
     xine_fast_memcpy (mem, frame->vo_frame.base[0], frame->vo_frame.pitches[0] * frame->height);
-    glUnmapBuffer( GL_PIXEL_UNPACK_BUFFER_ARB );
-    glTexSubImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, frame->vo_frame.pitches[0], frame->height, GL_LUMINANCE, GL_UNSIGNED_BYTE, 0 );
-    glActiveTexture( GL_TEXTURE1 );
-    glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->yuvtex.u );
-    mem = glMapBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY );
+    glUnmapBuffer (GL_PIXEL_UNPACK_BUFFER_ARB);
+    glTexSubImage2D (GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, frame->vo_frame.pitches[0], frame->height, GL_LUMINANCE, GL_UNSIGNED_BYTE, 0);
+
+    glActiveTexture (GL_TEXTURE1);
+    glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->yuvtex.tex[OGL2_TEX_u_v]);
+    mem = glMapBuffer (GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY);
+    xine_fast_memcpy (mem, frame->vo_frame.base[1], frame->vo_frame.pitches[1] * uvh * 2);
+    glUnmapBuffer (GL_PIXEL_UNPACK_BUFFER_ARB);
+    glTexSubImage2D (GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, frame->vo_frame.pitches[1], uvh * 2, GL_LUMINANCE, GL_UNSIGNED_BYTE, 0);
+
+    glBindBuffer (GL_PIXEL_UNPACK_BUFFER_ARB, 0);
+    glUseProgram (that->yuv420_program.program);
+    glUniform2f (glGetUniformLocationARB (that->yuv420_program.program, "offsV"), 0, uvh);
+    glUniform1i (glGetUniformLocationARB (that->yuv420_program.program, "texY"), 0);
+    glUniform1i (glGetUniformLocationARB (that->yuv420_program.program, "texU_V" ), 1);
+    load_csc_matrix (that->yuv420_program.program, that->csc_matrix);
+  }
+  else if (frame->format == XINE_IMGFMT_NV12) {
+    void *mem;
+
+    glBindBuffer (GL_PIXEL_UNPACK_BUFFER_ARB, that->videoPBO);
+
+    glActiveTexture (GL_TEXTURE0);
+    glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->yuvtex.tex[OGL2_TEX_y]);
+    mem = glMapBuffer (GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY);
+    xine_fast_memcpy (mem, frame->vo_frame.base[0], frame->vo_frame.pitches[0] * frame->height);
+    glUnmapBuffer (GL_PIXEL_UNPACK_BUFFER_ARB);
+    glTexSubImage2D (GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, frame->vo_frame.pitches[0], frame->height, GL_LUMINANCE, GL_UNSIGNED_BYTE, 0);
+
+    glActiveTexture (GL_TEXTURE1);
+    glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->yuvtex.tex[OGL2_TEX_uv]);
+    mem = glMapBuffer (GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY);
     xine_fast_memcpy (mem, frame->vo_frame.base[1], frame->vo_frame.pitches[1] * frame->height / 2);
-    glUnmapBuffer( GL_PIXEL_UNPACK_BUFFER_ARB );
-    glTexSubImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, frame->vo_frame.pitches[1], frame->height/2, GL_LUMINANCE, GL_UNSIGNED_BYTE, 0 );
-    glActiveTexture( GL_TEXTURE2 );
-    glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->yuvtex.v );
-    mem = glMapBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY );
-    xine_fast_memcpy (mem, frame->vo_frame.base[2], frame->vo_frame.pitches[2] * frame->height / 2);
-    glUnmapBuffer( GL_PIXEL_UNPACK_BUFFER_ARB );
-    glTexSubImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, frame->vo_frame.pitches[2], frame->height/2, GL_LUMINANCE, GL_UNSIGNED_BYTE, 0 );
-    glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, 0 );
+    glUnmapBuffer (GL_PIXEL_UNPACK_BUFFER_ARB);
+    glTexSubImage2D (GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, frame->vo_frame.pitches[1], frame->height/2, GL_LUMINANCE, GL_UNSIGNED_BYTE, 0);
 
-    glUseProgram( that->yuv420_program.program );
-    glUniform1i( glGetUniformLocationARB( that->yuv420_program.program, "texY" ), 0 );
-    glUniform1i( glGetUniformLocationARB( that->yuv420_program.program, "texU" ), 1 );
-    glUniform1i( glGetUniformLocationARB( that->yuv420_program.program, "texV" ), 2 );
-    load_csc_matrix( that->yuv420_program.program, that->csc_matrix );
+    glBindBuffer (GL_PIXEL_UNPACK_BUFFER_ARB, 0);
+    glUseProgram (that->nv12_program.program);
+    glUniform1i (glGetUniformLocationARB (that->nv12_program.program, "texY"), 0);
+    glUniform1i (glGetUniformLocationARB (that->nv12_program.program, "texUV"), 1);
+    load_csc_matrix( that->nv12_program.program, that->csc_matrix );
   }
   else if ( frame->format == XINE_IMGFMT_YUY2 ) {
-    glActiveTexture( GL_TEXTURE0 );
-    glBindTexture( GL_TEXTURE_RECTANGLE_ARB, that->yuvtex.yuv );
+    void *mem;
+
     glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, that->videoPBO );
-    void *mem = glMapBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY );
+
+    glActiveTexture( GL_TEXTURE0 );
+    glBindTexture (GL_TEXTURE_RECTANGLE_ARB, that->yuvtex.tex[OGL2_TEX_yuv]);
+    mem = glMapBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY );
     xine_fast_memcpy (mem, frame->vo_frame.base[0], frame->vo_frame.pitches[0] * frame->height);
     glUnmapBuffer( GL_PIXEL_UNPACK_BUFFER_ARB );
     glTexSubImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, frame->vo_frame.pitches[0] / 2, frame->height, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, 0 );
-    glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, 0 );
 
+    glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, 0 );
     glUseProgram( that->yuv422_program.program );
     glUniform1i( glGetUniformLocationARB( that->yuv422_program.program, "texYUV" ), 0 );
     load_csc_matrix( that->yuv422_program.program, that->csc_matrix );
   }
   else {
     /* unknown format */
-    xprintf( that->xine, XINE_VERBOSITY_LOG, "video_out_opengl2: unknown image format 0x%08x\n", frame->format );
+    xprintf( that->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": unknown image format 0x%08x\n", frame->format );
   }
 
   glViewport( 0, 0, frame->width, frame->height );
@@ -1422,7 +1275,7 @@
   glMatrixMode( GL_MODELVIEW );
   glLoadIdentity();
 
-  GLuint video_texture = that->videoTex;
+  GLuint video_texture = that->videoTex[0];
   glDrawBuffer( GL_COLOR_ATTACHMENT0 );
 
   glBegin( GL_QUADS );
@@ -1435,7 +1288,18 @@
   glUseProgram( 0 );
 
   // post-processing
-  if ( that->sharpness != 0 )
+  if (that->sharp.changed) {
+    that->sharp.side = that->sharp.value / 100.0 * frame->width / 1920.0;
+    if (that->sharp.value < 0)
+      that->sharp.side /= -6.8;
+    else
+      that->sharp.side /= -3.4;
+    that->sharp.corn = that->sharp.side * 0.707;
+    that->sharp.mid = 1.0 - 4.0 * (that->sharp.side + that->sharp.corn);
+    that->sharp.changed = 0;
+    xprintf (that->xine, XINE_VERBOSITY_DEBUG, LOG_MODULE ": sharpness %d\n", that->sharp.value);
+  }
+  if (that->sharp.value)
     video_texture = opengl2_sharpness( that, frame, video_texture );
 
   // draw scaled overlays
@@ -1445,47 +1309,65 @@
   glBindFramebuffer( GL_FRAMEBUFFER, 0 );
 
   // draw on screen
-  GLfloat u, u1, v, v1, x, x1, y, y1;
+  {
+    int res = 0;
+    opengl2_draw_info_t info;
+
+    info.video_texture = video_texture;
+
+    info.guiw = that->sc.gui_width;
+    info.guih = that->sc.gui_height;
 
-  u = that->sc.displayed_xoffset;
-  v = that->sc.displayed_yoffset;
-  u1 = that->sc.displayed_width + that->sc.displayed_xoffset;
-  v1 = that->sc.displayed_height + that->sc.displayed_yoffset;
-  x = that->sc.output_xoffset;
-  y = that->sc.output_yoffset;
-  x1 = that->sc.output_xoffset + that->sc.output_width;
-  y1 = that->sc.output_yoffset + that->sc.output_height;
-
-  int res = 0;
-
-  if ( that->scale_bicubic ) {
-    if ( that->sc.displayed_width != that->sc.output_width ) {
-      if ( that->sc.displayed_height != that->sc.output_height )
-        res = opengl2_draw_video_bicubic( that, that->sc.gui_width, that->sc.gui_height, u, v, u1, v1, x, y, x1, y1, video_texture );
-      else
-        res = opengl2_draw_video_cubic_x( that, that->sc.gui_width, that->sc.gui_height, u, v, u1, v1, x, y, x1, y1, video_texture );
+    info.sx1 = that->sc.displayed_xoffset;
+    info.sy1 = that->sc.displayed_yoffset;
+    info.sx2 = that->sc.displayed_width + that->sc.displayed_xoffset;
+    info.sy2 = that->sc.displayed_height + that->sc.displayed_yoffset;
+
+    info.dw  = that->sc.output_width;
+    info.dh  = that->sc.displayed_height;
+    if (!(that->transform.flags & XINE_VO_TRANSFORM_FLIP_H)) {
+      info.dx1 = that->sc.output_xoffset;
+      info.dx2 = that->sc.output_xoffset + that->sc.output_width;
     } else {
-      if ( that->sc.displayed_height != that->sc.output_height )
-        res = opengl2_draw_video_cubic_y( that, that->sc.gui_width, that->sc.gui_height, u, v, u1, v1, x, y, x1, y1, video_texture );
-      else
-        res = opengl2_draw_video_simple( that, that->sc.gui_width, that->sc.gui_height, u, v, u1, v1, x, y, x1, y1, video_texture );
+      info.dx1 = that->sc.output_xoffset + that->sc.output_width;
+      info.dx2 = that->sc.output_xoffset;
     }
+    if (!(that->transform.flags & XINE_VO_TRANSFORM_FLIP_V)) {
+      info.dy1 = that->sc.output_yoffset;
+      info.dy2 = that->sc.output_yoffset + that->sc.output_height;
+    } else {
+      info.dy1 = that->sc.output_yoffset + that->sc.output_height;
+      info.dy2 = that->sc.output_yoffset;
+    }
+    that->transform.changed = 0;
+
+    if (that->scale_bicubic) {
+      if (that->sc.displayed_width != that->sc.output_width) {
+        if (that->sc.displayed_height != that->sc.output_height)
+          res = opengl2_draw_video_bicubic (that, &info);
+        else
+          res = opengl2_draw_video_cubic_x (that, &info);
+      } else {
+        if (that->sc.displayed_height != that->sc.output_height)
+          res = opengl2_draw_video_cubic_y (that, &info);
+        else
+          res = opengl2_draw_video_simple (that, &info);
+      }
+    }
+    if (!res)
+      opengl2_draw_video_bilinear (that, &info);
   }
-  if (!res)
-    opengl2_draw_video_bilinear( that, that->sc.gui_width, that->sc.gui_height, u, v, u1, v1, x, y, x1, y1, video_texture );
 
   // draw unscaled overlays
-  opengl2_draw_unscaled_overlays( that );
+  opengl2_draw_unscaled_overlays (that);
 
-  //if ( that->mglXSwapInterval )
-    //that->mglXSwapInterval( 1 );
+  // if (that->mglXSwapInterval)
+    //that->mglXSwapInterval (1);
 
-  that->gl->swap_buffers(that->gl);
-  that->gl->release_current(that->gl);
+  that->gl->swap_buffers (that->gl);
+  that->gl->release_current (that->gl);
 }
 
-
-
 static void opengl2_display_frame( vo_driver_t *this_gen, vo_frame_t *frame_gen )
 {
   opengl2_driver_t  *this  = (opengl2_driver_t *) this_gen;
@@ -1561,7 +1443,7 @@
     case VO_PROP_BRIGHTNESS:
       return this->brightness;
     case VO_PROP_SHARPNESS:
-      return this->sharpness;
+      return this->sharp.value;
     case VO_PROP_ZOOM_X:
       return this->zoom_x;
     case VO_PROP_ZOOM_Y:
@@ -1572,6 +1454,10 @@
       return this->max_video_width;
     case VO_PROP_MAX_VIDEO_HEIGHT:
       return this->max_video_height;
+    case VO_PROP_CAPS2:
+      return VO_CAP2_NV12 | VO_CAP2_TRANSFORM;
+    case VO_PROP_TRANSFORM:
+      return this->transform.flags;
   }
 
   return -1;
@@ -1612,7 +1498,12 @@
     case VO_PROP_SATURATION: this->saturation = value; this->update_csc = 1; break;
     case VO_PROP_CONTRAST: this->contrast = value; this->update_csc = 1; break;
     case VO_PROP_BRIGHTNESS: this->brightness = value; this->update_csc = 1; break;
-    case VO_PROP_SHARPNESS: this->sharpness = value; this->update_sharpness = 1; break;
+    case VO_PROP_SHARPNESS: this->sharp.value = value; this->sharp.changed = 1; break;
+    case VO_PROP_TRANSFORM:
+      value &= XINE_VO_TRANSFORM_FLIP_H | XINE_VO_TRANSFORM_FLIP_V;
+      this->transform.changed |= value ^ this->transform.flags;
+      this->transform.flags = value;
+      break;
   }
 
   return value;
@@ -1713,16 +1604,13 @@
   opengl2_driver_t  *this  = (opengl2_driver_t *) this_gen;
 
   this->scale_bicubic = entry->num_value;
-  xprintf( this->xine, XINE_VERBOSITY_DEBUG, "video_out_opengl2: scale_bicubic=%d\n", this->scale_bicubic );
+  xprintf( this->xine, XINE_VERBOSITY_DEBUG, LOG_MODULE ": scale_bicubic=%d\n", this->scale_bicubic );
 }
 
-
-
-static void opengl2_dispose( vo_driver_t *this_gen )
-{
+static void opengl2_dispose (vo_driver_t *this_gen) {
   opengl2_driver_t *this = (opengl2_driver_t *) this_gen;
 
-  opengl2_exit_unregister( this );
+  opengl2_exit_unregister (this);
 
   /* cm_close already does this.
   this->xine->config->unregister_callbacks (this->xine->config, "video.output.opengl2_bicubic_scaling", NULL, this, sizeof (*this));
@@ -1734,11 +1622,12 @@
 
   this->gl->make_current(this->gl);
 
-  opengl2_delete_program( &this->yuv420_program );
-  opengl2_delete_program( &this->yuv422_program );
+  opengl2_delete_program (&this->yuv420_program);
+  opengl2_delete_program (&this->nv12_program);
+  opengl2_delete_program (&this->yuv422_program);
 
-  if ( this->sharpness_program.compiled )
-    opengl2_delete_program( &this->sharpness_program );
+  if (this->sharp.program.compiled)
+    opengl2_delete_program (&this->sharp.program);
 
   if ( this->bicubic_pass1_program.compiled )
     opengl2_delete_program( &this->bicubic_pass1_program );
@@ -1751,18 +1640,8 @@
   if ( this->bicubic_fbo )
     glDeleteFramebuffers( 1, &this->bicubic_fbo );
 
-  if ( this->yuvtex.y )
-    glDeleteTextures( 1, &this->yuvtex.y );
-  if ( this->yuvtex.u )
-    glDeleteTextures( 1, &this->yuvtex.u );
-  if ( this->yuvtex.v )
-    glDeleteTextures( 1, &this->yuvtex.v );
-  if ( this->yuvtex.yuv )
-    glDeleteTextures( 1, &this->yuvtex.yuv );
-  if ( this->videoTex )
-    glDeleteTextures( 1, &this->videoTex );
-  if ( this->videoTex2 )
-    glDeleteTextures( 1, &this->videoTex2 );
+  glDeleteTextures (OGL2_TEX_LAST, this->yuvtex.tex);
+  glDeleteTextures (2, this->videoTex);
   if ( this->fbo )
     glDeleteFramebuffers( 1, &this->fbo );
   if ( this->videoPBO )
@@ -1781,13 +1660,10 @@
   free (this);
 }
 
-
-
-static vo_driver_t *opengl2_open_plugin( video_driver_class_t *class_gen, const void *visual_gen )
-{
-  opengl2_class_t     *class   = (opengl2_class_t *) class_gen;
-  opengl2_driver_t    *this;
-  config_values_t     *config  = class->xine->config;
+static vo_driver_t *opengl2_open_plugin (video_driver_class_t *class_gen, const void *visual_gen) {
+  opengl2_class_t  *class = (opengl2_class_t *)class_gen;
+  opengl2_driver_t *this;
+  config_values_t  *config = class->xine->config;
 
   this = calloc (1, sizeof (*this));
   if (!this)
@@ -1795,9 +1671,11 @@
 #ifndef HAVE_ZERO_SAFE_MEM
   this->hue                            = 0;
   this->brightness                     = 0;
-  this->update_sharpness               = 0;
-  this->sharpness                      = 0;
-  this->sharpness_program.compiled     = 0;
+  this->sharp.changed                  = 0;
+  this->sharp.value                    = 0;
+  this->transform.flags                = 0;
+  this->transform.changed              = 0;
+  this->sharp.program.compiled         = 0;
   this->bicubic_pass1_program.compiled = 0;
   this->bicubic_pass2_program.compiled = 0;
   this->bicubic_lut_texture            = 0;
@@ -1807,16 +1685,17 @@
   this->bicubic_fbo                    = 0;
   this->ovl_changed                    = 0;
   this->num_ovls                       = 0;
-  this->yuvtex.y                       = 0;
-  this->yuvtex.u                       = 0;
-  this->yuvtex.v                       = 0;
-  this->yuvtex.yuv                     = 0;
+  this->yuvtex.tex[OGL2_TEX_y]         = 0;
+  this->yuvtex.tex[OGL2_TEX_u]         = 0;
+  this->yuvtex.tex[OGL2_TEX_v]         = 0;
+  this->yuvtex.tex[OGL2_TEX_yuv]       = 0;
+  this->yuvtex.tex[OGL2_TEX_uv]        = 0;
   this->yuvtex.width                   = 0;
   this->yuvtex.height                  = 0;
   this->fbo                            = 0;
   this->videoPBO                       = 0;
-  this->videoTex                       = 0;
-  this->videoTex2                      = 0;
+  this->videoTex[0]                    = 0;
+  this->videoTex[1]                    = 0;
   {
     int i;
     for (i = 0; i < XINE_VORAW_MAX_OVL; ++i) {
@@ -1829,180 +1708,152 @@
   }
 #endif
 
-  this->gl = _x_load_gl(class->xine, class->visual_type, visual_gen, XINE_GL_API_OPENGL);
-  if (!this->gl) {
-    goto fail_gl_init;
-  }
+  this->gl = _x_load_gl (class->xine, class->visual_type, visual_gen, XINE_GL_API_OPENGL);
+  if (this->gl) {
+    {
+      /* TJ. If X server link gets lost, our next render attempt will fire the
+       * Xlib fatal error handler -> exit () -> opengl2_exit () with drawable_lock held.
+       * opengl2_display_frame () does quite a lot anyway so the "recursive mutex"
+       * performance drop should not matter. */
+      pthread_mutexattr_t attr;
+      pthread_mutexattr_init (&attr);
+      pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
+      pthread_mutex_init (&this->drawable_lock, &attr);
+      pthread_mutexattr_destroy (&attr);
+    }
 
-  {
-    /* TJ. If X server link gets lost, our next render attempt will fire the
-     * Xlib fatal error handler -> exit () -> opengl2_exit () with drawable_lock held.
-     * opengl2_display_frame () does quite a lot anyway so the "recursive mutex"
-     * performance drop should not matter. */
-    pthread_mutexattr_t attr;
-    pthread_mutexattr_init (&attr);
-    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
-    pthread_mutex_init (&this->drawable_lock, &attr);
-    pthread_mutexattr_destroy (&attr);
-  }
-
-  _x_vo_scale_init(&this->sc, 1, 0, config);
-
-  if (class->visual_type == XINE_VISUAL_TYPE_X11) {
-    const x11_visual_t  *visual  = (const x11_visual_t *) visual_gen;
-    this->sc.frame_output_cb  = visual->frame_output_cb;
-    this->sc.dest_size_cb     = visual->dest_size_cb;
-    this->sc.user_data        = visual->user_data;
-  } else /*if (class->visual_type == XINE_VISUAL_TYPE_WAYLAND)*/ {
-    const xine_wayland_visual_t  *visual  = (const xine_wayland_visual_t *) visual_gen;
-    this->sc.frame_output_cb  = visual->frame_output_cb;
-    this->sc.user_data        = visual->user_data;
-  }
-  this->sc.user_ratio       = XINE_VO_ASPECT_AUTO;
-
-  this->zoom_x = 100;
-  this->zoom_y = 100;
-
-  this->xine   = class->xine;
-  this->config = config;
-
-  this->vo_driver.get_capabilities     = opengl2_get_capabilities;
-  this->vo_driver.alloc_frame          = opengl2_alloc_frame;
-  this->vo_driver.update_frame_format  = opengl2_update_frame_format;
-  this->vo_driver.overlay_begin        = opengl2_overlay_begin;
-  this->vo_driver.overlay_blend        = opengl2_overlay_blend;
-  this->vo_driver.overlay_end          = opengl2_overlay_end;
-  this->vo_driver.display_frame        = opengl2_display_frame;
-  this->vo_driver.get_property         = opengl2_get_property;
-  this->vo_driver.set_property         = opengl2_set_property;
-  this->vo_driver.get_property_min_max = opengl2_get_property_min_max;
-  this->vo_driver.gui_data_exchange    = opengl2_gui_data_exchange;
-  this->vo_driver.dispose              = opengl2_dispose;
-  this->vo_driver.redraw_needed        = opengl2_redraw_needed;
-
-  if (!this->gl->make_current(this->gl)) {
-    xprintf( this->xine, XINE_VERBOSITY_LOG, "video_out_opengl2: display unavailable for initialization\n" );
-    goto fail_make_current;
-  }
+    _x_vo_scale_init (&this->sc, 1, 0, config);
 
-  {
-    GLint v[1] = {0};
-    glGetIntegerv (GL_MAX_TEXTURE_SIZE, v);
-    if (v[0] > 0) {
-      this->max_video_width  =
-      this->max_video_height = v[0];
-      xprintf (this->xine, XINE_VERBOSITY_DEBUG, "video_out_opengl2: max video size %dx%d.\n",
-        this->max_video_width, this->max_video_height);
+    if (class->visual_type == XINE_VISUAL_TYPE_X11) {
+      const x11_visual_t *visual = (const x11_visual_t *)visual_gen;
+      this->sc.frame_output_cb   = visual->frame_output_cb;
+      this->sc.dest_size_cb      = visual->dest_size_cb;
+      this->sc.user_data         = visual->user_data;
+    } else /* class->visual_type == XINE_VISUAL_TYPE_WAYLAND) */ {
+      const xine_wayland_visual_t *visual = (const xine_wayland_visual_t *)visual_gen;
+      this->sc.frame_output_cb            = visual->frame_output_cb;
+      this->sc.user_data                  = visual->user_data;
     }
-  }
 
-  {
-    GLint v[2] = {0, 0};
-    glGetIntegerv (GL_MAX_VIEWPORT_DIMS, v);
-    if (v[0] > 0) {
-      this->max_display_width  = v[0];
-      this->max_display_height = v[1] > 0 ? v[1] : v[0];
-      xprintf (this->xine, XINE_VERBOSITY_DEBUG, "video_out_opengl2: max output size %dx%d.\n",
-        this->max_display_width, this->max_display_height);
-    }
-  }
+    this->sc.user_ratio = XINE_VO_ASPECT_AUTO;
+    this->zoom_x = 100;
+    this->zoom_y = 100;
+
+    this->xine   = class->xine;
+    this->config = config;
+
+    this->vo_driver.get_capabilities     = opengl2_get_capabilities;
+    this->vo_driver.alloc_frame          = mem_frame_alloc_frame;
+    this->vo_driver.update_frame_format  = mem_frame_update_frame_format;
+    this->vo_driver.overlay_begin        = opengl2_overlay_begin;
+    this->vo_driver.overlay_blend        = opengl2_overlay_blend;
+    this->vo_driver.overlay_end          = opengl2_overlay_end;
+    this->vo_driver.display_frame        = opengl2_display_frame;
+    this->vo_driver.get_property         = opengl2_get_property;
+    this->vo_driver.set_property         = opengl2_set_property;
+    this->vo_driver.get_property_min_max = opengl2_get_property_min_max;
+    this->vo_driver.gui_data_exchange    = opengl2_gui_data_exchange;
+    this->vo_driver.dispose              = opengl2_dispose;
+    this->vo_driver.redraw_needed        = opengl2_redraw_needed;
 
-  glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );
-  glClearDepth( 1.0f );
-  glDepthFunc( GL_LEQUAL );
-  glDisable( GL_DEPTH_TEST );
-  glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
-  glDisable( GL_BLEND );
-  glShadeModel( GL_SMOOTH );
-  glEnable( GL_TEXTURE_RECTANGLE_ARB );
-  glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
-
-  const char *extensions = glGetString( GL_EXTENSIONS );
-  if ( strstr( extensions, "ARB_texture_float" ) )
-    this->texture_float = 1;
-  else
-    this->texture_float = 0;
+    if (!this->gl->make_current (this->gl)) {
+      xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE ": display unavailable for initialization\n");
+    } else {
+      {
+        GLint v[1] = {0};
+        glGetIntegerv (GL_MAX_TEXTURE_SIZE, v);
+        if (v[0] > 0) {
+          this->max_video_width  =
+          this->max_video_height = v[0];
+          xprintf (this->xine, XINE_VERBOSITY_DEBUG, LOG_MODULE ": max video size %dx%d.\n",
+            this->max_video_width, this->max_video_height);
+        }
+      }
+      {
+        GLint v[2] = {0, 0};
+        glGetIntegerv (GL_MAX_VIEWPORT_DIMS, v);
+        if (v[0] > 0) {
+          this->max_display_width  = v[0];
+          this->max_display_height = v[1] > 0 ? v[1] : v[0];
+          xprintf (this->xine, XINE_VERBOSITY_DEBUG, LOG_MODULE ": max output size %dx%d.\n",
+            this->max_display_width, this->max_display_height);
+        }
+      }
 
-#define INITWIDTH  720
-#define INITHEIGHT 576
+      glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
+      glClearDepth (1.0f);
+      glDepthFunc (GL_LEQUAL);
+      glDisable (GL_DEPTH_TEST);
+      glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+      glDisable (GL_BLEND);
+      glShadeModel (GL_SMOOTH);
+      glEnable (GL_TEXTURE_RECTANGLE_ARB);
+      glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
 
-  if ( !opengl2_check_textures_size( this, INITWIDTH, INITHEIGHT ) ) {
-    goto fail;
-  }
+      {
+        const char *extensions = glGetString (GL_EXTENSIONS);
 
-  if ( !opengl2_build_program( this, &this->yuv420_program, &yuv420_frag, "yuv420_frag" ) ) {
-    goto fail;
-  }
-  if ( !opengl2_build_program( this, &this->yuv422_program, &yuv422_frag, "yuv422_frag" ) ) {
-    goto fail;
-  }
+        this->texture_float = (extensions && strstr (extensions, "ARB_texture_float")) ? 1 : 0;
+      }
 
-  this->gl->release_current(this->gl);
+#define INITWIDTH  720
+#define INITHEIGHT 576
+      if (opengl2_check_textures_size (this, INITWIDTH, INITHEIGHT)
+        && opengl2_build_program (this, &this->yuv420_program, &yuv420_frag, "yuv420_frag")
+        && opengl2_build_program (this, &this->nv12_program,   &nv12_frag,   "nv12_frag")
+        && opengl2_build_program (this, &this->yuv422_program, &yuv422_frag, "yuv422_frag")) {
+        this->gl->release_current (this->gl);
+
+        this->update_csc = 1;
+        this->color_standard = 10;
+        this->saturation = 128;
+        this->contrast = 128;
+        cm_init (this);
+
+        if (this->texture_float) {
+          this->scale_bicubic = config->register_bool (config,
+            "video.output.opengl2_bicubic_scaling", 0,
+            _("opengl2: use a bicubic algo to scale the video"),
+            _("Set to true if you want bicubic scaling.\n\n"),
+            10, opengl2_set_bicubic, this);
+        } else {
+          this->scale_bicubic = 0;
+        }
 
-  this->update_csc = 1;
-  this->color_standard = 10;
-  this->saturation = 128;
-  this->contrast = 128;
-
-  cm_init (this);
-
-  if ( this->texture_float ) {
-    this->scale_bicubic = config->register_bool( config, "video.output.opengl2_bicubic_scaling", 0,
-      _("opengl2: use a bicubic algo to scale the video"),
-      _("Set to true if you want bicubic scaling.\n\n"),
-      10, opengl2_set_bicubic, this );
+        xprintf (this->xine, XINE_VERBOSITY_DEBUG, LOG_MODULE ": initialized.\n");
+        return &this->vo_driver;
+      }
+      this->gl->release_current (this->gl);
+    }
+    pthread_mutex_destroy (&this->drawable_lock);
+    this->gl->dispose (&this->gl);
   }
-  else
-    this->scale_bicubic = 0;
-
-  xprintf( this->xine, XINE_VERBOSITY_DEBUG, "video_out_opengl2: initialized.\n");
-
-  return &this->vo_driver;
-
- fail:
-  this->gl->release_current(this->gl);
- fail_make_current:
-  this->gl->dispose(&this->gl);
- fail_gl_init:
-  free(this);
+  free (this);
   return NULL;
 }
 
-static int opengl2_check_platform( xine_t *xine, unsigned visual_type, const void *visual )
-{
-  const char *extensions;
+static int opengl2_check_platform (xine_t *xine, unsigned visual_type, const void *visual) {
   xine_gl_t  *gl;
   int result = 0;
 
-  gl = _x_load_gl(xine, visual_type, visual, XINE_GL_API_OPENGL);
+  gl = _x_load_gl (xine, visual_type, visual, XINE_GL_API_OPENGL);
   if (!gl)
     return 0;
 
-  if (!gl->make_current(gl))
-    goto fail_released;
+  if (gl->make_current (gl)) {
+    const char *extensions = glGetString (GL_EXTENSIONS);
 
-  extensions = glGetString(GL_EXTENSIONS);
-  if (!extensions)
-    goto fail;
-
-  if (!strstr( extensions, "ARB_texture_rectangle"))
-    goto fail;
-  if (!strstr( extensions, "ARB_texture_non_power_of_two"))
-    goto fail;
-  if (!strstr( extensions, "ARB_pixel_buffer_object"))
-    goto fail;
-  if (!strstr( extensions, "ARB_framebuffer_object"))
-    goto fail;
-  if (!strstr( extensions, "ARB_fragment_shader"))
-    goto fail;
-  if (!strstr( extensions, "ARB_vertex_shader"))
-    goto fail;
-  result = 1;
-
- fail:
-  gl->release_current(gl);
- fail_released:
-  gl->dispose(&gl);
+    if (extensions
+      && strstr (extensions, "ARB_texture_rectangle")
+      && strstr (extensions, "ARB_texture_non_power_of_two")
+      && strstr (extensions, "ARB_pixel_buffer_object")
+      && strstr (extensions, "ARB_framebuffer_object")
+      && strstr (extensions, "ARB_fragment_shader")
+      && strstr (extensions, "ARB_vertex_shader"))
+      result = 1;
+    gl->release_current (gl);
+  }
+  gl->dispose (&gl);
   return result;
 }
 
@@ -2033,17 +1884,14 @@
   return this;
 }
 
-static void *opengl2_init_class_x11( xine_t *xine, const void *visual_gen )
-{
-  return opengl2_init_class(xine, XINE_VISUAL_TYPE_X11, visual_gen);
+static void *opengl2_init_class_x11 (xine_t *xine, const void *visual_gen) {
+  return opengl2_init_class (xine, XINE_VISUAL_TYPE_X11, visual_gen);
 }
 
-static void *opengl2_init_class_wl( xine_t *xine, const void *visual_gen )
-{
-  return opengl2_init_class(xine, XINE_VISUAL_TYPE_WAYLAND, visual_gen);
+static void *opengl2_init_class_wl (xine_t *xine, const void *visual_gen) {
+  return opengl2_init_class (xine, XINE_VISUAL_TYPE_WAYLAND, visual_gen);
 }
 
-
 static const vo_info_t vo_info_opengl2 = {
   .priority    = 8,
   .visual_type = XINE_VISUAL_TYPE_X11,
@@ -2064,3 +1912,4 @@
   { PLUGIN_VIDEO_OUT, 22, "opengl2", XINE_VERSION_CODE, &vo_info_opengl2_wl, opengl2_init_class_wl },
   { PLUGIN_NONE, 0, NULL, 0, NULL, NULL }
 };
+
diff -urN xine-lib-1.2.11/src/video_out/video_out_vaapi.c xine-lib-1.2/src/video_out/video_out_vaapi.c
--- xine-lib-1.2.11/src/video_out/video_out_vaapi.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/video_out_vaapi.c	2022-01-15 22:03:19.599547234 +0100
@@ -74,7 +74,8 @@
 # define ENABLE_VA_GLX
 #endif /* OPENGL */
 
-#include "accel_vaapi.h"
+#include "vaapi/vaapi_util.h"
+#include "vaapi/vaapi_frame.h"
 
 #include <pthread.h>
 
@@ -83,7 +84,6 @@
     vaCreateSurfaces(d, w, h, f, ns, s)
 #endif
 
-#define  RENDER_SURFACES  50
 #define  MIN_SURFACES     22
 #define  SOFT_SURFACES    3
 #define  SW_WIDTH         1920
@@ -111,19 +111,6 @@
 #endif
 #endif
 
-#if defined(__linux__)
-// Linux select() changes its timeout parameter upon return to contain
-// the remaining time. Most other unixen leave it unchanged or undefined.
-#define SELECT_SETS_REMAINING
-#elif defined(__FreeBSD__) || defined(__sun__) || (defined(__MACH__) && defined(__APPLE__))
-#define USE_NANOSLEEP
-#elif defined(HAVE_PTHREADS) && defined(sgi)
-// SGI pthreads has a bug when using pthreads+signals+nanosleep,
-// so instead of using nanosleep, wait on a CV which is never signalled.
-#include <pthread.h>
-#define USE_COND_TIMEDWAIT
-#endif
-
 #ifndef HAVE_THREAD_SAFE_X11
 #define LOCK_DISPLAY(_this) XLockDisplay (_this->display)
 #define UNLOCK_DISPLAY(_this) XUnlockDisplay (_this->display)
@@ -156,15 +143,6 @@
 } vaapi_rect_t;
 
 typedef struct {
-  vo_frame_t         vo_frame;
-
-  int                width, height, format, flags;
-  double             ratio;
-
-  vaapi_accel_t     vaapi_accel_data;
-} vaapi_frame_t;
-
-typedef struct {
   VADisplayAttribType type;
   int                 value;
   int                 min;
@@ -214,7 +192,6 @@
 
   unsigned int        deinterlace;
 
-  int                 query_va_status;
 #ifdef ENABLE_VA_GLX
   int                 opengl_render;
   unsigned int        init_opengl_render;
@@ -235,7 +212,8 @@
   VASurfaceID         *va_soft_surface_ids;
   VAImage             *va_soft_images;
   unsigned int        va_soft_head;
-  int                 is_bound;
+  int                 soft_image_is_bound;
+
   /* subpicture */
   VAImageFormat       *va_subpic_formats;
   int                 va_num_subpic_formats;
@@ -269,12 +247,15 @@
   int                 have_user_csc_matrix;
   float               user_csc_matrix[12];
 
+  /* keep last frame surface alive (video_out shamelessy uses it ...) */
+  /* XXX maybe this issue could be solved with some kind of release callback.
+   * Such callback could be useful with dropped frames too. */
+  vo_frame_t        *recent_frames[VO_NUM_RECENT_FRAMES];
+
   /* */
-  ff_vaapi_context_t  va_context_storage;
   VASurfaceID         va_soft_surface_ids_storage[SOFT_SURFACES + 1];
   VAImage             va_soft_images_storage[SOFT_SURFACES + 1];
-  ff_vaapi_surface_t  va_render_surfaces_storage[RENDER_SURFACES + 1];
-  VASurfaceID         va_surface_ids_storage[RENDER_SURFACES + 1];
+  vaapi_context_impl_t *va;
 };
 
 /* import common color matrix stuff */
@@ -284,13 +265,9 @@
 #include "color_matrix.c"
 
 static void vaapi_destroy_subpicture(vaapi_driver_t *this);
-static void vaapi_destroy_image(vaapi_driver_t *this, VAImage *va_image);
 static int vaapi_ovl_associate(vaapi_driver_t *this, int format, int bShow);
 static VAStatus vaapi_destroy_soft_surfaces(vaapi_driver_t *this);
-static VAStatus vaapi_destroy_render_surfaces(vaapi_driver_t *this);
-static const char *vaapi_profile_to_string(VAProfile profile);
 static int vaapi_set_property (vo_driver_t *this_gen, int property, int value);
-static void vaapi_show_display_props(vaapi_driver_t *this);
 
 static void yv12_to_nv12(const uint8_t *y_src, int y_src_pitch, 
                          const uint8_t *u_src, int u_src_pitch, 
@@ -300,7 +277,6 @@
                          int width, int height);
 
 #ifdef ENABLE_VA_GLX
-void (GLAPIENTRY *mpglGenTextures)(GLsizei, GLuint *);
 void (GLAPIENTRY *mpglBindTexture)(GLenum, GLuint);
 void (GLAPIENTRY *mpglXBindTexImage)(Display *, GLXDrawable, int, const int *);
 void (GLAPIENTRY *mpglXReleaseTexImage)(Display *, GLXDrawable, int);
@@ -332,283 +308,34 @@
   return 1;
 }
 
-static int vaapi_lock_decode(vo_frame_t *frame_gen)
+static int vaapi_lock_decode_guarded(vo_frame_t *frame_gen)
 {
   vaapi_driver_t  *this = (vaapi_driver_t *) frame_gen->driver;
 
-  if (this->guarded_render) {
-    pthread_mutex_lock(&this->vaapi_lock);
-    //LOCK_DISPLAY (this);
-    return 1;
-  }
-  return 0;
+  pthread_mutex_lock(&this->vaapi_lock);
+  return 1;
 }
 
-static void vaapi_unlock_decode(vo_frame_t *frame_gen)
+static void vaapi_unlock_decode_guarded(vo_frame_t *frame_gen)
 {
   vaapi_driver_t  *this = (vaapi_driver_t *) frame_gen->driver;
 
   /* unconditional unlock - this is called only if lock was acquired */
-  //UNLOCK_DISPLAY (this);
-  pthread_mutex_unlock(&this->vaapi_lock);
-}
-
-static int guarded_render(vo_frame_t *frame_gen) {
-  vaapi_driver_t  *this = (vaapi_driver_t *) frame_gen->driver;
-
-  return this->guarded_render;
-}
-
-static ff_vaapi_surface_t *get_vaapi_surface(vo_frame_t *frame_gen) {
-
-  vaapi_driver_t      *this       = (vaapi_driver_t *) frame_gen->driver;
-  vaapi_frame_t       *frame      = (vaapi_frame_t *) frame_gen;
-  ff_vaapi_context_t  *va_context = this->va_context;
-  ff_vaapi_surface_t  *va_surface = NULL;
-  VAStatus            vaStatus;
-
-  lprintf("get_vaapi_surface\n");
-
-  if (!va_context->va_render_surfaces)
-    return NULL;
-
-  if(this->guarded_render) {
-    /* Get next VAAPI surface marked as SURFACE_FREE */
-    for(;;) {
-      int old_head = va_context->va_head;
-      va_context->va_head = (va_context->va_head + 1) % ((RENDER_SURFACES));
-
-      va_surface = &va_context->va_render_surfaces[old_head];
-
-      if( va_surface->status == SURFACE_FREE ) {
-
-        VASurfaceStatus surf_status = 0;
-
-        if(this->query_va_status) {
-          vaStatus = vaQuerySurfaceStatus(va_context->va_display, va_surface->va_surface_id, &surf_status);
-          vaapi_check_status(this, vaStatus, "vaQuerySurfaceStatus()");
-        } else {
-          surf_status = VASurfaceReady;
-        }
-
-        if(surf_status == VASurfaceReady) {
-
-          va_surface->status = SURFACE_ALOC;
-
-#ifdef DEBUG_SURFACE
-          printf("get_vaapi_surface 0x%08x\n", va_surface->va_surface_id);
-#endif
-
-          return &va_context->va_render_surfaces[old_head];
-        } else {
-#ifdef DEBUG_SURFACE
-          printf("get_vaapi_surface busy\n");
-#endif
-        }
-      }
-#ifdef DEBUG_SURFACE
-      printf("get_vaapi_surface miss\n");
-#endif
-    }
-  } else {
-      va_surface = &va_context->va_render_surfaces[frame->vaapi_accel_data.index];
-  }
-
-  return va_surface;
-}
-
-/* Set VAAPI surface status to render */
-static void render_vaapi_surface(vo_frame_t *frame_gen, ff_vaapi_surface_t *va_surface) {
-  vaapi_driver_t  *this = (vaapi_driver_t *) frame_gen->driver;
-  vaapi_accel_t *accel = (vaapi_accel_t*)frame_gen->accel_data;
-
-  lprintf("render_vaapi_surface\n");
-
-  if(!this->guarded_render || !accel || !va_surface)
-    return;
-
-  pthread_mutex_lock(&this->vaapi_lock);
-  //LOCK_DISPLAY (this);
-
-  accel->index = va_surface->index;
-
-  va_surface->status = SURFACE_RENDER;
-#ifdef DEBUG_SURFACE
-  printf("render_vaapi_surface 0x%08x\n", va_surface->va_surface_id);
-#endif
-
-  //UNLOCK_DISPLAY (this);
   pthread_mutex_unlock(&this->vaapi_lock);
 }
 
-/* Set VAAPI surface status to free */
-static void release_vaapi_surface(vo_frame_t *frame_gen, ff_vaapi_surface_t *va_surface) {
-  vaapi_driver_t  *this = (vaapi_driver_t *) frame_gen->driver;
-
-  lprintf("release_vaapi_surface\n");
-
-  if(va_surface == NULL || !this->guarded_render) {
-    return;
-  }
-
-  if(va_surface->status == SURFACE_RENDER) {
-    va_surface->status = SURFACE_RENDER_RELEASE;
-  } else if (va_surface->status != SURFACE_RENDER_RELEASE) {
-    va_surface->status = SURFACE_FREE;
-#ifdef DEBUG_SURFACE
-    printf("release_surface 0x%08x\n", va_surface->va_surface_id);
-#endif
-  }
-}
-
-static VADisplay vaapi_get_display(Display *display, int opengl_render)
-{
-  VADisplay ret;
-
-  if(opengl_render) {
-#ifdef ENABLE_VA_GLX
-    ret = vaGetDisplayGLX(display);
-#else
-    return NULL;
-#endif
-  } else {
-    ret = vaGetDisplay(display);
-  }
-
-  if (vaDisplayIsValid(ret))
-    return ret;
-
-  return NULL;
-}
-
-static VAStatus vaapi_terminate(ff_vaapi_context_t *va_context)
-{
-  VAStatus vaStatus = VA_STATUS_SUCCESS;
-
-  _x_freep(&va_context->va_image_formats);
-  va_context->va_num_image_formats  = 0;
-
-  if (va_context->va_display) {
-    vaStatus = vaTerminate(va_context->va_display);
-    va_context->va_display = NULL;
-  }
-
-  return vaStatus;
-}
-
-static VAStatus vaapi_initialize(ff_vaapi_context_t *va_context, Display *display, int opengl_render)
-{
-  VAStatus vaStatus;
-  int      maj, min;
-  int      fmt_count = 0;
-
-  va_context->va_display = vaapi_get_display(display, opengl_render);
-  if (!va_context->va_display) {
-    return VA_STATUS_ERROR_UNKNOWN;
-  }
-
-  vaStatus = vaInitialize(va_context->va_display, &maj, &min);
-  if (vaStatus != VA_STATUS_SUCCESS) {
-    goto fail;
-  }
-
-  lprintf("libva: %d.%d\n", maj, min);
-
-  fmt_count = vaMaxNumImageFormats(va_context->va_display);
-  va_context->va_image_formats = calloc(fmt_count, sizeof(*va_context->va_image_formats));
-  if (!va_context->va_image_formats) {
-    goto fail;
-  }
-
-  vaStatus = vaQueryImageFormats(va_context->va_display, va_context->va_image_formats, &va_context->va_num_image_formats);
-  if (vaStatus != VA_STATUS_SUCCESS) {
-    goto fail;
-  }
-
-  return vaStatus;
-
-fail:
-  _x_freep(&va_context->va_image_formats);
-  vaapi_terminate(va_context);
-  return vaStatus;
-}
-
 typedef struct {
   video_driver_class_t driver_class;
 
   xine_t              *xine;
+  unsigned             visual_type;
 } vaapi_class_t;
 
-static void delay_usec(unsigned int usec)
-{
-    // FIXME: xine_usec_sleep?
-    int was_error;
-
-#if defined(USE_NANOSLEEP)
-    struct timespec elapsed, tv;
-
-    elapsed.tv_sec = 0;
-    elapsed.tv_nsec = usec * 1000;
-
-    do {
-        errno = 0;
-        tv.tv_sec = elapsed.tv_sec;
-        tv.tv_nsec = elapsed.tv_nsec;
-        was_error = nanosleep(&tv, &elapsed);
-    } while (was_error && (errno == EINTR));
-
-#elif defined(USE_COND_TIMEDWAIT)
-    // Use a local mutex and cv, so threads remain independent
-    pthread_cond_t delay_cond = PTHREAD_COND_INITIALIZER;
-    pthread_mutex_t delay_mutex = PTHREAD_MUTEX_INITIALIZER;
-    struct timespec elapsed;
-    uint64_t future;
-
-    future = get_ticks_usec() + usec;
-    elapsed.tv_sec = future / 1000000;
-    elapsed.tv_nsec = (future % 1000000) * 1000;
-
-    do {
-        errno = 0;
-        was_error = pthread_mutex_lock(&delay_mutex);
-        was_error = pthread_cond_timedwait(&delay_cond, &delay_mutex, &elapsed);
-        was_error = pthread_mutex_unlock(&delay_mutex);
-    } while (was_error && (errno == EINTR));
-
-#else // using select()
-    struct timeval tv;
-# ifndef SELECT_SETS_REMAINING
-    uint64_t then, now, elapsed;
-
-    then = get_ticks_usec();
-# endif
-
-    tv.tv_sec = 0;
-    tv.tv_usec = usec;
-
-    do {
-        errno = 0;
-# ifndef SELECT_SETS_REMAINING
-        // Calculate the time interval left (in case of interrupt)
-        now = get_ticks_usec();
-        elapsed = now - then;
-        then = now;
-        if (elapsed >= usec)
-            break;
-        usec -= elapsed;
-        tv.tv_sec = 0;
-        tv.tv_usec = usec;
-# endif
-        was_error = select(0, NULL, NULL, NULL, &tv);
-    } while (was_error && (errno == EINTR));
-#endif
-}
-
 static void vaapi_x11_wait_event(Display *dpy, Window w, int type)
 {
   XEvent e;
   while (!XCheckTypedWindowEvent(dpy, w, type, &e))
-    delay_usec(10);
+    xine_usec_sleep(10);
 }
 
 /* X11 Error handler and error functions */
@@ -667,39 +394,29 @@
 static void vaapi_get_functions(void *(*getProcAddress)(const GLubyte *),
                                 const char *ext2)
 {
-#define DEF_FUNC_DESC(name) {&mpgl##name, NULL, {"gl"#name, NULL}, gl ##name}
   static const struct {
     void       *funcptr;
     const char *extstr;
     const char *funcnames[4];
-    void       *fallback;
   } extfuncs[] = {
-    DEF_FUNC_DESC(GenTextures),
     { &mpglBindTexture,
       NULL,
-      { "glBindTexture", "glBindTextureARB", "glBindTextureEXT", NULL },
-      NULL },
+      { "glBindTexture", "glBindTextureARB", "glBindTextureEXT", NULL } },
     { &mpglXBindTexImage,
       "GLX_EXT_texture_from_pixmap",
-      {" glXBindTexImageEXT", NULL },
-      NULL },
+      {" glXBindTexImageEXT", NULL }, },
     { &mpglXReleaseTexImage,
       "GLX_EXT_texture_from_pixmap",
-      { "glXReleaseTexImageEXT", NULL},
-      NULL },
+      { "glXReleaseTexImageEXT", NULL} },
     { &mpglXCreatePixmap,
       "GLX_EXT_texture_from_pixmap",
-      { "glXCreatePixmap", NULL },
-      NULL },
+      { "glXCreatePixmap", NULL } },
     { &mpglXDestroyPixmap,
       "GLX_EXT_texture_from_pixmap",
-      { "glXDestroyPixmap", NULL },
-      NULL },
+      { "glXDestroyPixmap", NULL } },
     { &mpglGenPrograms, "_program",
-      { "glGenProgramsARB", NULL },
-      NULL },
+      { "glGenProgramsARB", NULL } },
 };
-#undef DEF_FUNC_DESC
 
   const char *extensions;
   char *allexts;
@@ -728,8 +445,6 @@
       for (i = 0; !ptr && extfuncs[ext].funcnames[i]; i++)
         ptr = getProcAddress((const GLubyte *)extfuncs[ext].funcnames[i]);
     }
-    if (!ptr)
-        ptr = extfuncs[ext].fallback;
     *(void **)extfuncs[ext].funcptr = ptr;
   }
   lprintf("\n");
@@ -823,10 +538,8 @@
   return 0;
 }
 
-static void vaapi_glx_render_frame(vo_frame_t *frame_gen, int left, int top, int right, int bottom)
+static void vaapi_glx_render_frame(vaapi_driver_t *this, mem_frame_t *frame, int left, int top, int right, int bottom)
 {
-  vaapi_driver_t        *this = (vaapi_driver_t *) frame_gen->driver;
-  vaapi_frame_t         *frame = (vaapi_frame_t *) frame_gen;
   ff_vaapi_context_t    *va_context = this->va_context;
   int             x1, x2, y1, y2;
   float           tx, ty;
@@ -862,13 +575,11 @@
     return;
 }
 
-static void vaapi_glx_flip_page(vo_frame_t *frame_gen, int left, int top, int right, int bottom)
+static void vaapi_glx_flip_page(vaapi_driver_t *this, mem_frame_t *frame, int left, int top, int right, int bottom)
 {
-  vaapi_driver_t *this = (vaapi_driver_t *) frame_gen->driver;
-
   glClear(GL_COLOR_BUFFER_BIT);
 
-  vaapi_glx_render_frame(frame_gen, left, top, right, bottom);
+  vaapi_glx_render_frame(this, frame, left, top, right, bottom);
 
   //if (gl_finish)
   //  glFinish();
@@ -1173,153 +884,6 @@
   return this->capabilities;
 }
 
-static int vaapi_has_profile(VAProfile *va_profiles, int va_num_profiles, VAProfile profile)
-{
-  if (va_profiles && va_num_profiles > 0) {
-    int i;
-    for (i = 0; i < va_num_profiles; i++) {
-      if (va_profiles[i] == profile)
-        return 1;
-      }
-  }
-  return 0;
-}
-
-static int profile_from_imgfmt(vo_frame_t *frame_gen, unsigned format)
-{
-  vo_driver_t         *this_gen   = (vo_driver_t *) frame_gen->driver;
-  vaapi_driver_t      *this       = (vaapi_driver_t *) this_gen;
-  ff_vaapi_context_t  *va_context = this->va_context;
-  VAStatus            vaStatus;
-  int                 profile     = -1;
-  int                 i;
-  int                 va_num_profiles;
-  int                 max_profiles;
-  VAProfile           *va_profiles = NULL;
-
-  _x_assert(va_context->va_display);
-
-  max_profiles = vaMaxNumProfiles(va_context->va_display);
-  va_profiles = calloc(max_profiles, sizeof(*va_profiles));
-  if (!va_profiles)
-    goto out;
-
-  vaStatus = vaQueryConfigProfiles(va_context->va_display, va_profiles, &va_num_profiles);
-  if(!vaapi_check_status(this, vaStatus, "vaQueryConfigProfiles()"))
-    goto out;
-
-  xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " VAAPI Supported Profiles : ");
-  for (i = 0; i < va_num_profiles; i++) {
-    printf("%s ", vaapi_profile_to_string(va_profiles[i]));
-  }
-  printf("\n");
-
-  static const int mpeg2_profiles[] = { VAProfileMPEG2Main, VAProfileMPEG2Simple, -1 };
-  static const int mpeg4_profiles[] = { VAProfileMPEG4Main, VAProfileMPEG4AdvancedSimple, VAProfileMPEG4Simple, -1 };
-  static const int h264_profiles[]  = { VAProfileH264High, VAProfileH264Main, -1 };
-#if VA_CHECK_VERSION(0, 37, 0)
-  static const int hevc_profiles[]  = { VAProfileHEVCMain, VAProfileHEVCMain10, -1 };
-  static const int hevc_profiles10[]  = { VAProfileHEVCMain10, -1 };
-#endif
-  static const int wmv3_profiles[]  = { VAProfileVC1Main, VAProfileVC1Simple, -1 };
-  static const int vc1_profiles[]   = { VAProfileVC1Advanced, -1 };
-
-  const int *profiles = NULL;
-  switch (IMGFMT_VAAPI_CODEC(format)) 
-  {
-    case IMGFMT_VAAPI_CODEC_MPEG2:
-      profiles = mpeg2_profiles;
-      break;
-    case IMGFMT_VAAPI_CODEC_MPEG4:
-      profiles = mpeg4_profiles;
-      break;
-    case IMGFMT_VAAPI_CODEC_H264:
-      profiles = h264_profiles;
-      break;
-#if VA_CHECK_VERSION(0, 37, 0)
-    case IMGFMT_VAAPI_CODEC_HEVC:
-      switch (format) {
-        case IMGFMT_VAAPI_HEVC_MAIN10:
-          profiles = hevc_profiles10;
-          break;
-        case IMGFMT_VAAPI_HEVC:
-        default:
-          profiles = hevc_profiles;
-          break;
-      }
-      break;
-#endif
-    case IMGFMT_VAAPI_CODEC_VC1:
-      switch (format) {
-        case IMGFMT_VAAPI_WMV3:
-          profiles = wmv3_profiles;
-          break;
-        case IMGFMT_VAAPI_VC1:
-            profiles = vc1_profiles;
-            break;
-      }
-      break;
-  }
-
-  if (profiles) {
-    int i;
-    for (i = 0; profiles[i] != -1; i++) {
-      if (vaapi_has_profile(va_profiles, va_num_profiles, profiles[i])) {
-        profile = profiles[i];
-        xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " VAAPI Profile %s supported by your hardware\n", vaapi_profile_to_string(profiles[i]));
-        break;
-      }
-    }
-  }
-
-out:
-  free(va_profiles);
-  return profile;
-}
-
-
-static const char *vaapi_profile_to_string(VAProfile profile)
-{
-  switch(profile) {
-#define PROFILE(profile) \
-    case VAProfile##profile: return "VAProfile" #profile
-      PROFILE(MPEG2Simple);
-      PROFILE(MPEG2Main);
-      PROFILE(MPEG4Simple);
-      PROFILE(MPEG4AdvancedSimple);
-      PROFILE(MPEG4Main);
-      PROFILE(H264Main);
-      PROFILE(H264High);
-      PROFILE(VC1Simple);
-      PROFILE(VC1Main);
-      PROFILE(VC1Advanced);
-#if VA_CHECK_VERSION(0, 37, 0)
-      PROFILE(HEVCMain);
-      PROFILE(HEVCMain10);
-#endif
-#undef PROFILE
-    default: break;
-  }
-  return "<unknown>";
-}
-
-static const char *vaapi_entrypoint_to_string(VAEntrypoint entrypoint)
-{
-  switch(entrypoint)
-  {
-#define ENTRYPOINT(entrypoint) \
-    case VAEntrypoint##entrypoint: return "VAEntrypoint" #entrypoint
-      ENTRYPOINT(VLD);
-      ENTRYPOINT(IZZ);
-      ENTRYPOINT(IDCT);
-      ENTRYPOINT(MoComp);
-      ENTRYPOINT(Deblocking);
-#undef ENTRYPOINT
-    default: break;
-  }
-  return "<unknown>";
-}
-
 /* Init subpicture */
 static void vaapi_init_subpicture(vaapi_driver_t *this) {
   this->va_subpic_width               = 0;
@@ -1337,30 +901,9 @@
   this->va_num_subpic_formats = 0;
 }
 
-/* Init vaapi context */
-static void vaapi_init_va_context(ff_vaapi_context_t *va_context) {
-  int i;
-
-  va_context->va_config_id              = VA_INVALID_ID;
-  va_context->va_context_id             = VA_INVALID_ID;
-  va_context->valid_context             = 0;
-  va_context->va_head                   = 0;
-
-  for(i = 0; i < RENDER_SURFACES; i++) {
-    ff_vaapi_surface_t *va_surface      = &va_context->va_render_surfaces[i];
-
-    va_surface->index                   = i;
-    va_surface->status                  = SURFACE_FREE;
-    va_surface->va_surface_id           = VA_INVALID_SURFACE;
-
-    va_context->va_surface_ids[i]       = VA_INVALID_SURFACE;
-  }
-}
-
 /* Close vaapi  */
 static void vaapi_close(vaapi_driver_t *this) {
   ff_vaapi_context_t    *va_context = this->va_context;
-  VAStatus              vaStatus;
 
   if(!va_context || !va_context->va_display || !va_context->valid_context)
     return;
@@ -1371,112 +914,10 @@
   destroy_glx(this);
 #endif
 
-  if(va_context->va_context_id != VA_INVALID_ID) {
-    vaStatus = vaDestroyContext(va_context->va_display, va_context->va_context_id);
-    vaapi_check_status(this, vaStatus, "vaDestroyContext()");
-    va_context->va_context_id = VA_INVALID_ID;
-  }
-  
   vaapi_destroy_subpicture(this);
   vaapi_destroy_soft_surfaces(this);
-  vaapi_destroy_render_surfaces(this);
-
-  if(va_context->va_config_id != VA_INVALID_ID) {
-    vaStatus = vaDestroyConfig(va_context->va_display, va_context->va_config_id);
-    vaapi_check_status(this, vaStatus, "vaDestroyConfig()");
-    va_context->va_config_id = VA_INVALID_ID;
-  }
-
-  _x_freep(&this->va_subpic_formats);
-  this->va_num_subpic_formats = 0;
-
-  va_context->valid_context = 0;
-}
-
-/* Returns internal VAAPI context */
-static ff_vaapi_context_t *get_context(vo_frame_t *frame_gen) {
-  vaapi_driver_t        *this = (vaapi_driver_t *) frame_gen->driver;
 
-  return this->va_context;
-}
-
-/* Free allocated VAAPI image */
-static void vaapi_destroy_image(vaapi_driver_t *this, VAImage *va_image) {
-  ff_vaapi_context_t    *va_context = this->va_context;
-  VAStatus              vaStatus;
-
-  if(va_image->image_id != VA_INVALID_ID) {
-    lprintf("vaapi_destroy_image 0x%08x\n", va_image->image_id);
-    vaStatus = vaDestroyImage(va_context->va_display, va_image->image_id);
-    vaapi_check_status(this, vaStatus, "vaDestroyImage()");
-  }
-  va_image->image_id      = VA_INVALID_ID;
-  va_image->width         = 0;
-  va_image->height        = 0;
-}
-
-/* Allocated VAAPI image */
-static VAStatus vaapi_create_image(vaapi_driver_t *this, VASurfaceID va_surface_id, VAImage *va_image, int width, int height, int clear) {
-  ff_vaapi_context_t    *va_context = this->va_context;
-
-  int i = 0;
-  VAStatus vaStatus;
-
-  if(!va_context->valid_context || va_context->va_image_formats == NULL || va_context->va_num_image_formats == 0)
-    return VA_STATUS_ERROR_UNKNOWN;
-
-  this->is_bound = 0;
-
-  vaStatus = vaDeriveImage(va_context->va_display, va_surface_id, va_image);
-  if(vaStatus == VA_STATUS_SUCCESS) {
-    if (va_image->image_id != VA_INVALID_ID && va_image->buf != VA_INVALID_ID) {
-      this->is_bound = 1;
-    }
-  }
-
-  if (!this->is_bound) {
-    for (i = 0; i < va_context->va_num_image_formats; i++) {
-      if (va_context->va_image_formats[i].fourcc == VA_FOURCC( 'Y', 'V', '1', '2' ) ||
-          va_context->va_image_formats[i].fourcc == VA_FOURCC( 'I', '4', '2', '0' ) /*||
-          va_context->va_image_formats[i].fourcc == VA_FOURCC( 'N', 'V', '1', '2' ) */) {
-        vaStatus = vaCreateImage( va_context->va_display, &va_context->va_image_formats[i], width, height, va_image );
-        if(!vaapi_check_status(this, vaStatus, "vaCreateImage()"))
-          goto error;
-        break;
-      }
-    }
-  }
-
-  void *p_base = NULL;
-
-  vaStatus = vaMapBuffer( va_context->va_display, va_image->buf, &p_base );
-  if(!vaapi_check_status(this, vaStatus, "vaMapBuffer()"))
-    goto error;
-
-  if(clear) {
-    if(va_image->format.fourcc == VA_FOURCC( 'Y', 'V', '1', '2' ) ||
-       va_image->format.fourcc == VA_FOURCC( 'I', '4', '2', '0' )) {
-      memset((uint8_t*)p_base + va_image->offsets[0],   0, va_image->pitches[0] * va_image->height);
-      memset((uint8_t*)p_base + va_image->offsets[1], 128, va_image->pitches[1] * (va_image->height/2));
-      memset((uint8_t*)p_base + va_image->offsets[2], 128, va_image->pitches[2] * (va_image->height/2));
-    } else if (va_image->format.fourcc == VA_FOURCC( 'N', 'V', '1', '2' ) ) {
-      memset((uint8_t*)p_base + va_image->offsets[0],   0, va_image->pitches[0] * va_image->height);
-      memset((uint8_t*)p_base + va_image->offsets[1], 128, va_image->pitches[1] * (va_image->height/2));
-    }
-  }
-
-  vaStatus = vaUnmapBuffer( va_context->va_display, va_image->buf );
-  vaapi_check_status(this, vaStatus, "vaUnmapBuffer()");
-
-  lprintf("vaapi_create_image 0x%08x width %d height %d format %s\n", va_image->image_id, va_image->width, va_image->height,
-      string_of_VAImageFormat(&va_image->format));
-
-  return VA_STATUS_SUCCESS;
-
-error:
-  /* house keeping */
-  vaapi_destroy_image(this, va_image);
-  return VA_STATUS_ERROR_UNKNOWN;
+  _x_va_close(this->va);
 }
 
 /* Deassociate and free subpicture */
@@ -1489,11 +930,11 @@
 
   if (this->va_subpic_id != VA_INVALID_ID) {
     vaStatus = vaDestroySubpicture(va_context->va_display, this->va_subpic_id);
-    vaapi_check_status(this, vaStatus, "vaDeassociateSubpicture()");
+    vaapi_check_status(this, vaStatus, "vaDestroySubpicture()");
   }
   this->va_subpic_id = VA_INVALID_ID;
 
-  vaapi_destroy_image(this, &this->va_subpic_image);
+  _x_va_destroy_image(this->va, &this->va_subpic_image);
 
 }
 
@@ -1550,7 +991,7 @@
     vaapi_destroy_subpicture(this);
   this->va_subpic_id = VA_INVALID_ID;
 
-  vaapi_destroy_image(this, &this->va_subpic_image);
+  _x_va_destroy_image(this->va, &this->va_subpic_image);
 
   this->overlay_output_width  = 0;
   this->overlay_output_height = 0;
@@ -1600,7 +1041,7 @@
   return 1.0;
 }
 
-static void vaapi_update_csc (vaapi_driver_t *that, vaapi_frame_t *frame) {
+static void vaapi_update_csc (vaapi_driver_t *that, mem_frame_t *frame) {
   int color_matrix;
   int i;
 
@@ -1820,8 +1261,6 @@
   /*VAStatus vaStatus = */ vaSetDisplayAttributes(va_context->va_display, &attr, 1);
   //vaapi_check_status(this, vaStatus, "vaSetDisplayAttributes()");
 
-  vaapi_show_display_props(this);
-
   UNLOCK_DISPLAY (this);
   pthread_mutex_unlock(&this->vaapi_lock);
 }
@@ -1874,21 +1313,6 @@
   }
 }
 
-static void vaapi_show_display_props(vaapi_driver_t *this) {
-#if 0
-  if(this->capabilities & VO_CAP_BRIGHTNESS)
-    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : brightness     : %d\n", this->props[VO_PROP_BRIGHTNESS].value);
-  if(this->capabilities & VO_CAP_CONTRAST)
-    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : contrast       : %d\n", this->props[VO_PROP_CONTRAST].value);
-  if(this->capabilities & VO_CAP_HUE)
-    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : hue            : %d\n", this->props[VO_PROP_HUE].value);
-  if(this->capabilities & VO_CAP_SATURATION)
-    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : saturation     : %d\n", this->props[VO_PROP_SATURATION].value); 
-#else
-  (void)this;
-#endif
-}
-
 /* VAAPI display attributes. */
 static void vaapi_display_attribs(vaapi_driver_t *this) {
   ff_vaapi_context_t  *va_context = this->va_context;
@@ -1980,8 +1404,6 @@
         = (this->props[VO_PROP_BRIGHTNESS].max - this->props[VO_PROP_BRIGHTNESS].min) >> 1;
     }
   }
-
-  vaapi_show_display_props(this);
 }
 
 static void vaapi_set_background_color(vaapi_driver_t *this) {
@@ -2001,29 +1423,6 @@
   //vaapi_check_status(this, vaStatus, "vaSetDisplayAttributes()");
 }
 
-static VAStatus vaapi_destroy_render_surfaces(vaapi_driver_t *this) {
-  ff_vaapi_context_t  *va_context = this->va_context;
-  int                 i;
-  VAStatus            vaStatus;
-
-  for(i = 0; i < RENDER_SURFACES; i++) {
-    if (va_context->va_surface_ids[i] != VA_INVALID_SURFACE) {
-      vaStatus = vaSyncSurface(va_context->va_display, va_context->va_surface_ids[i]);
-      vaapi_check_status(this, vaStatus, "vaSyncSurface()");
-      vaStatus = vaDestroySurfaces(va_context->va_display, &va_context->va_surface_ids[i], 1);
-      vaapi_check_status(this, vaStatus, "vaDestroySurfaces()");
-      va_context->va_surface_ids[i] = VA_INVALID_SURFACE;
-
-      ff_vaapi_surface_t *va_surface  = &va_context->va_render_surfaces[i];
-      va_surface->index               = i;
-      va_surface->status              = SURFACE_FREE;
-      va_surface->va_surface_id       = va_context->va_surface_ids[i];
-    }
-  }
-
-  return VA_STATUS_SUCCESS;
-}
-
 static VAStatus vaapi_destroy_soft_surfaces(vaapi_driver_t *this) {
   ff_vaapi_context_t  *va_context = this->va_context;
   int                 i;
@@ -2032,7 +1431,7 @@
 
   for(i = 0; i < SOFT_SURFACES; i++) {
     if (this->va_soft_images[i].image_id != VA_INVALID_ID)
-      vaapi_destroy_image(this, &this->va_soft_images[i]);
+      _x_va_destroy_image(this->va, &this->va_soft_images[i]);
     this->va_soft_images[i].image_id = VA_INVALID_ID;
 
     if (this->va_soft_surface_ids[i] != VA_INVALID_SURFACE) {
@@ -2067,13 +1466,13 @@
   /* allocate software surfaces */
   for(i = 0; i < SOFT_SURFACES; i++) {
 
-    vaStatus = vaapi_create_image(this, this->va_soft_surface_ids[i], &this->va_soft_images[i], width, height, 1);
-    if(!vaapi_check_status(this, vaStatus, "vaapi_create_image()")) {
+    vaStatus = _x_va_create_image(this->va, this->va_soft_surface_ids[i], &this->va_soft_images[i], width, height, 1, &this->soft_image_is_bound);
+    if (!vaapi_check_status(this, vaStatus, "_x_va_create_image()")) {
       this->va_soft_images[i].image_id = VA_INVALID_ID;
       goto error;
     }
 
-    if (!this->is_bound) {
+    if (!this->soft_image_is_bound) {
       vaStatus = vaPutImage(va_context->va_display, this->va_soft_surface_ids[i], this->va_soft_images[i].image_id,
                0, 0, this->va_soft_images[i].width, this->va_soft_images[i].height,
                0, 0, this->va_soft_images[i].width, this->va_soft_images[i].height);
@@ -2096,118 +1495,49 @@
   return VA_STATUS_ERROR_UNKNOWN;
 }
 
+static int _flush_recent_frames (vaapi_driver_t *this) {
+  int i, n = 0;
+  for (i = 0; i < VO_NUM_RECENT_FRAMES; i++) {
+    if (this->recent_frames[i]) {
+      this->recent_frames[i]->free (this->recent_frames[i]);
+      this->recent_frames[i] = NULL;
+      n++;
+    }
+  }
+  return n;
+}
+
 static VAStatus vaapi_init_internal(vaapi_driver_t *this, int va_profile, int width, int height) {
-  ff_vaapi_context_t  *va_context = this->va_context;
-  VAConfigAttrib      va_attrib;
   int                 i;
   VAStatus            vaStatus;
 
   vaapi_close(this);
-  vaapi_init_va_context(this->va_context);
 
-  if (!this->va_context->va_display) {
-#ifdef ENABLE_VA_GLX
-    vaStatus = vaapi_initialize(va_context, this->display, this->opengl_render);
-#else
-    vaStatus = vaapi_initialize(va_context, this->display, 0);
-#endif
-    if(!vaapi_check_status(this, vaStatus, "vaInitialize()"))
-      goto error;
-  }
-
-  va_context->valid_context = 1;
-
-  int fmt_count = 0;
-  fmt_count = vaMaxNumSubpictureFormats( va_context->va_display );
-  this->va_subpic_formats = calloc( fmt_count, sizeof(*this->va_subpic_formats) );
+  _flush_recent_frames (this);
 
-  vaStatus = vaQuerySubpictureFormats( va_context->va_display, this->va_subpic_formats, 0, &this->va_num_subpic_formats );
-  if(!vaapi_check_status(this, vaStatus, "vaQuerySubpictureFormats()"))
+  vaStatus = _x_va_init(this->va, va_profile, width, height);
+  if (vaStatus != VA_STATUS_SUCCESS)
     goto error;
-  
-  const char *vendor = vaQueryVendorString(va_context->va_display);
-  xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Vendor : %s\n", vendor);
-    
-  this->query_va_status = 1;
-  const char *p = vendor;
-  for (i = strlen (vendor); i > 0; i--, p++) {
-    if(strncmp(p, "VDPAU", strlen("VDPAU")) == 0) {
-      xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Enable Splitted-Desktop Systems VDPAU-VIDEO workarounds.\n");
-      this->query_va_status = 0;
-#ifdef ENABLE_VA_GLX
-      this->opengl_use_tfp = 0;
-#endif
-      break;
-    }
-  }
-
-  vaapi_set_background_color(this);
-  vaapi_display_attribs(this);
-
-  va_context->width = width;
-  va_context->height = height;
-
-  xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : Context width %d height %d\n", va_context->width, va_context->height);
-
-  /* allocate decoding surfaces */
-  unsigned rt_format = VA_RT_FORMAT_YUV420;
-#if VA_CHECK_VERSION(0, 37, 0) && defined (VA_RT_FORMAT_YUV420_10BPP)
-  if (va_profile == VAProfileHEVCMain10) {
-    rt_format = VA_RT_FORMAT_YUV420_10BPP;
-  }
-#endif
-  vaStatus = vaCreateSurfaces(va_context->va_display, rt_format, va_context->width, va_context->height, va_context->va_surface_ids, RENDER_SURFACES, NULL, 0);
-  if(!vaapi_check_status(this, vaStatus, "vaCreateSurfaces()"))
-    goto error;
-
-  /* hardware decoding needs more setup */
-  if (va_profile >= 0) {
-    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : Profile: %d (%s) Entrypoint %d (%s) Surfaces %d\n", va_profile, vaapi_profile_to_string(va_profile), VAEntrypointVLD, vaapi_entrypoint_to_string(VAEntrypointVLD), RENDER_SURFACES);
-
-    memset( &va_attrib, 0, sizeof(va_attrib) );
-    va_attrib.type = VAConfigAttribRTFormat;
-
-    vaStatus = vaGetConfigAttributes(va_context->va_display, va_profile, VAEntrypointVLD, &va_attrib, 1);
-    if(!vaapi_check_status(this, vaStatus, "vaGetConfigAttributes()"))
-      goto error;
-  
-    if( (va_attrib.value & VA_RT_FORMAT_YUV420) == 0 )
-      goto error;
-
-    vaStatus = vaCreateConfig(va_context->va_display, va_profile, VAEntrypointVLD, &va_attrib, 1, &va_context->va_config_id);
-    if(!vaapi_check_status(this, vaStatus, "vaCreateConfig()")) {
-      va_context->va_config_id = VA_INVALID_ID;
-      goto error;
-    }
-
-    vaStatus = vaCreateContext(va_context->va_display, va_context->va_config_id, va_context->width, va_context->height,
-                               VA_PROGRESSIVE, va_context->va_surface_ids, RENDER_SURFACES, &va_context->va_context_id);
-    if(!vaapi_check_status(this, vaStatus, "vaCreateContext()")) {
-      va_context->va_context_id = VA_INVALID_ID;
-      goto error;
-    }
-  }
 
   /* xine was told to allocate RENDER_SURFACES frames. assign the frames the rendering surfaces. */
   for(i = 0; i < RENDER_SURFACES; i++) {
-    ff_vaapi_surface_t *va_surface  = &va_context->va_render_surfaces[i];
-    va_surface->index               = i;
-    va_surface->status              = SURFACE_FREE;
-    va_surface->va_surface_id       = va_context->va_surface_ids[i];
-
     if(this->frames[i]) {
       vaapi_frame_t *frame                  = this->frames[i];
-      frame->vaapi_accel_data.index         = i;
-
+      if (!this->guarded_render) {
+        frame->vaapi_accel_data.index = i;
+      } else {
+        frame->vaapi_accel_data.index = RENDER_SURFACES; /* invalid */
+      }
 #if 0
       /* this seems to break decoding to the surface ? */
       VAImage va_image;
-      vaStatus = vaapi_create_image(this, va_context->va_surface_ids[i], &va_image, width, height, 1);
-      if(vaapi_check_status(this, vaStatus, "vaapi_create_image()") && !this->is_bound) {
+      int is_bound;
+      vaStatus = _x_va_create_image(this->va, va_context->va_surface_ids[i], &va_image, width, height, 1, &is_bound);
+      if (vaapi_check_status(this, vaStatus, "_x_va_create_image()") && !is_bound) {
         vaStatus = vaPutImage(va_context->va_display, va_context->va_surface_ids[i], va_image.image_id,
                               0, 0, va_image.width, va_image.height,
                               0, 0, va_image.width, va_image.height);
-        vaapi_destroy_image(this, &va_image);
+        _x_va_destroy_image(this->va, &va_image);
       }
 #endif
     }
@@ -2228,7 +1558,7 @@
   xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : glxrender      : %d\n", this->opengl_render);
   xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : glxrender tfp  : %d\n", this->opengl_use_tfp);
 #endif
-  xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : is_bound       : %d\n", this->is_bound);
+  //xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : is_bound       : %d\n", this->is_bound);
   xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : scaling level  : name %s value 0x%08x\n", scaling_level_enum_names[this->scaling_level_enum], this->scaling_level);
 
 #ifdef ENABLE_VA_GLX
@@ -2239,8 +1569,6 @@
 
 error:
   vaapi_close(this);
-  vaapi_init_va_context(this->va_context);
-  va_context->valid_context = 0;
   xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_init : error init vaapi\n");
 
   return VA_STATUS_ERROR_UNKNOWN;
@@ -2280,36 +1608,19 @@
   return vaStatus;
 }
 
-static void vaapi_frame_proc_slice (vo_frame_t *vo_img, uint8_t **src)
-{
-  (void)src;
-  vo_img->proc_called = 1;
-}
-
-static void vaapi_frame_field (vo_frame_t *vo_img, int which_field)
-{
-  (void)vo_img;
-  (void)which_field;
-}
-
 static void vaapi_frame_dispose (vo_frame_t *vo_img) {
   vaapi_driver_t *this  = (vaapi_driver_t *) vo_img->driver;
-  vaapi_frame_t  *frame = (vaapi_frame_t *) vo_img ;
+  vaapi_frame_t  *frame = xine_container_of(vo_img, vaapi_frame_t, mem_frame.vo_frame);
   vaapi_accel_t  *accel = &frame->vaapi_accel_data;
 
   lprintf("vaapi_frame_dispose\n");
 
-  xine_freep_aligned(&frame->vo_frame.base[0]);
-  xine_freep_aligned(&frame->vo_frame.base[0]);
-  xine_freep_aligned(&frame->vo_frame.base[0]);
-
-  if(this->guarded_render) {
+  if (this->guarded_render && accel->index < RENDER_SURFACES) {
     ff_vaapi_surface_t *va_surface = &this->va_context->va_render_surfaces[accel->index];
     va_surface->status = SURFACE_FREE;
   }
 
-  pthread_mutex_destroy (&frame->vo_frame.mutex);
-  free (frame);
+  _mem_frame_dispose(vo_img);
 }
 
 static vo_frame_t *vaapi_alloc_frame (vo_driver_t *this_gen) {
@@ -2317,15 +1628,27 @@
   vaapi_frame_t   *frame;
   static const struct vaapi_accel_funcs_s accel_funcs = {
     .vaapi_init                = vaapi_init,
-    .profile_from_imgfmt       = profile_from_imgfmt,
-    .get_context               = get_context,
-    .lock_vaapi                = vaapi_lock_decode,
-    .unlock_vaapi              = vaapi_unlock_decode,
-
-    .get_vaapi_surface         = get_vaapi_surface,
-    .render_vaapi_surface      = render_vaapi_surface,
-    .release_vaapi_surface     = release_vaapi_surface,
-    .guarded_render            = guarded_render,
+    .profile_from_imgfmt       = _x_va_accel_profile_from_imgfmt,
+    .get_context               = _x_va_accel_get_context,
+    .lock_vaapi                = _x_va_accel_lock_decode_dummy,
+    .unlock_vaapi              = NULL,
+
+    .get_vaapi_surface         = _x_va_accel_get_vaapi_surface,
+    .render_vaapi_surface      = NULL,
+    .release_vaapi_surface     = NULL,
+    .guarded_render            = _x_va_accel_guarded_render,
+  };
+  static const struct vaapi_accel_funcs_s accel_funcs_guarded = {
+    .vaapi_init                = vaapi_init,
+    .profile_from_imgfmt       = _x_va_accel_profile_from_imgfmt,
+    .get_context               = _x_va_accel_get_context,
+    .lock_vaapi                = vaapi_lock_decode_guarded,
+    .unlock_vaapi              = vaapi_unlock_decode_guarded,
+
+    .get_vaapi_surface         = _x_va_accel_alloc_vaapi_surface,
+    .render_vaapi_surface      = _x_va_accel_render_vaapi_surface,
+    .release_vaapi_surface     = _x_va_accel_release_vaapi_surface,
+    .guarded_render            = _x_va_accel_guarded_render,
   };
 
   if (this->num_frame_buffers >= sizeof(this->frames) / sizeof(this->frames[0])) {
@@ -2334,36 +1657,27 @@
     return NULL;
   }
 
-  frame = (vaapi_frame_t *) calloc(1, sizeof(vaapi_frame_t));
+  frame = (vaapi_frame_t *)_mem_frame_alloc_frame(this_gen, sizeof(vaapi_frame_t));
 
   if (!frame)
     return NULL;
 
-  this->frames[this->num_frame_buffers++] = frame;
-
-  frame->vo_frame.base[0] = frame->vo_frame.base[1] = frame->vo_frame.base[2] = NULL;
-  frame->width = frame->height = frame->format = frame->flags = 0;
+  frame->mem_frame.vo_frame.dispose = vaapi_frame_dispose;
 
-  frame->vo_frame.accel_data = &frame->vaapi_accel_data;
+  this->frames[this->num_frame_buffers++] = frame;
 
-  pthread_mutex_init (&frame->vo_frame.mutex, NULL);
+  frame->mem_frame.vo_frame.accel_data = &frame->vaapi_accel_data;
+  frame->ctx_impl = this->va;
 
   /*
    * supply required functions
    */
-  frame->vo_frame.proc_duplicate_frame_data         = NULL;
-  frame->vo_frame.proc_provide_standard_frame_data  = NULL;
-  frame->vo_frame.proc_slice                        = vaapi_frame_proc_slice;
-  frame->vo_frame.proc_frame                        = NULL;
-  frame->vo_frame.field                             = vaapi_frame_field;
-  frame->vo_frame.dispose                           = vaapi_frame_dispose;
-  frame->vo_frame.driver                            = this_gen;
 
-  frame->vaapi_accel_data.f = &accel_funcs;
+  frame->vaapi_accel_data.f = this->guarded_render ? &accel_funcs_guarded : &accel_funcs;
 
   lprintf("alloc frame\n");
 
-  return (vo_frame_t *) frame;
+  return &frame->mem_frame.vo_frame;
 }
 
 
@@ -2526,7 +1840,7 @@
 
 static void vaapi_overlay_end (vo_driver_t *this_gen, vo_frame_t *frame_gen) {
   vaapi_driver_t      *this       = (vaapi_driver_t *) this_gen;
-  vaapi_frame_t       *frame      = (vaapi_frame_t *) frame_gen;
+  mem_frame_t         *frame      = xine_container_of(frame_gen, mem_frame_t, vo_frame);
   ff_vaapi_context_t  *va_context = this->va_context;
 
   int novls = this->ovl_changed;
@@ -2799,6 +2113,11 @@
   if (!accel)
     return;
 
+  if (accel->index >= RENDER_SURFACES /* invalid */) {
+    xprintf(driver->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_provide_standard_frame_data: invalid surface\n");
+    return;
+  }
+
   va_surface = &va_context->va_render_surfaces[accel->index];
   if (va_surface->va_surface_id == VA_INVALID_SURFACE)
     return;
@@ -2828,13 +2147,14 @@
     VAImage   va_image;
     VAStatus  vaStatus;
     void      *p_base;
+    int        is_bound;
 
     vaStatus = vaSyncSurface(va_context->va_display, va_surface->va_surface_id);
     vaapi_check_status(driver, vaStatus, "vaSyncSurface()");
 
     VASurfaceStatus surf_status = 0;
 
-    if(driver->query_va_status) {
+    if (driver->va->query_va_status) {
       vaStatus = vaQuerySurfaceStatus(va_context->va_display, va_surface->va_surface_id, &surf_status);
       vaapi_check_status(driver, vaStatus, "vaQuerySurfaceStatus()");
     } else {
@@ -2844,8 +2164,8 @@
     if(surf_status != VASurfaceReady)
       goto error;
 
-    vaStatus = vaapi_create_image(driver, va_surface->va_surface_id, &va_image, width, height, 0);
-    if(!vaapi_check_status(driver, vaStatus, "vaapi_create_image()"))
+    vaStatus = _x_va_create_image(driver->va, va_surface->va_surface_id, &va_image, width, height, 0, &is_bound);
+    if (!vaapi_check_status(driver, vaStatus, "_x_va_create_image()"))
       goto error;
 
     lprintf("vaapi_provide_standard_frame_data accel->va_surface_id 0x%08x va_image.image_id 0x%08x va_context->width %d va_context->height %d va_image.width %d va_image.height %d width %d height %d size1 %d size2 %d %d %d %d status %d num_planes %d\n", 
@@ -2855,7 +2175,7 @@
     if(va_image.image_id == VA_INVALID_ID)
       goto error;
 
-    if (!driver->is_bound) {
+    if (!is_bound) {
       vaStatus = vaGetImage(va_context->va_display, va_surface->va_surface_id, 0, 0,
                           va_image.width, va_image.height, va_image.image_id);
     } else {
@@ -2910,7 +2230,7 @@
 
         vaStatus = vaUnmapBuffer(va_context->va_display, va_image.buf);
         vaapi_check_status(driver, vaStatus, "vaUnmapBuffer()");
-        vaapi_destroy_image(driver, &va_image);
+        _x_va_destroy_image(driver->va, &va_image);
       }
     }
   }
@@ -2925,19 +2245,14 @@
   vaapi_driver_t      *driver     = (vaapi_driver_t *) original->driver;
   ff_vaapi_context_t  *va_context = driver->va_context;
 
-  vaapi_frame_t *this = (vaapi_frame_t *)this_gen;
-  vaapi_frame_t *orig = (vaapi_frame_t *)original;
-
-  vaapi_accel_t      *accel_this = &this->vaapi_accel_data;
-  vaapi_accel_t      *accel_orig = &orig->vaapi_accel_data;
+  mem_frame_t *this = xine_container_of(this_gen, mem_frame_t, vo_frame);
+  mem_frame_t *orig = xine_container_of(original, mem_frame_t, vo_frame);
 
-  ff_vaapi_surface_t *va_surface_this = &va_context->va_render_surfaces[accel_this->index];
-  ff_vaapi_surface_t *va_surface_orig = &va_context->va_render_surfaces[accel_orig->index];
+  vaapi_accel_t *accel_this = this_gen->accel_data;
+  vaapi_accel_t *accel_orig = original->accel_data;
 
-  lprintf("vaapi_duplicate_frame_data %s %s 0x%08x 0x%08x\n", 
-      (this_gen->format == XINE_IMGFMT_VAAPI) ? "XINE_IMGFMT_VAAPI" : ((this_gen->format == XINE_IMGFMT_YV12) ? "XINE_IMGFMT_YV12" : "XINE_IMGFMT_YUY2"),
-      (original->format == XINE_IMGFMT_VAAPI) ? "XINE_IMGFMT_VAAPI" : ((original->format == XINE_IMGFMT_YV12) ? "XINE_IMGFMT_YV12" : "XINE_IMGFMT_YUY2"),
-      va_surface_this->va_surface_id, va_surface_orig->va_surface_id);
+  ff_vaapi_surface_t *va_surface_this;
+  ff_vaapi_surface_t *va_surface_orig;
 
   if (orig->vo_frame.format != XINE_IMGFMT_VAAPI) {
     xprintf(driver->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_duplicate_frame_data: unexpected frame format 0x%08x!\n", orig->format);
@@ -2949,6 +2264,28 @@
     return;
   }
 
+  if (driver->guarded_render) {
+    if (accel_orig->index >= RENDER_SURFACES) {
+      xprintf(driver->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_duplicate_frame_data: invalid source surface\n");
+      return;
+    }
+    va_surface_orig = &va_context->va_render_surfaces[accel_orig->index];
+
+    va_surface_this = _x_va_accel_alloc_vaapi_surface(this_gen);
+    if (!va_surface_this) {
+      xprintf(driver->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_duplicate_frame_data: surface allocation failed\n");
+      return;
+    }
+  } else {
+    _x_assert (accel_this->index < RENDER_SURFACES); /* "fixed" in this mode */
+    _x_assert (accel_orig->index < RENDER_SURFACES); /* "fixed" in this mode */
+    va_surface_this = &va_context->va_render_surfaces[accel_this->index];
+    va_surface_orig = &va_context->va_render_surfaces[accel_orig->index];
+  }
+
+  lprintf("vaapi_duplicate_frame_data  0x%08x <- 0x%08x\n",
+          va_surface_this->va_surface_id, va_surface_orig->va_surface_id);
+
   pthread_mutex_lock(&driver->vaapi_lock);
   LOCK_DISPLAY (driver);
 
@@ -2968,15 +2305,16 @@
   int this_height = va_context->height;
   int orig_width = va_context->width;
   int orig_height = va_context->height;
+  int this_is_bound, orig_is_bound;
 
-  vaStatus = vaapi_create_image(driver, va_surface_orig->va_surface_id, &va_image_orig, orig_width, orig_height, 0);
-  if(!vaapi_check_status(driver, vaStatus, "vaapi_create_image()")) {
+  vaStatus = _x_va_create_image(driver->va, va_surface_orig->va_surface_id, &va_image_orig, orig_width, orig_height, 0, &orig_is_bound);
+  if (!vaapi_check_status(driver, vaStatus, "_x_va_create_image()")) {
     va_image_orig.image_id = VA_INVALID_ID;
     goto error;
   }
 
-  vaStatus = vaapi_create_image(driver, va_surface_this->va_surface_id, &va_image_this, this_width, this_height, 0);
-  if(!vaapi_check_status(driver, vaStatus, "vaapi_create_image()")) {
+  vaStatus = _x_va_create_image(driver->va, va_surface_this->va_surface_id, &va_image_this, this_width, this_height, 0, &this_is_bound);
+  if (!vaapi_check_status(driver, vaStatus, "_x_va_create_image()")) {
     va_image_this.image_id = VA_INVALID_ID;
     goto error;
   }
@@ -2990,7 +2328,7 @@
        va_image_orig.image_id, va_image_orig.width, va_image_orig.height, this->width, this->height, va_image_orig.data_size, 
        va_image_orig.pitches[0], va_image_orig.pitches[1], va_image_orig.pitches[2]);
 
-  if (!driver->is_bound) {
+  if (!orig_is_bound) {
     vaStatus = vaGetImage(va_context->va_display, va_surface_orig->va_surface_id, 0, 0,
                           va_image_orig.width, va_image_orig.height, va_image_orig.image_id);
   } else {
@@ -2999,7 +2337,7 @@
 
   if(vaapi_check_status(driver, vaStatus, "vaGetImage()")) {
     
-    if (!driver->is_bound) {
+    if (!this_is_bound) {
       vaStatus = vaPutImage(va_context->va_display, va_surface_this->va_surface_id, va_image_orig.image_id,
                             0, 0, va_image_orig.width, va_image_orig.height,
                             0, 0, va_image_this.width, va_image_this.height);
@@ -3021,7 +2359,7 @@
 
   if (driver->guarded_render) {
     accel_this->index = va_surface_this->index;
-    va_surface_this->status = SURFACE_RENDER;
+    va_surface_this->status = SURFACE_RENDER_RELEASE;
   }
 
 error:
@@ -3034,8 +2372,8 @@
     vaapi_check_status(driver, vaStatus, "vaUnmapBuffer()");
   }
 
-  vaapi_destroy_image(driver, &va_image_orig);
-  vaapi_destroy_image(driver, &va_image_this);
+  _x_va_destroy_image(driver->va, &va_image_orig);
+  _x_va_destroy_image(driver->va, &va_image_this);
 
   UNLOCK_DISPLAY (driver);
   pthread_mutex_unlock(&driver->vaapi_lock);
@@ -3046,86 +2384,33 @@
                                        uint32_t width, uint32_t height,
                                        double ratio, int format, int flags) {
   vaapi_driver_t      *this       = (vaapi_driver_t *) this_gen;
-  vaapi_frame_t       *frame      = (vaapi_frame_t*)frame_gen;
-  vaapi_accel_t       *accel      = &frame->vaapi_accel_data;
+  mem_frame_t         *frame      = xine_container_of(frame_gen, mem_frame_t, vo_frame);
+
+  if (this->guarded_render && frame->format == XINE_IMGFMT_VAAPI) {
+    /* This code handles frames that were dropped (used in decoder, but not drawn). */
+    _x_va_frame_displayed(frame_gen);
+  }
 
   lprintf("vaapi_update_frame_format %s %s width %d height %d\n", 
         (frame->format == XINE_IMGFMT_VAAPI) ? "XINE_IMGFMT_VAAPI" : ((frame->format == XINE_IMGFMT_YV12) ? "XINE_IMGFMT_YV12" : "XINE_IMGFMT_YUY2") ,
         (format == XINE_IMGFMT_VAAPI) ? "XINE_IMGFMT_VAAPI" : ((format == XINE_IMGFMT_YV12) ? "XINE_IMGFMT_YV12" : "XINE_IMGFMT_YUY2") ,
         width, height);
 
-  frame->vo_frame.width = width;
-  frame->vo_frame.height = height;
-
-  if ((frame->width != (int)width)
-      || (frame->height != (int)height)
-      || (frame->format != format)) {
-
-    // (re-) allocate render space
-    xine_freep_aligned(&frame->vo_frame.base[0]);
-    xine_freep_aligned(&frame->vo_frame.base[1]);
-    xine_freep_aligned(&frame->vo_frame.base[2]);
-
-    /* set init_vaapi on frame formats XINE_IMGFMT_YV12/XINE_IMGFMT_YUY2 only.
-     * for XINE_IMGFMT_VAAPI the init was already done.
-     */
-    if (format == XINE_IMGFMT_YV12) {
-      frame->vo_frame.pitches[0] = 8*((width + 7) / 8);
-      frame->vo_frame.pitches[1] = 8*((width + 15) / 16);
-      frame->vo_frame.pitches[2] = 8*((width + 15) / 16);
-
-      frame->vo_frame.base[0] = xine_mallocz_aligned (frame->vo_frame.pitches[0] * height);
-      frame->vo_frame.base[1] = xine_mallocz_aligned (frame->vo_frame.pitches[1] * ((height+1)/2));
-      frame->vo_frame.base[2] = xine_mallocz_aligned (frame->vo_frame.pitches[2] * ((height+1)/2));
+  if ((frame->width ^ width) | (frame->height ^ height) | (frame->format ^ format)) {
 
-      frame->vo_frame.proc_duplicate_frame_data = NULL;
-      frame->vo_frame.proc_provide_standard_frame_data = NULL;
-      lprintf("XINE_IMGFMT_YV12 width %d height %d\n", width, height);
-    } else if (format == XINE_IMGFMT_YUY2){
-      frame->vo_frame.pitches[0] = 8*((width + 3) / 4);
+    mem_frame_update_frame_format(this_gen, frame_gen, width, height, ratio, format, flags);
 
-      frame->vo_frame.base[0] = xine_mallocz_aligned (frame->vo_frame.pitches[0] * height);
-
-      frame->vo_frame.proc_duplicate_frame_data = NULL;
-      frame->vo_frame.proc_provide_standard_frame_data = NULL;
-      lprintf("XINE_IMGFMT_YUY2 width %d height %d\n", width, height);
-    } else if (format == XINE_IMGFMT_VAAPI) {
+    if (format == XINE_IMGFMT_VAAPI) {
+      frame->width = width; /* mem_frame freed frame->base */
+      frame->vo_frame.width = width;
       frame->vo_frame.proc_duplicate_frame_data = vaapi_duplicate_frame_data;
       frame->vo_frame.proc_provide_standard_frame_data = vaapi_provide_standard_frame_data;
       lprintf("XINE_IMGFMT_VAAPI width %d height %d\n", width, height);
-    }
-
-    frame->width  = width;
-    frame->height = height;
-    frame->format = format;
-    frame->flags  = flags;
-    vaapi_frame_field ((vo_frame_t *)frame, flags);
-  }
-
-  pthread_mutex_lock(&this->vaapi_lock);
-  LOCK_DISPLAY (this);
-
-  if(this->guarded_render) {
-    ff_vaapi_surface_t *va_surface = &this->va_context->va_render_surfaces[accel->index];
-
-    if(va_surface->status == SURFACE_RENDER_RELEASE) {
-      va_surface->status = SURFACE_FREE;
-#ifdef DEBUG_SURFACE
-      printf("release_surface vaapi_update_frame_format 0x%08x\n", va_surface->va_surface_id);
-#endif
-    } else if(va_surface->status == SURFACE_RENDER) {
-      va_surface->status = SURFACE_RELEASE;
-#ifdef DEBUG_SURFACE
-      printf("release_surface vaapi_update_frame_format 0x%08x\n", va_surface->va_surface_id);
-#endif
+    } else {
+      frame->vo_frame.proc_duplicate_frame_data = NULL;
+      frame->vo_frame.proc_provide_standard_frame_data = NULL;
     }
   }
-
-  UNLOCK_DISPLAY (this);
-  pthread_mutex_unlock(&this->vaapi_lock);
-
-  frame->ratio  = ratio;
-  frame->vo_frame.future_frame = NULL;
 }
 
 static void yv12_to_nv12(const uint8_t *y_src, int y_src_pitch, 
@@ -3199,9 +2484,8 @@
 }
 
 
-static VAStatus vaapi_software_render_frame(vaapi_driver_t *this, vo_frame_t *frame_gen,
-                                            VAImage *va_image, VASurfaceID va_surface_id) {
-  vaapi_frame_t      *frame           = (vaapi_frame_t *) frame_gen;
+static VAStatus vaapi_software_render_frame(vaapi_driver_t *this, mem_frame_t *frame,
+                                            VAImage *va_image, int is_bound, VASurfaceID va_surface_id) {
   ff_vaapi_context_t *va_context      = this->va_context;
   void               *p_base          = NULL;
   VAStatus           vaStatus;
@@ -3244,26 +2528,26 @@
 
       yv12_to_yv12(
               /* Y */
-              frame_gen->base[0], frame_gen->pitches[0],
+              frame->vo_frame.base[0], frame->vo_frame.pitches[0],
               dst[0], pitches[0],
               /* U */
-              frame_gen->base[1], frame_gen->pitches[1],
+              frame->vo_frame.base[1], frame->vo_frame.pitches[1],
               dst[1], pitches[1],
               /* V */
-              frame_gen->base[2], frame_gen->pitches[2],
+              frame->vo_frame.base[2], frame->vo_frame.pitches[2],
               dst[2], pitches[2],
               /* width x height */
-              frame_gen->width, frame_gen->height);
+              frame->vo_frame.width, frame->vo_frame.height);
 
     } else if (va_image->format.fourcc == VA_FOURCC( 'N', 'V', '1', '2' )) {
       lprintf("vaapi_software_render_frame yv12 -> nv12 convert\n");
 
-      yv12_to_nv12(frame_gen->base[0], frame_gen->pitches[0],
-                   frame_gen->base[1], frame_gen->pitches[1],
-                   frame_gen->base[2], frame_gen->pitches[2],
+      yv12_to_nv12(frame->vo_frame.base[0], frame->vo_frame.pitches[0],
+                   frame->vo_frame.base[1], frame->vo_frame.pitches[1],
+                   frame->vo_frame.base[2], frame->vo_frame.pitches[2],
                    (uint8_t *)p_base + va_image->offsets[0], va_image->pitches[0],
                    (uint8_t *)p_base + va_image->offsets[1], va_image->pitches[1],
-                   frame_gen->width, frame_gen->height);
+                   frame->vo_frame.width, frame->vo_frame.height);
 
     }
   } else if (frame->format == XINE_IMGFMT_YUY2) {
@@ -3272,19 +2556,19 @@
         va_image->format.fourcc == VA_FOURCC( 'I', '4', '2', '0' ) ) {
       lprintf("vaapi_software_render_frame yuy2 -> yv12 convert\n");
 
-      yuy2_to_yv12(frame_gen->base[0], frame_gen->pitches[0],
+      yuy2_to_yv12(frame->vo_frame.base[0], frame->vo_frame.pitches[0],
                   dst[0], pitches[0],
                   dst[1], pitches[1],
                   dst[2], pitches[2],
-                  frame_gen->width, frame_gen->height);
+                  frame->vo_frame.width, frame->vo_frame.height);
 
     } else if (va_image->format.fourcc == VA_FOURCC( 'N', 'V', '1', '2' )) {
       lprintf("vaapi_software_render_frame yuy2 -> nv12 convert\n");
 
-      yuy2_to_nv12(frame_gen->base[0], frame_gen->pitches[0],
+      yuy2_to_nv12(frame->vo_frame.base[0], frame->vo_frame.pitches[0],
                    (uint8_t *)p_base + va_image->offsets[0], va_image->pitches[0],
                    (uint8_t *)p_base + va_image->offsets[1], va_image->pitches[1],
-                   frame_gen->width, frame_gen->height);
+                   frame->vo_frame.width, frame->vo_frame.height);
     }
 
   }
@@ -3293,7 +2577,7 @@
   if(!vaapi_check_status(this, vaStatus, "vaUnmapBuffer()"))
     return vaStatus;
 
-  if (!this->is_bound) {
+  if (!is_bound) {
     vaStatus = vaPutImage(va_context->va_display, va_surface_id, va_image->image_id,
                         0, 0, va_image->width, va_image->height,
                         0, 0, va_image->width, va_image->height);
@@ -3304,9 +2588,8 @@
   return VA_STATUS_SUCCESS;
 }
 
-static VAStatus vaapi_hardware_render_frame (vaapi_driver_t *this, vo_frame_t *frame_gen,
+static VAStatus vaapi_hardware_render_frame (vaapi_driver_t *this, mem_frame_t *frame,
                                              VASurfaceID va_surface_id) {
-  vaapi_frame_t      *frame           = (vaapi_frame_t *) frame_gen;
   ff_vaapi_context_t *va_context      = this->va_context;
   VAStatus           vaStatus         = VA_STATUS_ERROR_UNKNOWN; 
   int                i                = 0;
@@ -3369,7 +2652,7 @@
       if(!vaapi_check_status(this, vaStatus, msg))
         return vaStatus;
 
-      vaapi_glx_flip_page(frame_gen, 0, 0, va_context->width, va_context->height);
+      vaapi_glx_flip_page(this, frame, 0, 0, va_context->width, va_context->height);
 
     } else
 #endif
@@ -3402,10 +2685,26 @@
 }
 */
 
+static void _add_recent_frame (vaapi_driver_t *this, vo_frame_t *vo_frame) {
+  int i;
+
+  i = VO_NUM_RECENT_FRAMES-1;
+  if (this->recent_frames[i]) {
+    if (this->guarded_render && vo_frame->format == XINE_IMGFMT_VAAPI)
+      _x_va_frame_displayed(this->recent_frames[i]);
+    this->recent_frames[i]->free (this->recent_frames[i]);
+  }
+
+  for( ; i ; i-- )
+    this->recent_frames[i] = this->recent_frames[i-1];
+
+  this->recent_frames[0] = vo_frame;
+}
+
 static void vaapi_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen) {
   vaapi_driver_t     *this          = (vaapi_driver_t *) this_gen;
-  vaapi_frame_t      *frame         = (vaapi_frame_t *) frame_gen;
-  vaapi_accel_t      *accel         = &frame->vaapi_accel_data;
+  vaapi_accel_t      *accel         = frame_gen->accel_data;
+  mem_frame_t        *frame         = xine_container_of(frame_gen, mem_frame_t, vo_frame);
   ff_vaapi_context_t *va_context    = this->va_context;
   VASurfaceID        va_surface_id  = VA_INVALID_SURFACE;
   VAImage            *va_image      = NULL;
@@ -3544,28 +2843,26 @@
     va_surface_id = this->va_soft_surface_ids[this->va_soft_head];
     va_image = &this->va_soft_images[this->va_soft_head];
     this->va_soft_head = (this->va_soft_head + 1) % (SOFT_SURFACES);
-  } else { // (frame->format == XINE_IMGFMT_VAAPI)
+  } else if (accel->index < RENDER_SURFACES) { // (frame->format == XINE_IMGFMT_VAAPI)
+    ff_vaapi_surface_t *va_surface = &va_context->va_render_surfaces[accel->index];
     if (this->guarded_render) {
-      ff_vaapi_surface_t *va_surface = &va_context->va_render_surfaces[accel->index];
       if (va_surface->status == SURFACE_RENDER || va_surface->status == SURFACE_RENDER_RELEASE) {
         va_surface_id = va_surface->va_surface_id;
       }
-      va_image      = NULL;
 #ifdef DEBUG_SURFACE
       printf("vaapi_display_frame va_surface 0x%08x status %d index %d\n", va_surface_id, va_surface->status, accel->index);
 #endif
     } else {
-      ff_vaapi_surface_t *va_surface = &va_context->va_render_surfaces[accel->index];
       va_surface_id = va_surface->va_surface_id;
-      va_image      = NULL;
     }
+    va_image      = NULL;
   }
 
   lprintf("2: 0x%08x\n", va_surface_id);
 
   if (va_surface_id != VA_INVALID_SURFACE) {
     VASurfaceStatus surf_status = 0;
-    if (this->query_va_status) {
+    if (this->va->query_va_status) {
       vaStatus = vaQuerySurfaceStatus(va_context->va_display, va_surface_id, &surf_status);
       vaapi_check_status(this, vaStatus, "vaQuerySurfaceStatus()");
     } else {
@@ -3593,36 +2890,20 @@
 
     /* transfer image data to a VAAPI surface */
     if (frame->format != XINE_IMGFMT_VAAPI) {
-      vaapi_software_render_frame(this, frame_gen, va_image, va_surface_id);
+      vaapi_software_render_frame(this, frame, va_image, this->soft_image_is_bound, va_surface_id);
     }
-    vaapi_hardware_render_frame(this, frame_gen, va_surface_id);
+    vaapi_hardware_render_frame(this, frame, va_surface_id);
   }
 
   XSync(this->display, False);
 
   //end_time = timeOfDay();
 
-  if(this->guarded_render) {
-    ff_vaapi_surface_t *va_surface = &va_context->va_render_surfaces[accel->index];
-
-    if(va_surface->status == SURFACE_RENDER_RELEASE) {
-      va_surface->status = SURFACE_FREE;
-#ifdef DEBUG_SURFACE
-      printf("release_surface vaapi_display_frame 0x%08x\n", va_surface->va_surface_id);
-#endif
-    } else if(va_surface->status == SURFACE_RENDER) {
-      va_surface->status = SURFACE_RELEASE;
-#ifdef DEBUG_SURFACE
-      printf("release_surface vaapi_display_frame 0x%08x\n", va_surface->va_surface_id);
-#endif
-    }
-  }
+  _add_recent_frame (this, frame_gen);
 
   pthread_mutex_unlock(&this->vaapi_lock);
   UNLOCK_DISPLAY (this);
 
-  frame_gen->free( frame_gen );
-
   /*
   elapse_time = end_time - start_time;
   factor = (int)(elapse_time/(1.0/60.0));
@@ -3710,8 +2991,6 @@
     if (this->props[property].entry)
       this->props[property].entry->num_value = this->props[property].value;
 
-    vaapi_show_display_props(this);
-
     return this->props[property].value;
   } else {
     switch (property) {
@@ -3742,6 +3021,10 @@
           this->sc.force_redraw = 1;
         }
         break;
+
+      case VO_PROP_DISCARD_FRAMES:
+        this->props[property].value = _flush_recent_frames (this);
+        break;
     }
   }
   return value;
@@ -3775,13 +3058,11 @@
      * This works with opengl2 and vdpau.
      * FIXME: With vaapi here, 2. does _not_ work. Why? */
     pthread_mutex_lock(&this->vaapi_lock);
-    LOCK_DISPLAY (this);
     lprintf("XINE_GUI_SEND_EXPOSE_EVENT:\n");
     this->sc.force_redraw = 1;
 #ifdef ENABLE_VA_GLX
     this->init_opengl_render = 1;
 #endif
-    UNLOCK_DISPLAY (this);
     pthread_mutex_unlock(&this->vaapi_lock);
   }
   break;
@@ -3831,7 +3112,6 @@
 }
 
 static void vaapi_dispose_locked (vaapi_driver_t *this) {
-  ff_vaapi_context_t  *va_context = this->va_context;
   config_values_t     *config = this->xine->config;
 
   /* cm_close already does this.
@@ -3847,7 +3127,7 @@
 
   vaapi_close(this);
 
-  vaapi_terminate(va_context);
+  _x_va_free(&this->va);
 
   _x_freep(&this->overlay_bitmap);
 
@@ -3862,9 +3142,14 @@
 
   UNLOCK_DISPLAY (this);
 
+  _x_freep(&this->va_subpic_formats);
+  this->va_num_subpic_formats = 0;
+
   pthread_mutex_unlock(&this->vaapi_lock);
   pthread_mutex_destroy(&this->vaapi_lock);
 
+  _x_assert(this->recent_frames[0] == NULL);
+
   free (this);
 }
 
@@ -3934,12 +3219,8 @@
   vaapi_set_csc_mode (this, new_mode);
 }
 
-static vo_driver_t *vaapi_open_plugin (video_driver_class_t *class_gen, const void *visual_gen) {
-
-  vaapi_class_t           *class  = (vaapi_class_t *) class_gen;
-  const x11_visual_t      *visual = (const x11_visual_t *) visual_gen;
-  vaapi_driver_t          *this;
-  config_values_t         *config = class->xine->config;
+static int vaapi_init_x11(vaapi_driver_t *this)
+{
   XSetWindowAttributes    xswa;
   unsigned long           xswa_mask;
   XWindowAttributes       wattr;
@@ -3947,10 +3228,114 @@
   XVisualInfo             visualInfo;
   XVisualInfo             *vi;
   int                     depth;
-  int                     i;
-  const int               x11_event_mask = ExposureMask | 
+  int                     result = 0;
+  const int               x11_event_mask = ExposureMask |
                                            StructureNotifyMask;
 
+  LOCK_DISPLAY (this);
+
+  black_pixel = BlackPixel(this->display, this->screen);
+
+  XGetWindowAttributes(this->display, this->drawable, &wattr);
+
+  depth = wattr.depth;
+  if (depth != 15 && depth != 16 && depth != 24 && depth != 32)
+    depth = 24;
+
+  vi = &visualInfo;
+  XMatchVisualInfo(this->display, this->screen, depth, TrueColor, vi);
+
+  xswa_mask             = CWBorderPixel | CWBackPixel | CWColormap;
+  xswa.border_pixel     = black_pixel;
+  xswa.background_pixel = black_pixel;
+  xswa.colormap         = CopyFromParent;
+
+  vaapi_x11_trap_errors();
+  this->window = XCreateWindow(this->display, this->drawable,
+                             0, 0, 1, 1, 0, depth,
+                             InputOutput, vi->visual, xswa_mask, &xswa);
+  XSync(this->display, False);
+  if (vaapi_x11_untrap_errors() || this->window == None) {
+    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " XCreateWindow() failed\n");
+    goto out;
+  }
+
+  XSelectInput(this->display, this->window, x11_event_mask);
+
+  XMapWindow(this->display, this->window);
+  vaapi_x11_wait_event(this->display, this->window, MapNotify);
+
+  result = 1;
+
+ out:
+  UNLOCK_DISPLAY (this);
+
+  if (vi != &visualInfo)
+    XFree(vi);
+
+  return result;
+}
+
+static int vaapi_initialize(vaapi_driver_t *this, int visual_type, const void *visual)
+{
+  VAStatus vaStatus;
+  int fmt_count = 0;
+
+#ifdef ENABLE_VA_GLX
+  this->va = _x_va_new(this->xine, visual_type, visual, this->opengl_render);
+#else
+  this->va = _x_va_new(this->xine, visual_type, visual, 0);
+#endif
+  if (!this->va)
+    return 0;
+
+  this->va_context = &this->va->c;
+  this->va_context->driver = &this->vo_driver;
+
+#ifdef ENABLE_VA_GLX
+  {
+    const char *p, *vendor;
+    size_t i;
+
+    vendor = vaQueryVendorString(this->va_context->va_display);
+    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Vendor : %s\n", vendor);
+
+    for (p = vendor, i = strlen (vendor); i > 0; i--, p++) {
+      if(strncmp(p, "VDPAU", strlen("VDPAU")) == 0) {
+        xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Enable Splitted-Desktop Systems VDPAU-VIDEO workarounds.\n");
+        this->opengl_use_tfp = 0;
+        break;
+      }
+    }
+  }
+#endif
+
+  vaapi_set_background_color(this);
+  vaapi_display_attribs(this);
+
+  fmt_count = vaMaxNumSubpictureFormats( this->va_context->va_display );
+  this->va_subpic_formats = calloc( fmt_count, sizeof(*this->va_subpic_formats) );
+
+  vaStatus = vaQuerySubpictureFormats( this->va_context->va_display, this->va_subpic_formats, 0, &this->va_num_subpic_formats );
+  if(!vaapi_check_status(this, vaStatus, "vaQuerySubpictureFormats()"))
+    return 0;
+
+  if(vaapi_init_internal(this, SW_CONTEXT_INIT_FORMAT, SW_WIDTH, SW_HEIGHT) != VA_STATUS_SUCCESS)
+    return 0;
+
+  vaapi_close(this);
+
+  return 1;
+}
+
+static vo_driver_t *vaapi_open_plugin (video_driver_class_t *class_gen, const void *visual_gen) {
+
+  vaapi_class_t           *class  = (vaapi_class_t *) class_gen;
+  const x11_visual_t      *visual = (const x11_visual_t *) visual_gen;
+  vaapi_driver_t          *this;
+  config_values_t         *config = class->xine->config;
+  int                     i;
+
   this = (vaapi_driver_t *) calloc(1, sizeof(vaapi_driver_t));
   if (!this)
     return NULL;
@@ -3964,8 +3349,6 @@
   this->screen                  = visual->screen;
   this->drawable                = visual->d;
 
-  this->va_context              = &this->va_context_storage;
-
   /* number of video frames from config - register it with the default value. */
   int frame_num = config->register_num (config, "engine.buffers.video_num_frames", MIN_SURFACES, /* default */
        _("default number of video frames"),
@@ -3994,13 +3377,13 @@
         20, vaapi_opengl_use_tfp, this );
 
 
-  LOCK_DISPLAY (this);
   if(this->opengl_render) {
+      LOCK_DISPLAY (this);
       this->opengl_render = vaapi_opengl_verify_direct (visual);
+      UNLOCK_DISPLAY (this);
       if(!this->opengl_render)
         xprintf (this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Opengl indirect/software rendering does not work. Fallback to plain VAAPI output !!!!\n");
   }
-  UNLOCK_DISPLAY (this);
 
   this->gl_context                      = NULL;
   this->gl_pixmap                       = None;
@@ -4012,15 +3395,12 @@
 
   this->va_soft_surface_ids             = this->va_soft_surface_ids_storage;
   this->va_soft_images                  = this->va_soft_images_storage;
-  this->va_context->va_render_surfaces  = this->va_render_surfaces_storage;
-  this->va_context->va_surface_ids      = this->va_surface_ids_storage;
 
   for (i = 0; i < SOFT_SURFACES; i++) {
     this->va_soft_surface_ids[i]        = VA_INVALID_SURFACE;
     this->va_soft_images[i].image_id    = VA_INVALID_ID;
   }
 
-  vaapi_init_va_context(this->va_context);
   vaapi_init_subpicture(this);
 
   _x_vo_scale_init (&this->sc, 1, 0, config );
@@ -4030,46 +3410,6 @@
   this->sc.user_data            = visual->user_data;
   this->sc.user_ratio           = XINE_VO_ASPECT_AUTO;
 
-  LOCK_DISPLAY (this);
-
-  black_pixel         = BlackPixel(this->display, this->screen);
-
-  XGetWindowAttributes(this->display, this->drawable, &wattr);
-
-  depth = wattr.depth;
-  if (depth != 15 && depth != 16 && depth != 24 && depth != 32)
-    depth = 24;
-
-  vi = &visualInfo;
-  XMatchVisualInfo(this->display, this->screen, depth, TrueColor, vi);
-
-  xswa_mask             = CWBorderPixel | CWBackPixel | CWColormap;
-  xswa.border_pixel     = black_pixel;
-  xswa.background_pixel = black_pixel;
-  xswa.colormap         = CopyFromParent;
-
-  vaapi_x11_trap_errors();
-  this->window = XCreateWindow(this->display, this->drawable,
-                             0, 0, 1, 1, 0, depth,
-                             InputOutput, vi->visual, xswa_mask, &xswa);
-  XSync(this->display, False);
-  if (vaapi_x11_untrap_errors() || this->window == None) {
-    UNLOCK_DISPLAY (this);
-    xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " XCreateWindow() failed\n");
-    vaapi_dispose_locked(this);
-    return NULL;
-  }
-
-  XSelectInput(this->display, this->window, x11_event_mask);
-
-  XMapWindow(this->display, this->window);
-  vaapi_x11_wait_event(this->display, this->window, MapNotify);
-
-  UNLOCK_DISPLAY (this);
-
-  if(vi != &visualInfo)
-    XFree(vi);
-
   this->capabilities            = VO_CAP_YV12 | VO_CAP_YUY2 | VO_CAP_CROP | VO_CAP_UNSCALED_OVERLAY | VO_CAP_ARGB_LAYER_OVERLAY | VO_CAP_VAAPI | VO_CAP_CUSTOM_EXTENT_OVERLAY;
 
   this->vo_driver.get_capabilities     = vaapi_get_capabilities;
@@ -4145,14 +3485,6 @@
 
   this->last_sub_image_fmt                   = 0;
 
-  if(vaapi_init_internal(this, SW_CONTEXT_INIT_FORMAT, SW_WIDTH, SW_HEIGHT) != VA_STATUS_SUCCESS) {
-    vaapi_dispose_locked(this);
-    return NULL;
-  }
-  vaapi_close(this);
-  this->va_context->valid_context = 0;
-  this->va_context->driver        = (vo_driver_t *)this;
-
   this->csc_mode = this->xine->config->register_enum (this->xine->config, "video.output.vaapi_csc_mode", 3,
     (char **)vaapi_csc_mode_labels,
     _("VAAPI colour conversion method"),
@@ -4173,6 +3505,13 @@
   xprintf(this->xine, XINE_VERBOSITY_LOG, LOG_MODULE " vaapi_open: Opengl render : %d\n", this->opengl_render);
 #endif
 
+  if (!vaapi_init_x11(this) ||
+      !vaapi_initialize(this, XINE_VISUAL_TYPE_X11, visual_gen)) {
+
+    vaapi_dispose_locked(this);
+    return NULL;
+  }
+
   pthread_mutex_unlock(&this->vaapi_lock);
 
   return &this->vo_driver;
diff -urN xine-lib-1.2.11/src/video_out/video_out_vdpau.c xine-lib-1.2/src/video_out/video_out_vdpau.c
--- xine-lib-1.2.11/src/video_out/video_out_vdpau.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/video_out/video_out_vdpau.c	2022-01-15 22:03:19.617547310 +0100
@@ -1,6 +1,6 @@
 /*
  * kate: space-indent on; indent-width 2; mixedindent off; indent-mode cstyle; remove-trailing-space on;
- * Copyright (C) 2008-2019 the xine project
+ * Copyright (C) 2008-2021 the xine project
  * Copyright (C) 2008 Christophe Thommeret <hftom@free.fr>
  *
  * This file is part of xine, a free video player.
@@ -1327,7 +1327,7 @@
           VDPAU_IF_ERROR ("failed to get surface parameters !!");
           else if ((w != width) || (h != height)) {
             xprintf (this->xine, XINE_VERBOSITY_LOG,
-              "vo_vdpau: video surface doesn't match size contraints (%u x %u) -> (%u x %u) != (%u x %u). Segfaults ahead!\n",
+              "vo_vdpau: video surface doesn't match size constraints (%u x %u) -> (%u x %u) != (%u x %u). Segfaults ahead!\n",
               requested_width, requested_height, width, height, w, h);
           }
         }
@@ -2420,46 +2420,72 @@
 
 /*
  * grab next displayed output surface.
- * Note: This feature only supports grabbing of next displayed frame (implicit VO_GRAB_FRAME_FLAGS_WAIT_NEXT)
  */
 static int vdpau_grab_grab_video_frame (xine_grab_video_frame_t *frame_gen) {
   vdpau_grab_video_frame_t *frame = (vdpau_grab_video_frame_t *) frame_gen;
   vdpau_driver_t *this = (vdpau_driver_t *) frame->vo_driver;
-  struct timeval tvnow, tvdiff, tvtimeout;
-  struct timespec ts;
+  int yes = 0;
 
-  /* calculate absolute timeout time */
-  tvdiff.tv_sec = frame->grab_frame.timeout / 1000;
-  tvdiff.tv_usec = frame->grab_frame.timeout % 1000;
-  tvdiff.tv_usec *= 1000;
-  gettimeofday(&tvnow, NULL);
-  timeradd(&tvnow, &tvdiff, &tvtimeout);
-  ts.tv_sec  = tvtimeout.tv_sec;
-  ts.tv_nsec = tvtimeout.tv_usec;
-  ts.tv_nsec *= 1000;
+  do {
+    if (frame->grab_frame.flags & XINE_GRAB_VIDEO_FRAME_FLAGS_WAIT_NEXT)
+      break;
+    pthread_mutex_lock (&this->drawable_lock);
+    if (this->back_frame[0]) {
+      vdpau_grab_video_frame_t *pending_frame;
 
-  pthread_mutex_lock(&this->grab_lock);
+      pthread_mutex_lock (&this->grab_lock);
+      pending_frame = this->pending_grab_request;
+      this->pending_grab_request = frame;
+      pthread_mutex_unlock (&this->grab_lock);
+
+      vdpau_grab_current_output_surface (this, this->back_frame[0]->vo_frame.vpts);
 
-  /* wait until other pending grab request is finished */
-  while (this->pending_grab_request) {
-    if (pthread_cond_timedwait(&this->grab_cond, &this->grab_lock, &ts) == ETIMEDOUT) {
-      pthread_mutex_unlock(&this->grab_lock);
-      return 1;   /* no frame available */
+      pthread_mutex_lock (&this->grab_lock);
+      this->pending_grab_request = pending_frame;
+      pthread_mutex_unlock (&this->grab_lock);
+
+      yes = 1;
     }
-  }
+    pthread_mutex_unlock (&this->drawable_lock);
+  } while (0);
 
-  this->pending_grab_request = frame;
-
-  /* wait until our request is finished */
-  while (this->pending_grab_request) {
-    if (pthread_cond_timedwait(&this->grab_cond, &this->grab_lock, &ts) == ETIMEDOUT) {
-      this->pending_grab_request = NULL;
-      pthread_mutex_unlock(&this->grab_lock);
-      return 1;   /* no frame available */
+  if (!yes) {
+    struct timeval tvnow;
+    struct timespec ts;
+    /* calculate absolute timeout time */
+    gettimeofday (&tvnow, NULL);
+    tvnow.tv_sec += frame->grab_frame.timeout / 1000;
+    tvnow.tv_usec += (frame->grab_frame.timeout % 1000) * 1000;
+    if (tvnow.tv_usec >= 1000000) {
+      tvnow.tv_usec -= 1000000;
+      tvnow.tv_sec += 1;
     }
-  }
+    ts.tv_sec  = tvnow.tv_sec;
+    ts.tv_nsec = tvnow.tv_usec * 1000;
 
-  pthread_mutex_unlock(&this->grab_lock);
+    pthread_mutex_lock (&this->grab_lock);
+
+    /* wait until other pending grab request is finished */
+    while (this->pending_grab_request) {
+      if (pthread_cond_timedwait (&this->grab_cond, &this->grab_lock, &ts) == ETIMEDOUT) {
+        pthread_mutex_unlock (&this->grab_lock);
+        return 1;   /* no frame available */
+      }
+    }
+
+    this->pending_grab_request = frame;
+
+    /* wait until our request is finished */
+    while (this->pending_grab_request) {
+      if (pthread_cond_timedwait (&this->grab_cond, &this->grab_lock, &ts) == ETIMEDOUT) {
+        this->pending_grab_request = NULL;
+        pthread_mutex_unlock (&this->grab_lock);
+        return 1;   /* no frame available */
+      }
+    }
+
+    pthread_mutex_unlock (&this->grab_lock);
+  }
 
   if (frame->grab_frame.vpts == -1)
     return -1; /* error happened */
@@ -2494,6 +2520,14 @@
   return (xine_grab_video_frame_t *) frame;
 }
 
+static void vdpau_set_process_snapshots (void *this_gen, xine_cfg_entry_t *entry) {
+  vdpau_driver_t *this = (vdpau_driver_t *)this_gen;
+
+  /* vdpau_new_grab_video_frame () is always there, and the pointer to it
+   * reads and writes atomically. i guess we dont need locks here ;-) */
+  this->vo_driver.new_grab_video_frame = entry->num_value ? vdpau_new_grab_video_frame : NULL;
+}
+
 
 static int vdpau_gui_data_exchange (vo_driver_t *this_gen, int data_type, void *data)
 {
@@ -2725,7 +2759,7 @@
   this->vo_driver.gui_data_exchange    = vdpau_gui_data_exchange;
   this->vo_driver.dispose              = vdpau_dispose;
   this->vo_driver.redraw_needed        = vdpau_redraw_needed;
-  this->vo_driver.new_grab_video_frame = vdpau_new_grab_video_frame;
+  this->vo_driver.new_grab_video_frame = NULL; /* see below */
 
   this->video_mixer = VDP_INVALID_HANDLE;
   for ( i=0; i<NOUTPUTSURFACE; ++i )
@@ -3067,6 +3101,13 @@
       config->update_num (config, "engine.buffers.video_num_frames", 22);
   }
 
+  this->vo_driver.new_grab_video_frame = config->register_bool (config,
+    "video.output.vdpau_process_snapshots", 0,
+    _("vdpau: make snapshots like visible on screen"),
+    _("If set, snapshots will be scaled, cropped, padded and subtitled.\n"
+      "Otherwise, you get the pure original video image.\n"),
+    10, vdpau_set_process_snapshots, this) ? vdpau_new_grab_video_frame : NULL;
+
   this->capabilities = VO_CAP_YV12 | VO_CAP_YUY2
                      | VO_CAP_COLOR_MATRIX | VO_CAP_FULLRANGE
                      | VO_CAP_CROP
@@ -3180,3 +3221,4 @@
   { PLUGIN_VIDEO_OUT, 22, "vdpau", XINE_VERSION_CODE, &vo_info_vdpau, vdpau_init_class },
   { PLUGIN_NONE, 0, NULL, 0, NULL, NULL }
 };
+
diff -urN xine-lib-1.2.11/src/xine-engine/audio_decoder.c xine-lib-1.2/src/xine-engine/audio_decoder.c
--- xine-lib-1.2.11/src/xine-engine/audio_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/audio_decoder.c	2022-01-15 22:03:19.639547403 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -540,19 +540,27 @@
      * of audio, wich should be enough to compensate for drive delays.
      * We provide buffers of 8k size instead of 2k for demuxers sending
      * larger chunks.
+     * TJ. There are live streams with 5...10s fragments. Nice clients fetch
+     * 1 fragment, then wait the gap without blocking the server port all the
+     * time. With 2s reserve and 48k AAC, we need up to 12*48000/1024 = 563
+     * frame buffers. High bitrate video over a budget connection somewhat
+     * hides the issue, but web radio turns down all excuses.
+     * Lets give away a high multiple of 4 of 2k bufs instead, and LPCM can
+     * still have 8k ones via buffer_pool_size_alloc ().
      */
 
     num_buffers = stream->s.xine->config->register_num (stream->s.xine->config,
-      "engine.buffers.audio_num_buffers", 230,
+      "engine.buffers.audio_num_buffers", 700,
       _("number of audio buffers"),
-      _("The number of audio buffers (each is 8k in size) xine uses in its "
+      _("The number of audio buffers (each is 2k in size) xine uses in its "
         "internal queue. Higher values mean smoother playback for unreliable "
         "inputs, but also increased latency and memory consumption."),
       20, NULL, NULL);
+    num_buffers = (num_buffers + 3) & ~4;
     if (num_buffers > 2000)
       num_buffers = 2000;
 
-    stream->s.audio_fifo = _x_fifo_buffer_new (num_buffers, 8192);
+    stream->s.audio_fifo = _x_fifo_buffer_new (num_buffers, 2048);
     if (!stream->s.audio_fifo)
       return 0;
 
diff -urN xine-lib-1.2.11/src/xine-engine/audio_out.c xine-lib-1.2/src/xine-engine/audio_out.c
--- xine-lib-1.2.11/src/xine-engine/audio_out.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/audio_out.c	2022-01-15 22:03:19.619547318 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -208,7 +208,7 @@
     pthread_mutex_t    intr_mutex;         /* protects num_driver_actions */
     pthread_cond_t     intr_wake;          /* informs about num_driver_actions-- */
     ao_driver_t       *d;
-    uint32_t           open;
+    uint32_t           open;                /* 0 (closed), 1 (known idle), 2 (open) */
     int                intr_num;           /* number of threads, that wish to call
                                             * functions needing driver_lock */
     int                dreqs_all;          /* statistics */
@@ -282,6 +282,8 @@
     int              num_buffers;
     int              num_waiters;
     uint32_t         pts_fill;
+    uint32_t         pts_last_buf;
+    uint32_t         pts_in_driver;
     int              seek_count1;
     struct timespec  wake_time;            /* time to drop next buf in trick play mode without sound */
     int              use_wake_time;        /* 0 (play), 1 (wake_time or event), 2 (event) */
@@ -329,6 +331,7 @@
   double          compression_factor;   /* current compression */
   double          compression_factor_max; /* user limit on compression */
   double          amp_factor;
+  int             amp_level;
 
   /* 10-band equalizer */
 
@@ -339,6 +342,7 @@
 
   int             last_gap;
   int             last_sgap;
+  uint32_t        pts_in_driver;
 
   /* If driver cannot pause while keeping its own buffers alive,
    * resend some frames at unpause time instead of filling a big gap with silence. */
@@ -416,6 +420,7 @@
     return;
   ao_driver_lock (this);
   if (this->driver.open) {
+    this->driver.open = 1;
     if (this->driver.d->delay (this->driver.d) > 0) {
       this->driver.d->control (this->driver.d, AO_CTRL_FLUSH_BUFFERS, NULL);
       ao_driver_unlock (this);
@@ -625,7 +630,9 @@
   this->out_fifo.first             = NULL;
   this->out_fifo.num_buffers       = 0;
   this->out_fifo.num_waiters       = 0;
+  this->out_fifo.pts_last_buf      = 0;
   this->out_fifo.pts_fill          = 0;
+  this->out_fifo.pts_in_driver     = 0;
   this->out_fifo.wake_time.tv_sec  = 0;
   this->out_fifo.wake_time.tv_nsec = 0;
   this->out_fifo.use_wake_time     = 0;
@@ -660,7 +667,9 @@
   this->out_fifo.add               = &this->out_fifo.first;
   this->out_fifo.num_buffers       = 0;
   this->out_fifo.num_waiters       = 0;
+  this->out_fifo.pts_last_buf      = 0;
   this->out_fifo.pts_fill          = 0;
+  this->out_fifo.pts_in_driver     = 0;
   this->out_fifo.wake_time.rv_sec  = 0;
   this->out_fifo.wake_time.tv_nsec = 0;
   this->out_fifo.use_wake_time     = 0;
@@ -765,6 +774,8 @@
   int dry = 0;
 
   pthread_mutex_lock (&this->out_fifo.mutex);
+  /* this is 1 buf late, make it consistent at least. */
+  this->out_fifo.pts_in_driver = this->pts_in_driver + this->out_fifo.pts_last_buf;
   while (1) {
 
     if (this->out_fifo.seek_count1 >= 0) {
@@ -823,6 +834,7 @@
     }
 
     if (!buf) {
+      this->out_fifo.pts_last_buf = 0;
       buf = this->out_fifo.first;
       if (buf) {
         this->out_fifo.first = buf->next;
@@ -834,8 +846,10 @@
           this->out_fifo.num_buffers = 0;
           dry = 1;
         }
-        if (buf->format.rate)
-          this->out_fifo.pts_fill -= (uint32_t)90000 * (uint32_t)buf->num_frames / buf->format.rate;
+        if (buf->format.rate) {
+          this->out_fifo.pts_last_buf = (uint32_t)90000 * (uint32_t)buf->num_frames / buf->format.rate;
+          this->out_fifo.pts_fill -= this->out_fifo.pts_last_buf;
+        }
       }
     }
     if (buf && !this->out_fifo.use_wake_time)
@@ -845,17 +859,16 @@
       break;
 
     /* no more bufs for now... */
-    if (!this->out_fifo.use_wake_time && this->driver.open) {
-      int n;
-      xine_rwlock_rdlock (&this->streams_lock);
-      n = this->num_null_streams + this->num_anon_streams + this->num_streams;
-      xine_rwlock_unlock (&this->streams_lock);
-      if (!n) {
-        /* ...and no users. When driver runs idle as well, close it. */
-        pthread_mutex_lock (&this->driver.mutex);
-        n = this->driver.d->delay (this->driver.d);
+    if (!this->out_fifo.use_wake_time) {
+      pthread_mutex_lock (&this->driver.mutex);
+      if ((this->driver.open > 1) && (this->driver.speed > 0)) {
+        int s = this->driver.speed;
+        int n = this->driver.d->delay (this->driver.d);
+        /* ...wait for driver idle or new buf, speed change, ... */
         pthread_mutex_unlock (&this->driver.mutex);
         n = (n > 0) && this->output.rate ? (uint32_t)n * 1000u / this->output.rate : 0;
+        this->out_fifo.pts_in_driver = n * 90u;
+        n = xine_uint_mul_div (n, XINE_FINE_SPEED_NORMAL, s);
         if (n > 0) {
           struct timespec ts = {0, 0};
           xine_gettime (&ts);
@@ -871,16 +884,34 @@
         } else {
           n = ETIMEDOUT;
         }
+        /* timeout? */
         if (n == ETIMEDOUT) {
-          xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "audio_out: driver idle, closing.\n");
-          pthread_mutex_lock (&this->driver.mutex);
-          this->driver.d->close (this->driver.d);
-          this->driver.open = 0;
-          pthread_mutex_unlock (&this->driver.mutex);
-          /* unref streams as well. */
-          ao_force_unref_all (this, 0);
+          xine_rwlock_rdlock (&this->streams_lock);
+          n = this->num_null_streams + this->num_anon_streams + this->num_streams;
+          xine_rwlock_unlock (&this->streams_lock);
+          this->out_fifo.pts_last_buf = 0;
+          this->out_fifo.pts_in_driver = this->pts_in_driver = 0;
+          if (!n) {
+            /* no users -> close driver. */
+            xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "audio_out: driver idle, closing.\n");
+            pthread_mutex_lock (&this->driver.mutex);
+            this->driver.d->close (this->driver.d);
+            this->driver.open = 0;
+            pthread_mutex_unlock (&this->driver.mutex);
+            /* unref streams as well. */
+            ao_force_unref_all (this, 0);
+          } else {
+            /* stream still there, eg DVB signal loss. */
+            xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "audio_out: driver idle.\n");
+            /* avoid infinite loop */
+            pthread_mutex_lock (&this->driver.mutex);
+            this->driver.open = 1;
+            pthread_mutex_unlock (&this->driver.mutex);
+          }
         }
         continue;
+      } else {
+        pthread_mutex_unlock (&this->driver.mutex);
       }
     }
 
@@ -981,6 +1012,7 @@
     this->out_fifo.first = NULL;
     this->out_fifo.add = &this->out_fifo.first;
     this->out_fifo.num_buffers = 0;
+    this->out_fifo.pts_last_buf = 0;
     this->out_fifo.pts_fill = 0;
     pthread_mutex_lock (&this->free_fifo.mutex);
     this->free_fifo.num_buffers = n + (this->free_fifo.first ? this->free_fifo.num_buffers : 0);
@@ -1095,8 +1127,10 @@
     while (num_frames > 1536) {
       if (ao_driver_test_intr_2 (this))
         return 1;
-      if (this->driver.open)
+      if (this->driver.open) {
         this->driver.d->write (this->driver.d, this->zero_space, 1536);
+        this->driver.open = 2;
+      }
       num_frames -= 1536;
     }
 
@@ -1108,15 +1142,19 @@
     while ((num_frames >= max_frames) && !this->out_fifo.discard_buffers) {
       if (ao_driver_test_intr_2 (this))
         return 1;
-      if (this->driver.open)
+      if (this->driver.open) {
         this->driver.d->write (this->driver.d, this->zero_space, max_frames);
+        this->driver.open = 2;
+      }
       num_frames -= max_frames;
     }
     if (num_frames && !this->out_fifo.discard_buffers) {
       if (ao_driver_test_intr_2 (this))
         return 1;
-      if (this->driver.open)
+      if (this->driver.open) {
         this->driver.d->write (this->driver.d, this->zero_space, num_frames);
+        this->driver.open = 2;
+      }
     }
 
   }
@@ -1164,21 +1202,27 @@
       if (!this->out_fifo.discard_buffers) {
         if (ao_driver_test_intr_2 (this))
           return 1;
-        if (this->driver.open)
+        if (this->driver.open) {
           this->driver.d->write (this->driver.d, (int16_t *)(this->resend.buf + start_frame * this->resend.frame_size), fill_frames2);
+          this->driver.open = 2;
+        }
       }
       if (!this->out_fifo.discard_buffers) {
         if (ao_driver_test_intr_2 (this))
           return 1;
-        if (this->driver.open)
+        if (this->driver.open) {
           this->driver.d->write (this->driver.d, (int16_t *)this->resend.buf, fill_frames1);
+          this->driver.open = 2;
+        }
       }
     } else {
       if (!this->out_fifo.discard_buffers) {
         if (ao_driver_test_intr_2 (this))
           return 1;
-        if (this->driver.open)
+        if (this->driver.open) {
           this->driver.d->write (this->driver.d, (int16_t *)(this->resend.buf + start_frame * this->resend.frame_size), fill_frames1);
+          this->driver.open = 2;
+        }
       }
     }
   }
@@ -1907,6 +1951,7 @@
         }
         cur_time = this->clock->get_current_time (this->clock);
         pthread_mutex_unlock (&this->driver.mutex);
+        this->pts_in_driver = 0;
         xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG,
           "audio_out: got driver running with %d pts of silence.\n", start_pts);
       } else {
@@ -1957,6 +2002,7 @@
       lprintf ("current delay is %d, current time is %" PRId64 "\n", delay, cur_time);
       /* no sound card should delay more than 23.301s ;-) */
       delay = ((uint32_t)delay * this->out_pts_per_kframe) >> 10;
+      this->pts_in_driver = delay;
       /* External A52 decoder delay correction (in pts) */
       delay += this->ptoffs;
       /* calculate gap: */
@@ -2096,6 +2142,7 @@
             continue;
           if (this->driver.open) {
             result = this->driver.d->write (this->driver.d, out_buf->mem, out_buf->num_frames);
+            this->driver.open = 2;
           }
           pthread_mutex_unlock (&this->driver.mutex);
         }
@@ -2676,7 +2723,7 @@
     break;
 
   case AO_PROP_AMP:
-    ret = this->amp_factor*100;
+    ret = this->amp_level;
     break;
 
   case AO_PROP_AMP_MUTE:
@@ -2710,7 +2757,10 @@
 
   case AO_PROP_PTS_IN_FIFO:
     pthread_mutex_lock (&this->out_fifo.mutex);
-    ret = this->out_fifo.pts_fill;
+    /* easier and more precise:
+     * this->out_fifo.pts_sill + last_buf_vpts - this->clock->get_current_time ().
+     * however, net_buf_ctrl calls this _very_ often :-/ */
+    ret = this->out_fifo.pts_fill + this->out_fifo.pts_in_driver;
     pthread_mutex_unlock (&this->out_fifo.mutex);
     break;
 
@@ -2759,12 +2809,19 @@
     break;
 
   case AO_PROP_AMP:
-
-    this->amp_factor = (double) value / 100.0;
-
-    this->do_amp = (this->amp_factor != 1.0 || this->amp_mute);
-
-    ret = this->amp_factor*100;
+    this->amp_level = value;
+    this->do_amp = (value != 100) || this->amp_mute;
+    ret = value;
+    if (value) {
+      static const uint32_t mant[12] = {
+        2147483648u, 2275179671u, 2410468894u, 2553802834u, 2705659852u, 2866546760u,
+        3037000500u, 3217589947u, 3408917802u, 3611622603u, 3826380858u, 4053909305u
+      };
+      value += 20;
+      this->amp_factor = (double)mant[value % 12] * (double)(1 << (value / 12)) * (1.0 / (2147483648.0 * (1 << 10)));
+    } else {
+      this->amp_factor = 0;
+    }
     break;
 
   case AO_PROP_AMP_MUTE:
@@ -2844,7 +2901,7 @@
 
   case AO_PROP_PTS_IN_FIFO:
     pthread_mutex_lock (&this->out_fifo.mutex);
-    ret = this->out_fifo.pts_fill;
+    ret = this->out_fifo.pts_fill + this->out_fifo.pts_in_driver;
     pthread_mutex_unlock (&this->out_fifo.mutex);
     break;
 
@@ -2980,6 +3037,7 @@
   this->step                   = 0;
   this->last_gap               = 0;
   this->last_sgap              = 0;
+  this->pts_in_driver          = 0;
   this->compression_factor_max = 0.0;
   this->do_compress            = 0;
   this->do_amp                 = 0;
@@ -3133,6 +3191,7 @@
 
   this->compression_factor = 2.0;
   this->amp_factor         = 1.0;
+  this->amp_level          = 100;
 
   /*
    * pre-allocate memory for samples
@@ -3240,3 +3299,4 @@
   this->xine->x.clock->register_speed_change_callback (this->xine->x.clock, ao_speed_change_cb, this);
   return &this->ao;
 }
+
diff -urN xine-lib-1.2.11/src/xine-engine/buffer.c xine-lib-1.2/src/xine-engine/buffer.c
--- xine-lib-1.2.11/src/xine-engine/buffer.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/buffer.c	2022-01-15 22:03:19.621547327 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2019 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -46,6 +46,7 @@
 #include <xine/buffer.h>
 #include <xine/xineutils.h>
 #include <xine/xine_internal.h>
+#include "xine_private.h"
 
 /* The large buffer feature.
  * If we have enough contigous memory, and if we can afford to hand if out,
@@ -70,6 +71,75 @@
 
 #define LARGE_NUM 0x7fffffff
 
+/* The file buf ctrl feature.
+ * After stream start/seek (fifo flush), there is a phase when a few decoded frames
+ * are better than a lot of merely demuxed ones. Net_buf_ctrl wants large fifos to
+ * handle fragment and other stuttering streams. Lets assume that it knows what to
+ * do there. For plain files, however, demux is likely to drain processor time from
+ * decoders initially.
+ * A separate file_buf_ctrl module should not mess with fifo internals, thus lets
+ * do a little soft start version here when there are no callbacks:
+ * fifo->alloc_cb[0] == fbc_dummy,
+ * fifo->alloc_cb_data[0] == count of yet not to be used bufs. */
+
+static void fbc_dummy (fifo_buffer_t *this, void *data) {
+  (void)this;
+  (void)data;
+}
+
+int xine_fbc_set (fifo_buffer_t *fifo, int on) {
+  if (!fifo)
+    return 0;
+  pthread_mutex_lock (&fifo->mutex);
+
+  if (on) {
+    int n;
+    if (fifo->alloc_cb[0]) {
+      n = (fifo->alloc_cb[0] == fbc_dummy);
+      pthread_mutex_unlock (&fifo->mutex);
+      return n;
+    }
+    fifo->alloc_cb[0] = fbc_dummy;
+    n = (fifo->buffer_pool_capacity * 3) >> 2;
+    if (n < 75)
+      n = 0;
+    fifo->alloc_cb_data[0] = (void *)(intptr_t)n;
+    pthread_mutex_unlock (&fifo->mutex);
+    return 1;
+  }
+
+  if (fifo->alloc_cb[0] == fbc_dummy) {
+    fifo->alloc_cb[0] = NULL;
+    fifo->alloc_cb_data[0] = (void *)0;
+  }
+  pthread_mutex_unlock (&fifo->mutex);
+  return 0;
+}
+
+static int fbc_avail (fifo_buffer_t *this) {
+  return this->alloc_cb[0] != fbc_dummy
+    ? this->buffer_pool_num_free
+    : this->buffer_pool_num_free - (intptr_t)this->alloc_cb_data[0];
+}
+
+static void fbc_reset (fifo_buffer_t *this) {
+  if (this->alloc_cb[0] == fbc_dummy) {
+    int n = (this->buffer_pool_capacity * 3) >> 2;
+    if (n < 75)
+      n = 0;
+    this->alloc_cb_data[0] = (void *)(intptr_t)n;
+  }
+}
+
+static void fbc_sub (fifo_buffer_t *this, int n) {
+  if (this->alloc_cb[0] == fbc_dummy) {
+    n = (intptr_t)this->alloc_cb_data[0] - n;
+    if (n < 0)
+      n = 0;
+    this->alloc_cb_data[0] = (void *)(intptr_t)n;
+  }
+}
+
 /*
  * put a previously allocated buffer element back into the buffer pool
  */
@@ -82,6 +152,7 @@
 
   newhead = (be_ei_t *)element;
   n = newhead->nbufs;
+  fbc_sub (this, n);
   this->buffer_pool_num_free += n;
   if (this->buffer_pool_num_free > this->buffer_pool_capacity) {
     fprintf(stderr, _("xine-lib: buffer.c: There has been a fatal error: TOO MANY FREE's\n"));
@@ -125,7 +196,7 @@
 
   /* dont provoke useless wakeups */
   if (this->buffer_pool_num_waiters ||
-    (this->buffer_pool_large_wait <= this->buffer_pool_num_free))
+    (this->buffer_pool_large_wait <= fbc_avail (this)))
     pthread_cond_signal (&this->buffer_pool_cond_not_empty);
 
   pthread_mutex_unlock (&this->buffer_pool_mutex);
@@ -148,19 +219,19 @@
   /* we always keep one free buffer for emergency situations like
    * decoder flushes that would need a buffer in buffer_pool_try_alloc() */
   n += 2;
-  if (this->buffer_pool_num_free < n) {
+  if (fbc_avail (this) < n) {
     /* Paranoia: someone else than demux calling this in parallel ?? */
     if (this->buffer_pool_large_wait != LARGE_NUM) {
       this->buffer_pool_num_waiters++;
       do {
         pthread_cond_wait (&this->buffer_pool_cond_not_empty, &this->buffer_pool_mutex);
-      } while (this->buffer_pool_num_free < n);
+      } while (fbc_avail (this) < n);
       this->buffer_pool_num_waiters--;
     } else {
       this->buffer_pool_large_wait = n;
       do {
         pthread_cond_wait (&this->buffer_pool_cond_not_empty, &this->buffer_pool_mutex);
-      } while (this->buffer_pool_num_free < n);
+      } while (fbc_avail (this) < n);
       this->buffer_pool_large_wait = LARGE_NUM;
     }
   }
@@ -244,11 +315,11 @@
 
   /* we always keep one free buffer for emergency situations like
    * decoder flushes that would need a buffer in buffer_pool_try_alloc() */
-  if (this->buffer_pool_num_free < 2) {
+  if (fbc_avail (this) < 2) {
     this->buffer_pool_num_waiters++;
     do {
       pthread_cond_wait (&this->buffer_pool_cond_not_empty, &this->buffer_pool_mutex);
-    } while (this->buffer_pool_num_free < 2);
+    } while (fbc_avail (this) < 2);
     this->buffer_pool_num_waiters--;
   }
 
@@ -641,6 +712,7 @@
     start = next;
   }
 
+  fbc_reset (fifo);
   /* printf("Free buffers after clear: %d\n", fifo->buffer_pool_num_free); */
   pthread_mutex_unlock (&fifo->mutex);
 }
@@ -753,12 +825,17 @@
   int i;
 
   pthread_mutex_lock(&this->mutex);
+  if (this->alloc_cb[0] == fbc_dummy) {
+    this->alloc_cb[0] = NULL;
+    this->alloc_cb_data[0] = NULL;
+  }
   for(i = 0; this->alloc_cb[i]; i++)
     ;
   if( i != BUF_MAX_CALLBACKS-1 ) {
     this->alloc_cb[i] = cb;
     this->alloc_cb_data[i] = data_cb;
     this->alloc_cb[i+1] = NULL;
+    this->alloc_cb_data[i+1] = (void *)(intptr_t)0;
   }
   pthread_mutex_unlock(&this->mutex);
 }
@@ -984,4 +1061,3 @@
     }
   }
 }
-
diff -urN xine-lib-1.2.11/src/xine-engine/demux.c xine-lib-1.2/src/xine-engine/demux.c
--- xine-lib-1.2.11/src/xine-engine/demux.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/demux.c	2022-01-15 22:03:19.629547360 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -360,18 +360,17 @@
 
   /* do-while needed to seek after demux finished */
   do {
+    uint32_t input_caps = 0;
+
     xine_gettime (&seek_time);
 
-    {
-      uint32_t input_caps = 0;
-      /* tell xine_play_internal () whether we can seek.
-       * so it may flush fifos early, and suspend us faster. */
-      if (stream->s.input_plugin)
-        input_caps = stream->s.input_plugin->get_capabilities (stream->s.input_plugin);
-      pthread_mutex_lock (&stream->demux.action_lock);
-      stream->demux.input_caps = input_caps;
-      pthread_mutex_unlock (&stream->demux.action_lock);
-    }
+    /* tell xine_play_internal () whether we can seek.
+     * so it may flush fifos early, and suspend us faster. */
+    if (stream->s.input_plugin)
+      input_caps = stream->s.input_plugin->get_capabilities (stream->s.input_plugin);
+    pthread_mutex_lock (&stream->demux.action_lock);
+    stream->demux.input_caps = input_caps;
+    pthread_mutex_unlock (&stream->demux.action_lock);
 
     /* main demuxer loop */
     status = stream->demux.plugin->get_status (stream->demux.plugin);
@@ -380,10 +379,24 @@
       iterations++;
       status = stream->demux.plugin->send_chunk (stream->demux.plugin);
 
+      if (!(iterations & 31)) {
+        uint32_t new_caps = stream->s.input_plugin
+                          ? stream->s.input_plugin->get_capabilities (stream->s.input_plugin)
+                          : 0;
+        if (new_caps != input_caps) {
+          input_caps = new_caps;
+          pthread_mutex_lock (&stream->demux.action_lock);
+          stream->demux.input_caps = input_caps;
+          pthread_mutex_unlock (&stream->demux.action_lock);
+        }
+      }
+
       /* someone may want to interrupt us */
       if (stream->demux.action_pending > 0) {
         pthread_mutex_lock (&stream->demux.action_lock);
         if (stream->demux.action_pending > 0) {
+          if (stream->s.input_plugin)
+            stream->demux.input_caps = stream->s.input_plugin->get_capabilities (stream->s.input_plugin);
           pthread_mutex_unlock (&stream->demux.lock);
           do {
             pthread_cond_wait (&stream->demux.resume, &stream->demux.action_lock);
@@ -551,6 +564,14 @@
   return NULL;
 }
 
+int _x_demux_called_from (xine_stream_t *s) {
+  xine_stream_private_t *stream = (xine_stream_private_t *)s;
+
+  if (!stream->demux.thread_running)
+    return 0;
+  return pthread_equal (pthread_self (), stream->demux.thread);
+}
+
 int _x_demux_start_thread (xine_stream_t *s) {
 
   xine_stream_private_t *stream = (xine_stream_private_t *)s;
@@ -635,6 +656,11 @@
 
   caps = input->get_capabilities (input);
 
+  if ((caps & INPUT_CAP_SIZED_PREVIEW) && (want_size >= (int)sizeof (want_size))) {
+    memcpy (buffer, &want_size, sizeof (want_size));
+    return input->get_optional_data (input, buffer, INPUT_OPTIONAL_DATA_SIZED_PREVIEW);
+  }
+
   if (caps & INPUT_CAP_SEEKABLE) {
     if (input->seek (input, 0, SEEK_SET) != 0)
       return 0;
@@ -644,11 +670,6 @@
     return want_size;
   }
 
-  if ((caps & INPUT_CAP_SIZED_PREVIEW) && (want_size >= (int)sizeof (want_size))) {
-    memcpy (buffer, &want_size, sizeof (want_size));
-    return input->get_optional_data (input, buffer, INPUT_OPTIONAL_DATA_SIZED_PREVIEW);
-  }
-
   if (caps & INPUT_CAP_PREVIEW) {
     if (want_size < MAX_PREVIEW_SIZE) {
       int read_size;
diff -urN xine-lib-1.2.11/src/xine-engine/dummy.c xine-lib-1.2/src/xine-engine/dummy.c
--- xine-lib-1.2.11/src/xine-engine/dummy.c	2020-12-06 14:14:11.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/dummy.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* Automatically generated */
diff -urN xine-lib-1.2.11/src/xine-engine/input_rip.c xine-lib-1.2/src/xine-engine/input_rip.c
--- xine-lib-1.2.11/src/xine-engine/input_rip.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/input_rip.c	2022-01-15 22:03:19.602547246 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -65,6 +65,8 @@
 #endif
 
 #include <xine/xine_internal.h>
+#include <xine/input_plugin.h>
+#include <xine/mfrag.h>
 #include "xine_private.h"
 
 #ifndef HAVE_FSEEKO
@@ -72,29 +74,149 @@
 #endif
 
 #define SCRATCH_SIZE 1024
-#define MAX_TARGET_LEN 256
-#define MAX_TARGET_LEN_SUFFIXED (MAX_TARGET_LEN + 16)
+#define MAX_TARGET_LEN 512
 #define SEEK_TIMEOUT 2.5
 
-typedef struct {
+typedef struct rip_input_plugin_s {
   input_plugin_t    input_plugin;      /* inherited structure */
 
   input_plugin_t   *main_input_plugin; /* original input plugin */
+  xine_mfrag_list_t *fraglist;         /* bypass main input for backseek */
 
   xine_stream_t    *stream;
+  char             *fname;
   FILE             *file;              /* destination file */
+  FILE             *rfile;             /* avoid lots of seeking if possible */
 
   char             *preview;           /* preview data */
-  off_t             preview_size;      /* size of read preview data */
+  size_t            preview_size;      /* size of read preview data */
   off_t             curpos;            /* current position */
   off_t             savepos;           /* amount of already saved data */
+  off_t             endpos;            /* skip useless "recording done" msgs */
 
+  ssize_t         (*read) (struct rip_input_plugin_s *this, char *buf, size_t len);
   int               regular;           /* permit reading from the file */
+  int               behind;            /* 0 (off), 1 (with), 2 (without read ahead) */
 } rip_input_plugin_t;
 
+/* read from main file */
+static ssize_t rip_read_file_read_1a (rip_input_plugin_t *this, char *buf, size_t len) {
+  size_t r = fread (buf, 1, len, this->file);
+  this->curpos += r;
+  if (this->curpos == this->savepos) {
+    this->behind = 0;
+    /* yes this is set_already, but we like to enable shared code optimization. */
+    this->read = rip_read_file_read_1a;
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "input_rip: live again.\n");
+  }
+  if (r != len) {
+    int e = errno;
+    xine_log (this->stream->xine, XINE_LOG_MSG,
+      _("input_rip: reading of saved data failed: %s\n"), strerror (e));
+  }
+  return r;
+}
+
+/* read from main file, and reseek */
+static ssize_t rip_read_file_read_1b (rip_input_plugin_t *this, char *buf, size_t len) {
+  size_t r = 0;
+  if (!fseeko (this->file, this->curpos, SEEK_SET)) {
+    r = fread (buf, 1, len, this->file);
+    this->curpos += r;
+  }
+  fseeko (this->file, this->savepos, SEEK_SET);
+  if (this->curpos == this->savepos) {
+    this->behind = 0;
+    this->read = rip_read_file_read_1a;
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "input_rip: live again.\n");
+  }
+  if (r != len) {
+    int e = errno;
+    xine_log (this->stream->xine, XINE_LOG_MSG,
+      _("input_rip: reading of saved data failed: %s\n"), strerror (e));
+  }
+  return r;
+}
+
+/* read from clone */
+static ssize_t rip_read_file_read_2 (rip_input_plugin_t *this, char *buf, size_t len) {
+  size_t r = fread (buf, 1, len, this->rfile);
+  if (r < len) {
+    fflush (this->file);
+    r = fread (buf, 1, len, this->rfile);
+  }
+  this->curpos += r;
+  if (this->curpos == this->savepos) {
+    fclose (this->rfile);
+    this->rfile = NULL;
+    this->behind = 0;
+    this->read = rip_read_file_read_1a;
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "input_rip: live again.\n");
+  }
+  if (r != len) {
+    int e = errno;
+    xine_log (this->stream->xine, XINE_LOG_MSG,
+      _("input_rip: reading of saved data failed: %s\n"), strerror (e));
+  }
+  return r;
+}
+
+static int rip_read_file_start (rip_input_plugin_t *this, off_t offs1) {
+  int mode = (this->main_input_plugin->get_capabilities (this->main_input_plugin) & INPUT_CAP_LIVE) ? 2 : 1;
+  off_t offs2 = offs1 < (off_t)this->preview_size ? (off_t)this->preview_size : offs1;
+  if (mode == 1) {
+    if (!this->rfile && this->fname) {
+      fflush (this->file);
+      this->rfile = fopen (this->fname, "rb");
+    }
+    if (this->rfile) {
+      if (fseeko (this->rfile, offs2, SEEK_SET)) {
+        fclose (this->rfile);
+        this->rfile = NULL;
+      }
+    }
+  } else {
+    if (this->rfile) {
+      fclose (this->rfile);
+      this->rfile = NULL;
+    }
+  }
+  if (this->rfile) {
+    this->read = rip_read_file_read_2;
+  } else {
+    if (fseeko (this->file, offs2, SEEK_SET)) {
+      int e = errno;
+      fseeko (this->file, this->savepos, SEEK_SET);
+      xine_log (this->stream->xine, XINE_LOG_MSG, _("input_rip: seeking failed: %s\n"), strerror (e));
+      return 0;
+    }
+    if (mode == 1) {
+      fseeko (this->file, this->savepos, SEEK_SET);
+      this->read = rip_read_file_read_1b;
+    } else {
+      this->read = rip_read_file_read_1a;
+    }
+  }
+  this->curpos = offs1;
+  this->behind = mode;
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "input_rip: reading from %s%s after backseek.\n",
+    this->rfile ? "clone of " : "",
+    this->fname ? this->fname : "save file");
+  return 1;
+}
 
-static off_t min_off(off_t a, off_t b) {
-  return a <= b ? a : b;
+static void rip_read_file_set_2 (rip_input_plugin_t *this) {
+  this->behind = 2;
+  if (this->rfile) {
+    fclose (this->rfile);
+    this->rfile = NULL;
+  }
+  fseeko (this->file, this->curpos, SEEK_SET);
+  this->read = rip_read_file_read_1a;
+  xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+    "input_rip: end of main input, still reading from %s.\n",
+    this->fname ? this->fname : "save file");
 }
 
 /*
@@ -103,76 +225,148 @@
 static off_t rip_plugin_read(input_plugin_t *this_gen, void *buf_gen, off_t len) {
   rip_input_plugin_t *this = (rip_input_plugin_t *)this_gen;
   char *buf = (char *)buf_gen;
-  off_t retlen, npreview, nread, nwrite, nread_orig, nread_file;
+  off_t d;
+  size_t left;
 
   lprintf("reading %"PRId64" bytes (curpos = %"PRId64", savepos = %"PRId64")\n", len, this->curpos, this->savepos);
 
-  if (len < 0) return -1;
+  /* bail out on bogus args */
+  if (!this || !buf || (len < 0))
+    return -1;
+  if (len == 0)
+    return 0;
+  left = len;
 
-  /* compute sizes and copy data from preview */
-  if (this->curpos < this->preview_size && this->preview) {
-    npreview = this->preview_size - this->curpos;
-    if (npreview > len) {
-      npreview = len;
-      nread = 0;
-    } else {
-      nread = min_off(this->savepos - this->preview_size, len - npreview);
+  d = this->savepos - this->curpos;
+  if (d > 0) {
+    if (this->curpos < (off_t)this->preview_size) {
+      /* get from preview */
+      size_t s2 = this->preview_size - this->curpos;
+      if (left < s2)
+        s2 = left;
+      memcpy (buf, this->preview + this->curpos, s2);
+      buf += s2;
+      this->curpos += s2;
+      left -= s2;
+      if (left == 0)
+        return s2;
     }
-
-    lprintf(" => get %"PRId64" bytes from preview (%"PRId64" bytes)\n", npreview, this->preview_size);
-
-    memcpy(buf, &this->preview[this->curpos], npreview);
-  } else {
-    npreview = 0;
-    nread = min_off(this->savepos - this->curpos, len);
+    d = this->savepos - this->curpos;
   }
 
-  /* size to write into file */
-  nwrite = len - npreview - nread;
-  /* size to read from file */
-  nread_file = this->regular ? nread : 0;
-  /* size to read from original input plugin */
-  nread_orig = this->regular ? 0 : nread;
-
-  /* re-reading from file */
-  if (nread_file) {
-    lprintf(" => read %"PRId64" bytes from file\n", nread_file);
-    if (fread(&buf[npreview], nread_file, 1, this->file) != 1) {
-      xine_log(this->stream->xine, XINE_LOG_MSG, _("input_rip: reading of saved data failed: %s\n"), strerror(errno));
-      return -1;
+  /* gcc jump target optimize here ;-) */
+  if (d > 0) {
+    /* NOTE: size_t (unsigned) may be same size or smaller than off_t (signed). */
+    size_t s2 = left;
+    d -= (off_t)left;
+    if (this->behind) {
+      if (d > 0) {
+        /* Hair raising naive HACK:
+         * read and append left bytes as usual, then return left older bytes from the file.
+         * this shall help with inputs that tend to lose track when seeking.
+         * OK at least we dont try this in real live mode (behind == 2). bitrate fluctuations
+         * and repeated reads like .mp4 fragment scans disharmonize with strict live timing. */
+        if (this->behind == 1) {
+          ssize_t r = this->main_input_plugin->read (this->main_input_plugin, buf, s2);
+          if (r > 0) {
+            size_t w = fwrite (buf, 1, r, this->file);
+            this->savepos += w;
+          } else {
+            /* dont stop yet, we still got the rest of the file,
+             * and maybe more seeks. */
+            rip_read_file_set_2 (this);
+            if (this->savepos != this->endpos) {
+              this->endpos = this->savepos;
+              _x_message (this->stream, XINE_MSG_RECORDING_DONE,
+                this->main_input_plugin->get_mrl (this->main_input_plugin), this->fname, NULL);
+            }
+          }
+        }
+      } else {
+        /* catch up now */
+        s2 += d;
+      }
+      s2 = this->read (this, buf, s2);
+      buf += s2;
+    } else {
+      ssize_t r;
+      if (d < 0)
+        s2 += d;
+      /* read from main input */
+      if (this->main_input_plugin->seek (this->main_input_plugin, this->curpos, SEEK_SET) != this->curpos)
+        return -1;
+      r = this->main_input_plugin->read (this->main_input_plugin, buf, s2);
+      if (r != (ssize_t)s2) {
+        if (r > 0)
+          this->curpos += r;
+        xine_log (this->stream->xine, XINE_LOG_MSG,
+          _("input_rip: reading by input plugin failed\n"));
+        return r;
+      }
+      buf += s2;
+      this->curpos += s2;
+    }
+    left -= s2;
+    if (this->curpos == this->savepos) {
+      /* take care of non_seekable _fragments_. */
+      if (this->main_input_plugin->get_current_pos (this->main_input_plugin) != this->savepos) {
+        off_t have = this->main_input_plugin->seek (this->main_input_plugin, this->savepos, SEEK_SET);
+        if (have >= 0) {
+          have = this->savepos - have;
+          if (have > 0) {
+            char temp[4096];
+            this->savepos -= have;
+            if (fseeko (this->file, this->savepos, SEEK_SET))
+              return -1;
+            xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+              "input_rip: re-reading %" PRId64 " bytes.\n", (int64_t)have);
+            while (have > 0) {
+              ssize_t r = have > (off_t)sizeof (temp) ? (off_t)sizeof (temp) : have;
+              r = this->main_input_plugin->read (this->main_input_plugin, temp, r);
+              if (r <= 0)
+                break;
+              have -= r;
+              r = fwrite (temp, 1, r, this->file);
+              this->savepos += r;
+            }
+          }
+        }
+      }
+      /* some stdio implementations need an fseek () between read and write. */
+      if (fseeko (this->file, this->savepos, SEEK_SET))
+        return -1;
     }
+    if (left == 0)
+      return buf - (char *)buf_gen;
   }
 
-  /* really to read/catch */
-  if (nread_orig + nwrite) {
-    lprintf(" => read %"PRId64" bytes from input plugin\n", nread_orig + nwrite);
-
-    /* read from main input plugin */
-    retlen = this->main_input_plugin->read(this->main_input_plugin, &buf[npreview + nread_file], nread_orig + nwrite);
-    lprintf("%s => returned %"PRId64"" CLR_RST "\n", retlen == nread_orig + nwrite ? "" : CLR_FAIL, retlen);
-
-    if (retlen < 0) {
-      xine_log(this->stream->xine, XINE_LOG_MSG,
-               _("input_rip: reading by input plugin failed\n"));
+  {
+    /* read from main input, and save to file */
+    size_t w = 0;
+    int ew = 0;
+    ssize_t r = this->main_input_plugin->read (this->main_input_plugin, buf, left);
+    if (r > 0) {
+      this->curpos += r;
+      w = fwrite (buf, 1, r, this->file);
+      buf += r;
+      ew = errno;
+      if (w > 0)
+        this->savepos += w;
+    }
+    if (r != (ssize_t)left) {
+      xine_log (this->stream->xine, XINE_LOG_MSG,
+        _("input_rip: reading by input plugin failed\n"));
+      return r;
+    }
+    if ((ssize_t)w != r) {
+      xine_log (this->stream->xine, XINE_LOG_MSG,
+        _("input_rip: error writing to file %" PRIdMAX " bytes: %s\n"),
+        (intmax_t)r, strerror (ew));
       return -1;
     }
-
-    /* write to file (only successfully read data) */
-    if (retlen > nread_orig) {
-      nwrite = retlen - nread_orig;
-      if (fwrite(buf + this->savepos - this->curpos, nwrite, 1, this->file) != 1) {
-        xine_log(this->stream->xine, XINE_LOG_MSG, _("input_rip: error writing to file %" PRIdMAX " bytes: %s\n"), (intmax_t)(retlen - nread_orig), strerror(errno));
-        return -1;
-      }
-      this->savepos += nwrite;
-      lprintf(" => saved %"PRId64" bytes\n", nwrite);
-    } else
-      nwrite = 0;
   }
 
-  this->curpos += (npreview + nread + nwrite);
-
-  return npreview + nread + nwrite;
+  return buf - (char *)buf_gen;
 }
 
 /*
@@ -198,7 +392,7 @@
   if (this->regular)
     caps |= INPUT_CAP_SEEKABLE;
 
-  if (this->preview) caps |= INPUT_CAP_PREVIEW;
+  if (this->preview) caps |= INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW;
   return caps;
 }
 
@@ -209,101 +403,92 @@
  * cases are reading over preview or reading already saved data - it returns
  * own allocated block.
  */
-static buf_element_t *rip_plugin_read_block(input_plugin_t *this_gen, fifo_buffer_t *fifo, off_t todo) {
+static buf_element_t *rip_plugin_read_block(input_plugin_t *this_gen, fifo_buffer_t *fifo, off_t len) {
   rip_input_plugin_t *this = (rip_input_plugin_t *)this_gen;
-  buf_element_t *buf = NULL;
-  off_t retlen, npreview, nread, nwrite, nread_orig, nread_file;
+  size_t left;
 
-  lprintf("reading %"PRId64" bytes (curpos = %"PRId64", savepos = %"PRId64") (block)\n", todo, this->curpos, this->savepos);
+  lprintf("reading %"PRId64" bytes (curpos = %"PRId64", savepos = %"PRId64") (block)\n", len, this->curpos, this->savepos);
 
-  if (todo <= 0) return NULL;
+  /* bail out on bogus args */
+  if (!this || !fifo || (len <= 0))
+    return NULL;
+  left = len;
 
-  /* compute sizes and copy data from preview */
-  if (this->curpos < this->preview_size && this->preview) {
-    npreview = this->preview_size - this->curpos;
-    if (npreview > todo) {
-      npreview = todo;
-      nread = 0;
-    } else {
-      nread = min_off(this->savepos - this->preview_size, todo - npreview);
+  if (this->curpos < this->savepos) {
+    buf_element_t *buf = NULL;
+    char *q = NULL;
+    off_t d;
+    size_t s2;
+    if ((this->curpos < (off_t)this->preview_size) || this->regular) {
+      buf = fifo->buffer_pool_alloc (fifo);
+      buf->content = buf->mem;
+      buf->type = BUF_DEMUX_BLOCK;
+      buf->size = 0;
+      if (buf->max_size < (int)left)
+        left = buf->max_size;
+      q = buf->content;
     }
-
-    lprintf(" => get %"PRId64" bytes from preview (%"PRId64" bytes) (block)\n", npreview, this->preview_size);
-  } else {
-    npreview = 0;
-    nread = min_off(this->savepos - this->curpos, todo);
-  }
-
-  /* size to write into file */
-  nwrite = todo - npreview - nread;
-  /* size to read from file */
-  nread_file = this->regular ? nread : 0;
-  /* size to read from original input plugin */
-  nread_orig = this->regular ? 0 : nread;
-
-  /* create own block by RIP if needed */
-  if (npreview + nread_file) {
-    buf = fifo->buffer_pool_alloc(fifo);
-    buf->content = buf->mem;
-    buf->type = BUF_DEMUX_BLOCK;
-
-    /* get data from preview */
-    if (npreview) {
-      lprintf(" => get %"PRId64" bytes from the preview (block)\n", npreview);
-      memcpy(buf->content, &this->preview[this->curpos], npreview);
-    }
-
-    /* re-reading from the file */
-    if (nread_file) {
-      lprintf(" => read %"PRId64" bytes from the file (block)\n", nread_file);
-      if (fread(&buf->content[npreview], nread_file, 1, this->file) != 1) {
-        xine_log(this->stream->xine, XINE_LOG_MSG,
-                 _("input_rip: reading of saved data failed: %s\n"),
-                 strerror(errno));
-        return NULL;
+    if (this->curpos < (off_t)this->preview_size) {
+      /* get from preview */
+      s2 = this->preview_size - this->curpos;
+      if (left < s2)
+        s2 = left;
+      memcpy (q, this->preview + this->curpos, s2);
+      q += s2;
+      buf->size = s2;
+      this->curpos += s2;
+      left -= s2;
+      if ((left == 0) || !this->regular)
+        return buf;
+    }
+    d = this->savepos - this->curpos;
+    s2 = d <= (off_t)(~(size_t)0) ? (size_t)d : ~(size_t)0;
+    if (left < s2)
+      s2 = left;
+    if (this->behind) {
+      /* get from saved file */
+      size_t r = this->read (this, q, s2);
+      buf->size += r;
+      return buf;
+    }
+    /* read from main input */
+    buf = this->main_input_plugin->read_block (this->main_input_plugin, fifo, s2);
+    if (buf && (buf->size > 0)) {
+      this->curpos += buf->size;
+      if (buf->size > (int)s2) {
+        /* paranoia?? */
+        left = buf->size - s2;
+        s2 = fwrite (buf->content + s2, 1, left, this->file);
+        this->savepos += s2;
+        if (s2 != left) {
+          int ew = errno;
+          xine_log (this->stream->xine, XINE_LOG_MSG,
+            _("input_rip: error writing to file %" PRIdMAX " bytes: %s\n"),
+            (intmax_t)left, strerror (ew));
+        }
       }
     }
+    return buf;
   }
 
-  /* really to read/catch */
-  if (nread_orig + nwrite) {
-    /* read from main input plugin */
-    if (buf) {
-      lprintf(" => read %"PRId64" bytes from input plugin (block)\n", nread_orig + nwrite);
-      retlen = this->main_input_plugin->read(this->main_input_plugin, &buf->content[npreview + nread_file], nread_orig + nwrite);
-    } else {
-      lprintf(" => read block of %"PRId64" bytes from input plugin (block)\n", nread_orig + nwrite);
-      buf = this->main_input_plugin->read_block(this->main_input_plugin, fifo, nread_orig + nwrite);
-      if (buf) retlen = buf->size;
-      else {
-        lprintf(CLR_FAIL " => returned NULL" CLR_RST "\n");
-        return NULL;
+  {
+    /* read from main input, and save to file */
+    buf_element_t *buf = this->main_input_plugin->read_block (this->main_input_plugin, fifo, left);
+    if (buf && (buf->size > 0)) {
+      size_t r;
+      this->curpos += buf->size;
+      r = fwrite (buf->content, 1, buf->size, this->file);
+      this->savepos += r;
+      if ((int)r != buf->size) {
+        int ew = errno;
+        xine_log (this->stream->xine, XINE_LOG_MSG,
+          _("input_rip: error writing to file %" PRIdMAX " bytes: %s\n"),
+          (intmax_t)buf->size, strerror (ew));
       }
     }
-    if (retlen != nread_orig + nwrite) {
-      lprintf(CLR_FAIL " => returned %"PRId64"" CLR_RST "\n", retlen);
-      return NULL;
-    }
-
-    /* write to file (only successfully read data) */
-    if (retlen > nread_orig) {
-      nwrite = retlen - nread_orig;
-      if (fwrite(buf->content + this->savepos - this->curpos, nwrite, 1, this->file) != 1) {
-        xine_log(this->stream->xine, XINE_LOG_MSG,
-                 _("input_rip: error writing to file %" PRIdMAX " bytes: %s\n"),
-                 (intmax_t)(retlen - nread_orig), strerror(errno));
-        return NULL;
-      }
-      this->savepos += nwrite;
-      lprintf(" => saved %"PRId64" bytes\n", nwrite);
-    } else
-      nwrite = 0;
+    return buf;
   }
 
-  this->curpos += (npreview + nread + nwrite);
-  buf->size = npreview + nread + nwrite;
-
-  return buf;
 }
 
 static off_t rip_seek_original(rip_input_plugin_t *this, off_t reqpos) {
@@ -337,7 +522,7 @@
   char buffer[SCRATCH_SIZE];
   rip_input_plugin_t *this = (rip_input_plugin_t *)this_gen;
   uint32_t blocksize;
-  off_t newpos, reqpos, pos;
+  off_t newpos, pos;
   struct timeval time1, time2;
   double interval = 0;
 
@@ -359,23 +544,12 @@
   if (newpos < this->savepos) {
     lprintf(" => virtual seeking from %"PRId64" to %"PRId64"\n", this->curpos, newpos);
 
-    /* don't seek into preview area */
-    if (this->preview && newpos < this->preview_size) {
-      reqpos = this->preview_size;
-    } else  {
-      reqpos = newpos;
-    }
-
     if (this->regular) {
-      if (reqpos != this->savepos) {
-        lprintf(" => seeking file to %"PRId64"\n", reqpos);
-        if (fseeko(this->file, reqpos, SEEK_SET) != 0) {
-          xine_log(this->stream->xine, XINE_LOG_MSG, _("input_rip: seeking failed: %s\n"), strerror(errno));
-          return -1;
-        }
-      }
-      this->curpos = newpos;
+      if (!rip_read_file_start (this, newpos))
+        return -1;
     } else {
+      /* don't seek into preview area */
+      off_t reqpos = newpos < (off_t)this->preview_size ? (off_t)this->preview_size : newpos;
       if ((pos = rip_seek_original(this, reqpos)) == -1) return -1;
       if (pos == reqpos) this->curpos = newpos;
     }
@@ -434,10 +608,64 @@
 
 static off_t rip_plugin_seek_time(input_plugin_t *this_gen, int time_offset, int origin) {
   rip_input_plugin_t *this = (rip_input_plugin_t *)this_gen;
+  off_t r;
 
   lprintf("seek_time, time_offset: %d, origin: %d\n", time_offset, origin);
 
-  return this->main_input_plugin->seek_time(this->main_input_plugin, time_offset, origin);
+  /* HACK: if we have a fragment index, ask for byte offset directly,
+   * and keep main input running at the head. */
+  do {
+    int idx;
+    int64_t timebase, timepos, offs;
+    if (!this->regular)
+      break;
+    if (!this->fraglist)
+      break;
+    timebase = 0;
+    xine_mfrag_get_index_frag (this->fraglist, 0, &timebase, NULL);
+    if (timebase <= 0)
+      break;
+    switch (origin) {
+      case SEEK_CUR:
+        idx = xine_mfrag_find_pos (this->fraglist, this->curpos);
+        goto _rip_time_seek_list;
+      case SEEK_END:
+        idx = xine_mfrag_get_frag_count (this->fraglist) + 1;
+      _rip_time_seek_list:
+        timepos = 0;
+        xine_mfrag_get_index_start (this->fraglist, idx, &timepos, NULL);
+        timepos = timepos * 1000 / timebase;
+        time_offset += (int)timepos;
+        /* fall through */
+      case SEEK_SET:
+        timepos = (int64_t)time_offset * timebase / 1000;
+        idx = xine_mfrag_find_time (this->fraglist, timepos);
+        offs = 0;
+        xine_mfrag_get_index_start (this->fraglist, idx, &timepos, &offs);
+        if (offs < this->savepos)
+          rip_read_file_start (this, offs);
+        return this->curpos;
+      default: ;
+    }
+  } while (0);
+
+  if (!this->main_input_plugin->seek_time)
+    return this->curpos;
+
+  r = this->main_input_plugin->seek_time (this->main_input_plugin, time_offset, origin);
+  if ((r >= 0) && (r != this->curpos)) {
+    this->curpos = r;
+    if (this->regular) {
+      off_t s = r;
+      if (s < (off_t)this->preview_size) {
+        s = this->preview_size;
+      } else if (s > this->savepos) {
+        s = this->savepos;
+      }
+      fseeko (this->file, s, SEEK_SET);
+    }
+  }
+  return r;
 }
 
 /*
@@ -461,6 +689,33 @@
 static int rip_plugin_get_current_time(input_plugin_t *this_gen) {
   rip_input_plugin_t *this = (rip_input_plugin_t *)this_gen;
 
+  do {
+    int idx, num;
+    int64_t timebase, timepos1, timepos2, offs1, offs2;
+    if (!this->fraglist)
+      break;
+    timebase = 0;
+    xine_mfrag_get_index_frag (this->fraglist, 0, &timebase, NULL);
+    if (timebase <= 0)
+      break;
+    num = xine_mfrag_get_frag_count (this->fraglist);
+    idx = xine_mfrag_find_pos (this->fraglist, this->curpos);
+    timepos1 = 0;
+    offs1 = 0;
+    xine_mfrag_get_index_start (this->fraglist, idx, &timepos1, &offs1);
+    if (idx <= num) {
+      timepos2 = 0;
+      offs2 = 0;
+      xine_mfrag_get_index_start (this->fraglist, idx + 1, &timepos2, &offs2);
+      timepos1 += (this->curpos - offs1) * (timepos2 - timepos1) / (offs2 - offs1);
+    }
+    timepos1 = timepos1 * 1000 / timebase;
+    return (int)timepos1;
+  } while (0);
+
+  if (!this->main_input_plugin->get_current_time)
+    return -1;
+
   return this->main_input_plugin->get_current_time(this->main_input_plugin);
 }
 
@@ -490,14 +745,35 @@
 static int rip_plugin_get_optional_data (input_plugin_t *this_gen,
 					  void *data, int data_type) {
   rip_input_plugin_t *this = (rip_input_plugin_t *)this_gen;
+  int r;
 
   lprintf("get optional data\n");
-  if (this->preview && data_type == INPUT_OPTIONAL_DATA_PREVIEW) {
-    memcpy(data, this->preview, this->preview_size);
-    return this->preview_size;
-  } else
-    return this->main_input_plugin->get_optional_data(
-	this->main_input_plugin, data, data_type);
+
+  r = this->main_input_plugin->get_optional_data (this->main_input_plugin, data, data_type);
+  if (r != INPUT_OPTIONAL_UNSUPPORTED)
+    return r;
+
+  switch (data_type) {
+    case INPUT_OPTIONAL_DATA_PREVIEW:
+      if (!this->preview || !data)
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      memcpy (data, this->preview, this->preview_size);
+      return this->preview_size;
+
+    case INPUT_OPTIONAL_DATA_SIZED_PREVIEW:
+      if (!this->preview || !data)
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      memcpy (&r, data, sizeof (r));
+      if (r <= 0)
+        return INPUT_OPTIONAL_UNSUPPORTED;
+      if (r > (int)this->preview_size)
+        r = this->preview_size;
+      memcpy (data, this->preview, r);
+      return r;
+
+    default: ;
+  }
+  return INPUT_OPTIONAL_UNSUPPORTED;
 }
 
 /*
@@ -509,52 +785,31 @@
   lprintf("rip_plugin_dispose\n");
 
   _x_free_input_plugin(this->stream, this->main_input_plugin);
-  fclose(this->file);
+  if (this->rfile) {
+    fclose (this->rfile);
+    this->rfile = NULL;
+  }
+  if (this->file) {
+    fclose (this->file);
+    this->file = NULL;
+  }
+  _x_freep (&this->fname);
   _x_freep(&this->preview);
   free(this);
 }
 
 
 /*
- * concat name of directory and name of file,
- * returns non-zero, if there was enough space
- */
-static int dir_file_concat(char *target, size_t maxlen, const char *dir, const char *name) {
-  size_t len_name = strlen(name);
-  size_t len_dir = strlen(dir);
-  size_t pos_name = 0;
-
-  /* remove slashes */
-  if (dir[len_dir - 1] == '/') len_dir--;
-  if (name[0] == '/') {
-    pos_name = 1;
-    len_name--;
-  }
-
-  /* test and perform copy */
-  if (len_dir + len_name + 2 > maxlen) {
-    target[0] = '\0';
-    return 0;
-  }
-  if (len_dir) memcpy(target, dir, len_dir);
-  target[len_dir] = '/';
-  strcpy(&target[len_dir + 1], name + pos_name);
-  return 1;
-}
-
-
-/*
  * create self instance,
  * target file for writing stream is specified in 'data'
  */
 input_plugin_t *_x_rip_plugin_get_instance (xine_stream_t *stream, const char *filename) {
   rip_input_plugin_t *this;
   input_plugin_t *main_plugin = stream->input_plugin;
-  struct stat pstat;
-  const char *mode;
-  char target[MAX_TARGET_LEN], target_no[MAX_TARGET_LEN_SUFFIXED];
-  char *fnc, *target_basename;
-  int i;
+  FILE *file;
+  size_t nlen, slen1, slen2;
+  char suff1[16], suff2[32], target[4 + MAX_TARGET_LEN + 16 + 32];
+  int ptsoffs, regular, i;
 
   lprintf("catch file = %s, path = %s\n", filename, stream->xine->save_path);
 
@@ -587,97 +842,176 @@
     return NULL;
   }
 
-  this = calloc(1, sizeof(rip_input_plugin_t));
-  if (!this)
-    return NULL;
+  {
+    char *p;
 
-  this->main_input_plugin = main_plugin;
-  this->stream            = stream;
-  this->curpos  = 0;
-  this->savepos = 0;
+    nlen = strlen (stream->xine->save_path);
+    if (nlen > MAX_TARGET_LEN)
+      return NULL;
+    memcpy (target + 4, stream->xine->save_path, nlen + 1);
+    target[3] = 0;
+    for (p = target + 4 + nlen; p[-1] == '/'; p--) ;
+    if (p == target + 4) {
+      if (*p == '/')
+        p++;
+    } else {
+      *p++ = '/';
+    }
+    nlen = p - target - 4;
+  }
 
-  fnc = strdup(filename);
-  target_basename = basename(fnc);
-  dir_file_concat(target, MAX_TARGET_LEN, stream->xine->save_path,
-                  target_basename);
-  strcpy(target_no, target);
+  {
+    const char *fn1, *fn2, *fn3, *fn4;
 
+    fn1 = fn2 = fn3 = fn4 = filename;
+    while (1) {
+      while (*fn4 && (*fn4 != '/'))
+        fn4++;
+      if (fn4 > fn3) {
+        fn1 = fn3;
+        fn2 = fn4;
+      }
+      if (!*fn4)
+        break;
+      fn4++;
+      fn3 = fn4;
+    }
+    slen1 = fn2 - fn1;
+    if (!slen1)
+      return NULL;
+    if (nlen + slen1 > MAX_TARGET_LEN)
+      return NULL;
+    memcpy (target + 4 + nlen, fn1, slen1);
+    nlen += slen1;
+  }
+
+  slen1 = 0;
+  suff1[0] = 0;
+  ptsoffs = main_plugin->get_optional_data (main_plugin, NULL, INPUT_OPTIONAL_DATA_PTSOFFS);
+  if (ptsoffs) {
+    slen2 = sprintf (suff2, ".ptsoffs=%d", ptsoffs);
+  } else {
+    slen2 = 0;
+    suff2[0] = 0;
+  }
+
+  regular = 1;
   i = 1;
-  mode = "wb+";
-  do {
+  while (1) {
+    struct stat pstat;
+    if (slen1)
+      xine_small_memcpy (target + 4 + nlen, suff1, slen1);
+    if (slen2)
+      xine_small_memcpy (target + 4 + nlen + slen1, suff2, slen2);
+    target[4 + nlen + slen1 + slen2] = 0;
     /* find out kind of target */
-    if (stat(target_no, &pstat) < 0) break;
+    if (stat (target + 4, &pstat) < 0)
+      break;
 #ifndef _MSC_VER
-    if (S_ISFIFO(pstat.st_mode)) this->regular = 0;
-    else this->regular = 1;
+    regular = (S_ISFIFO (pstat.st_mode)) ? 0 : 1;
+    if (!regular) {
+      /* we want write into fifos */
+      break;
+    }
 #else
     /* no fifos under MSVC */
-    this->regular = 1;
 #endif
-    /* we want write into fifos */
-    if (!this->regular) {
-      mode = "wb";
-      break;
-    }
-
-    snprintf_buf(target_no, "%s.%d", target, i);
+    slen1 = sprintf (suff1, ".%d", i);
     i++;
-  } while(1);
-  free(fnc);
-  lprintf("target file: %s\n", target_no);
-
-  if ((this->file = fopen(target_no, mode)) == NULL) {
-    xine_log(this->stream->xine, XINE_LOG_MSG,
-	     _("input_rip: error opening file %s: %s\n"), target_no, strerror(errno));
-    free(this);
+  };
+
+  lprintf ("target file: %s\n", target + 4);
+  file = fopen (target + 4, regular ? "wb+" : "wb");
+  if (!file) {
+    int e = errno;
+    xine_log (stream->xine, XINE_LOG_MSG,
+        _("input_rip: error opening file %s: %s\n"), target + 4, strerror (e));
     return NULL;
   }
 
-  /* fill preview memory */
-  if ( (main_plugin->get_capabilities(main_plugin) & INPUT_CAP_SEEKABLE) == 0) {
-    if ( main_plugin->get_capabilities(main_plugin) & INPUT_CAP_BLOCK ) {
-      buf_element_t *buf;
-      uint32_t blocksize;
-
-      blocksize = main_plugin->get_blocksize(main_plugin);
-      buf = main_plugin->read_block(main_plugin, stream->video_fifo, blocksize);
+  this = calloc (1, sizeof (*this));
+  if (!this) {
+    fclose (file);
+    return NULL;
+  }
 
-      this->preview_size = buf->size;
-      this->preview = malloc(this->preview_size);
-      memcpy(this->preview, buf->content, this->preview_size);
+  this->main_input_plugin = main_plugin;
+  this->stream            = stream;
+  this->file              = file;
+  this->fname             = strdup (target + 4);
+  this->regular           = regular;
+  this->read              = rip_read_file_read_1a;
+#ifndef HAVE_ZERO_SAFE_MEM
+  this->rfile        = NULL;
+  this->fraglist     = NULL;
+  this->preview      = NULL;
+  this->behind       = 0;
+  this->curpos       = 0;
+  this->savepos      = 0;
+  this->endpos       = 0;
+  this->preview_size = 0;
+#endif
 
-      buf->free_buffer(buf);
-    } else {
-      this->preview = malloc(MAX_PREVIEW_SIZE);
-      this->preview_size = main_plugin->read(main_plugin, this->preview, MAX_PREVIEW_SIZE);
+  /* fill preview memory */
+  {
+    uint32_t caps = this->main_input_plugin->get_capabilities (this->main_input_plugin);
+    if (!(caps & (INPUT_CAP_SEEKABLE | INPUT_CAP_PREVIEW | INPUT_CAP_SIZED_PREVIEW))) {
+      if (caps & INPUT_CAP_BLOCK) {
+        buf_element_t *buf;
+        uint32_t blocksize;
+
+        blocksize = main_plugin->get_blocksize (main_plugin);
+        buf = main_plugin->read_block (main_plugin, stream->video_fifo, blocksize);
+        this->preview = malloc (buf->size);
+        if (this->preview) {
+          this->preview_size = buf->size;
+          memcpy (this->preview, buf->content, this->preview_size);
+        }
+        buf->free_buffer (buf);
+      } else {
+        this->preview = malloc (MAX_PREVIEW_SIZE);
+        if (this->preview) {
+          ssize_t r = main_plugin->read (main_plugin, this->preview, MAX_PREVIEW_SIZE);
+          if (r > 0) {
+            this->preview_size = r;
+          } else {
+            _x_freep (&this->preview);
+          }
+        }
+      }
     }
-  } else {
-    this->preview = NULL;
   }
 
-  if (this->preview && this->preview_size) {
-    if (fwrite(this->preview, this->preview_size, 1, this->file) != 1) {
-      xine_log(this->stream->xine, XINE_LOG_MSG,
-               _("input_rip: error writing to file %" PRIdMAX " bytes: %s\n"),
-               (intmax_t)(this->preview_size), strerror(errno));
-      fclose(this->file);
-      free(this);
+  if (this->preview_size) {
+    if (fwrite (this->preview, 1, this->preview_size, this->file) != this->preview_size) {
+      int e = errno;
+      xine_log (this->stream->xine, XINE_LOG_MSG,
+        _("input_rip: error writing to file %" PRIdMAX " bytes: %s\n"),
+        (intmax_t)(this->preview_size), strerror (e));
+      fclose (this->file);
+      _x_freep (&this->preview);
+      free (this);
       return NULL;
     }
-    lprintf(" => saved %"PRId64" bytes (preview)\n", this->preview_size);
+    lprintf(" => saved %u bytes (preview)\n", (unsigned int)this->preview_size);
     this->savepos = this->preview_size;
   }
 
+  {
+    xine_mfrag_list_t *list = NULL;
+    if (this->main_input_plugin->get_optional_data (this->main_input_plugin, &list, INPUT_OPTIONAL_DATA_FRAGLIST)
+      == INPUT_OPTIONAL_SUCCESS)
+      this->fraglist = list;
+  }
+
   this->input_plugin.open                = rip_plugin_open;
   this->input_plugin.get_capabilities    = rip_plugin_get_capabilities;
   this->input_plugin.read                = rip_plugin_read;
   this->input_plugin.read_block          = rip_plugin_read_block;
   this->input_plugin.seek                = rip_plugin_seek;
-  if(this->main_input_plugin->seek_time)
-    this->input_plugin.seek_time         = rip_plugin_seek_time;
+  this->input_plugin.seek_time           = rip_plugin_seek_time;
   this->input_plugin.get_current_pos     = rip_plugin_get_current_pos;
-  if(this->main_input_plugin->get_current_time)
-    this->input_plugin.get_current_time  = rip_plugin_get_current_time;
+  this->input_plugin.get_current_time    = rip_plugin_get_current_time;
   this->input_plugin.get_length          = rip_plugin_get_length;
   this->input_plugin.get_blocksize       = rip_plugin_get_blocksize;
   this->input_plugin.get_mrl             = rip_plugin_get_mrl;
@@ -687,3 +1021,4 @@
 
   return &this->input_plugin;
 }
+
diff -urN xine-lib-1.2.11/src/xine-engine/io_helper.c xine-lib-1.2/src/xine-engine/io_helper.c
--- xine-lib-1.2.11/src/xine-engine/io_helper.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/io_helper.c	2022-01-15 22:03:19.610547280 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project,
+ * Copyright (C) 2000-2021 the xine project,
  *
  * This file is part of xine, a free video player.
  *
@@ -444,7 +444,9 @@
       return XIO_ABORTED;
     }
     FD_ZERO (&fdset);
-    FD_SET  (fd, &fdset);
+    if (fd >= 0) {
+      FD_SET  (fd, &fdset);
+    }
     rset = (state & XIO_READ_READY) ? &fdset : NULL;
     wset = (state & XIO_WRITE_READY) ? &fdset : NULL;
     ret = select (fd + 1, rset, wset, NULL, &select_timeout);
@@ -464,7 +466,9 @@
     fd_set *rset, *wset;
 
     FD_ZERO (&fdset);
-    FD_SET  (fd, &fdset);
+    if (fd >= 0) {
+      FD_SET  (fd, &fdset);
+    }
     rset = (state & XIO_READ_READY) ? &fdset : NULL;
     wset = (state & XIO_WRITE_READY) ? &fdset : NULL;
     ret = select (fd + 1, rset, wset, NULL, &select_timeout);
diff -urN xine-lib-1.2.11/src/xine-engine/load_plugins.c xine-lib-1.2/src/xine-engine/load_plugins.c
--- xine-lib-1.2.11/src/xine-engine/load_plugins.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/load_plugins.c	2022-01-15 22:03:19.630547365 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -190,6 +190,80 @@
   return strcmp (a->file.filename, b->file.filename);
 }
 
+static const uint8_t tab_tolower[256] = {
+    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
+   64,'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',
+  'p','q','r','s','t','u','v','w','x','y','z', 91, 92, 93, 94, 95,
+   96,'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',
+  'p','q','r','s','t','u','v','w','x','y','z',123,124,125,126,127,
+  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
+  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
+  160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
+  176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
+  192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
+  208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
+  224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
+  240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
+};
+
+static const uint8_t tab_mime[256] = {
+  ['\0'] = 1,
+  ['\r'] = 2,
+  ['\n'] = 2,
+  ['\t'] = 2,
+  [' ']  = 2,
+  [':']  = 4,
+  [';']  = 8
+};
+
+static void _mime_set (uint8_t *buf, size_t bsize, const char *needle) {
+  const uint8_t *n = (const uint8_t *)needle;
+  uint8_t *e = buf + bsize - 1, *q = buf;
+
+  if (!n) {
+    buf[0] = 0;
+    return;
+  }
+
+  /* skip leading needle space */
+  while (tab_mime[*n] & 2)
+    n++;
+  /* pattern = lowercase needle */
+  while ((q < e) && !(tab_mime[*n] & (1 | 2 | 4 | 8)))
+    *q++ = tab_tolower[*n++];
+  e = q;
+  /* safe brake */
+  *e = 'A';
+}
+
+static int _mime_find (uint8_t *buf, const char *haystack) {
+  const uint8_t *h = (const uint8_t *)haystack;
+
+  if (!buf[0] || !h)
+    return -1;
+
+  while (1) {
+    const uint8_t *n;
+    int o;
+    while (tab_mime[*h] & 2)
+      h++;
+    o = h - (const uint8_t *)haystack;
+    n = buf;
+    while (*n == tab_tolower[*h])
+      n++, h++;
+    if ((*n == 'A') && (tab_mime[*h] & (1 | 2 | 4 | 8)))
+      return o;
+    while (!(tab_mime[*h] & (1 | 8)))
+      h++;
+    if (!*h)
+      break;
+    h++;
+  }
+  return -1;
+}
 
 /* Note const char * --> void * is ok here as the strings are never written to. */
 typedef int (_cmp_func_t) (void *a, void *b);
@@ -1897,47 +1971,63 @@
   }
 }
 
-static int probe_mime_type (xine_t *self, plugin_node_t *node, const char *mime_type)
-{
-  /* catalog->lock is expected to be locked */
-  if (node->plugin_class || _load_plugin_class(self, node, NULL))
-  {
-    const unsigned int mime_type_len = strlen (mime_type);
-    demux_class_t *cls = (demux_class_t *)node->plugin_class;
-    const char *mime = cls->mimetypes;
-    while (mime)
-    {
-      while (*mime == ';' || isspace (*mime))
-        ++mime;
-      if (!strncasecmp (mime, mime_type, mime_type_len) &&
-          (!mime[mime_type_len] || mime[mime_type_len] == ':' || mime[mime_type_len] == ';'))
-        return 1;
-      mime = strchr (mime, ';');
-    }
-  }
-  return 0;
-}
-
-static demux_plugin_t *probe_demux (xine_stream_t *stream, int method1, int method2,
-				    input_plugin_t *input) {
+demux_plugin_t *_x_find_demux_plugin (xine_stream_t *stream, input_plugin_t *input) {
+  uint8_t           mbuf[256];
+  int               methods[3], i;
+  plugin_catalog_t *catalog;
+  demux_plugin_t   *plugin;
+  const char       *mime_type = "";
 
-  int               i;
-  int               methods[3];
-  plugin_catalog_t *catalog = stream->xine->plugin_catalog;
-  demux_plugin_t   *plugin = NULL;
+  if (!stream || !input)
+    return NULL;
 
-  methods[0] = method1;
-  methods[1] = method2;
+  switch (stream->xine->demux_strategy) {
+    default:
+      xprintf (stream->xine, XINE_VERBOSITY_LOG,
+        _("load_plugins: unknown content detection strategy %d\n"),
+        stream->xine->demux_strategy);
+      /* fall through */
+    case XINE_DEMUX_DEFAULT_STRATEGY:
+      methods[0] = METHOD_BY_CONTENT;
+      methods[1] = METHOD_BY_MRL;
+      break;
+    case XINE_DEMUX_REVERT_STRATEGY:
+      methods[0] = METHOD_BY_MRL;
+      methods[1] = METHOD_BY_CONTENT;
+      break;
+    case XINE_DEMUX_CONTENT_STRATEGY:
+      methods[0] = METHOD_BY_CONTENT;
+      methods[1] = -1;
+      mime_type = NULL;
+      break;
+    case XINE_DEMUX_EXTENSION_STRATEGY:
+      methods[0] = METHOD_BY_MRL;
+      methods[1] = -1;
+      break;
+  }
   methods[2] = -1;
 
-  i = 0;
-  while (methods[i] != -1 && !plugin) {
+  if (mime_type
+    && input->get_optional_data
+    && (input->get_optional_data (input, NULL, INPUT_OPTIONAL_DATA_DEMUX_MIME_TYPE) != INPUT_OPTIONAL_UNSUPPORTED)
+    && (input->get_optional_data (input, &mime_type, INPUT_OPTIONAL_DATA_MIME_TYPE) != INPUT_OPTIONAL_UNSUPPORTED)
+    && strcasecmp (mime_type, "text/plain")) {
+    ;
+  } else {
+    mime_type = NULL;
+  }
+  _mime_set (mbuf, sizeof (mbuf), mime_type);
+
+  plugin = NULL;
+  catalog = stream->xine->plugin_catalog;
+
+  for (i = 0; (methods[i] >= 0) && !plugin; i++) {
     int list_id, list_size;
 
     pthread_mutex_lock (&catalog->lock);
 
     list_size = xine_sarray_size(catalog->plugin_lists[PLUGIN_DEMUX - 1]);
-    for(list_id = 0; list_id < list_size; list_id++) {
+    for (list_id = 0; list_id < list_size; list_id++) {
       plugin_node_t *node;
 
       node = xine_sarray_get (catalog->plugin_lists[PLUGIN_DEMUX - 1], list_id);
@@ -1945,18 +2035,13 @@
       xprintf(stream->xine, XINE_VERBOSITY_DEBUG, "load_plugins: probing demux '%s'\n", node->info->id);
 
       if (node->plugin_class || _load_plugin_class(stream->xine, node, NULL)) {
-        const char *mime_type;
+        demux_class_t *class = (demux_class_t *)node->plugin_class;
 
         /* If detecting by MRL, try the MIME type first (but not text/plain)... */
         stream->content_detection_method = METHOD_EXPLICIT;
-        if (methods[i] == METHOD_BY_MRL &&
-            stream->input_plugin->get_optional_data &&
-            stream->input_plugin->get_optional_data (stream->input_plugin, NULL, INPUT_OPTIONAL_DATA_DEMUX_MIME_TYPE) != INPUT_OPTIONAL_UNSUPPORTED &&
-            stream->input_plugin->get_optional_data (stream->input_plugin, &mime_type, INPUT_OPTIONAL_DATA_MIME_TYPE) != INPUT_OPTIONAL_UNSUPPORTED &&
-            mime_type && strcasecmp (mime_type, "text/plain") &&
-            probe_mime_type (stream->xine, node, mime_type) &&
-            (plugin = ((demux_class_t *)node->plugin_class)->open_plugin (node->plugin_class, stream, input)))
-        {
+        if ((methods[i] == METHOD_BY_MRL)
+          && (_mime_find (mbuf, class->mimetypes) >= 0)
+          && (plugin = class->open_plugin (class, stream, input))) {
           inc_node_ref(node);
           plugin->node = node;
           break;
@@ -1964,13 +2049,11 @@
 
         /* ... then try the extension */
         stream->content_detection_method = methods[i];
-	if ( stream->content_detection_method == METHOD_BY_MRL &&
-	     ! _x_demux_check_extension(input->get_mrl(input),
-					 ((demux_class_t *)node->plugin_class)->extensions)
-	     )
-	  continue;
+        if ((stream->content_detection_method == METHOD_BY_MRL) &&
+            !_x_demux_check_extension (input->get_mrl (input), class->extensions))
+          continue;
 
-        if ((plugin = ((demux_class_t *)node->plugin_class)->open_plugin(node->plugin_class, stream, input))) {
+        if ((plugin = class->open_plugin (class, stream, input))) {
 	  inc_node_ref(node);
 	  plugin->node = node;
 	  break;
@@ -1979,36 +2062,14 @@
     }
 
     pthread_mutex_unlock (&catalog->lock);
-
-    i++;
   }
 
-  return plugin;
-}
-
-demux_plugin_t *_x_find_demux_plugin (xine_stream_t *stream, input_plugin_t *input) {
-
-  switch (stream->xine->demux_strategy) {
-
-  default:
-    xprintf (stream->xine, XINE_VERBOSITY_LOG,
-             _("load_plugins: unknown content detection strategy %d\n"),
-             stream->xine->demux_strategy);
-    /* fall through */
-  case XINE_DEMUX_DEFAULT_STRATEGY:
-    return probe_demux (stream, METHOD_BY_CONTENT, METHOD_BY_MRL, input);
-
-  case XINE_DEMUX_REVERT_STRATEGY:
-    return probe_demux (stream, METHOD_BY_MRL, METHOD_BY_CONTENT, input);
-
-  case XINE_DEMUX_CONTENT_STRATEGY:
-    return probe_demux (stream, METHOD_BY_CONTENT, -1, input);
-
-  case XINE_DEMUX_EXTENSION_STRATEGY:
-    return probe_demux (stream, METHOD_BY_MRL, -1, input);
+  if (input == stream->input_plugin) {
+    xine_stream_private_t *s = (xine_stream_private_t *)stream;
+    s->demux.input_caps = input->get_capabilities (input);
   }
 
-  return NULL;
+  return plugin;
 }
 
 demux_plugin_t *_x_find_demux_plugin_by_name(xine_stream_t *stream, const char *name, input_plugin_t *input) {
@@ -3236,22 +3297,30 @@
  *
  * the pointer returned can be free()ed when no longer used
  * returns NULL if no demuxer is available to handle this. */
-char *xine_get_demux_for_mime_type (xine_t *self, const char *mime_type) {
-
-  plugin_catalog_t *catalog = self->plugin_catalog;
-  plugin_node_t    *node;
+char *xine_get_demux_for_mime_type (xine_t *xine, const char *mime_type) {
+  uint8_t           mbuf[256];
+  plugin_catalog_t *catalog;
   char             *id = NULL;
   int               list_id, list_size;
 
+  if (!xine || !mime_type)
+    return NULL;
+
+  _mime_set (mbuf, sizeof (mbuf), mime_type);
+  catalog = xine->plugin_catalog;
   pthread_mutex_lock (&catalog->lock);
 
   list_size = xine_sarray_size (catalog->plugin_lists[PLUGIN_DEMUX - 1]);
 
   for (list_id = 0; (list_id < list_size) && !id; list_id++) {
+    plugin_node_t *node = xine_sarray_get (catalog->plugin_lists[PLUGIN_DEMUX - 1], list_id);
+
+    if (node->plugin_class || _load_plugin_class (xine, node, NULL)) {
+      demux_class_t *class = (demux_class_t *)node->plugin_class;
 
-    node = xine_sarray_get (catalog->plugin_lists[PLUGIN_DEMUX - 1], list_id);
-    if (probe_mime_type (self, node, mime_type))
-      id = strdup(node->info->id);
+      if (_mime_find (mbuf, class->mimetypes) >= 0)
+        id = strdup (node->info->id);
+    }
   }
 
   pthread_mutex_unlock (&catalog->lock);
@@ -3379,4 +3448,3 @@
     _x_freep (&this->plugin_catalog);
   }
 }
-
diff -urN xine-lib-1.2.11/src/xine-engine/net_buf_ctrl.c xine-lib-1.2/src/xine-engine/net_buf_ctrl.c
--- xine-lib-1.2.11/src/xine-engine/net_buf_ctrl.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/net_buf_ctrl.c	2022-01-15 22:03:19.597547225 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -28,6 +28,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <pthread.h>
+#include <errno.h>
 
 /********** logging **********/
 #define LOG_MODULE "net_buf_ctrl"
@@ -49,9 +50,19 @@
 #define FIFO_PUT                   0
 #define FIFO_GET                   1
 
+/* protected by fifo->mutex (already held when entering callback) */
 typedef struct {
   /* pointer */
   fifo_buffer_t   *fifo;
+  xine_nbc_t      *nbc;
+  /* pts */
+  int64_t          last_in_pts;
+  int64_t          last_out_pts;
+  int64_t          pos_pts;
+  int              fill_pts;
+  int              out_pts;
+  /* type */
+  uint32_t         type;
   /* buffers */
   int              fifo_fill;
   int              fifo_free;
@@ -73,6 +84,9 @@
 
   xine_stream_t   *stream;
 
+  int              speed_change;
+  int              speed_val;
+
   int              buffering;
   int              enabled;
 
@@ -88,6 +102,8 @@
 
   pthread_mutex_t  mutex;
 
+  int64_t          pos_pts;
+
   /* follow live dvb delivery speed.
      0 = fix disabled
      1 = play at normal speed
@@ -96,11 +112,242 @@
      4..6 = same as 1..3 but watch audio fifo instead
      7 = pause */
   int dvbspeed;
-  int dvbs_center, dvbs_width, dvbs_audio_fill, dvbs_video_fill;
-  int64_t dvbs_audio_in, dvbs_audio_out;
-  int64_t dvbs_video_in, dvbs_video_out;
+  int dvbs_center, dvbs_width;
+
+  struct {
+    /* in live mode, we start playback ~2s delayed. this happens
+     * a) when a slow input actually sent that much data (DVB), or
+     * b) while a fast input is waiting for the 2nd fragment.
+     *    in that case, we need our own wakeup agent because nobody
+     *    fires our callbacks then. */
+    pthread_cond_t msg;
+    pthread_t thread;
+    struct timespec base, until;
+    enum {
+      NBC_DELAY_OFF = 0, /* cond not inited, no thread */
+      NBC_DELAY_READY,   /* cond inited, no thread */
+      NBC_DELAY_RUN,     /* cond inited, thread running */
+      NBC_DELAY_STOP,    /* cond inited, thread exiting normally */
+      NBC_DELAY_JOIN     /* cond inited, waiting for thread to exit */
+    } state;
+  } delay;
+
+  struct {
+    /* the buffer fill history, in units of 1/16s.
+     * we need at least 10s. with 48kHz AAC, these are
+     * 10*48000/1024=469 bufs. each buf goes both in and out,
+     * thus 1024 will be fine. */
+#define NBC_HSIZE_LD 10
+#define NBC_HSIZE_NUM (1 << NBC_HSIZE_LD)
+#define NBC_HSIZE_MASK (NBC_HSIZE_NUM - 1)
+    uint32_t min;
+    uint32_t hpos;
+    uint8_t hist[NBC_HSIZE_NUM];
+    /* the count of history entries per unit. */
+    uint32_t num[256];
+  } stats;
 };
 
+static void nbc_set_speed (xine_nbc_t *this, int speed_val) {
+  int speed_change;
+  /* at least pauseing with mutex held may freeze.
+   * make sure to apply the latest change anyway. */
+  this->speed_val = speed_val;
+  speed_change = ++this->speed_change;
+  while (1) {
+    pthread_mutex_unlock (&this->mutex);
+    if (speed_val) {
+      /* this wont stop xine_close (), and we are going to repause on the next put anyway...
+       * this->stream->xine->clock->set_option (this->stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1); */
+      _x_set_fine_speed (this->stream, speed_val);
+    } else {
+      _x_set_fine_speed (this->stream, 0);
+      /* allow decoding while paused */
+      _x_set_fine_speed (this->stream, XINE_LIVE_PAUSE_ON);
+      /* this->stream->xine->clock->set_option (this->stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 0); */
+    }
+    pthread_mutex_lock (&this->mutex);
+    if (speed_change == this->speed_change)
+      break;
+    speed_val = this->speed_val;
+    speed_change = this->speed_change;
+  }
+}
+
+static void nbc_delay_init (xine_nbc_t *this) {
+  this->delay.state = NBC_DELAY_OFF;
+}
+
+static void nbc_delay_unpause (xine_nbc_t *this, int delay) {
+  nbc_set_speed (this, XINE_FINE_SPEED_NORMAL);
+  if ((this->dvbspeed >= 1) && (this->dvbspeed <= 3)) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+      "net_buf_ctrl (%p): dvbspeed 100%% @ video %d ms %d buffers%s.\n",
+      (void *)this->stream, this->video.fill_pts / 90, this->video.fifo_fill, delay ? " [delayed]" : "");
+  } else {
+    if (delay && _x_lock_port_rewiring (this->stream->xine, 0)) {
+      this->audio.out_pts = this->stream->audio_out->get_property (this->stream->audio_out, AO_PROP_PTS_IN_FIFO);
+      _x_unlock_port_rewiring (this->stream->xine);
+    }
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+      "net_buf_ctrl (%p): dvbspeed 100%% @ audio %d ms %d buffers%s.\n",
+      (void *)this->stream, (this->audio.fill_pts + this->audio.out_pts) / 90,
+      this->audio.fifo_fill, delay ? " [delayed]" : "");
+  }
+}                                                     
+
+static void *nbc_delay_thread (void *data) {
+  xine_nbc_t *this = (xine_nbc_t *)data;
+  pthread_mutex_lock (&this->mutex);
+  while (this->delay.state == NBC_DELAY_RUN) {
+    if (pthread_cond_timedwait (&this->delay.msg, &this->mutex, &this->delay.until) == ETIMEDOUT) {
+      nbc_delay_unpause (this, 1);
+      break;
+    }
+  }
+  if (this->delay.state != NBC_DELAY_JOIN)
+    this->delay.state = NBC_DELAY_STOP;
+  pthread_mutex_unlock (&this->mutex);
+  return NULL;
+}
+
+static void nbc_delay_base (xine_nbc_t *this) {
+  xine_gettime (&this->delay.base);
+}
+
+static void nbc_delay_set (xine_nbc_t *this, uint32_t pts) {
+  struct timespec ts = {0, 0};
+
+  this->delay.until.tv_sec = this->delay.base.tv_sec + pts / 90000;
+  this->delay.until.tv_nsec = this->delay.base.tv_nsec + (pts % 90000) / 9 * 100000;
+  if (this->delay.until.tv_nsec >= 1000000000) {
+    this->delay.until.tv_nsec -= 1000000000;
+    this->delay.until.tv_sec += 1;
+  }
+  xine_gettime (&ts);
+  if ((ts.tv_sec > this->delay.until.tv_sec)
+    || ((ts.tv_sec == this->delay.until.tv_sec) && (ts.tv_nsec >= this->delay.until.tv_nsec))) {
+    nbc_delay_unpause (this, 0);
+    return;
+  }
+  if (this->delay.state == NBC_DELAY_RUN) {
+    pthread_cond_signal (&this->delay.msg);
+    return;
+  }
+  if (this->delay.state == NBC_DELAY_OFF) {
+    pthread_cond_init (&this->delay.msg, NULL);
+  } else if (this->delay.state == NBC_DELAY_STOP) {
+    void *dummy;
+    pthread_mutex_unlock (&this->mutex);
+    pthread_join (this->delay.thread, &dummy);
+    pthread_mutex_lock (&this->mutex);
+  }
+  this->delay.state = NBC_DELAY_READY;
+  if (!pthread_create (&this->delay.thread, NULL, nbc_delay_thread, this)) {
+    this->delay.state = NBC_DELAY_RUN;
+    return;
+  }
+  this->delay.state = NBC_DELAY_OFF;
+  pthread_cond_destroy (&this->delay.msg);
+  nbc_delay_unpause (this, 0);
+}
+
+static void nbc_delay_clean (xine_nbc_t *this) {
+  if (this->delay.state == NBC_DELAY_STOP) {
+    void *dummy;
+    this->delay.state = NBC_DELAY_JOIN;
+    pthread_mutex_unlock (&this->mutex);
+    pthread_join (this->delay.thread, &dummy);
+    pthread_mutex_lock (&this->mutex);
+    if (this->delay.state == NBC_DELAY_JOIN) {
+      this->delay.state = NBC_DELAY_OFF;
+      pthread_cond_destroy (&this->delay.msg);
+    }
+  }
+}
+
+static void nbc_delay_stop (xine_nbc_t *this) {
+  switch (this->delay.state) {
+    case NBC_DELAY_RUN:
+      this->delay.state = NBC_DELAY_JOIN;
+      nbc_set_speed (this, XINE_FINE_SPEED_NORMAL);
+      if (this->delay.state != NBC_DELAY_JOIN)
+        break;
+      /* fall through */
+    case NBC_DELAY_STOP:
+      this->delay.state = NBC_DELAY_JOIN;
+      pthread_cond_signal (&this->delay.msg);
+      pthread_mutex_unlock (&this->mutex);
+      {
+        void *dummy;
+        pthread_join (this->delay.thread, &dummy);
+      }
+      pthread_mutex_lock (&this->mutex);
+      if (this->delay.state != NBC_DELAY_JOIN)
+        break;
+      /* fall through */
+    case NBC_DELAY_READY:
+      this->delay.state = NBC_DELAY_OFF;
+      pthread_cond_destroy (&this->delay.msg);
+      break;
+    default: ;
+  }
+}
+
+static void nbc_stats_reset (xine_nbc_t *this) {
+  uint32_t u;
+  this->stats.min = 0;
+  this->stats.hpos = 0;
+  memset (this->stats.hist, 0, sizeof (this->stats.hist));
+  this->stats.num[0] = NBC_HSIZE_NUM;
+  for (u = 1; u < 256; u++)
+    this->stats.num[u] = 0;
+}
+
+static void nbc_stats_flat (xine_nbc_t *this, int pts) {
+  uint32_t level, u;
+  if (pts < 0)
+    pts = 0;
+  level = pts;
+  level /= (90000u / 16u);
+  if (level > 255)
+    level = 255;
+  this->stats.min = level;
+  for (u = 0; u < NBC_HSIZE_NUM; u++)
+    this->stats.hist[u] = level;
+  for (u = 0; u < 256; u++)
+    this->stats.num[u] = 0;
+  this->stats.num[level] = NBC_HSIZE_NUM;
+}
+
+/* live fragment streams may yield an extreme sawtooth fill curve.
+ * weed ont really need to delay playback by half its amplitude either.
+ * watch recent minimum instead of current value. */
+static int nbc_stats_add (xine_nbc_t *this, int pts) {
+  uint32_t level, min;
+  if (pts < 0)
+    return this->stats.min * (90000 / 16u);
+  level = pts;
+  level /= (90000u / 16u);
+  if (level > 255)
+    level = 255;
+  this->stats.hpos = (this->stats.hpos + 1) & NBC_HSIZE_MASK;
+  this->stats.num[this->stats.hist[this->stats.hpos]] -= 1;
+  this->stats.hist[this->stats.hpos] = level;
+  this->stats.num[level] += 1;
+  if (level < this->stats.min) {
+    min = level;
+  } else {
+    for (min = this->stats.min; this->stats.num[min] <= 0; min++) ;
+  }
+  if (min != this->stats.min) {
+    this->stats.min = min;
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+      "net_buf_ctrl (%p): min buf fill %u ms.\n", (void *)this->stream, (unsigned int)min * (1000u / 16u));
+  }
+  return min * (90000 / 16u);
+}
+
 static void report_progress (xine_stream_t *stream, int p) {
 
   xine_event_t             event;
@@ -116,24 +363,6 @@
   xine_event_send (stream, &event);
 }
 
-static void nbc_set_speed_pause (xine_nbc_t *this) {
-  xine_stream_t *stream = this->stream;
-
-  xprintf(stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_set_speed_pause\n");
-  _x_set_speed (stream, XINE_SPEED_PAUSE);
-  /* allow decoding while paused */
-  _x_set_fine_speed (stream, XINE_LIVE_PAUSE_ON);
-  stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 0);
-}
-
-static void nbc_set_speed_normal (xine_nbc_t *this) {
-  xine_stream_t *stream = this->stream;
-
-  xprintf(stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_set_speed_normal\n");
-  _x_set_speed (stream, XINE_SPEED_NORMAL);
-  stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
-}
-
 static void dvbspeed_init (xine_nbc_t *this) {
   int use_dvbs = 0;
   if (this->stream->input_plugin) {
@@ -150,12 +379,17 @@
     }
   }
   if (use_dvbs) {
+    nbc_delay_init (this);
     this->dvbs_center = 2 * 90000;
     this->dvbs_width = 90000;
-    this->dvbs_audio_in = this->dvbs_audio_out = this->dvbs_audio_fill = 0;
-    this->dvbs_video_in = this->dvbs_video_out = this->dvbs_video_fill = 0;
+    this->audio.pos_pts = 0;
+    this->audio.last_in_pts = this->audio.last_out_pts = 0;
+    this->audio.fill_pts = this->audio.out_pts = 0;
+    this->video.pos_pts = 0;
+    this->video.last_in_pts = this->video.last_out_pts = 0;
+    this->video.fill_pts = this->video.out_pts = 0;
     this->dvbspeed = 7;
-    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: dvbspeed mode\n");
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl (%p): dvbspeed mode.\n", (void *)this->stream);
 #if 1
     {
       /* somewhat rude but saves user a lot of frustration */
@@ -165,12 +399,14 @@
       if (xine_config_lookup_entry (xine, "audio.synchronization.slow_fast_audio",
         &entry) && (entry.num_value == 0)) {
         config->update_num (config, "audio.synchronization.slow_fast_audio", 1);
-        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: slow/fast audio playback enabled\n");
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+          "net_buf_ctrl (%p): slow/fast audio playback enabled.\n", (void *)this->stream);
       }
       if (xine_config_lookup_entry (xine, "engine.buffers.video_num_buffers",
         &entry) && (entry.num_value < 800)) {
         config->update_num (config, "engine.buffers.video_num_buffers", 800);
-        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: enlarged video fifo to 800 buffers\n");
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+          "net_buf_ctrl (%p): enlarged video fifo to 800 buffers.\n", (void *)this->stream);
       }
     }
 #endif
@@ -178,179 +414,147 @@
 }
 
 static void dvbspeed_close (xine_nbc_t *this) {
+  nbc_delay_stop (this);
   if ((0xec >> this->dvbspeed) & 1)
-    _x_set_fine_speed (this->stream, XINE_FINE_SPEED_NORMAL);
+    nbc_set_speed (this, XINE_FINE_SPEED_NORMAL);
   if (this->dvbspeed)
-    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: dvbspeed OFF\n");
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl (%p): dvbspeed OFF.\n", (void *)this->stream);
   this->dvbspeed = 0;
 }
 
-static void dvbspeed_put (xine_nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
-  int all_fill, used, mode;
+/* return speed */
+static int dvbspeed_put (xine_nbc_fifo_info_t *fifo_info) {
+  xine_nbc_t *this = fifo_info->nbc;
+  int all_fill, used, speed = -1;
   const char *name;
   /* select vars */
-  mode = b->type & BUF_MAJOR_MASK;
-  if (mode == BUF_VIDEO_BASE) {
-    /* update fifo fill time */
-    if (b->pts) {
-      if (this->dvbs_video_in) {
-        int64_t diff = b->pts - this->dvbs_video_in;
-        if ((diff > -220000) && (diff < 220000))
-          this->dvbs_video_fill += diff;
-      }
-      this->dvbs_video_in = b->pts;
-    }
+  if (fifo_info->type == BUF_VIDEO_BASE) {
     if ((0x71 >> this->dvbspeed) & 1)
-      return;
+      return -1;
     name = "video";
-    all_fill = this->dvbs_video_fill;
-  } else if (mode == BUF_AUDIO_BASE) {
-    /* update fifo fill time */
-    if (b->pts) {
-      if (this->dvbs_audio_in) {
-        int64_t diff = b->pts - this->dvbs_audio_in;
-        if ((diff > -220000) && (diff < 220000))
-          this->dvbs_audio_fill += diff;
-      }
-      this->dvbs_audio_in = b->pts;
-    }
+  } else { /* fifo_info->type == BUF_AUDIO_BASE */
     if ((0x0f >> this->dvbspeed) & 1)
-      return;
+      return -1;
     name = "audio";
-    all_fill = this->dvbs_audio_fill;
-    if (_x_lock_port_rewiring (this->stream->xine, 0)) {
-      all_fill += this->stream->audio_out->get_property (this->stream->audio_out, AO_PROP_PTS_IN_FIFO);
-      _x_unlock_port_rewiring (this->stream->xine);
-    }
-  } else
-    return;
+  }
+  all_fill = fifo_info->fill_pts + fifo_info->out_pts;
+  used = fifo_info->fifo_fill;
+
   /* take actions */
-  used = fifo->fifo_size;
   switch (this->dvbspeed) {
     case 1:
     case 4:
+      all_fill = nbc_stats_add (this, all_fill);
       if ((all_fill > this->dvbs_center + this->dvbs_width) ||
-        (100 * used > 98 * fifo->buffer_pool_capacity)) {
-        _x_set_fine_speed (this->stream, XINE_FINE_SPEED_NORMAL * 201 / 200);
+        (100 * used > 98 * fifo_info->fifo->buffer_pool_capacity)) {
         this->dvbspeed += 2;
+        speed = XINE_FINE_SPEED_NORMAL * 1005 / 1000;
         xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-          "net_buf_ctrl: dvbspeed 100.5%% @ %s %d ms %d buffers\n", name, all_fill / 90, used);
+          "net_buf_ctrl (%p): dvbspeed 100.5%% @ %s %d ms %d buffers.\n", (void *)this->stream, name, all_fill / 90, used);
       }
       break;
     case 7:
       if (_x_get_fine_speed (this->stream)) {
         /* Pause on first a/v buffer. Decoder headers went through at this time
            already, and xine_play is done waiting for that */
-        _x_set_fine_speed (this->stream, 0);
-        /* allow decoding while paused */
-        _x_set_fine_speed (this->stream, XINE_LIVE_PAUSE_ON);
-        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: prebuffering...\n");
-        break;
-      }
-      /* DVB streams usually mux video > 0.5 seconds earlier than audio
-         to give slow TVs time to decode and present in sync. Take care
-         of unusual high delays of some DVB-T streams */
-      if (this->dvbs_audio_in && this->dvbs_video_in) {
-        int64_t d = this->dvbs_video_in - this->dvbs_audio_in + 110000;
-        if ((d < 3 * 90000) && (d > this->dvbs_center)) this->dvbs_center = d;
+        nbc_delay_base (this);
+        speed = 0;
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl (%p): prebuffering...\n", (void *)this->stream);
+      }
+      if ((all_fill > this->dvbs_center) || (100 * used > 73 * fifo_info->fifo->buffer_pool_capacity)) {
+        /* DVB streams usually mux video > 0.5 seconds earlier than audio
+         * to give slow TVs time to decode and present in sync. Take care
+         * of unusual high delays of some DVB-T streams. */
+        if (this->audio.last_in_pts && this->video.last_in_pts) {
+          int64_t d = this->video.last_in_pts - this->audio.last_in_pts + 110000;
+          if ((d < 3 * 90000) && (d > this->dvbs_center))
+            this->dvbs_center = d;
+        }
+        /* dont make the startup phase switch to slow mode later. */
+        nbc_stats_flat (this, all_fill);
+        nbc_delay_set (this, this->dvbs_center);
+        this->dvbspeed = (fifo_info->type == BUF_VIDEO_BASE) ? 1 : 4;
+        /* dont let low bitrate radio switch speed too often */
+        if (used < 30)
+          this->dvbs_width = 135000;
       }
-      /* fall through */
+      break;
     case 2:
     case 5:
-      if ((all_fill > this->dvbs_center) || (100 * used > 73 * fifo->buffer_pool_capacity)) {
-        _x_set_fine_speed (this->stream, XINE_FINE_SPEED_NORMAL);
-        this->dvbspeed = (mode == BUF_VIDEO_BASE) ? 1 : 4;
-        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-          "net_buf_ctrl: dvbspeed 100%% @ %s %d ms %d buffers\n", name, all_fill / 90, used);
+      all_fill = nbc_stats_add (this, all_fill);
+      if ((all_fill > this->dvbs_center) || (100 * used > 73 * fifo_info->fifo->buffer_pool_capacity)) {
+        nbc_delay_set (this, this->dvbs_center);
+        this->dvbspeed = (fifo_info->type == BUF_VIDEO_BASE) ? 1 : 4;
         /* dont let low bitrate radio switch speed too often */
-        if (used < 30) this->dvbs_width = 135000;
+        if (used < 30)
+          this->dvbs_width = 135000;
       }
-    break;
+      break;
+    default: ;
   }
+  return speed;
 }
 
-static int dvbspeed_get (xine_nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
-  int all_fill, used, mode, pause = 0;
+/* return speed */
+static int dvbspeed_get (xine_nbc_fifo_info_t *fifo_info) {
+  xine_nbc_t *this = fifo_info->nbc;
+  int all_fill, used, speed = -1;
   const char *name;
+  nbc_delay_clean (this);
   /* select vars */
-  mode = b->type & BUF_MAJOR_MASK;
-  if (mode == BUF_VIDEO_BASE) {
-    /* update fifo fill time */
-    if (b->pts) {
-      if (this->dvbs_video_out) {
-        int64_t diff = b->pts - this->dvbs_video_out;
-        if ((diff > -220000) && (diff < 220000))
-          this->dvbs_video_fill -= diff;
-      }
-      this->dvbs_video_out = b->pts;
-    }
+  if (fifo_info->type == BUF_VIDEO_BASE) {
     if ((0x71 >> this->dvbspeed) & 1)
-      return 0;
+      return -1;
     name = "video";
-    all_fill = this->dvbs_video_fill;
-  } else if (mode == BUF_AUDIO_BASE) {
-    /* update fifo fill time */
-    if (b->pts) {
-      if (this->dvbs_audio_out) {
-        int64_t diff = b->pts - this->dvbs_audio_out;
-        if ((diff > -220000) && (diff < 220000))
-          this->dvbs_audio_fill -= diff;
-      }
-      this->dvbs_audio_out = b->pts;
-    }
+  } else { /* fifo_info->type == BUF_AUDIO_BASE */
     if ((0x0f >> this->dvbspeed) & 1)
-      return 0;
+      return -1;
     name = "audio";
-    all_fill = this->dvbs_audio_fill;
-  } else
-    return 0;
+  }
+  all_fill = fifo_info->fill_pts + fifo_info->out_pts;
+  used = fifo_info->fifo_fill;
+
   /* take actions */
-  used = fifo->fifo_size;
   switch (this->dvbspeed) {
     case 4:
-      /* The usual 48kHz stereo mp2 can fill audio out fifo with > 7 seconds!! */
-      if (_x_lock_port_rewiring (this->stream->xine, 0)) {
-        all_fill += this->stream->audio_out->get_property (this->stream->audio_out, AO_PROP_PTS_IN_FIFO);
-        _x_unlock_port_rewiring (this->stream->xine);
-      }
-      /* fall through */
     case 1:
+      all_fill = nbc_stats_add (this, all_fill);
       if (all_fill && (all_fill < this->dvbs_center - this->dvbs_width) &&
-        (100 * used < 38 * fifo->buffer_pool_capacity)) {
-        _x_set_fine_speed (this->stream, XINE_FINE_SPEED_NORMAL * 199 / 200);
+        (100 * used < 38 * fifo_info->fifo->buffer_pool_capacity)) {
         this->dvbspeed += 1;
+        speed = XINE_FINE_SPEED_NORMAL * 995 / 1000;
         xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-          "net_buf_ctrl: dvbspeed 99.5%% @ %s %d ms %d buffers\n", name, all_fill / 90, used);
+          "net_buf_ctrl (%p): dvbspeed 99.5%% @ %s %d ms %d buffers.\n", (void *)this->stream, name, all_fill / 90, used);
       }
-    break;
+      break;
     case 2:
     case 5:
       if (used <= 1) {
         this->dvbspeed = 7;
-        pause = 1;
-        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: signal lost\n");
+        nbc_stats_reset (this);
+        speed = 0;
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl (%p): signal lost.\n", (void *)this->stream);
       }
-    break;
+      break;
     case 6:
-      if (_x_lock_port_rewiring (this->stream->xine, 0)) {
-        all_fill += this->stream->audio_out->get_property (this->stream->audio_out, AO_PROP_PTS_IN_FIFO);
-        _x_unlock_port_rewiring (this->stream->xine);
-      }
-      /* fall through */
     case 3:
-      if (all_fill && (all_fill < this->dvbs_center) && (100 * used < 73 * fifo->buffer_pool_capacity)) {
-        _x_set_fine_speed (this->stream, XINE_FINE_SPEED_NORMAL);
+      all_fill = nbc_stats_add (this, all_fill);
+      if (all_fill && (all_fill < this->dvbs_center) && (100 * used < 73 * fifo_info->fifo->buffer_pool_capacity)) {
         this->dvbspeed -= 2;
+        speed = XINE_FINE_SPEED_NORMAL;
         xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
-          "net_buf_ctrl: dvbspeed 100%% @ %s %d ms %d buffers\n", name, all_fill / 90, used);
+          "net_buf_ctrl (%p): dvbspeed 100%% @ %s %d ms %d buffers.\n", (void *)this->stream, name, all_fill / 90, used);
       }
-    break;
+      break;
+    default: ;
   }
-  return pause;
+  return speed;
 }
 
 void xine_nbc_event (xine_stream_private_t *stream, uint32_t type) {
   if (stream && (type == XINE_NBC_EVENT_AUDIO_DRY)) {
+    /* this is here mainly for the case of an old style DVB signal loss.
+     * skip the false alert when there is still audio waiting in fifo. */
     stream = stream->side_streams[0];
     pthread_mutex_lock (&stream->counter.lock);
     if (stream->counter.nbc_refs <= 0) {
@@ -360,19 +564,20 @@
       stream->counter.nbc_refs += 1;
       pthread_mutex_unlock (&stream->counter.lock);
       pthread_mutex_lock (&this->mutex);
-      switch (this->dvbspeed) {
-        case 4:
-        case 5:
-        case 6:
-          this->dvbspeed = 7;
-          pthread_mutex_unlock (&this->mutex);
-          xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: signal lost\n");
-          _x_set_fine_speed (this->stream, 0);
-          _x_set_fine_speed (this->stream, XINE_LIVE_PAUSE_ON);
-          break;
-        default:
-          pthread_mutex_unlock (&this->mutex);
+      if (this->audio.fill_pts < 1000) {
+        switch (this->dvbspeed) {
+          case 4:
+          case 5:
+          case 6:
+            this->dvbspeed = 7;
+            nbc_stats_reset (this);
+            nbc_set_speed (this, 0);
+            xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl (%p): signal lost.\n", (void *)this->stream);
+            break;
+          default: ;
+        }
       }
+      pthread_mutex_unlock (&this->mutex);
       xine_nbc_close (this);
     }
   }
@@ -506,21 +711,34 @@
 }
 
 /* Alloc callback */
-static void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen) {
-  xine_nbc_t *this = this_gen;
+static void nbc_alloc_cb (fifo_buffer_t *fifo, void *data) {
+  xine_nbc_t *this = (xine_nbc_t *)data;
 
   lprintf("enter nbc_alloc_cb\n");
   /* restart playing if one fifo is full (to avoid deadlock).
    * fifo is locked already, test this one first. */
   if (fifo->buffer_pool_num_free <= FULL_FIFO_MARK) {
     pthread_mutex_lock (&this->mutex);
-    if (this->buffering && this->enabled) {
-      this->progress = 100;
-      this->buffering = 0;
-      pthread_mutex_unlock (&this->mutex);
-      nbc_set_speed_normal (this);
-      report_progress (this->stream, 100);
-      xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: nbc_alloc_cb: stops buffering\n");
+    if (this->enabled) {
+      if (this->dvbspeed) {
+        if (!((0x48 >> this->dvbspeed) & 1)) {
+          this->dvbspeed = ((0x06 >> this->dvbspeed) & 1) ? 3 : 6;
+          nbc_set_speed (this, 1005 * XINE_FINE_SPEED_NORMAL / 1000);
+          xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+            "net_buf_ctrl (%p): nbc_alloc_cb: dvbspeed 100.5%%.\n", (void *)this->stream);
+        }
+        pthread_mutex_unlock (&this->mutex);
+      } else if (this->buffering) {
+        this->progress = 100;
+        this->buffering = 0;
+        nbc_set_speed (this, XINE_FINE_SPEED_NORMAL);
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+          "net_buf_ctrl (%p): nbc_alloc_cb: stops buffering.\n", (void *)this->stream);
+        pthread_mutex_unlock (&this->mutex);
+        report_progress (this->stream, 100);
+      } else {
+        pthread_mutex_unlock (&this->mutex);
+      }
     } else {
       pthread_mutex_unlock (&this->mutex);
     }
@@ -530,96 +748,144 @@
 
 /* Put callback
  * the fifo mutex is locked */
-static void nbc_put_cb (fifo_buffer_t *fifo,
-                        buf_element_t *buf, void *this_gen) {
-  xine_nbc_t *this = this_gen;
-  int pause = 0;
+static void nbc_put_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *data) {
+  xine_nbc_fifo_info_t *fifo_info = (xine_nbc_fifo_info_t *)data;
+  xine_nbc_t *this = fifo_info->nbc;
+  uint32_t type = buf->type & BUF_MAJOR_MASK;
+  int speed = -1;
+
+  lprintf ("enter nbc_put_cb\n");
+
+  if (type == fifo_info->type) {
+
+    fifo_info->fifo_size = fifo->fifo_data_size;
+    fifo_info->fifo_fill = fifo->fifo_size;
+    fifo_info->fifo_free = fifo->buffer_pool_num_free;
+    /* update fifo fill time.
+     * NOTE: this is somewhat inaccurate. we assume that
+     * buf2.pts - buf1.pts == buf2.duration
+     * that is 1 buf late, and it jitters on reaordered video :-/ */
+    if (buf->pts) {
+      if (fifo_info->last_in_pts) {
+        int64_t diff = buf->pts - fifo_info->last_in_pts;
+        do {
+          if (diff < -220000) {
+            /* try mpeg pts wrap */
+            diff += (uint64_t)1 << 33;
+            if ((diff < -220000) || (diff > 220000))
+              break;
+          } else if (diff > 220000) {
+            diff -= (uint64_t)1 << 33;
+            if ((diff < -220000) || (diff > 220000))
+              break;
+          }
+          fifo_info->pos_pts += diff;
+          fifo_info->fill_pts += (int)diff;
+        } while (0);
+      }
+      fifo_info->last_in_pts = buf->pts;
+    }
+    if (type == BUF_AUDIO_BASE) {
+      /* The usual 48kHz stereo mp2 can fill audio out fifo with > 7 seconds!! */
+      if (_x_lock_port_rewiring (this->stream->xine, 0)) {
+        fifo_info->out_pts = this->stream->audio_out->get_property (this->stream->audio_out, AO_PROP_PTS_IN_FIFO);
+        _x_unlock_port_rewiring (this->stream->xine);
+      }
+    } else {
+      /* not supported yet */
+      fifo_info->out_pts = 0;
+    }
 
-  lprintf("enter nbc_put_cb\n");
-  pthread_mutex_lock(&this->mutex);
+    pthread_mutex_lock (&this->mutex);
 
-  if ((buf->type & BUF_MAJOR_MASK) != BUF_CONTROL_BASE) {
+    if (fifo_info->pos_pts > this->pos_pts)
+      this->pos_pts = fifo_info->pos_pts;
 
-    if (this->enabled) {
+    if (this->dvbspeed) {
 
-      if (this->dvbspeed)
-        dvbspeed_put (this, fifo, buf);
-      else {
-        nbc_compute_fifo_length(this, fifo, buf, FIFO_PUT);
-
-        if (this->buffering) {
-          /* restart playing if high_water_mark is reached by all fifos
-           * do not restart if has_video and has_audio are false to avoid
-           * a yoyo effect at the beginning of the stream when these values
-           * are not yet known.
-           *
-           * be sure that the next buffer_pool_alloc() call will not deadlock,
-           * we need at least 2 buffers (see buffer.c)
-           */
-          int progress;
-          if (this->has_video) {
-            if (this->has_audio) {
-              if ((this->video.fifo_length > this->high_water_mark) &&
-                  (this->audio.fifo_length > this->high_water_mark)) {
-                progress = 100;
-                this->buffering = 0;
-              } else {
-                /*  compute the buffering progress, 50%: video, 50%: audio */
-                progress = (this->video.fifo_length + this->audio.fifo_length) * 50 / this->high_water_mark;
-              }
+      speed = dvbspeed_put (fifo_info);
+
+    } else if (this->enabled) {
+
+      nbc_compute_fifo_length (this, fifo, buf, FIFO_PUT);
+
+      if (this->buffering) {
+        int progress;
+        /* restart playing if high_water_mark is reached by all fifos
+         * do not restart if has_video and has_audio are false to avoid
+         * a yoyo effect at the beginning of the stream when these values
+         * are not yet known.
+         * be sure that the next buffer_pool_alloc() call will not deadlock,
+         * we need at least 2 buffers (see buffer.c) */
+        if (this->has_video) {
+          if (this->has_audio) {
+            if ((this->video.fifo_length > this->high_water_mark) &&
+                (this->audio.fifo_length > this->high_water_mark)) {
+              progress = 100;
+              this->buffering = 0;
             } else {
-              if (this->video.fifo_length > this->high_water_mark) {
-                progress = 100;
-                this->buffering = 0;
-              } else {
-                progress = this->video.fifo_length * 100 / this->high_water_mark;
-              }
+              /*  compute the buffering progress, 50%: video, 50%: audio */
+              progress = (this->video.fifo_length + this->audio.fifo_length) * 50 / this->high_water_mark;
             }
           } else {
-            if (this->has_audio) {
-              if (this->audio.fifo_length > this->high_water_mark) {
-                progress = 100;
-                this->buffering = 0;
-              } else {
-                progress = this->audio.fifo_length * 100 / this->high_water_mark;
-              }
+            if (this->video.fifo_length > this->high_water_mark) {
+              progress = 100;
+              this->buffering = 0;
             } else {
-              progress = 0;
+              progress = this->video.fifo_length * 100 / this->high_water_mark;
             }
           }
-          if (!this->buffering) {
-            this->progress = 100;
-            nbc_set_speed_normal (this);
-            report_progress (this->stream, 100);
-            xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_put_cb: stops buffering\n");
+        } else {
+          if (this->has_audio) {
+            if (this->audio.fifo_length > this->high_water_mark) {
+              progress = 100;
+              this->buffering = 0;
+            } else {
+              progress = this->audio.fifo_length * 100 / this->high_water_mark;
+            }
+          } else {
+            progress = 0;
+          }
+        }
+        if (!this->buffering) {
+          this->progress = 100;
+          speed = XINE_FINE_SPEED_NORMAL;
+          report_progress (this->stream, 100);
+          xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+            "\nnet_buf_ctrl (%p): nbc_put_cb: stops buffering.\n", (void *)this->stream);
 #if 0 /* WTF... */
-            this->high_water_mark += this->high_water_mark / 2;
+          this->high_water_mark += this->high_water_mark / 2;
 #endif
-          } else {
-            if (!progress) {
-              /* if the progress can't be computed using the fifo length, use the number of buffers */
-              progress = this->video.fifo_fill > this->audio.fifo_fill ? this->video.fifo_fill : this->audio.fifo_fill;
-            }
-            if (progress > this->progress) {
-              this->progress = progress;
-              report_progress (this->stream, progress);
-            }
+        } else {
+          if (!progress) {
+            /* if the progress can't be computed using the fifo length, use the number of buffers */
+            progress = this->video.fifo_fill > this->audio.fifo_fill ? this->video.fifo_fill : this->audio.fifo_fill;
+          }
+          if (progress > this->progress) {
+            this->progress = progress;
+            report_progress (this->stream, progress);
           }
-          report_stats (this, 0);
-          if (this->stream->xine->verbosity >= XINE_VERBOSITY_DEBUG)
-            display_stats (this);
         }
-
+        report_stats (this, 0);
+        if (this->stream->xine->verbosity >= XINE_VERBOSITY_DEBUG)
+          display_stats (this);
       }
     }
-  } else {
 
+  } else if (type == BUF_CONTROL_BASE) {
+
+    pthread_mutex_lock (&this->mutex);
     switch (buf->type) {
       case BUF_CONTROL_START:
         lprintf("BUF_CONTROL_START\n");
         if (!this->enabled) {
           /* a new stream starts */
-          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_put_cb: starts buffering\n");
+          xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+            "\nnet_buf_ctrl (%p): nbc_put_cb: starts buffering.\n", (void *)this->stream);
+          fifo_info->last_in_pts  = 0;
+          fifo_info->last_out_pts = 0;
+          fifo_info->pos_pts      = 0;
+          this->pos_pts           = 0;
           this->enabled           = 1;
           this->buffering         = 1;
           this->video.first_pts   = 0;
@@ -629,7 +895,7 @@
           this->video.fifo_length = 0;
           this->audio.fifo_length = 0;
           dvbspeed_init (this);
-          if (!this->dvbspeed) pause = 1;
+          if (!this->dvbspeed) speed = 0;
           this->progress = 0;
           report_progress (this->stream, 0);
         }
@@ -656,9 +922,10 @@
             this->progress = 100;
             report_progress (this->stream, this->progress);
 
-            xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_put_cb: stops buffering\n");
+            xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+              "\nnet_buf_ctrl (%p): nbc_put_cb: stops buffering.\n", (void *)this->stream);
 
-            nbc_set_speed_normal(this);
+            speed = XINE_FINE_SPEED_NORMAL;
           }
         }
         break;
@@ -668,11 +935,11 @@
         if (fifo == this->video.fifo) {
           this->video.in_disc++;
           xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
-		  "\nnet_buf_ctrl: nbc_put_cb video disc %d\n", this->video.in_disc);
+            "\nnet_buf_ctrl (%p): nbc_put_cb video disc %d.\n", (void *)this->stream, this->video.in_disc);
         } else {
           this->audio.in_disc++;
           xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
-		  "\nnet_buf_ctrl: nbc_put_cb audio disc %d\n", this->audio.in_disc);
+            "\nnet_buf_ctrl (%p): nbc_put_cb audio disc %d.\n", (void *)this->stream, this->audio.in_disc);
         }
         break;
     }
@@ -684,69 +951,110 @@
       this->audio.fifo_free = fifo->buffer_pool_num_free;
       this->audio.fifo_size = fifo->fifo_data_size;
     }
+
+  } else {
+    pthread_mutex_lock (&this->mutex);
   }
-  pthread_mutex_unlock(&this->mutex);
-  if (pause)
-    nbc_set_speed_pause (this);
+  if (speed >= 0)
+    nbc_set_speed (this, speed);
+  pthread_mutex_unlock (&this->mutex);
   lprintf("exit nbc_put_cb\n");
 }
 
 /* Get callback
  * the fifo mutex is locked */
-static void nbc_get_cb (fifo_buffer_t *fifo,
-			buf_element_t *buf, void *this_gen) {
-  xine_nbc_t *this = this_gen;
-  int pause = 0;
+static void nbc_get_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *data) {
+  xine_nbc_fifo_info_t *fifo_info = (xine_nbc_fifo_info_t *)data;
+  xine_nbc_t *this = fifo_info->nbc;
+  uint32_t type = buf->type & BUF_MAJOR_MASK;
+  int speed = -1;
+
+  lprintf ("enter nbc_get_cb\n");
+
+  if (type == fifo_info->type) {
+
+    fifo_info->fifo_size = fifo->fifo_data_size;
+    fifo_info->fifo_fill = fifo->fifo_size;
+    fifo_info->fifo_free = fifo->buffer_pool_num_free;
+    /* update fifo fill time.
+     * NOTE: this is somewhat inaccurate. we assume that
+     * buf2.pts - buf1.pts == buf2.duration
+     * that is 1 buf late, and it jitters on reaordered video :-/ */
+    if (buf->pts) {
+      if (fifo_info->last_out_pts) {
+        int64_t diff = buf->pts - fifo_info->last_out_pts;
+        do {
+          if (diff < -220000) {
+            /* try mpeg pts wrap */
+            diff += (uint64_t)1 << 33;
+            if ((diff < -220000) || (diff > 220000))
+              break;
+          } else if (diff > 220000) {
+            diff -= (uint64_t)1 << 33;
+            if ((diff < -220000) || (diff > 220000))
+              break;
+          }
+          fifo_info->fill_pts -= (int)diff;
+        } while (0);
+      }
+      fifo_info->last_out_pts = buf->pts;
+    }
+    if (type == BUF_AUDIO_BASE) {
+      if (_x_lock_port_rewiring (this->stream->xine, 0)) {
+        fifo_info->out_pts = this->stream->audio_out->get_property (this->stream->audio_out, AO_PROP_PTS_IN_FIFO);
+        _x_unlock_port_rewiring (this->stream->xine);
+      }
+    } else {
+      fifo_info->out_pts = 0;
+    }
 
-  lprintf("enter nbc_get_cb\n");
-  pthread_mutex_lock(&this->mutex);
+    pthread_mutex_lock (&this->mutex);
+    if (this->dvbspeed) {
 
-  if ((buf->type & BUF_MAJOR_MASK) != BUF_CONTROL_BASE) {
+      speed = dvbspeed_get (fifo_info);
 
-    if (this->enabled) {
+    } else if (this->enabled) {
 
-      if (this->dvbspeed)
-        pause = dvbspeed_get (this, fifo, buf);
-      else {
-        nbc_compute_fifo_length(this, fifo, buf, FIFO_GET);
+      nbc_compute_fifo_length (this, fifo, buf, FIFO_GET);
 
-        if (!this->buffering) {
-          /* start buffering if one fifo is empty
-           */
-          if (((this->video.fifo_length == 0) && this->has_video) ||
-              ((this->audio.fifo_length == 0) && this->has_audio)) {
-            /* do not pause if a fifo is full to avoid yoyo (play-pause-play-pause) */
-            if ((this->video.fifo_free > FULL_FIFO_MARK) &&
-                (this->audio.fifo_free > FULL_FIFO_MARK)) {
-              this->buffering = 1;
-              this->progress  = 0;
-              report_progress (this->stream, 0);
-
-              xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
-                      "\nnet_buf_ctrl: nbc_get_cb: starts buffering, vid: %d, aud: %d\n",
-                      this->video.fifo_fill, this->audio.fifo_fill);
-              pause = 1;
-            }
+      if (!this->buffering) {
+        /* start buffering if one fifo is empty */
+        if (((this->video.fifo_length == 0) && this->has_video) ||
+            ((this->audio.fifo_length == 0) && this->has_audio)) {
+          /* do not pause if a fifo is full to avoid yoyo (play-pause-play-pause) */
+          if ((this->video.fifo_free > FULL_FIFO_MARK) &&
+              (this->audio.fifo_free > FULL_FIFO_MARK)) {
+            this->buffering = 1;
+            this->progress  = 0;
+            report_progress (this->stream, 0);
+
+            xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+              "\nnet_buf_ctrl (%p): nbc_get_cb: starts buffering, vid: %d, aud: %d.\n",
+              (void *)this->stream, this->video.fifo_fill, this->audio.fifo_fill);
+            speed = 0;
           }
-          report_stats (this, 1);
-          if (this->stream->xine->verbosity >= XINE_VERBOSITY_DEBUG)
-            display_stats (this);
-        } else {
-          pause = 1;
         }
+        report_stats (this, 1);
+        if (this->stream->xine->verbosity >= XINE_VERBOSITY_DEBUG)
+          display_stats (this);
+      } else {
+        speed = 0;
       }
     }
-  } else {
+
+  } else if (type == BUF_CONTROL_BASE) {
+
+    pthread_mutex_lock (&this->mutex);
     /* discontinuity management */
     if (buf->type == BUF_CONTROL_NEWPTS) {
       if (fifo == this->video.fifo) {
         this->video.in_disc--;
         xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
-		"\nnet_buf_ctrl: nbc_get_cb video disc %d\n", this->video.in_disc);
+          "\nnet_buf_ctrl (%p): nbc_get_cb video disc %d\n", (void *)this->stream, this->video.in_disc);
       } else {
         this->audio.in_disc--;
         xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
-		"\nnet_buf_ctrl: nbc_get_cb audio disc %d\n", this->audio.in_disc);
+          "\nnet_buf_ctrl (%p): nbc_get_cb audio disc %d\n", (void *)this->stream, this->audio.in_disc);
       }
     }
 
@@ -757,17 +1065,28 @@
       this->audio.fifo_free = fifo->buffer_pool_num_free;
       this->audio.fifo_size = fifo->fifo_data_size;
     }
+  } else {
+    pthread_mutex_lock (&this->mutex);
   }
 
-  pthread_mutex_unlock(&this->mutex);
-  if (pause)
-    nbc_set_speed_pause (this);
+  if (speed >= 0)
+    nbc_set_speed (this, speed);
+  pthread_mutex_unlock (&this->mutex);
   lprintf("exit nbc_get_cb\n");
 }
 
+int64_t xine_nbc_get_pos_pts (xine_nbc_t *this) {
+  int64_t r;
+  if (!this)
+    return 0;
+  pthread_mutex_lock (&this->mutex);
+  r = this->pos_pts;
+  pthread_mutex_unlock (&this->mutex);
+  return r;
+}
+
 xine_nbc_t *xine_nbc_init (xine_stream_t *stream) {
   xine_nbc_t *this;
-  fifo_buffer_t *video_fifo, *audio_fifo;
   double video_fifo_factor, audio_fifo_factor;
   cfg_entry_t *entry;
 
@@ -784,7 +1103,8 @@
       refs = s->counter.nbc_refs;
       this = s->counter.nbc;
       pthread_mutex_unlock (&s->counter.lock);
-      xprintf (s->s.xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: add to stream %p (%d refs).\n", (void *)s, refs);
+      xprintf (s->s.xine, XINE_VERBOSITY_DEBUG,
+        "net_buf_ctrl (%p): add to stream (%d refs).\n", (void *)s, refs);
       return this;
     }
     this = calloc (1, sizeof (*this));
@@ -796,32 +1116,46 @@
     s->counter.nbc = this;
     pthread_mutex_unlock (&s->counter.lock);
     xine_refs_add (&s->refs, 1);
-    xprintf (s->s.xine, XINE_VERBOSITY_DEBUG, "net_buf_ctrl: add to stream %p (1 refs).\n", (void *)s);
+    xprintf (s->s.xine, XINE_VERBOSITY_DEBUG,
+      "net_buf_ctrl (%p): add to stream (1 refs).\n", (void *)s);
     stream = &s->s;
   }
 
-  video_fifo = stream->video_fifo;
-  audio_fifo = stream->audio_fifo;
+  this->stream     = stream;
+  this->video.fifo = stream->video_fifo;
+  this->audio.fifo = stream->audio_fifo;
+  this->video.nbc  = this;
+  this->audio.nbc  = this;
+  this->video.type = BUF_VIDEO_BASE;
+  this->audio.type = BUF_AUDIO_BASE;
+#ifndef HAVE_ZERO_SAFE_MEM
+  this->video.last_pts  = 0;
+  this->video.first_pts = 0;
+  this->video.fill_pts  = 0;
+  this->video.out_pts   = 0;
+  this->audio.last_pts  = 0;
+  this->audio.first_pts = 0;
+  this->audio.fill_pts  = 0;
+  this->audio.out_pts   = 0;
+#endif
 
   lprintf("nbc_init\n");
   pthread_mutex_init (&this->mutex, NULL);
 
-  this->stream              = stream;
-  this->video.fifo          = video_fifo;
-  this->audio.fifo          = audio_fifo;
+  nbc_stats_reset (this);
 
   /* when the FIFO sizes are increased compared to the default configuration,
    * apply a factor to the high water mark */
   entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.video_num_buffers");
   /* No entry when no video output */
   if (entry)
-    video_fifo_factor = (double)video_fifo->buffer_pool_capacity / (double)entry->num_default;
+    video_fifo_factor = (double)this->video.fifo->buffer_pool_capacity / (double)entry->num_default;
   else
     video_fifo_factor = 1.0;
   entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.audio_num_buffers");
   /* When there's no audio output, there's no entry */
   if (entry)
-    audio_fifo_factor = (double)audio_fifo->buffer_pool_capacity / (double)entry->num_default;
+    audio_fifo_factor = (double)this->audio.fifo->buffer_pool_capacity / (double)entry->num_default;
   else
     audio_fifo_factor = 1.0;
   /* use the smaller factor */
@@ -830,13 +1164,16 @@
   else
     this->high_water_mark = (double)DEFAULT_HIGH_WATER_MARK * audio_fifo_factor;
 
-  video_fifo->register_alloc_cb(video_fifo, nbc_alloc_cb, this);
-  video_fifo->register_put_cb(video_fifo, nbc_put_cb, this);
-  video_fifo->register_get_cb(video_fifo, nbc_get_cb, this);
-
-  audio_fifo->register_alloc_cb(audio_fifo, nbc_alloc_cb, this);
-  audio_fifo->register_put_cb(audio_fifo, nbc_put_cb, this);
-  audio_fifo->register_get_cb(audio_fifo, nbc_get_cb, this);
+  this->speed_change = 0;
+  this->speed_val = _x_get_fine_speed (this->stream);
+
+  this->video.fifo->register_alloc_cb (this->video.fifo, nbc_alloc_cb, this);
+  this->video.fifo->register_put_cb   (this->video.fifo, nbc_put_cb,   &this->video);
+  this->video.fifo->register_get_cb   (this->video.fifo, nbc_get_cb,   &this->video);
+
+  this->audio.fifo->register_alloc_cb (this->audio.fifo, nbc_alloc_cb, this);
+  this->audio.fifo->register_put_cb   (this->audio.fifo, nbc_put_cb,   &this->audio);
+  this->audio.fifo->register_get_cb   (this->audio.fifo, nbc_get_cb,   &this->audio);
 
   return this;
 }
@@ -856,7 +1193,10 @@
     refs = s->counter.nbc_refs;
     if (refs > 0) {
       pthread_mutex_unlock (&s->counter.lock);
-      xprintf (xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: remove from stream %p (%d refs).\n", (void *)s, refs);
+#if 0
+      xprintf (xine, XINE_VERBOSITY_DEBUG,
+        "\nnet_buf_ctrl (%p): remove from stream (%d refs).\n", (void *)s, refs);
+#endif
       return;
     }
     s->counter.nbc_refs = 0;
@@ -864,7 +1204,8 @@
     pthread_mutex_unlock (&s->counter.lock);
   }
 
-  xprintf (xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: remove from stream %p (0 refs).\n", (void *)this->stream);
+  xprintf (xine, XINE_VERBOSITY_DEBUG,
+    "\nnet_buf_ctrl (%p): remove from stream (0 refs).\n", (void *)this->stream);
   video_fifo = this->stream->video_fifo;
   audio_fifo = this->stream->audio_fifo;
 
@@ -879,10 +1220,10 @@
   audio_fifo->unregister_get_cb(audio_fifo, nbc_get_cb);
 
   /* now we are sure that nobody will call a callback */
-  this->stream->xine->clock->set_option (this->stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
+  /* this->stream->xine->clock->set_option (this->stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1); */
 
   pthread_mutex_destroy(&this->mutex);
-  xprintf(xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_close: done\n");
+  xprintf (xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl (%p): nbc_close: done\n", (void *)this->stream);
 
   {
     xine_stream_private_t *s = (xine_stream_private_t *)this->stream;
diff -urN xine-lib-1.2.11/src/xine-engine/osd.c xine-lib-1.2/src/xine-engine/osd.c
--- xine-lib-1.2.11/src/xine-engine/osd.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/osd.c	2022-01-15 22:03:19.627547352 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -915,7 +915,7 @@
     lprintf ("font '%s' chars=%d\n", font->name, font->num_fontchars);
 
     /* estimate total uncompressed size, and load entire rest. */
-    dsize = font->num_fontchars * font->size * font->size;
+    dsize = (size_t)font->num_fontchars * font->size * font->size;
     font->data = malloc (dsize);
     if (!font->data)
       break;
diff -urN xine-lib-1.2.11/src/xine-engine/video_decoder.c xine-lib-1.2/src/xine-engine/video_decoder.c
--- xine-lib-1.2.11/src/xine-engine/video_decoder.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/video_decoder.c	2022-01-15 22:03:19.598547229 +0100
@@ -69,13 +69,15 @@
 
 int _x_spu_decoder_sleep (xine_stream_t *s, int64_t next_spu_vpts) {
   xine_stream_private_t *stream = (xine_stream_private_t *)s;
-  xine_private_t *xine = (xine_private_t *)stream->s.xine;
+  xine_private_t *xine;
   int64_t time, wait;
   int thread_vacant = 1;
 
   if (!stream)
     return 0;
 
+  xine = (xine_private_t *)stream->s.xine;
+
   /* we wait until one second before the next SPU is due */
   next_spu_vpts -= 90000;
 
diff -urN xine-lib-1.2.11/src/xine-engine/video_out.c xine-lib-1.2/src/xine-engine/video_out.c
--- xine-lib-1.2.11/src/xine-engine/video_out.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/video_out.c	2022-01-15 22:03:19.615547301 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2022 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -408,7 +408,7 @@
     for (a = d; *a; a++)
       xine_refs_sub (&(*a)->refs, 1);
     xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG,
-      "video_out: freed %d obsolete stream refs.\n", (int)(a - d));
+      LOG_MODULE ": freed %d obsolete stream refs.\n", (int)(a - d));
   }
 }
 
@@ -524,7 +524,7 @@
   const char *s1 = (flags & XINE_TICKET_FLAG_ATOMIC) ? " atomic" : "";
   const char *s2 = (flags & XINE_TICKET_FLAG_REWIRE) ? " port_rewire" : "";
   pthread_cond_signal (&this->free_queue.not_empty);
-  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "video_out: port ticket revoked%s%s.\n", s1, s2);
+  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, LOG_MODULE ": port ticket revoked%s%s.\n", s1, s2);
 }
 
 static void vo_display_reref_append (vos_t *this, vo_frame_t *img) {
@@ -637,7 +637,7 @@
   if (this->free_queue.first) {
     f = vo_free_queue_pop_int (this);
     pthread_mutex_unlock (&this->free_queue.mutex);
-    xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "video_out: got unblock frame from free queue.\n");
+    xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, LOG_MODULE ": got unblock frame from free queue.\n");
     return f;
   }
   pthread_mutex_unlock (&this->free_queue.mutex);
@@ -661,7 +661,7 @@
     }
     pthread_mutex_unlock (&this->display_queue.mutex);
     vo_frame_dec2_lock_int (this, f);
-    xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "video_out: got unblock frame from display queue.\n");
+    xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, LOG_MODULE ": got unblock frame from display queue.\n");
     return f;
   }
   pthread_mutex_unlock (&this->display_queue.mutex);
@@ -732,7 +732,7 @@
           img = vo_get_unblock_frame (this);
           if (img)
             return img;
-          xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "video_out: allow port rewire.\n");
+          xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, LOG_MODULE ": allow port rewire.\n");
           this->xine->port_ticket->renew (this->xine->port_ticket, XINE_TICKET_FLAG_REWIRE);
           pthread_mutex_lock (&this->free_queue.mutex);
           continue;
@@ -1280,16 +1280,22 @@
 
   lprintf ("get_frame (%d x %d)\n", width, height);
 
+  if (width * height == 0) {
+    /* drivers need not support or trap this. */
+    xprintf (&this->xine->x, XINE_VERBOSITY_LOG,
+      LOG_MODULE ": vo_get_frame: invalid frame size %u x %u.\n", (unsigned int)width, (unsigned int)height);
+    width = height = 16;
+  }
+  /* some decoders report strange ratios */
+  if (ratio <= 0.0)
+    ratio = (double)width / (double)height;
+
   while (1) {
 
     img = vo_free_queue_get (this, width, height, ratio, format, flags);
 
     lprintf ("got a frame -> pthread_mutex_lock (&img->mutex)\n");
 
-    /* some decoders report strange ratios */
-    if (ratio <= 0.0)
-      ratio = (double)width / (double)height;
-
     pthread_mutex_lock (&img->mutex);
     img->lock_counter   = 1;
     img->width          = width;
@@ -1464,7 +1470,7 @@
       }
       if (this->num_frames_burst) {
         xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG,
-          "video_out: dropped %d bad frames after seek.\n", this->num_frames_burst);
+          LOG_MODULE ": dropped %d bad frames after seek.\n", this->num_frames_burst);
         this->num_frames_burst = 0;
       }
     }
@@ -1476,7 +1482,7 @@
       if (this->keyframe_mode == 0) {
         if (!stream->index_array && stream->input_plugin && INPUT_IS_SEEKABLE (stream->input_plugin)) {
           xprintf (stream->xine, XINE_VERBOSITY_DEBUG,
-            "video_out: no keyframe index found, lets do it from this side.\n");
+            LOG_MODULE ": no keyframe index found, lets do it from this side.\n");
           this->keyframe_mode = 1;
         } else {
           this->keyframe_mode = -1;
@@ -2038,7 +2044,7 @@
     /* Report success. */
     if (n) {
       xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG,
-        "video_out: flushed out %d frames (now=%"PRId64", discard=%d).\n",
+        LOG_MODULE ": flushed out %d frames (now=%"PRId64", discard=%d).\n",
         n, *vpts, this->display_queue.discard_frames);
     }
     this->redraw_needed = 0;
@@ -2053,7 +2059,7 @@
 
     if (img->is_first > 0) {
 #ifdef LOG_FLUSH
-      printf ("video_out: first frame pts=%"PRId64", now=%"PRId64", discard=%d\n",
+      printf (LOG_MODULE ": first frame pts=%"PRId64", now=%"PRId64", discard=%d\n",
         img->vpts, *vpts, this->display_queue.discard_frames);
 #endif
       /* The user seek brake feature: display first frame after seek right now
@@ -2282,7 +2288,7 @@
           vpts = f->vpts;
           this->clock->adjust_clock (this->clock, vpts);
           xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG,
-            "video_out: SINGLE_STEP: vpts %"PRId64".\n", vpts);
+            LOG_MODULE ": SINGLE_STEP: vpts %"PRId64".\n", vpts);
           overlay_and_display_frame (this, f, vpts);
           vo_grab_current_frame (this, f, vpts);
         }
@@ -2353,7 +2359,7 @@
 #ifndef WIN32
   errno = 0;
   if (nice(-2) == -1 && errno)
-    xine_log(&this->xine->x, XINE_LOG_MSG, "video_out: can't raise nice priority by 2: %s\n", strerror(errno));
+    xine_log(&this->xine->x, XINE_LOG_MSG, LOG_MODULE ": can't raise nice priority by 2: %s\n", strerror(errno));
 #endif /* WIN32 */
 
   this->disable_decoder_flush_from_video_out = this->xine->x.config->register_bool (this->xine->x.config,
@@ -2453,13 +2459,13 @@
     lprintf ("next_frame_vpts is %" PRId64 "\n", next_frame_vpts);
     if ((next_frame_vpts - vpts) > 2 * 90000) {
       xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG,
-      "video_out: vpts/clock error, next_vpts=%" PRId64 " cur_vpts=%" PRId64 "\n", next_frame_vpts, vpts);
+      LOG_MODULE ": vpts/clock error, next_vpts=%" PRId64 " cur_vpts=%" PRId64 "\n", next_frame_vpts, vpts);
       if (this->rp.ready_first && this->rp.ready_first->next) {
         int64_t d = this->rp.ready_first->next->vpts - vpts;
         if ((d >= 0) && (d <= 2 * 90000)) {
           d = (d >> 1) + vpts;
           xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG,
-            "video_out: looks like a missed decoder flush, fixing next_vpts to %" PRId64 ".\n", d);
+            LOG_MODULE ": looks like a missed decoder flush, fixing next_vpts to %" PRId64 ".\n", d);
           this->rp.ready_first->vpts = d;
           next_frame_vpts = d;
         }
@@ -2640,7 +2646,7 @@
 
   vos_t      *this = (vos_t *) this_gen;
 
-  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "video_out: vo_open (%p)\n", (void*)stream);
+  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, LOG_MODULE ": vo_open (%p)\n", (void*)stream);
 
   this->video_opened = 1;
   pthread_mutex_lock (&this->display_queue.mutex);
@@ -2661,7 +2667,7 @@
 
   vos_t      *this = (vos_t *) this_gen;
 
-  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "video_out: vo_close (%p)\n", (void*)stream);
+  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, LOG_MODULE ": vo_close (%p)\n", (void*)stream);
 
   /* this will make sure all hide events were processed */
   if (this->overlay_source)
@@ -2728,24 +2734,20 @@
   case XINE_PARAM_VO_CONTRAST:
   case XINE_PARAM_VO_BRIGHTNESS:
   case XINE_PARAM_VO_GAMMA:
-   {
-    int v, min_v, max_v, range_v;
-
-    pthread_mutex_lock( &this->driver_lock );
-    this->driver->get_property_min_max (this->driver,
-					property & 0xffffff,
-					&min_v, &max_v);
-
-    v = this->driver->get_property (this->driver, property & 0xffffff);
-
-    range_v = max_v - min_v + 1;
+    {
+      int v, min_v = 0, max_v = 0xffff, range_v;
 
-    if (range_v > 0)
-      ret = ((v-min_v) * 65536 + 32768) / range_v;
-    else
-      ret = 0;
-    pthread_mutex_unlock( &this->driver_lock );
-  }
+      pthread_mutex_lock (&this->driver_lock);
+      this->driver->get_property_min_max (this->driver, property & 0xffffff, &min_v, &max_v);
+      v = this->driver->get_property (this->driver, property & 0xffffff);
+      pthread_mutex_unlock (&this->driver_lock);
+
+      range_v = max_v - min_v;
+      if (range_v > 0)
+        ret = ((v - min_v) * 0xffff + (range_v >> 1)) / range_v;
+      else
+        ret = 0;
+    }
     break;
 
   default:
@@ -2861,20 +2863,14 @@
   case XINE_PARAM_VO_BRIGHTNESS:
   case XINE_PARAM_VO_GAMMA:
     if (!this->grab_only) {
-      int v, min_v, max_v, range_v;
+      int v, min_v = 0, max_v = 0xffff, range_v;
 
-      pthread_mutex_lock( &this->driver_lock );
-
-      this->driver->get_property_min_max (this->driver,
-					property & 0xffffff,
-					&min_v, &max_v);
-
-      range_v = max_v - min_v + 1;
-
-      v = (value * range_v + (range_v/2)) / 65536 + min_v;
-
-      this->driver->set_property(this->driver, property & 0xffffff, v);
-      pthread_mutex_unlock( &this->driver_lock );
+      pthread_mutex_lock (&this->driver_lock);
+      this->driver->get_property_min_max (this->driver, property & 0xffffff, &min_v, &max_v);
+      range_v = max_v - min_v;
+      v = (value * range_v + 0x7fff) / 0xffff + min_v;
+      this->driver->set_property (this->driver, property & 0xffffff, v);
+      pthread_mutex_unlock (&this->driver_lock);
       ret = value;
     } else
       ret = 0;
@@ -2940,14 +2936,14 @@
   }
   this->trigger_drawing.speed = new_speed;
   pthread_mutex_unlock (&this->trigger_drawing.mutex);
-  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "video_out: new speed %d.\n", new_speed);
+  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, LOG_MODULE ": new speed %d.\n", new_speed);
 }
 
 static void vo_exit (xine_video_port_t *this_gen) {
 
   vos_t      *this = (vos_t *) this_gen;
 
-  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "video_out: exit.\n");
+  xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, LOG_MODULE ": exit.\n");
 
   this->xine->port_ticket->revoke_cb_unregister (this->xine->port_ticket, vo_ticket_revoked, this);
   
@@ -2970,7 +2966,7 @@
     int n = this->driver->set_property (this->driver, VO_PROP_DISCARD_FRAMES, -1);
     if (n > 0)
       xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG,
-        "video_out: returned %d held frames from driver.\n", n);
+        LOG_MODULE ": returned %d held frames from driver.\n", n);
   }
 
   {
@@ -2992,7 +2988,7 @@
     for (i = 0; i < this->frames_total; i++) {
       if (this->display_queue.frames[i]) {
         xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG,
-          "video_out: BUG: frame #%d (%p) still in use (%d refs).\n",
+          LOG_MODULE ": BUG: frame #%d (%p) still in use (%d refs).\n",
           i, (void*)this->display_queue.frames[i], this->display_queue.frames[i]->lock_counter);
       }
     }
@@ -3315,7 +3311,7 @@
     pthread_attr_destroy(&pth_attrs);
 
     if (err != 0) {
-      xprintf (&this->xine->x, XINE_VERBOSITY_NONE, "video_out: can't create thread (%s)\n", strerror(err));
+      xprintf (&this->xine->x, XINE_VERBOSITY_NONE, LOG_MODULE ": can't create thread (%s)\n", strerror(err));
       /* FIXME: how does this happen ? */
       xprintf (&this->xine->x, XINE_VERBOSITY_LOG,
 	       _("video_out: sorry, this should not happen. please restart xine.\n"));
@@ -3328,7 +3324,7 @@
     this->clock->register_speed_change_callback (this->clock, vo_speed_change_cb, this);
     this->trigger_drawing.speed = this->clock->speed;
 
-    xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, "video_out: thread created\n");
+    xprintf (&this->xine->x, XINE_VERBOSITY_DEBUG, LOG_MODULE ": thread created\n");
 
   }
 
diff -urN xine-lib-1.2.11/src/xine-engine/vo_scale.c xine-lib-1.2/src/xine-engine/vo_scale.c
--- xine-lib-1.2.11/src/xine-engine/vo_scale.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/vo_scale.c	2022-01-15 22:03:19.612547289 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2022 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -52,13 +52,14 @@
 
   } else {
     double image_ratio, desired_ratio;
+    int vw = this->delivered_width - this->crop_left - this->crop_right;
+    int vh = this->delivered_height - this->crop_top - this->crop_bottom;
 
     /*
      * aspect ratio
      */
 
-    image_ratio = (double) (this->delivered_width - (this->crop_left + this->crop_right)) /
-                  (double) (this->delivered_height - (this->crop_top + this->crop_bottom));
+    image_ratio = vh > 0 ? (double)vw / (double)vh : 1.0;
 
     switch (this->user_ratio) {
     case XINE_VO_ASPECT_AUTO:
@@ -80,7 +81,7 @@
 
     this->video_pixel_aspect = desired_ratio / image_ratio;
 
-    _x_assert(this->gui_pixel_aspect != 0.0);
+    _x_assert (this->gui_pixel_aspect > 0.0);
 
     /* dont scale just for tiny pixel aspect shift */
     if (this->scaling_disabled & 1) {
@@ -283,11 +284,13 @@
 			 &gui_x, &gui_y, &gui_width, &gui_height,
 			 &gui_pixel_aspect, &gui_win_x, &gui_win_y );
 
-  if ( (gui_x != this->gui_x) || (gui_y != this->gui_y)
-      || (gui_width != this->gui_width) || (gui_height != this->gui_height)
-      || (gui_pixel_aspect != this->gui_pixel_aspect)
-      || (gui_win_x != this->gui_win_x) || (gui_win_y != this->gui_win_y) ) {
-
+  /* test for the rare change case in just 2 branches. */
+  if (!((gui_x ^ this->gui_x) | (gui_y ^ this->gui_y)
+      | (gui_width ^ this->gui_width) | (gui_height ^ this->gui_height)
+      | (gui_win_x ^ this->gui_win_x) | (gui_win_y ^ this->gui_win_y))
+    && (gui_pixel_aspect == this->gui_pixel_aspect)) {
+    ret = this->force_redraw;
+  } else {
     this->gui_x      = gui_x;
     this->gui_y      = gui_y;
     this->gui_width  = gui_width;
@@ -295,11 +298,8 @@
     this->gui_win_x  = gui_win_x;
     this->gui_win_y  = gui_win_y;
     this->gui_pixel_aspect = gui_pixel_aspect;
-
     ret = 1;
   }
-  else
-    ret = this->force_redraw;
 
   this->force_redraw = 0;
   return ret;
@@ -466,22 +466,59 @@
   config->unregister_callbacks (config, NULL, NULL, self, sizeof (*self));
 }
 
-void _x_vo_scale_init(vo_scale_t *this, int support_zoom, int scaling_disabled,
-                   config_values_t *config ) {
+void _x_vo_scale_init (vo_scale_t *this, int support_zoom, int scaling_disabled, config_values_t *config) {
+#ifdef HAVE_ZERO_SAFE_MEM
+  memset (this, 0, sizeof (*this));
+#else
+  this->delivered_width    = 0;
+  this->delivered_height   = 0;
+  this->crop_left          = 0;
+  this->crop_right         = 0;
+  this->crop_top           = 0;
+  this->crop_bottom        = 0;
+  this->displayed_xoffset  = 0;
+  this->displayed_yoffset  = 0;
+  this->displayed_width    = 0;
+  this->displayed_height   = 0;
+  this->gui_x              = 0;
+  this->gui_y              = 0;
+  this->gui_width          = 0;
+  this->gui_height         = 0;
+  this->gui_win_x          = 0;
+  this->gui_win_y          = 0;
+  this->output_width       = 0;
+  this->output_height      = 0;
+  this->output_xoffset     = 0;
+  this->output_yoffset     = 0;
+  this->user_data          = NULL;
+  this->frame_output_cb    = NULL;
+  this->dest_size_cb       = NULL;
+  this->border[0].x        = 0;
+  this->border[0].y        = 0;
+  this->border[0].w        = 0;
+  this->border[0].h        = 0;
+  this->border[1].x        = 0;
+  this->border[1].y        = 0;
+  this->border[1].w        = 0;
+  this->border[1].h        = 0;
+  this->border[2].x        = 0;
+  this->border[2].y        = 0;
+  this->border[2].w        = 0;
+  this->border[2].h        = 0;
+  this->border[3].x        = 0;
+  this->border[3].y        = 0;
+  this->border[3].w        = 0;
+  this->border[3].h        = 0;
+#endif
 
-  memset( this, 0, sizeof(vo_scale_t) );
   this->support_zoom = support_zoom;
   this->force_redraw = 1;
   this->zoom_factor_x = 1.0;
   this->zoom_factor_y = 1.0;
   this->gui_pixel_aspect = 1.0;
+  this->video_pixel_aspect = 1.0;
   this->user_ratio = XINE_VO_ASPECT_AUTO;
-  this->delivered_ratio = 0.0;
-
-  this->crop_left   = 0;
-  this->crop_right  = 0;
-  this->crop_top    = 0;
-  this->crop_bottom = 0;
+  this->delivered_ratio = 1.0;
 
   this->output_horizontal_position =
     config->register_range(config, "video.output.horizontal_position", 50, 0, 100,
@@ -520,4 +557,3 @@
 	"sharpness.\n"),
       10, vo_scale_square_pixels_changed, this);
 }
-
diff -urN xine-lib-1.2.11/src/xine-engine/xine.c xine-lib-1.2/src/xine-engine/xine.c
--- xine-lib-1.2.11/src/xine-engine/xine.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/xine.c	2022-01-15 22:03:19.638547398 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -84,6 +84,24 @@
 
 #include "xine_private.h"
 
+static const uint8_t tab_tolower[256] = {
+    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+  ' ','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/',
+  '0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?',
+  '@','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',
+  'p','q','r','s','t','u','v','w','x','y','z','[','\\',']','^','_',
+  '`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',
+  'p','q','r','s','t','u','v','w','x','y','z','{','|','}','~',127,
+  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
+  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
+  160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
+  176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
+  192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
+  208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
+  224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
+  240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
+};
 
 
 static void mutex_cleanup (void *mutex) {
@@ -1069,6 +1087,7 @@
   stream->slave_is_subtitle        = 0;
   stream->query_input_plugins[0]   = NULL;
   stream->query_input_plugins[1]   = NULL;
+  stream->seekable                 = 0;
   {
     int i;
     for (i = 1; i < XINE_NUM_SIDE_STREAMS; i++)
@@ -1313,6 +1332,7 @@
   s->slave_is_subtitle        = 0;
   s->query_input_plugins[0]   = NULL;
   s->query_input_plugins[1]   = NULL;
+  s->seekable                 = 0;
   {
     int i;
     for (i = 1; i < XINE_NUM_SIDE_STREAMS; i++)
@@ -1517,6 +1537,141 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
 
+typedef enum {
+  _X_ARG_CONFIG = 0,
+  _X_ARG_demux,
+  _X_ARG_save,
+  _X_ARG_lastdemuxprobe,
+  _X_ARG_novideo,
+  _X_ARG_noaudio,
+  _X_ARG_nospu,
+  _X_ARG_nocache,
+  _X_ARG_volume,
+  _X_ARG_compression,
+  _X_ARG_subtitle,
+  _X_ARG_rewind,
+  _X_ARG_LAST
+} _xine_arg_type_t;
+
+typedef struct {
+  _xine_arg_type_t type;
+  uint8_t *key, *value;
+} _xine_arg_t;
+
+typedef struct {
+  _xine_arg_t *args;
+  uint32_t used, have;
+  uint32_t known[_X_ARG_LAST];
+} _xine_args_t;
+
+static const struct {
+  _xine_arg_type_t type;
+  const char *name;
+} _xine_arg_keys[] = { /* sort please */
+  {_X_ARG_compression,    "compression"},
+  {_X_ARG_demux,          "demux"},
+  {_X_ARG_lastdemuxprobe, "lastdemuxprobe"},
+  {_X_ARG_noaudio,        "noaudio"},
+  {_X_ARG_nocache,        "nocache"},
+  {_X_ARG_nospu,          "nospu"},
+  {_X_ARG_novideo,        "novideo"},
+  {_X_ARG_rewind,         "rewind"},
+  {_X_ARG_save,           "save"},
+  {_X_ARG_subtitle,       "subtitle"},
+  {_X_ARG_volume,         "volume"}
+};
+
+static void _xine_parse_args (_xine_args_t *args, uint8_t *s) {
+  args->args = NULL;
+  args->used = 0;
+  args->have = 0;
+  {
+    uint32_t l;
+
+    for (l = 0; l < sizeof (args->known) / sizeof (args->known[0]); l++)
+      args->known[l] = ~0u;
+  }
+
+  if (s && s[0]) {
+    args->used = 0;
+    args->have = 32;
+    args->args = malloc (args->have * sizeof (args->args[0]));
+    if (!args->args)
+      return;
+
+    /* Turn "WhatAGreat:Bullshit[;]" into lowkey="whatagreat" key="WhatAGreat" value="Bullshit". */
+    while (*s) {
+      _xine_arg_t *arg;
+      uint8_t *p;
+      uint32_t n;
+
+      while (*s == ';')
+        s++;
+
+      if (args->used >= args->have) {
+        arg = realloc (args->args, (args->have + 32) * sizeof (*arg));
+        if (!arg)
+          return;
+        args->args = arg;
+        args->have += 32;
+      }
+      arg = args->args + args->used;
+
+      arg->type = _X_ARG_CONFIG;
+      arg->key = p = s;
+      arg->value = NULL;
+      while (!(tab_parse[*s] & 0x19))
+        s++;
+      n = s - p;
+      if ((n > 0) && (n < 80)) {
+        uint8_t lowkey[80], *q = lowkey;
+        uint32_t b, m, e;
+        s = p;
+        while (n--)
+          *q++ = tab_tolower[*s++];
+        *q = 0;
+        b = 0;
+        e = sizeof (_xine_arg_keys) / sizeof (_xine_arg_keys[0]);
+        do {
+          int d;
+          m = (b + e) >> 1;
+          d = strcmp ((const char *)lowkey, (const char *)_xine_arg_keys[m].name);
+          if (d < 0) {
+            e = m;
+          } else if (d > 0) {
+            b = m + 1;
+          } else {
+            arg->type = _xine_arg_keys[m].type;
+            args->known[arg->type] = args->used;
+            break;
+          }
+        } while (b != e);
+      }
+      if (*s == ':') {
+        *s++ = 0;
+        arg->value = s;
+        while (!(tab_parse[*s] & 0x11))
+          s++;
+      }
+
+      if (!*s) {
+        if (*p) /* skip empty keys */
+          args->used += 1;
+        break;
+      }
+      *s++ = 0;
+      if (*p) /* skip empty keys */
+        args->used += 1;
+    }
+  }
+}
+
+static void _xine_free_args (_xine_args_t *args) {
+  _x_freep (&args->args);
+  args->used = 0;
+  args->have = 0;
+}
+
 /* aka "does path have a protocol prefix" */
 static inline int _x_path_looks_like_mrl (const char *path) {
   const uint8_t *p = (const uint8_t *)path;
@@ -1526,27 +1681,30 @@
   return (p[-1] == ':') && (p[0] == '/');
 }
 
-static int open_internal (xine_stream_private_t *stream, const char *mrl) {
-
-  static const uint8_t tab_tolower[256] = {
-      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
-     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-    ' ','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/',
-    '0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?',
-    '@','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',
-    'p','q','r','s','t','u','v','w','x','y','z','[','\\',']','^','_',
-    '`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',
-    'p','q','r','s','t','u','v','w','x','y','z','{','|','}','~',127,
-    128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
-    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
-    160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
-    176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
-    192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
-    208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
-    224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
-    240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
-  };
+static int _xine_str2secs (const uint8_t *s) {
+  uint32_t v = 0, minus = 0;
+  if (!s)
+    return 0;
+  while (*s == '-')
+    minus ^= 1, s++;
+  while (*s == '+')
+    s++;
+  while (1) {
+    uint32_t part = 0;
+    uint8_t z;
+    while ((z = *s ^ '0') < 10u)
+      part = part * 10u + z, s++;
+    v += part;
+    if (*s != ':')
+      break;
+    s++;
+    v *= 60;
+  }
+  return minus ? -(int)v : (int)v;
+}
 
+static int open_internal (xine_stream_private_t *stream, const char *mrl, input_plugin_t *input) {
+  _xine_args_t _args;
   uint8_t *buf, *name, *args;
   int no_cache = 0;
 
@@ -1612,13 +1770,17 @@
       if (args) args[-1] = 0;
     }
   }
+  _xine_parse_args (&_args, args);
     
-  {
+  if (!input) {
     /*
      * find an input plugin
      */
     stream->s.input_plugin = _x_find_input_plugin (&stream->s, (const char *)name);
-
+  } else {
+    stream->s.input_plugin = input;
+  }
+  {
     if (stream->s.input_plugin) {
       int res;
       input_class_t *input_class = stream->s.input_plugin->input_class;
@@ -1631,6 +1793,16 @@
       _x_meta_info_set_utf8 (&stream->s, XINE_META_INFO_INPUT_PLUGIN,
         stream->s.input_plugin->input_class->identifier);
 
+      if (_args.known[_X_ARG_rewind] != ~0u) {
+        int secs = _xine_str2secs (_args.args[_args.known[_X_ARG_rewind]].value);
+        if (secs < 0) {
+          xprintf (stream->s.xine, XINE_VERBOSITY_LOG,
+            "xine: cant rewind %d seconds into the future, ignoring.\n", -secs);
+        } else {
+          stream->s.input_plugin->get_optional_data (stream->s.input_plugin, &secs, INPUT_OPTIONAL_DATA_REWIND);
+        }
+      }
+
       res = (stream->s.input_plugin->open) (stream->s.input_plugin);
       switch(res) {
       case 1: /* Open successfull */
@@ -1658,189 +1830,168 @@
   }
 
   if (args) {
-    uint8_t *entry = NULL;
+    uint32_t u;
 
-    while (*args) {
-      /* Turn "WhatAGreat:Bullshit[;]" into key="whatagreat" entry="WhatAGreat" value="Bullshit". */
-      uint8_t *key = buf, *value = NULL;
-      if (entry)
-        xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: no value for \"%s\", ignoring.\n"), entry);
-      entry = args;
-      {
-        uint8_t *spos = args + 31, sval = *spos, *q = key, z;
-        *spos = 0;
-        while (!(tab_parse[z = *args] & 0x19)) *q++ = tab_tolower[z], args++;
-        *q = 0;
-        *spos = sval;
-        while (!(tab_parse[z = *args] & 0x19)) args++;
-        if (z == ':') {
-          *args++ = 0;
-          value = args;
-          while (!(tab_parse[z = *args] & 0x11)) args++;
-        }
-        if (z == ';')
-          *args++ = 0;
-      }
+    for (u = 0; u < _args.used; u++) {
+      char *key, *value;
+      _xine_arg_type_t type;
+
+      key = (char *)_args.args[u].key;
+      value = (char *)_args.args[u].value;
+      type = _args.args[u].type;
+
+      switch (type) {
+
+        case _X_ARG_demux:
+          if (value) {
+            /* demuxer specified by name */
+            _x_mrl_unescape (value);
+            if (!(stream->demux.plugin = _x_find_demux_plugin_by_name (&stream->s, value, stream->s.input_plugin))) {
+              xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: specified demuxer %s failed to start\n"), value);
+              stream->err = XINE_ERROR_NO_DEMUX_PLUGIN;
+              stream->status = XINE_STATUS_IDLE;
+              _xine_free_args (&_args);
+              free (buf);
+              return 0;
+            }
+            _x_meta_info_set_utf8 (&stream->s, XINE_META_INFO_SYSTEMLAYER,
+              stream->demux.plugin->demux_class->identifier);
+            key = NULL;
+          }
+          break;
 
-      if (!memcmp (key, "demux", 6)) {
-        if (value) {
-          /* demuxer specified by name */
-          char *demux_name = (char *)value;
-          _x_mrl_unescape (demux_name);
-	  if (!(stream->demux.plugin = _x_find_demux_plugin_by_name (&stream->s, demux_name, stream->s.input_plugin))) {
-	    xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: specified demuxer %s failed to start\n"), demux_name);
-	    stream->err = XINE_ERROR_NO_DEMUX_PLUGIN;
-	    stream->status = XINE_STATUS_IDLE;
-            free (buf);
-	    return 0;
-	  }
-
-          _x_meta_info_set_utf8 (&stream->s, XINE_META_INFO_SYSTEMLAYER,
-            stream->demux.plugin->demux_class->identifier);
-          entry = NULL;
-        }
-	continue;
-      }
+        case _X_ARG_save:
+          if (value) {
+            /* filename to save */
+            input_plugin_t *input_saver;
+
+            _x_mrl_unescape (value);
+            xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: join rip input plugin\n"));
+            input_saver = _x_rip_plugin_get_instance (&stream->s, value);
+            if (input_saver) {
+              stream->s.input_plugin = input_saver;
+            } else {
+              xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("xine: error opening rip input plugin instance\n"));
+              stream->err = XINE_ERROR_MALFORMED_MRL;
+              stream->status = XINE_STATUS_IDLE;
+              _xine_free_args (&_args);
+              free (buf);
+              return 0;
+            }
+            key = NULL;
+          }
+          break;
 
-      if (!memcmp (key, "save", 5)) {
-        if (value) {
-          /* filename to save */
-          char *filename = (char *)value;
-	  input_plugin_t *input_saver;
-
-          _x_mrl_unescape (filename);
-
-	  xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: join rip input plugin\n"));
-          input_saver = _x_rip_plugin_get_instance (&stream->s, filename);
-
-	  if( input_saver ) {
-            stream->s.input_plugin = input_saver;
-	  } else {
-            xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("xine: error opening rip input plugin instance\n"));
-	    stream->err = XINE_ERROR_MALFORMED_MRL;
-	    stream->status = XINE_STATUS_IDLE;
-            free (buf);
-	    return 0;
-	  }
-          entry = NULL;
-        }
-	continue;
-      }
+        case _X_ARG_lastdemuxprobe:
+          if (value) {
+            /* all demuxers will be probed before the specified one */
+            _x_mrl_unescape (value);
+            if (!(stream->demux.plugin = _x_find_demux_plugin_last_probe (&stream->s, value, stream->s.input_plugin))) {
+              xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: last_probed demuxer %s failed to start\n"), value);
+              stream->err = XINE_ERROR_NO_DEMUX_PLUGIN;
+              stream->status = XINE_STATUS_IDLE;
+              _xine_free_args (&_args);
+              free (buf);
+              return 0;
+            }
+            lprintf ("demux and input plugin found\n");
+            _x_meta_info_set_utf8 (&stream->s, XINE_META_INFO_SYSTEMLAYER,
+              stream->demux.plugin->demux_class->identifier);
+            key = NULL;
+          }
+          break;
 
-      if (!memcmp (key, "lastdemuxprobe", 15)) {
-        if (value) {
-          /* all demuxers will be probed before the specified one */
-          char *demux_name = (char *)value;
-          _x_mrl_unescape (demux_name);
-	  if (!(stream->demux.plugin = _x_find_demux_plugin_last_probe (&stream->s, demux_name, stream->s.input_plugin))) {
-            xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: last_probed demuxer %s failed to start\n"), demux_name);
-	    stream->err = XINE_ERROR_NO_DEMUX_PLUGIN;
-	    stream->status = XINE_STATUS_IDLE;
-            free (buf);
-	    return 0;
-	  }
-	  lprintf ("demux and input plugin found\n");
-
-          _x_meta_info_set_utf8 (&stream->s, XINE_META_INFO_SYSTEMLAYER,
-            stream->demux.plugin->demux_class->identifier);
-          entry = NULL;
-        }
-	continue;
-      }
+        case _X_ARG_novideo:
+          _x_stream_info_set (&stream->s, XINE_STREAM_INFO_IGNORE_VIDEO, 1);
+          xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("ignoring video\n"));
+          key = NULL;
+          break;
 
-      if (!memcmp (key, "novideo", 8)) {
-        _x_stream_info_set (&stream->s, XINE_STREAM_INFO_IGNORE_VIDEO, 1);
-        xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("ignoring video\n"));
-        entry = NULL;
-	continue;
-      }
+        case _X_ARG_noaudio:
+          _x_stream_info_set (&stream->s, XINE_STREAM_INFO_IGNORE_AUDIO, 1);
+          xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("ignoring audio\n"));
+          key = NULL;
+          break;
 
-      if (!memcmp (key, "noaudio", 8)) {
-        _x_stream_info_set (&stream->s, XINE_STREAM_INFO_IGNORE_AUDIO, 1);
-        xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("ignoring audio\n"));
-        entry = NULL;
-	continue;
-      }
+        case _X_ARG_nospu:
+          _x_stream_info_set (&stream->s, XINE_STREAM_INFO_IGNORE_SPU, 1);
+          xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("ignoring subpicture\n"));
+          key = NULL;
+          break;
 
-      if (!memcmp (key, "nospu", 6)) {
-        _x_stream_info_set (&stream->s, XINE_STREAM_INFO_IGNORE_SPU, 1);
-        xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("ignoring subpicture\n"));
-        entry = NULL;
-	continue;
-      }
+        case _X_ARG_nocache:
+          no_cache = 1;
+          xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("input cache plugin disabled\n"));
+          key = NULL;
+          break;
 
-      if (!memcmp (key, "nocache", 8)) {
-        no_cache = 1;
-        xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("input cache plugin disabled\n"));
-        entry = NULL;
-	continue;
-      }
+        case _X_ARG_volume:
+          if (value) {
+            _x_mrl_unescape (value);
+            xine_set_param (&stream->s, XINE_PARAM_AUDIO_VOLUME, atoi (value));
+            key = NULL;
+          }
+          break;
 
-      if (!memcmp (key, "volume", 7)) {
-        if (value) {
-          char *volume = (char *)value;
-          _x_mrl_unescape (volume);
-          xine_set_param (&stream->s, XINE_PARAM_AUDIO_VOLUME, atoi (volume));
-          entry = NULL;
-        }
-	continue;
-      }
+        case _X_ARG_compression:
+          if (value) {
+            _x_mrl_unescape (value);
+            xine_set_param (&stream->s, XINE_PARAM_AUDIO_COMPR_LEVEL, atoi (value));
+            key = NULL;
+          }
+          break;
 
-      if (!memcmp (key, "compression", 12)) {
-        if (value) {
-          char *compression = (char *)value;
-          _x_mrl_unescape (compression);
-          xine_set_param (&stream->s, XINE_PARAM_AUDIO_COMPR_LEVEL, atoi (compression));
-          entry = NULL;
-        }
-	continue;
-      }
+        case _X_ARG_subtitle:
+          if (value) {
+            /* unescape for xine_open() if the MRL looks like a raw pathname */
+            if (!_x_path_looks_like_mrl (value))
+              _x_mrl_unescape (value);
+            stream->s.slave = xine_stream_new (stream->s.xine, NULL, stream->s.video_out);
+            stream->slave_affection = XINE_MASTER_SLAVE_PLAY | XINE_MASTER_SLAVE_STOP;
+            if (xine_open (stream->s.slave, value)) {
+              xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("subtitle mrl opened '%s'\n"), value);
+              stream->s.slave->master = &stream->s;
+              stream->slave_is_subtitle = 1;
+            } else {
+              xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("xine: error opening subtitle mrl\n"));
+              xine_dispose (stream->s.slave);
+              stream->s.slave = NULL;
+            }
+            key = NULL;
+          }
+          break;
 
-      if (!memcmp (key, "subtitle", 9)) {
-        if (value) {
-          char *subtitle_mrl = (char *)value;
-	  /* unescape for xine_open() if the MRL looks like a raw pathname */
-	  if (!_x_path_looks_like_mrl(subtitle_mrl))
-	    _x_mrl_unescape(subtitle_mrl);
-          stream->s.slave = xine_stream_new (stream->s.xine, NULL, stream->s.video_out);
-	  stream->slave_affection = XINE_MASTER_SLAVE_PLAY | XINE_MASTER_SLAVE_STOP;
-          if (xine_open (stream->s.slave, subtitle_mrl)) {
-            xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("subtitle mrl opened '%s'\n"), subtitle_mrl);
-            stream->s.slave->master = &stream->s;
-	    stream->slave_is_subtitle = 1;
-	  } else {
-            xprintf (stream->s.xine, XINE_VERBOSITY_LOG, _("xine: error opening subtitle mrl\n"));
-            xine_dispose (stream->s.slave);
-            stream->s.slave = NULL;
-	  }
-          entry = NULL;
-        }
-	continue;
-      }
+        case _X_ARG_CONFIG:
+          if (value) {
+            /* when we got here, the stream setup parameter must be a config entry */
+            int retval;
+            value[-1] = ':';
+            _x_mrl_unescape (key);
+            retval = _x_config_change_opt (stream->s.xine->config, key);
+            if (retval <= 0) {
+              value[-1] = 0;
+              if (retval == 0) {
+                /* the option not found */
+                xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: unknown config option \"%s\", ignoring.\n"), key);
+              } else {
+                /* not permitted to change from MRL */
+                xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: changing option '%s' from MRL isn't permitted\n"), key);
+              }
+            }
+            key = NULL;
+          }
+          break;
 
-      if (value) {
-        /* when we got here, the stream setup parameter must be a config entry */
-        int retval;
-        value[-1] = ':';
-        _x_mrl_unescape ((char *)entry);
-        retval = _x_config_change_opt (stream->s.xine->config, (char *)entry);
-	if (retval <= 0) {
-          value[-1] = 0;
-	  if (retval == 0) {
-            /* the option not found */
-            xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: unknown config option \"%s\", ignoring.\n"), entry);
-	  } else {
-            /* not permitted to change from MRL */
-            xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: changing option '%s' from MRL isn't permitted\n"), entry);
-	  }
-	}
-        entry = NULL;
+        default:
+          key = NULL;
       }
+
+      if (key)
+        xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: no value for \"%s\", ignoring.\n"), key);
     }
-    if (entry)
-      xine_log (stream->s.xine, XINE_LOG_MSG, _("xine: no value for \"%s\", ignoring.\n"), entry);
   }
 
+  _xine_free_args (&_args);
   free (buf);
 
   /* Nasty xine-ui issue:
@@ -1970,15 +2121,16 @@
   xine_stream_private_t *stream = (xine_stream_private_t *)s;
   xine_private_t *xine = (xine_private_t *)stream->s.xine;
   pthread_mutex_t *frontend_lock = &stream->side_streams[0]->frontend_lock;
-  int ret;
+  int ret, sn;
 
   pthread_mutex_lock (frontend_lock);
   pthread_cleanup_push (mutex_cleanup, (void *) frontend_lock);
 
   lprintf ("open MRL:%s\n", mrl);
 
-  ret = open_internal (stream, mrl);
+  ret = open_internal (stream, mrl, NULL);
 
+  sn = 0;
   if (xine->join_av && mrl && (stream->side_streams[0] == stream)) do {
     char nbuf[1024];
     struct stat st;
@@ -2027,7 +2179,41 @@
       break;
     xprintf (&xine->x, XINE_VERBOSITY_DEBUG,
       "xine_open: auto joining \"%s\" with \"%s\".\n", orig, nbuf);
-    open_internal (side, nbuf);
+    open_internal (side, nbuf, NULL);
+    sn = 1;
+  } while (0);
+
+  if (!sn && mrl && (stream->side_streams[0] == stream)) do {
+    input_plugin_t *main_input = stream->s.input_plugin;
+
+    if (!main_input)
+      break;
+    for (sn = 1; sn < (int)(sizeof (stream->side_streams) / sizeof (stream->side_streams[0])); sn++) {
+      xine_stream_private_t *side;
+      union {
+        int index;
+        input_plugin_t *input;
+      } si;
+
+      si.index = sn;
+      if (main_input->get_optional_data (main_input, &si, INPUT_OPTIONAL_DATA_SIDE) != INPUT_OPTIONAL_SUCCESS)
+        break;
+      /* load_plugins.c please keep calm ;-) */
+      if (si.input->node) {
+        pthread_mutex_lock (&stream->s.xine->plugin_catalog->lock);
+        si.input->node->ref += 1;
+        pthread_mutex_unlock (&stream->s.xine->plugin_catalog->lock);
+      }
+      side = (xine_stream_private_t *)xine_get_side_stream (&stream->s, sn);
+      if (!side) {
+        _x_free_input_plugin (&stream->s, si.input);
+        break;
+      }
+      xprintf (&xine->x, XINE_VERBOSITY_DEBUG,
+        "xine_open: adding side stream #%d (%p).\n", sn, (void *)side);
+      open_internal (side, mrl, si.input);
+    }
+    sn--;
   } while (0);
 
   pthread_cleanup_pop (0);
@@ -2105,12 +2291,22 @@
   do {
     pthread_mutex_lock (&sp->s->demux.action_lock);
     sp->s->demux.action_pending += 0x10001;
-    if (!(sp->s->demux.input_caps & (INPUT_CAP_SEEKABLE | INPUT_CAP_SLOW_SEEKABLE)))
+    if (!(sp->s->demux.input_caps & (INPUT_CAP_SEEKABLE | INPUT_CAP_SLOW_SEEKABLE | INPUT_CAP_TIME_SEEKABLE)))
       input_is_seekable = 0;
     pthread_mutex_unlock (&sp->s->demux.action_lock);
     sp++;
   } while (sp->s);
 
+  if (input_is_seekable != stream->seekable) {
+    static const char * const fbc_mode[4] = {"off", "a", "v", "av"};
+    int on;
+    stream->seekable = input_is_seekable;
+    on = (xine_fbc_set (stream->s.audio_fifo, input_is_seekable) ? 1 : 0)
+       | (xine_fbc_set (stream->s.audio_fifo, input_is_seekable) ? 2 : 0);
+    xprintf (stream->s.xine, XINE_VERBOSITY_DEBUG,
+        "file_buf_ctrl: %s.\n", fbc_mode[on]);
+  }
+
   /* WTF??
    * TJ. OK these calls involve lock/unlock of the fifo mutexes.
    * Demux will do that again later by fifo->put ().
diff -urN xine-lib-1.2.11/src/xine-engine/xine_interface.c xine-lib-1.2/src/xine-engine/xine_interface.c
--- xine-lib-1.2.11/src/xine-engine/xine_interface.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/xine_interface.c	2022-01-15 22:03:19.642547415 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -506,6 +506,7 @@
   case XINE_PARAM_VO_CROP_RIGHT:
   case XINE_PARAM_VO_CROP_TOP:
   case XINE_PARAM_VO_CROP_BOTTOM:
+  case XINE_PARAM_VO_TRANSFORM:
     xine->port_ticket->acquire (xine->port_ticket, 1);
     stream->s.video_out->set_property (stream->s.video_out, param, value);
     xine->port_ticket->release (xine->port_ticket, 1);
@@ -701,6 +702,7 @@
   case XINE_PARAM_VO_CROP_RIGHT:
   case XINE_PARAM_VO_CROP_TOP:
   case XINE_PARAM_VO_CROP_BOTTOM:
+  case XINE_PARAM_VO_TRANSFORM:
     xine->port_ticket->acquire (xine->port_ticket, 1);
     ret = stream->s.video_out->get_property(stream->s.video_out, param);
     xine->port_ticket->release (xine->port_ticket, 1);
@@ -1032,6 +1034,8 @@
     N_("Audio device unavailable"),
     N_("Permission error"),
     N_("File is empty:"),
+    N_("Authentication needed"),
+    N_("Recording done:")
   };
 
   if (!stream) return 0;
diff -urN xine-lib-1.2.11/src/xine-engine/xine_private.h xine-lib-1.2/src/xine-engine/xine_private.h
--- xine-lib-1.2.11/src/xine-engine/xine_private.h	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-engine/xine_private.h	2022-01-15 22:03:19.620547323 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2020 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -636,6 +636,9 @@
 
   uint32_t                   disable_decoder_flush_at_discontinuity;
 
+  /* all input is... */
+  uint32_t                   seekable;
+
   /* _x_find_input_plugin () recursion protection */
   input_class_t             *query_input_plugins[2];
 
@@ -648,6 +651,11 @@
 #define XINE_NBC_EVENT_AUDIO_DRY 1
 void xine_nbc_event (xine_stream_private_t *stream, uint32_t type) INTERNAL;
 
+/* Enable file_buf_ctrl optimizations when there is no net_buf_ctrl.
+ * This is a kludge to detect less compatible plugins like vdr and vdr-xineliboutput.
+ * Return actual state. */
+int xine_fbc_set (fifo_buffer_t *fifo, int on) INTERNAL;
+
 EXTERN_C_STOP
 
 #endif
diff -urN xine-lib-1.2.11/src/xine-utils/cpu_accel.c xine-lib-1.2/src/xine-utils/cpu_accel.c
--- xine-lib-1.2.11/src/xine-utils/cpu_accel.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-utils/cpu_accel.c	2022-01-15 22:03:19.617547310 +0100
@@ -453,6 +453,13 @@
   if (!sched_getaffinity(0, sizeof(cpuset), &cpuset))
     cpu_count = CPU_COUNT(&cpuset);
 
+#elif defined(HAVE_SYSCTL) && defined(HW_NCPUONLINE)
+
+  int mib[2] = { CTL_HW, HW_NCPUONLINE };
+  size_t len = sizeof(cpu_count);
+  if (sysctl(mib, 2, &cpu_count, &len, NULL, 0) == -1)
+    cpu_count = 1;
+
 #elif defined(HAVE_SYSCTL) && defined(HW_NCPU)
 
   int mib[2] = { CTL_HW, HW_NCPU };
diff -urN xine-lib-1.2.11/src/xine-utils/Makefile.am xine-lib-1.2/src/xine-utils/Makefile.am
--- xine-lib-1.2.11/src/xine-utils/Makefile.am	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-utils/Makefile.am	2022-01-15 22:03:19.612547289 +0100
@@ -22,22 +22,24 @@
 YUV_LIB = libyuv2rgb.la
 
 libxineutils_la_SOURCES = $(pppc_files) \
+	array.c \
 	cpu_accel.c \
 	color.c \
 	copy.c \
 	list.c \
 	memcpy.c \
+	mfrag.c \
 	monitor.c \
+	pool.c \
+	ring_buffer.c \
+	sorted_array.c \
+	stree.c \
 	utils.c \
+	xine_buffer.c \
 	xine_check.c \
 	xine_mutex.c \
 	xmllexer.c \
-	xine_buffer.c \
-	xmlparser.c \
-	array.c \
-	sorted_array.c \
-	pool.c \
-	ring_buffer.c
+	xmlparser.c
 
 libxineutils_la_LIBADD = $(DYNAMIC_LD_LIBS) $(YUV_LIB)
 
diff -urN xine-lib-1.2.11/src/xine-utils/mfrag.c xine-lib-1.2/src/xine-utils/mfrag.c
--- xine-lib-1.2.11/src/xine-utils/mfrag.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/xine-utils/mfrag.c	2022-01-15 22:03:19.603547251 +0100
@@ -0,0 +1,312 @@
+/*
+ * Copyright (C) 2021 the xine project
+ * Copyright (C) 2021 Torsten Jager <t.jager@gmx.de>
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Xine media fragment list utility.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#define LOG_MODULE "mfrag"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+
+#include <xine/mfrag.h>
+
+#define MFRAG_STEP 256
+
+typedef struct {
+  int64_t t, p;  /** << start time, byte pos */
+  uint32_t d, l; /** << duration or 0, byte length or 0 if unknoen */
+} xine_mfrag_frag_t;
+
+struct xine_mfrag_list_s {
+  xine_mfrag_frag_t *frags;
+  uint32_t refs;
+  uint32_t have, used, known_nd, known_nl; /** << fragment counts */
+  uint32_t dirty_from; /** << rebuild start times/byte pos from here when needed */
+  uint32_t avg_d, avg_l;
+  uint64_t known_d; /** << time sum */
+  uint64_t known_l; /** << byte length sum */
+};
+
+static void _xine_mfrag_fix (xine_mfrag_list_t *list, uint32_t last) {
+  /** rebuild on demand only, for speed, and forward only, to avoid mass confusion. */
+  xine_mfrag_frag_t *frag, *end;
+  uint64_t t, p;
+  list->avg_d = list->known_nd ? list->known_d / list->known_nd : 0;
+  list->avg_l = list->known_nl ? list->known_l / list->known_nl : 0;
+  frag = list->frags + list->dirty_from;
+  end = list->frags + last;
+  if (frag == list->frags) {
+    frag[0].t = frag[1].t = 0;
+    frag[0].p = 0;
+    frag[1].p = frag[0].l;
+    frag += 1;
+  }
+  t = frag[0].t;
+  p = frag[0].p;
+  while (frag < end) {
+    t += frag[0].d ? frag[0].d : list->avg_d;
+    frag[1].t = t;
+    p += frag[0].l ? frag[0].l : list->avg_l;
+    frag[1].p = p;
+    frag += 1;
+  }
+  list->dirty_from = last;
+}
+
+static void _xine_mfrag_test (xine_mfrag_list_t *list, uint32_t last) {
+  if (list->dirty_from < last)
+    _xine_mfrag_fix (list, last);
+}
+
+void xine_mfrag_list_open (xine_mfrag_list_t **plist) {
+  xine_mfrag_list_t *list;
+  xine_mfrag_frag_t *frag;
+
+  if (!plist)
+    return;
+  list = *plist;
+  if (list) {
+    list->refs++;
+    return;
+  }
+  list = malloc (sizeof (*list));
+  if (!list)
+    return;
+
+  list->refs = 1;
+  list->have = MFRAG_STEP - 2;
+  list->used = list->known_nd = list->known_nl = 0;
+  list->dirty_from = 0;
+  list->avg_d = list->avg_l = 0;
+  list->known_d = list->known_l = 0;
+
+  frag = malloc ((list->have + 2) * sizeof (*frag));
+  if (!frag) {
+    free (list);
+    return;
+  }
+  list->frags = frag;
+  frag[0].d = 1;
+  frag[0].l = 0;
+  frag[0].t = frag[0].p = 0;
+  frag[1].d = frag[1].l = 0;
+
+  *plist = list;
+}
+
+int xine_mfrag_set_index_frag (xine_mfrag_list_t *list, xine_mfrag_index_t index, int64_t dur, off_t len) {
+  xine_mfrag_frag_t *frag;
+  uint32_t idx;
+
+  if (!list)
+    return 0;
+  if (index < 0)
+    return 0;
+
+  if (index == 0) {
+    if (dur >= 0)
+      list->frags[0].d = dur;
+    if ((len >= 0) && ((uint32_t)len != list->frags[0].l)) {
+      list->frags[0].l = len;
+      list->dirty_from = 0;
+    }
+    return 1;
+  }
+
+  idx = index;
+  if (idx > list->used + 1)
+    return 0;
+
+  if (idx == list->used + 1) {
+    if (list->used >= list->have) {
+      frag = realloc (list->frags, (list->have + 2 + MFRAG_STEP) * sizeof (*frag));
+      if (!frag)
+        return 0;
+      list->frags = frag;
+      list->have += MFRAG_STEP;
+    }
+    list->used += 1;
+    if (idx < list->dirty_from)
+      list->dirty_from = idx;
+    frag = list->frags + idx;
+    if (dur >= 0) {
+      frag[0].d = dur;
+      list->known_d += dur;
+      list->known_nd += 1;
+    } else {
+      frag[0].d = 0;
+    }
+    if (len >= 0) {
+      frag[0].l = len;
+      list->known_l += len;
+      list->known_nl += 1;
+    } else {
+      frag[0].l = 0;
+    }
+    frag[1].d = frag[1].l = 0;
+    return 1;
+  }
+
+  frag = list->frags + idx;
+  if ((dur >= 0) && ((uint32_t)dur != frag[0].d)) {
+    if (!frag[0].d) {
+      list->known_nd += 1;
+      list->known_d += dur;
+    } else if ((uint32_t)dur == 0) {
+      list->known_nd -= 1;
+      list->known_d -= frag[0].d;
+    } else {
+      list->known_d -= frag[0].d;
+      list->known_d += dur;
+    }
+    frag[0].d = dur;
+    if (idx < list->dirty_from)
+      list->dirty_from = idx;
+  }
+  if ((len >= 0) && ((uint32_t)len != frag[0].l)) {
+    if (!frag[0].l) {
+      list->known_nl += 1;
+      list->known_l += len;
+    } else if ((uint32_t)len == 0) {
+      list->known_nl -= 1;
+      list->known_l -= frag[0].l;
+    } else {
+      list->known_l -= frag[0].l;
+      list->known_l += len;
+    }
+    frag[0].l = len;
+    if (idx < list->dirty_from)
+      list->dirty_from = idx;
+  }
+  return 1;
+}
+
+int32_t xine_mfrag_get_frag_count (xine_mfrag_list_t *list) {
+  if (!list)
+    return 0;
+  return list->used;
+}
+
+xine_mfrag_index_t xine_mfrag_find_time (xine_mfrag_list_t *list, int64_t timepos) {
+  uint32_t b, m, l, e;
+
+  if (!list)
+    return -1;
+
+  _xine_mfrag_test (list, list->used + 1);
+  b = l = 1;
+  e = list->used + 2;
+  m = (b + e) >> 1;
+  while (m != l) {
+    int64_t d = timepos - list->frags[m].t;
+    if (d < 0)
+      e = m;
+    else
+      b = m;
+    l = m;
+    m = (b + e) >> 1;
+  }
+  return b;
+}
+
+xine_mfrag_index_t xine_mfrag_find_pos (xine_mfrag_list_t *list, off_t offs) {
+  uint32_t b, l, m, e;
+
+  if (!list)
+    return -1;
+
+  _xine_mfrag_test (list, list->used + 1);
+  b = l = list->frags[0].l ? 0 : 1;
+  e = list->used + 2;
+  m = (b + e) >> 1;
+  while (m != l) {
+    int64_t d = offs - list->frags[m].p;
+    if (d < 0)
+      e = m;
+    else
+      b = m;
+    l = m;
+    m = (b + e) >> 1;
+  }
+  return b;
+}
+
+int xine_mfrag_get_index_frag (xine_mfrag_list_t *list, xine_mfrag_index_t index, int64_t *dur, off_t *len) {
+  xine_mfrag_frag_t *frag;
+  uint32_t idx;
+
+  if (!list)
+    return 0;
+  if (index < 0)
+    return 0;
+  idx = index;
+  if (idx > list->have)
+    return 0;
+  frag = list->frags + idx;
+  if (dur)
+    *dur = frag[0].d;
+  if (len)
+    *len = frag[0].l;
+  return 1;
+}
+
+int xine_mfrag_get_index_start (xine_mfrag_list_t *list, xine_mfrag_index_t index, int64_t *timepos, off_t *offs) {
+  xine_mfrag_frag_t *frag;
+  uint32_t idx;
+
+  if (!list)
+    return 0;
+  if (!list->frags || (index < 0))
+    return 0;
+  idx = index;
+  if (idx > list->have + 1)
+    return 0;
+  _xine_mfrag_test (list, idx);
+  frag = list->frags + idx;
+  if (timepos)
+    *timepos = frag[0].t;
+  if (offs)
+    *offs = frag[0].p;
+  return 1;
+}
+  
+void xine_mfrag_list_close (xine_mfrag_list_t **plist) {
+  if (plist && *plist) {
+    xine_mfrag_list_t *list = *plist;
+    if (--list->refs == 0) {
+      free (list->frags);
+      list->frags = NULL;
+      free (list);
+      *plist = NULL;
+    }
+  }
+}
+
diff -urN xine-lib-1.2.11/src/xine-utils/stree.c xine-lib-1.2/src/xine-utils/stree.c
--- xine-lib-1.2.11/src/xine-utils/stree.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2/src/xine-utils/stree.c	2022-01-15 22:03:19.604547255 +0100
@@ -0,0 +1,1014 @@
+/*
+ * Copyright (C) 2021 the xine project
+ * Copyright (C) 2021 Torsten Jager <t.jager@gmx.de>
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Xine string tree library.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef TEST_THIS_FILE
+#  include "../../include/xine/stree.h"
+#else
+#  include <xine/stree.h>
+#endif
+
+/* 128: not a hex digit, 64: value separator, 32: -x placeholder */
+static const uint8_t _tab_unhex[256] = {
+  128,128,128,128,128,128,128,128,128,192,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  192,128,128,128,128,128,128,128,128,128,128,128,128,192,128,128,
+    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,192,128,128,128,128,128,
+  128, 10, 11, 12, 13, 14, 15,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128, 10, 11, 12, 13, 14, 15,161,162,163,164,165,166,167,168,169,
+  170,171,172,173,174,175,176,177,178,179,180,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128
+};
+
+size_t xine_string_unpercent (char *s) {
+  const uint8_t *p = (const uint8_t *)s;
+  uint8_t *q, v;
+
+  /* optimization: skip identical write */
+  while (*p && (*p != '%'))
+    p++;
+  q = (uint8_t *)s + (p - (const uint8_t *)s);
+
+  while ((v = *p)) {
+    p++;
+    if (v == '%') do {
+      uint8_t z;
+
+      z = _tab_unhex[*p];
+      if (z & 128)
+        break;
+      v = z;
+      p++;
+      z = _tab_unhex[*p];
+      if (z & 128)
+        break;
+      v = (v << 4) | z;
+      p++;
+    } while (0);
+    *q++ = v;
+  }
+  *q = 0;
+  return q - (uint8_t *)s;
+}
+
+size_t xine_string_unbackslash (char *s) {
+  static const uint8_t _tab_unbackslash[128] = {
+      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+    ' ','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/',
+    128,129,130,131,132,133,134,135,'8','9',':',';','<','=','>','?',
+    '@',  7,  8,194,'D', 27, 12,'G','H','I','J','K','L','M', 10,'O',
+    'P','Q', 13,'S',  9,193, 11,'W',192,'Y','Z','[','\\',']','^','_',
+    '`',  7,  8,194,'d', 27, 12,'g','h','i','j','k','l','m', 10,'o',
+    'p','q', 13,'s',  9,193, 11,'w',192,'y','z','{','|','}','~',127
+  };
+  const uint8_t *p = (const uint8_t *)s;
+  uint8_t *q, z;
+
+  while (*p && (*p != '\\'))
+    p++;
+  q = (uint8_t *)s + (p - (const uint8_t *)s);
+
+  while ((z = *p)) {
+    p++;
+    do {
+      if (z != '\\')
+        break;
+      z = *p;
+      if (!z)
+        break;
+      p++;
+      if (z & 128)
+        break;
+      z = _tab_unbackslash[z];
+      if (!(z & 128))
+        break;
+      if (!(z & 0x78)) { /* oktal */
+        uint8_t d;
+        z &= 7;
+        d = *p ^ '0';
+        if (d & 0xf8)
+          break;
+        z = (z << 3) | d;
+        p++;
+        d = *p ^ '0';
+        if (d & 0xf8)
+          break;
+        z = (z << 3) | d;
+        p++;
+        break;
+      }
+      if (z == 192) { /* x */
+        uint8_t v;
+        z = p[-1];
+        v = _tab_unhex[*p];
+        if (v & 128)
+          break;
+        z = v;
+        p++;
+        v = _tab_unhex[*p];
+        if (v & 128)
+          break;
+        z = (z << 4) | v;
+        p++;
+        break;
+      }
+      if (z == 193) { /* u */
+        uint32_t x = p[-1];
+        do {
+          z = _tab_unhex[*p];
+          if (z & 128)
+            break;
+          x = z;
+          p++;
+          z = _tab_unhex[*p];
+          if (z & 128)
+            break;
+          x = (x << 4) | z;
+          p++;
+          z = _tab_unhex[*p];
+          if (z & 128)
+            break;
+          x = (x << 4) | z;
+          p++;
+          z = _tab_unhex[*p];
+          if (z & 128)
+            break;
+          x = (x << 4) | z;
+          p++;
+        } while (0);
+        z = x;
+        if (x & 0xff80) { /* utf8 */
+          if (x & 0xf800) { /* 1110xxxx 10xxxxxx 10xxxxxx */
+            *q++ = 0xe0 | (x >> 12);
+            *q++ = 0x80 | ((x >> 6) & 0x3f);
+          } else { /* 110xxxxx 10xxxxxx */
+            *q++ = 0xc0 | (x >> 6);
+          }
+          z &= 0x3f;
+          z |= 0x80;
+        }
+        break;
+      }
+      /* (z == 194), c */
+      z = p[0] & 0x1f, p++;
+    } while (0);
+    *q++ = z;
+  }
+  *q = 0;
+  return q - (uint8_t *)s;
+}
+
+size_t xine_string_unampersand (char *s) {
+  static const uint8_t _tab_amp[256] = {
+    ['&'] = 1,
+    [';'] = 2,
+    ['\0'] = 128
+  };
+  uint8_t *p = (uint8_t *)s, *q;
+
+  while (!(_tab_amp[*p] & (1 | 128)))
+    p++;
+  if (!*p)
+    return p - (uint8_t *)s;
+
+  q = p;
+  while (1) {
+    /* *p == '&' */
+    uint8_t *e = p + 1;
+    while (!(_tab_amp[*e] & (2 | 128)))
+      e++;
+    if (!*e)
+      break;
+    *e = 0;
+    p++;
+    if (!strcasecmp ((const char *)p, "amp")) {
+      *q++ = '&';
+      p = e + 1;
+    } else if (!strcasecmp ((const char *)p, "lt")) {
+      *q++ = '<';
+      p = e + 1;
+    } else if (!strcasecmp ((const char *)p, "gt")) {
+      *q++ = '>';
+      p = e + 1;
+    } else if (!strcasecmp ((const char *)p, "quot")) {
+      *q++ = '"';
+      p = e + 1;
+    } else if (*p == '#') {
+      uint32_t v = 0;
+      uint8_t z;
+      p++;
+      if ((*p | 0x20) == 'x') {
+        p++;
+        while (!((z =_tab_unhex[*p]) & 128))
+          v = (v << 4) | z, p++;
+      } else if (*p == '0') {
+        while ((z = *p ^ '0') < 8)
+          v = v * 8u + z, p++;
+      } else {
+        while ((z = *p ^ '0') < 10)
+          v = v * 10u + z, p++;
+      }
+      z = v;
+      if (v & 0xff80) { /* utf8 */
+        if (v & 0xf800) { /* 1110xxxx 10xxxxxx 10xxxxxx */
+          *q++ = 0xe0 | (v >> 12);
+          *q++ = 0x80 | ((v >> 6) & 0x3f);
+        } else { /* 110xxxxx 10xxxxxx */
+          *q++ = 0xc0 | (v >> 6);
+        }
+        z &= 0x3f;
+        z |= 0x80;
+      }
+      *q++ = z;
+      p = e + 1;
+    } else {
+      *q++ = '&';
+      *e = ';';
+    }
+    while (!(_tab_amp[*p] & (1 | 128)))
+      *q++ = *p++;
+    if (!*p)
+      break;
+  }
+  while (*p)
+    *q++ = *p++;
+
+  *q = 0;
+  return q - (uint8_t *)s;
+}
+
+static int _xine_stree_node_new (xine_stree_t **root, uint32_t *have, uint32_t *used, uint32_t parent) {
+  xine_stree_t *p, *n;
+  if (*used >= *have) {
+    xine_stree_t *new = realloc (*root, (*have + 64) * sizeof (**root));
+    if (!new)
+      return 0;
+    *root = new;
+    *have += 64;
+  }
+  p = *root + parent;
+  n = *root + *used;
+  n->key = 0;
+  n->value = 0;
+  n->level = p->level + 1;
+  n->parent = parent;
+  n->next = 0;
+  n->first_child = 0;
+  n->last_child = 0;
+  n->num_children = 0;
+  if (p->last_child) {
+    n->prev = p->last_child;
+    (*root)[p->last_child].next = *used;
+  } else {
+    p->first_child = *used;
+    n->prev = 0;
+  }
+  p->last_child = *used;
+  p->num_children += 1;
+  *used += 1;
+  return *used - 1;
+}
+
+static uint8_t *_xine_stree_get_string (uint8_t **p, uint8_t **q, const uint8_t *tab) {
+  uint8_t *r = *q;
+  if (**p == '\"') {
+    (*p)++;
+    while (!(tab[**p] & (2 | 128))) {
+      while (!(tab[**p] & (2 | 64 | 128)))
+        *(*q)++ = *(*p)++;
+      if (**p == '\\')
+        *(*q)++ = *(*p)++;
+    }
+    if (**p == '\"')
+      (*p)++;
+  } else if (**p == '\'') {
+    (*p)++;
+    while (!(tab[**p] & (4 | 128))) {
+      while (!(tab[**p] & (4 | 64 | 128)))
+        *(*q)++ = *(*p)++;
+      if (**p == '\\')
+        *(*q)++ = *(*p)++;
+    }
+    if (**p == '\'')
+      (*p)++;
+  } else {
+    while (!(tab[**p] & (1 | 8 | 16 | 32 | 128))) {
+      while (!(tab[**p] & (1 | 8 | 16 | 32 | 64 | 128)))
+        *(*q)++ = *(*p)++;
+      if (**p == '\\')
+        *(*q)++ = *(*p)++;
+    }
+  }
+  return r;
+}
+
+static const uint8_t _tab_xml[256] = {
+  ['\r'] = 1,
+  ['\n'] = 1,
+  ['\t'] = 1,
+  [' '] = 1,
+  ['\"'] = 2,
+  ['\''] = 4,
+  ['<'] = 8,
+  ['>'] = 16,
+  ['='] = 32,
+  ['\\'] = 64,
+  [0] = 128
+};
+
+static xine_stree_t *_xine_stree_load_xml (char *buf) {
+  xine_stree_t *root;
+  uint32_t have, used, here, plain;
+  uint8_t *p, *q, *e;
+
+  have = 64;
+  root = (xine_stree_t *)malloc (have * sizeof (*root));
+  if (!root)
+    return NULL;
+
+  here = 0;
+  used = 1;
+  root->next = root->prev = 0;
+  root->first_child = root->last_child = root->parent = 0;
+  root->num_children = root->level = root->index = 0;
+  root->key = root->value = 0;
+
+  plain = ~0u;
+
+  e = p = (uint8_t *)buf;
+  q = (uint8_t *)buf + 1;
+  while (1) {
+    while (_tab_xml[p[0]] & 1)
+      p++;
+    if (!*p)
+      break;
+    if (p[0] == '<') {
+      p++;
+      if (p[0] == '!') { /* <!comment ... /> */
+        p++;
+        if (!strncmp ((const char *)p, "[CDATA[", 7)) {
+          /* CDATA pseudo comment */
+          uint32_t new = _xine_stree_node_new (&root, &have, &used, here);
+          if (!new)
+            return root;
+          p += 7;
+          if (plain == ~0u) {
+            plain = q - (uint8_t *)buf;
+            memcpy (q, "[]", 2);
+            q += 2;
+            *e = 0;
+            e = q++;
+          }
+          root[new].key = plain;
+          root[new].value = q - (uint8_t *)buf;
+          while (1) {
+            while (!(_tab_xml[*p] & (16 | 128)))
+              *q++ = *p++;
+            if (!*p)
+              break;
+            if ((p[-1] == ']') && (p[-2] == ']') && (p[-3] != '\\')) {
+              p++;
+              q -= 2;
+              break;
+            }
+            *q++ = *p++;
+          }
+          *e = 0;
+          e = q++;
+        } else {
+          while (!(_tab_xml[*p] & (16 | 128)))
+            p++;
+          if (*p == '>')
+            p++;
+        }
+      } else if (p[0] == '/') { /* </tag> */
+        uint8_t *v, z;
+        p++;
+        /* defer writing string end until that location is not read any more. */
+        *e = 0;
+        v = _xine_stree_get_string (&p, &q, _tab_xml);
+        e = q++;
+        z = *e;
+        *e = 0;
+        if (*v) { /* _not_ just </> */
+          while (root[here].level) {
+            if (!strcasecmp ((const char *)buf + root[here].key, (const char *)v))
+              break;
+            here = root[here].parent;
+          }
+        }
+        *e = z;
+        here = root[here].parent;
+        while (!(_tab_xml[*p] & (16 | 128)))
+          p++;
+        if (*p == '>')
+          p++;
+      } else { /* <reguler_tag ... */
+        uint32_t new = _xine_stree_node_new (&root, &have, &used, here);
+        if (!new)
+          return root;
+        *e = 0;
+        root[new].key = _xine_stree_get_string (&p, &q, _tab_xml) - (uint8_t *)buf;
+        e = q++;
+        here = new;
+      }
+    } else if (*p == '/') { /* ... /> */
+      p++;
+      if (*p == '>') {
+        p++;
+        here = root[here].parent;
+      }
+    } else if (!(_tab_xml[*p] & (1 | 16 | 128))) { /* ... key=value ... */
+      uint32_t new = _xine_stree_node_new (&root, &have, &used, here);
+      if (!new)
+        return root;
+      *e = 0;
+      root[new].key = _xine_stree_get_string (&p, &q, _tab_xml) - (uint8_t *)buf;
+      e = q++;
+      if (*p == '=')
+        p++;
+      *e = 0;
+      root[new].value = _xine_stree_get_string (&p, &q, _tab_xml) - (uint8_t *)buf;
+      e = q++;
+    } else if (*p == '>') { /* <tag_with_inner_text ...>here</... */
+      p++;
+      /* trim leading spc */
+      while (_tab_xml[*p] & 1)
+        p++;
+      if (!(_tab_xml[*p] & (8 | 128))) {
+        uint8_t *b;
+        uint32_t new = _xine_stree_node_new (&root, &have, &used, here), value;
+        if (!new)
+          return root;
+        /* generic key */
+        if (plain == ~0u) {
+          plain = q - (uint8_t *)buf;
+          memcpy (q, "[]", 2);
+          q += 2;
+          *e = 0;
+          e = q++;
+        }
+        root[new].key = plain;
+        /* main text */
+        b = q;
+        value = q - (uint8_t *)buf;
+        root[new].value = value;
+        if (!root[here].value)
+          root[here].value = value;
+        /* trim trailing spc */
+        while (1) {
+          while (!(_tab_xml[*p] & (1 | 8 | 128)))
+            *q++ = *p++;
+          while (_tab_xml[*p] & 1)
+            p++;
+          if (_tab_xml[*p] & (8 | 128))
+            break;
+          *q++ = ' ';
+        }
+        {
+          uint8_t z = *q;
+          *q = 0;
+          /* this will be just right in most cases :-) */
+          value = xine_string_unampersand ((char *)b);
+          *q = z;
+        }
+        q = b + value;
+        *e = 0;
+        e = q++;
+      }
+    } else {
+      p++;
+    }
+  }
+  *e = 0;
+  buf[0] = 0;
+  return root;
+}
+
+static const uint8_t _tab_json1[256] = {
+  ['\r'] = 1,
+  ['\n'] = 1,
+  ['\t'] = 1,
+  [' '] = 1,
+  ['\"'] = 2,
+  ['\''] = 4,
+  ['{'] = 8,
+  ['['] = 8,
+  [']'] = 16,
+  ['}'] = 16,
+  [','] = 32,
+  [':'] = 32,
+  ['\\'] = 64,
+  [0] = 128
+};
+
+static const uint8_t _tab_json2[256] = {
+  ['/'] = 1,
+  ['*'] = 2,
+  ['\n'] = 4,
+  [0] = 128
+};
+
+static xine_stree_t *_xine_stree_load_json (char *buf) {
+  xine_stree_t *root;
+  uint32_t have, used, here;
+  uint8_t *p, *q, *e;
+
+  have = 64;
+  root = (xine_stree_t *)malloc (have * sizeof (*root));
+  if (!root)
+    return NULL;
+
+  here = 0;
+  used = 1;
+  root->next = root->prev = 0;
+  root->first_child = root->last_child = root->parent = 0;
+  root->num_children = root->level = root->index = 0;
+  root->key = root->value = 0;
+
+  e = p = (uint8_t *)buf;
+  q = (uint8_t *)buf + 1;
+  if (_tab_json1[*p] & 8) /* {[ */
+    p++;
+  while (*p) {
+    /* skip whitespace */
+    while (_tab_json1[*p] & 1)
+      p++;
+    /* skip comment */
+    if (*p == '/') {
+      if (p[1] == '*') { /* C comment */
+        p += 2;
+        do {
+          while (!(_tab_json2[*p] & (2 | 128)))
+            p++;
+          if (!*p)
+            break;
+          p++;
+        } while (*p != '/');
+        if (*p == '/')
+          p++;
+        continue;
+      } 
+      if (p[1] == '/') { /* C++ comment */
+        p += 2;
+        while (!(_tab_json2[*p] & (4 | 128)))
+          p++;
+        if (*p == '\n')
+          p++;
+        continue;
+      }
+    }
+    if (_tab_json1[*p] & 8) { /* {[ */
+      uint32_t new = root[here].last_child;
+      p++;
+      if (!new) {
+        new = _xine_stree_node_new (&root, &have, &used, here);
+        if (!new)
+          break;
+      }
+      root[new].level &= ~0x80000000;
+      here = new;
+      continue;
+    }
+    if (_tab_json1[*p] & 32) { /* :, */
+      uint32_t item = root[here].last_child;
+      root[item].level &= ~0x80000000;
+      if (*p == ',') {
+        item = _xine_stree_node_new (&root, &have, &used, here);
+        if (!item)
+          break;
+        root[item].level |= 0x80000000;
+      }
+      p++;
+      continue;
+    }
+    if (_tab_json1[*p] & 16) { /* ]} */
+      uint32_t item = root[here].last_child;
+      if (item)
+        root[item].level &= ~0x80000000;
+      p++;
+      if (!root[here].level)
+        break;
+      here = root[here].parent;
+      continue;
+    }
+    {
+      uint8_t *v;
+      uint32_t item = root[here].last_child;
+      if (!item) {
+        item = _xine_stree_node_new (&root, &have, &used, here);
+        if (!item)
+          break;
+        root[item].level |= 0x80000000;
+      }
+      v = _xine_stree_get_string (&p, &q, _tab_json1);
+      if (v != q) {
+        /* defer writing string end until that location is not read any more. */
+        *e = 0;
+        e = q++;
+        if (root[item].level & 0x80000000) {
+          root[item].key = v - (uint8_t *)buf;
+        } else {
+          uint8_t z;
+          root[item].value = v - (uint8_t *)buf;
+          /* this will be just right in most cases :-) */
+          z = *e;
+          *e = 0;
+          xine_string_unbackslash ((char *)v);
+          *e = z;
+        }
+      }
+    }
+  }
+  *e = 0;
+  buf[0] = 0;
+  return root;
+}
+
+static const uint8_t _tab_url[256] = {
+  ['?'] = 1,
+  ['#'] = 2,
+  ['&'] = 4,
+  ['='] = 8,
+  ['\\'] = 64,
+  [0] = 128
+};
+
+static xine_stree_t *_xine_stree_load_url (char *buf) {
+  xine_stree_t *root;
+  uint32_t have, used, here, key;
+  uint8_t *p, *e, dummy;
+
+  have = 64;
+  root = (xine_stree_t *)malloc (have * sizeof (*root));
+  if (!root)
+    return NULL;
+
+  used = 1;
+  root->next = root->prev = 0;
+  root->first_child = root->last_child = root->parent = 0;
+  root->num_children = root->level = root->index = 0;
+  root->key = root->value = 0;
+
+  p = (uint8_t *)buf;
+
+  /* skip [http://host/path?]key1=val1&key2=val2#extra */
+  while (1) {
+    while (!(_tab_url[*p] & (1 | 64 | 128))) /* ? \\ \0 */
+      p++;
+    if (*p != '\\')
+      break;
+    p++;
+  }
+  if (*p)
+    p++;
+  else
+    p = (uint8_t *)buf;
+
+  /* cut key1=val1&key2=val2[#extra] */
+  e = p;
+  while (1) {
+    while (!(_tab_url[*p] & (2 | 64 | 128))) /* # \\ \0 */
+      p++;
+    if (*p != '\\')
+      break;
+    p++;
+  }
+  *p = 0;
+  p = e;
+
+  e = &dummy;
+  here = 0;
+  key = 1;
+  while (*p) {
+    uint8_t *r = p;
+    if (key) {
+      while (1) {
+        while (!(_tab_url[*p] & (4 | 8 | 64 | 128))) /* & = \\ \0 */
+          p++;
+        if (*p != '\\')
+          break;
+        p++;
+      }
+    } else {
+      /* value may contain any number of equal signs. */
+      while (1) {
+        while (!(_tab_url[*p] & (4 | 64 | 128))) /* & \\ \0 */
+          p++;
+        if (*p != '\\')
+          break;
+        p++;
+      }
+    }
+    if (!here) {
+      here = _xine_stree_node_new (&root, &have, &used, 0);
+      if (!here)
+        break;
+      /* NOTE: buf may start with a key, thus we cannot put a global empty string there. */
+      root[here].key = root[here].value = p - (uint8_t *)buf;
+    }
+    if (key) {
+      root[here].key = r - (uint8_t *)buf;
+    } else {
+      uint8_t z;
+      root[here].value = r - (uint8_t *)buf;
+      /* this will be just right in most cases :-) */
+      z = *p;
+      *p = 0;
+      xine_string_unpercent ((char *)r);
+      *p = z;
+    }
+    if (*p == '&') {
+      *e = 0;
+      e = p++;
+      here = 0;
+      key = 1;
+    } else if (*p == '=') {
+      *e = 0;
+      e = p++;
+      key = 0;
+    }
+  }
+  *e = 0;
+  root->key = root->value = p - (uint8_t *)buf;
+  return root;
+}
+
+xine_stree_t *xine_stree_load (char *buf, xine_stree_mode_t *mode) {
+  xine_stree_mode_t m2 = XINE_STREE_AUTO;
+  if (!buf)
+    return NULL;
+  if (!mode)
+    mode = &m2;
+  if (*mode >= XINE_STREE_LAST)
+    return NULL;
+  if (*mode == XINE_STREE_AUTO) {
+    const uint8_t *p = (const uint8_t *)buf;
+    while (_tab_xml[*p] & 1)
+      p++;
+    if (*p == '<') {
+      *mode = XINE_STREE_XML;
+    } else if ((*p == '{') || (*p == '[')) {
+      *mode = XINE_STREE_JSON;
+    } else {
+      *mode = XINE_STREE_URL;
+    }
+  }
+  switch (*mode) {
+    case XINE_STREE_XML: return _xine_stree_load_xml (buf);
+    case XINE_STREE_JSON: return _xine_stree_load_json (buf);
+    case XINE_STREE_URL: return _xine_stree_load_url (buf);
+    default: return NULL;
+  }
+}
+
+void xine_stree_dump (const xine_stree_t *tree, const char *buf, uint32_t base) {
+  static const char spc[] = "                                ";
+  const xine_stree_t *here, *stop;
+  uint32_t index;
+
+  if (!tree || !buf)
+    return;
+
+  here = tree + base;
+  stop = base ? here : NULL;
+  {
+    const xine_stree_t *test;
+
+    for (index = 0, test = here; test->prev; index += 1, test = tree + test->prev) ;
+  }
+
+  while (1) {
+    printf ("%s[%d:%d] \"%s\" = \"%s\"\n",
+      spc + (sizeof (spc) - 1) - 2 * (here->level > (sizeof (spc) - 1) / 2 ? sizeof (spc) - 1 : here->level),
+      (int)here->level, (int)index, buf + here->key, buf + here->value);
+    if (here->first_child) { /* down */
+      index = 0;
+      here = tree + here->first_child;
+    } else if (here == stop) { /* done */
+      break;
+    } else if (here->next) { /* next */
+      index += 1;
+      here = tree + here->next;
+    } else { /* up */
+      const xine_stree_t *test;
+
+      while (here->level) {
+        here = tree + here->parent;
+        if ((here == stop) || here->next)
+          break;
+      }
+      if ((here == stop) || !here->next)
+        break;
+      for (index = 1, test = here; test->prev; index += 1, test = tree + test->prev) ;
+      here = tree + here->next;
+    }
+  }
+}
+
+static const uint8_t _tab_key[256] = {
+  ['.'] = 1,
+  ['['] = 2,
+  ['0'] = 4,
+  ['1'] = 4,
+  ['2'] = 4,
+  ['3'] = 4,
+  ['4'] = 4,
+  ['5'] = 4,
+  ['6'] = 4,
+  ['7'] = 4,
+  ['8'] = 4,
+  ['9'] = 4,
+  ['\t'] = 8,
+  [' '] = 8,
+  ['\0'] = 128
+};
+
+uint32_t xine_stree_find (const xine_stree_t *tree, const char *buf, const char *path, uint32_t base, int case_sens) {
+  const xine_stree_t *here;
+  const uint8_t *s;
+  uint8_t part[512], *q, *e;
+
+  if (!tree || !buf)
+    return 0;
+  if (!path)
+    return base;
+
+  here = tree + base;
+  e = part + sizeof (part) - 1;
+  s = (const uint8_t *)path;
+  while (1) {
+    uint32_t v;
+    while (*s == '.')
+      s++;
+    if (!*s)
+      return here - tree;
+    if (!here->first_child)
+      return 0;
+    here = tree + here->first_child;
+    q = part;
+    while (1) {
+      while (!(_tab_key[*s] & (1 | 2 | 128)) && (q < e))
+        *q++ = *s++;
+      if (q >= e)
+        return 0;
+      if (*s != '[')
+        break;
+      if (_tab_key[s[1]] & (4 | 8))
+        break;
+      *q++ = *s++;
+    }
+    if (q >= e)
+      return 0;
+    *q = 0;
+    v = 0;
+    if (*s == '[') {
+      uint8_t z;
+      s++;
+      while (_tab_xml[*s] & 1)
+        s++;
+      while ((z = *s ^ '0') < 10)
+        v = 10u * v + z, s++;
+      while (_tab_xml[*s] & 1)
+        s++;
+      if (*s == ']')
+        s++;
+    }
+    if (*part) {
+      if (case_sens) {
+        while (1) {
+          if (!strcmp ((const char *)buf + here->key, (const char *)part)) {
+            if (!v)
+              break;
+            v--;
+          }
+          if (!here->next)
+            return 0;
+          here = tree + here->next;
+        }
+      } else {
+        while (1) {
+          if (!strcasecmp ((const char *)buf + here->key, (const char *)part)) {
+            if (!v)
+              break;
+            v--;
+          }
+          if (!here->next)
+            return 0;
+          here = tree + here->next;
+        }
+      }
+    } else {
+      while (v && here->next)
+        v--, here = tree + here->next;
+      if (v)
+        return 0;
+    }
+  }
+}
+
+void xine_stree_delete (xine_stree_t **tree) {
+  if (tree) {
+    free (*tree);
+    *tree = NULL;
+  }
+}
+
+#ifdef TEST_THIS_FILE
+int main (int argc, char **argv) {
+  (void)argc;
+
+  do {
+    FILE *f;
+    size_t fsize;
+    char *buf;
+    xine_stree_t *tree;
+    uint32_t here;
+    xine_stree_mode_t mode;
+
+    if (!argv[0])
+      break;
+    if (!argv[1])
+      break;
+
+    f = fopen (argv[1], "rb");
+    if (!f)
+      break;
+
+    fseek (f, 0, SEEK_END);
+    fsize = ftell (f);
+    fseek (f, 0, SEEK_SET);
+    buf = malloc (fsize + 1);
+    if (!buf) {
+      fclose (f);
+      break;
+    }
+
+    fread (buf, 1, fsize, f);
+    fclose (f);
+    buf[fsize] = 0;
+    mode = XINE_STREE_AUTO;
+    tree = xine_stree_load (buf, &mode);
+    if (!tree) {
+      free (buf);
+      break;
+    }
+
+    here = xine_stree_find (tree, buf, argv[2], 0, mode == XINE_STREE_JSON);
+    if (!argv[2] || here)
+      xine_stree_dump (tree, buf, here);
+    xine_stree_delete (&tree);
+    free (buf);
+    return 0;
+  } while (0);
+
+  {
+    static const char helptext[] =
+      "usage: stree <file> [<path>]\n"
+      "  path is a dot separated list of parts.\n"
+      "  part is a key, a zero based index number in square brackets, or both.\n"
+      "  the special key \"[]\" refers to xml tag content text.\n"
+      "  \"foo.[][0]\" will also be available as \"foo\".\n";
+
+    fwrite (helptext, 1, sizeof (helptext) - 1, stdout);
+  }
+  return 1;
+}
+#endif
diff -urN xine-lib-1.2.11/src/xine-utils/utils.c xine-lib-1.2/src/xine-utils/utils.c
--- xine-lib-1.2.11/src/xine-utils/utils.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-utils/utils.c	2022-01-15 22:03:19.604547255 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2018 the xine project
+ * Copyright (C) 2000-2021 the xine project
  *
  * This file is part of xine, a free video player.
  *
diff -urN xine-lib-1.2.11/src/xine-utils/xmllexer.c xine-lib-1.2/src/xine-utils/xmllexer.c
--- xine-lib-1.2.11/src/xine-utils/xmllexer.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-utils/xmllexer.c	2022-01-15 22:03:19.624547339 +0100
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2002-2020 the xine project
+ *  Copyright (C) 2002-2021 the xine project
  *
  *  This file is part of xine, a free video player.
  *
@@ -522,6 +522,7 @@
 	  if (strncmp(lexer->lexbuf + lexer->lexbuf_pos, "]]>", 3) == 0) {
 	    lexer->lexbuf_pos += 3;
 	    lexer->lex_mode = DATA;
+	    tok[tok_pos] = '\0';
 	    return T_CDATA_STOP;
 	  } else {
 	    tok[tok_pos] = c;
@@ -542,13 +543,18 @@
 
     /* pb */
     if (tok_pos + 8 >= tok_size) {
+      char *tmp_tok;
+      int new_size;
       if (fixed)
         return T_ERROR;
-      *_tok_size *= 2;
-      *_tok = realloc (*_tok, *_tok_size);
-      lprintf("token buffer is too small\n");
+      new_size = *_tok_size * 2;
+      tmp_tok = realloc (*_tok, new_size);
+      lprintf("token buffer is too small (need %d)\n", tok_pos);
       lprintf("increasing buffer size to %d bytes\n", *_tok_size);
-      if (*_tok) {
+      if (tmp_tok) {
+	  *_tok = tmp_tok;
+	  memset (*_tok + tok_size, 0, new_size - tok_size);
+	  *_tok_size = new_size;
           return lexer_get_token_d_r (lexer, _tok, _tok_size, 0);
       } else {
           return T_ERROR;
diff -urN xine-lib-1.2.11/src/xine-utils/xmlparser.c xine-lib-1.2/src/xine-utils/xmlparser.c
--- xine-lib-1.2.11/src/xine-utils/xmlparser.c	2020-11-19 11:30:37.000000000 +0100
+++ xine-lib-1.2/src/xine-utils/xmlparser.c	2022-01-15 22:03:19.611547284 +0100
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2002-2020 the xine project
+ *  Copyright (C) 2002-2021 the xine project
  *
  *  This file is part of xine, a free video player.
  *
@@ -375,6 +375,7 @@
 						    pname_buffer, pname_buffer_size,
 						    nname_buffer, nname_buffer_size,
 						    subtree, root_names, rec + 1, flags);
+	  tok = *token_buffer;
 	  free (root_names[rec + 1]);
 	  if (parse_res == -1 || parse_res > 0) {
             xml_parser_free_tree_rec(subtree, 1);
@@ -432,8 +433,14 @@
 	  }
 	  /* make sure the buffer for the property name is big enough */
 	  if (*token_buffer_size > *pname_buffer_size) {
+	    char *tmp_prop;
 	    *pname_buffer_size = *token_buffer_size;
-	    *pname_buffer = realloc (*pname_buffer, *pname_buffer_size);
+	    tmp_prop = realloc (*pname_buffer, *pname_buffer_size);
+	    if (!tmp_prop)
+	      return -1;
+	    *pname_buffer = tmp_prop;
+	    property_name = tmp_prop;
+	  } else {
 	    property_name = *pname_buffer;
 	  }
 	  strcpy(property_name, tok);
